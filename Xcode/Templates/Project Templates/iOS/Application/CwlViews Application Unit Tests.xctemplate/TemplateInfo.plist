<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Ancestors</key>
	<array>
		<string>com.apple.dt.unit.iosUnitTestBundleBase</string>
	</array>
	<key>Definitions</key>
	<dict>
		<key>*:imports:importProject</key>
		<string>@testable import ___VARIABLE_productName:identifier___</string>
		<key>CwlViews_iOSTesting.swift:content</key>
		<string>//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-05-11 02:03:27 +0000 from the following files:
//   CwlBindingParser.swift
//   CwlAlertActionTesting_iOS.swift
//   CwlAlertControllerTesting_iOS.swift
//   CwlApplicationTesting_iOS.swift
//   CwlBarButtonItemTesting_iOS.swift
//   CwlBarItemTesting_iOS.swift
//   CwlButtonTesting_iOS.swift
//   CwlControlTesting_iOS.swift
//   CwlExtendedViewControllerTesting_iOS.swift
//   CwlGestureRecognizerTesting_iOS.swift
//   CwlImageViewTesting_iOS.swift
//   CwlLabelTesting_iOS.swift
//   CwlLongPressGestureRecognizerTesting_iOS.swift
//   CwlNavigationBarTesting_iOS.swift
//   CwlNavigationControllerTesting_iOS.swift
//   CwlNavigationItemTesting_iOS.swift
//   CwlPageControl.swift
//   CwlPageViewControllerTesting_iOS.swift
//   CwlPanGestureRecognizerTesting_iOS.swift
//   CwlPinchGestureRecognizerTesting_iOS.swift
//   CwlRotationGestureRecognizerTesting_iOS.swift
//   CwlScreenEdgePanGestureRecognizerTesting_iOS.swift
//   CwlScrollViewTesting_iOS.swift
//   CwlSearchBarTesting_iOS.swift
//   CwlSliderTesting_iOS.swift
//   CwlSplitViewControllerTesting_iOS.swift
//   CwlSwipeGestureRecognizerTesting_iOS.swift
//   CwlSwitchTesting_iOS.swift
//   CwlTabBarControllerTesting_iOS.swift
//   CwlTabBarItemTesting_iOS.swift
//   CwlTabBarTesting_iOS.swift
//   CwlTableViewCellTesting_iOS.swift
//   CwlTableViewTesting_iOS.swift
//   CwlTapGestureRecognizerTesting_iOS.swift
//   CwlTextFieldTesting_iOS.swift
//   CwlTextInputTraitsTesting_iOS.swift
//   CwlTextViewTesting_iOS.swift
//   CwlToolbarTesting_iOS.swift
//   CwlViewControllerTesting_iOS.swift
//   CwlViewTesting_iOS.swift
//   CwlWindowTesting_iOS.swift

import UIKit

struct BindingParser&lt;Value, Binding, Downcast&gt; {
	var extract: (Binding) -&gt; Value?
	var upcast: (Downcast) -&gt; Binding?
	init(extract: @escaping (Binding) -&gt; Value?, upcast: @escaping (Downcast) -&gt; Binding?) {
		self.extract = extract
		self.upcast = upcast
	}
	func parse(_ downcast: Downcast) -&gt; Value? {
		return upcast(downcast).flatMap { extract($0) }
	}
}


enum BindingParserErrors: Error {
	case multipleMatchesFound
	case noMatchesFound
	case unexpectedArgumentType
}

extension Dynamic {
	var values: [Value] {
		switch self {
		case .constant(let v): return [v]
		case .dynamic(let s): return s.capture().values
		}
	}
	
	var signal: Signal&lt;Value&gt; {
		switch self {
		case .constant(let f): return Signal.just(f)
		case .dynamic(let s): return s
		}
	}
}

extension Binder {
	static func consume(from possibleBinder: Any) throws -&gt; (type: Self.Preparer.Instance.Type, parameters: Self.Preparer.Parameters, bindings: [Self.Preparer.Binding]) {
		if let b = possibleBinder as? Self {
			return b.consume()
		}
		throw BindingParserErrors.unexpectedArgumentType
	}
	
	static func consumeBindings(from possibleBinder: Any) throws -&gt; [Self.Preparer.Binding] {
		return try consume(from: possibleBinder).bindings
	}
	
	static func latestValue&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;Dynamic&lt;V&gt;, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; V where S.Element == Downcast {
		var found: V? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.values.first
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func latestArray&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;Dynamic&lt;V&gt;, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; [V] where S.Element == Downcast {
		var found: [V]? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.values
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func constantValue&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;Constant&lt;V&gt;, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; V where S.Element == Downcast {
		var found: V? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.value
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func valueSignal&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;Dynamic&lt;V&gt;, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; Signal&lt;V&gt; where S.Element == Downcast {
		var found: Signal&lt;V&gt;? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.signal
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func argument&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;V, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; V where S.Element == Downcast {
		var found: V? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

#if os(iOS)

extension BindingParser where Downcast: AlertActionBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, AlertAction.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asAlertActionBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var style: BindingParser&lt;Constant&lt;UIAlertAction.Style&gt;, AlertAction.Binding, Downcast&gt; { return .init(extract: { if case .style(let x) = $0 { return x } else { return nil } }, upcast: { $0.asAlertActionBinding() }) }
	static var title: BindingParser&lt;Constant&lt;String&gt;, AlertAction.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asAlertActionBinding() }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, AlertAction.Binding, Downcast&gt; { return .init(extract: { if case .isEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asAlertActionBinding() }) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	static var handler: BindingParser&lt;SignalInput&lt;Void&gt;, AlertAction.Binding, Downcast&gt; { return .init(extract: { if case .handler(let x) = $0 { return x } else { return nil } }, upcast: { $0.asAlertActionBinding() }) }

	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: AlertControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, AlertController.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asAlertControllerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var actions: BindingParser&lt;Constant&lt;[AlertActionConvertible]&gt;, AlertController.Binding, Downcast&gt; { return .init(extract: { if case .actions(let x) = $0 { return x } else { return nil } }, upcast: { $0.asAlertControllerBinding() }) }
	static var preferredStyle: BindingParser&lt;Constant&lt;UIAlertController.Style&gt;, AlertController.Binding, Downcast&gt; { return .init(extract: { if case .preferredStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asAlertControllerBinding() }) }
	static var textFields: BindingParser&lt;Constant&lt;[TextField]&gt;, AlertController.Binding, Downcast&gt; { return .init(extract: { if case .textFields(let x) = $0 { return x } else { return nil } }, upcast: { $0.asAlertControllerBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var message: BindingParser&lt;Dynamic&lt;String?&gt;, AlertController.Binding, Downcast&gt; { return .init(extract: { if case .message(let x) = $0 { return x } else { return nil } }, upcast: { $0.asAlertControllerBinding() }) }
	static var preferredActionIndex: BindingParser&lt;Dynamic&lt;Int?&gt;, AlertController.Binding, Downcast&gt; { return .init(extract: { if case .preferredActionIndex(let x) = $0 { return x } else { return nil } }, upcast: { $0.asAlertControllerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ApplicationBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Application.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asApplicationBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var iconBadgeNumber: BindingParser&lt;Dynamic&lt;Int&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .iconBadgeNumber(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var isIdleTimerDisabled: BindingParser&lt;Dynamic&lt;Bool&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .isIdleTimerDisabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var isNetworkActivityIndicatorVisible: BindingParser&lt;Dynamic&lt;Bool&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .isNetworkActivityIndicatorVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var shortcutItems: BindingParser&lt;Dynamic&lt;[UIApplicationShortcutItem]?&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .shortcutItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var supportShakeToEdit: BindingParser&lt;Dynamic&lt;Bool&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .supportShakeToEdit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var window: BindingParser&lt;Dynamic&lt;WindowConvertible?&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .window(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var ignoreInteractionEvents: BindingParser&lt;Signal&lt;Bool&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .ignoreInteractionEvents(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var registerForRemoteNotifications: BindingParser&lt;Signal&lt;Bool&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .registerForRemoteNotifications(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var continueUserActivity: BindingParser&lt;(_ application: UIApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .continueUserActivity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didBecomeActive: BindingParser&lt;(UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didBecomeActive(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didDecodeRestorableState: BindingParser&lt;(UIApplication, NSKeyedUnarchiver) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didDecodeRestorableState(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didEnterBackground: BindingParser&lt;(UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didEnterBackground(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didFailToContinueUserActivity: BindingParser&lt;(UIApplication, String, Error) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didFailToContinueUserActivity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didFinishLaunching: BindingParser&lt;(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .didFinishLaunching(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didReceiveMemoryWarning: BindingParser&lt;(UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didReceiveMemoryWarning(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didReceiveRemoteNotification: BindingParser&lt;(UIApplication, [AnyHashable: Any], @escaping (UIBackgroundFetchResult) -&gt; Void) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didReceiveRemoteNotification(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didRegisterRemoteNotifications: BindingParser&lt;(UIApplication, Error) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didRegisterRemoteNotifications(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didUpdate: BindingParser&lt;(_ application: UIApplication, NSUserActivity) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didUpdate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var handleEventsForBackgroundURLSession: BindingParser&lt;(UIApplication, String, @escaping () -&gt; Void) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .handleEventsForBackgroundURLSession(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var handleWatchKitExtensionRequest: BindingParser&lt;(UIApplication, [AnyHashable : Any]?, @escaping ([AnyHashable : Any]?) -&gt; Void) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .handleWatchKitExtensionRequest(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var open: BindingParser&lt;(_ application: UIApplication, _ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .open(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var performAction: BindingParser&lt;(UIApplication, UIApplicationShortcutItem, @escaping (Bool) -&gt; Void) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .performAction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var performFetch: BindingParser&lt;(UIApplication, @escaping (UIBackgroundFetchResult) -&gt; Void) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .performFetch(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var protectedDataDidBecomeAvailable: BindingParser&lt;(UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .protectedDataDidBecomeAvailable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var protectedDataWillBecomeUnavailable: BindingParser&lt;(UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .protectedDataWillBecomeUnavailable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var shouldAllowExtensionPointIdentifier: BindingParser&lt;(_ application: UIApplication, UIApplication.ExtensionPointIdentifier) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .shouldAllowExtensionPointIdentifier(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var shouldRequestHealthAuthorization: BindingParser&lt;(_ application: UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .shouldRequestHealthAuthorization(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var significantTimeChange: BindingParser&lt;(UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .significantTimeChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var viewControllerWithRestorationPath: BindingParser&lt;(_ application: UIApplication, _ path: [String], _ coder: NSCoder) -&gt; UIViewController?, Application.Binding, Downcast&gt; { return .init(extract: { if case .viewControllerWithRestorationPath(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willContinueUserActivity: BindingParser&lt;(_ application: UIApplication, String) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .willContinueUserActivity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willEncodeRestorableState: BindingParser&lt;(_ application: UIApplication, NSKeyedArchiver) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .willEncodeRestorableState(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willEnterForeground: BindingParser&lt;(UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .willEnterForeground(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willFinishLaunching: BindingParser&lt;(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .willFinishLaunching(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willResignActive: BindingParser&lt;(UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .willResignActive(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willTerminate: BindingParser&lt;(_ application: UIApplication) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .willTerminate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: BarButtonItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asBarButtonItemBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var systemItem: BindingParser&lt;Constant&lt;UIBarButtonItem.SystemItem&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .systemItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var backButtonBackgroundImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;StateAndMetrics, UIImage?&gt;&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .backButtonBackgroundImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	static var backButtonTitlePositionAdjustment: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIBarMetrics, UIOffset&gt;&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .backButtonTitlePositionAdjustment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	static var backgroundImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;StateStyleAndMetrics, UIImage?&gt;&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .backgroundImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	static var backgroundVerticalPositionAdjustment: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIBarMetrics, CGFloat&gt;&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .backgroundVerticalPositionAdjustment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	static var customView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .customView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	static var itemStyle: BindingParser&lt;Dynamic&lt;UIBarButtonItem.Style&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .itemStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	static var possibleTitles: BindingParser&lt;Dynamic&lt;Set&lt;String&gt;?&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .possibleTitles(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	static var tintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .tintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	static var titlePositionAdjustment: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIBarMetrics, UIOffset&gt;&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .titlePositionAdjustment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	static var width: BindingParser&lt;Dynamic&lt;CGFloat&gt;, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .width(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	static var action: BindingParser&lt;TargetAction, BarButtonItem.Binding, Downcast&gt; { return .init(extract: { if case .action(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarButtonItemBinding() }) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: BarItemBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, BarItem.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asBarItemBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var image: BindingParser&lt;Dynamic&lt;UIImage?&gt;, BarItem.Binding, Downcast&gt; { return .init(extract: { if case .image(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarItemBinding() }) }
	static var imageInsets: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, BarItem.Binding, Downcast&gt; { return .init(extract: { if case .imageInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarItemBinding() }) }
	static var isEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, BarItem.Binding, Downcast&gt; { return .init(extract: { if case .isEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarItemBinding() }) }
	static var landscapeImagePhone: BindingParser&lt;Dynamic&lt;UIImage?&gt;, BarItem.Binding, Downcast&gt; { return .init(extract: { if case .landscapeImagePhone(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarItemBinding() }) }
	static var landscapeImagePhoneInsets: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, BarItem.Binding, Downcast&gt; { return .init(extract: { if case .landscapeImagePhoneInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarItemBinding() }) }
	static var tag: BindingParser&lt;Dynamic&lt;Int&gt;, BarItem.Binding, Downcast&gt; { return .init(extract: { if case .tag(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarItemBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;String&gt;, BarItem.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarItemBinding() }) }
	static var titleTextAttributes: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, [NSAttributedString.Key: Any]&gt;&gt;, BarItem.Binding, Downcast&gt; { return .init(extract: { if case .titleTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asBarItemBinding() }) }

	//	2. Signal bindings are performed on the object after construction.

	//	3. Action bindings are triggered by the object after construction.

	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ButtonBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Button.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asButtonBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var imageView: BindingParser&lt;Constant&lt;ImageView&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .imageView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var titleLabel: BindingParser&lt;Constant&lt;Label&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .titleLabel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var type: BindingParser&lt;Constant&lt;UIButton.ButtonType&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .type(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsImageWhenDisabled: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .adjustsImageWhenDisabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var adjustsImageWhenHighlighted: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .adjustsImageWhenHighlighted(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var attributedTitle: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, NSAttributedString?&gt;&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .attributedTitle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var backgroundImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, UIImage?&gt;&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .backgroundImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var contentEdgeInsets: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .contentEdgeInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var image: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, UIImage?&gt;&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .image(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var imageEdgeInsets: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .imageEdgeInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var showsTouchWhenHighlighted: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .showsTouchWhenHighlighted(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, String?&gt;&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var titleColor: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, UIColor?&gt;&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .titleColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var titleEdgeInsets: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .titleEdgeInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var titleShadowColor: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, UIColor?&gt;&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .titleShadowColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ControlBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Control.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asControlBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .isEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var isSelected: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .isSelected(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var isHighlighted: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .isHighlighted(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var contentVerticalAlignment: BindingParser&lt;Dynamic&lt;UIControl.ContentVerticalAlignment&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .contentVerticalAlignment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var contentHorizontalAlignment: BindingParser&lt;Dynamic&lt;UIControl.ContentHorizontalAlignment&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .contentHorizontalAlignment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var actions: BindingParser&lt;ControlActions, Control.Binding, Downcast&gt; { return .init(extract: { if case .actions(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ExtendedViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ExtendedViewController&lt;Downcast.SubclassType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asExtendedViewControllerBinding() }) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didAppear: BindingParser&lt;(UIViewController, Bool) -&gt; Void, ExtendedViewController&lt;Downcast.SubclassType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didAppear(let x) = $0 { return x } else { return nil } }, upcast: { $0.asExtendedViewControllerBinding() }) }
	static var didDisappear: BindingParser&lt;(UIViewController, Bool) -&gt; Void, ExtendedViewController&lt;Downcast.SubclassType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didDisappear(let x) = $0 { return x } else { return nil } }, upcast: { $0.asExtendedViewControllerBinding() }) }
	static var didReceiveMemoryWarning: BindingParser&lt;(UIViewController) -&gt; Void, ExtendedViewController&lt;Downcast.SubclassType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didReceiveMemoryWarning(let x) = $0 { return x } else { return nil } }, upcast: { $0.asExtendedViewControllerBinding() }) }
	static var loadView: BindingParser&lt;() -&gt; ViewConvertible, ExtendedViewController&lt;Downcast.SubclassType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .loadView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asExtendedViewControllerBinding() }) }
	static var traitCollectionDidChange: BindingParser&lt;(UIViewController, UITraitCollection?) -&gt; Void, ExtendedViewController&lt;Downcast.SubclassType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .traitCollectionDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asExtendedViewControllerBinding() }) }
	static var willAppear: BindingParser&lt;(UIViewController, Bool) -&gt; Void, ExtendedViewController&lt;Downcast.SubclassType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willAppear(let x) = $0 { return x } else { return nil } }, upcast: { $0.asExtendedViewControllerBinding() }) }
	static var willDisappear: BindingParser&lt;(UIViewController, Bool) -&gt; Void, ExtendedViewController&lt;Downcast.SubclassType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willDisappear(let x) = $0 { return x } else { return nil } }, upcast: { $0.asExtendedViewControllerBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: GestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asGestureRecognizerBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowedPressTypes: BindingParser&lt;Dynamic&lt;[NSNumber]&gt;, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .allowedPressTypes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var allowedTouchTypes: BindingParser&lt;Dynamic&lt;[NSNumber]&gt;, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .allowedTouchTypes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var cancelsTouchesInView: BindingParser&lt;Dynamic&lt;Bool&gt;, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .cancelsTouchesInView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var delaysTouchesBegan: BindingParser&lt;Dynamic&lt;Bool&gt;, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .delaysTouchesBegan(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var delaysTouchesEnded: BindingParser&lt;Dynamic&lt;Bool&gt;, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .delaysTouchesEnded(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var requiresExclusiveTouchType: BindingParser&lt;Dynamic&lt;Bool&gt;, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .requiresExclusiveTouchType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: BindingParser&lt;SignalInput&lt;Any?&gt;, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .action(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldBegin: BindingParser&lt;(UIGestureRecognizer) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldBegin(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldBeRequiredToFail: BindingParser&lt;(UIGestureRecognizer, _ by: UIGestureRecognizer) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldBeRequiredToFail(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldReceivePress: BindingParser&lt;(UIGestureRecognizer, UIPress) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldReceivePress(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldReceiveTouch: BindingParser&lt;(UIGestureRecognizer, UITouch) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldReceiveTouch(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldRecognizeSimultanously: BindingParser&lt;(UIGestureRecognizer, UIGestureRecognizer) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldRecognizeSimultanously(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldRequireFailure: BindingParser&lt;(UIGestureRecognizer, _ of: UIGestureRecognizer) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldRequireFailure(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ImageViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asImageViewBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var image: BindingParser&lt;Dynamic&lt;UIImage?&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .image(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var highlightedImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .highlightedImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var animationImages: BindingParser&lt;Dynamic&lt;[UIImage]?&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .animationImages(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var highlightedAnimationImages: BindingParser&lt;Dynamic&lt;[UIImage]?&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .highlightedAnimationImages(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var animationDuration: BindingParser&lt;Dynamic&lt;TimeInterval&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .animationDuration(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var animationRepeatCount: BindingParser&lt;Dynamic&lt;Int&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .animationRepeatCount(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var isHighlighted: BindingParser&lt;Dynamic&lt;Bool&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .isHighlighted(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var animating: BindingParser&lt;Signal&lt;Bool&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .animating(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: LabelBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Label.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asLabelBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsFontSizeToFitWidth: BindingParser&lt;Dynamic&lt;Bool&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .adjustsFontSizeToFitWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var allowsDefaultTighteningForTruncation: BindingParser&lt;Dynamic&lt;Bool&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .allowsDefaultTighteningForTruncation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var attributedText: BindingParser&lt;Dynamic&lt;NSAttributedString?&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .attributedText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var baselineAdjustment: BindingParser&lt;Dynamic&lt;UIBaselineAdjustment&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .baselineAdjustment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var font: BindingParser&lt;Dynamic&lt;UIFont&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .font(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var highlightedTextColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .highlightedTextColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var isEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .isEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var isHighlighted: BindingParser&lt;Dynamic&lt;Bool&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .isHighlighted(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var lineBreakMode: BindingParser&lt;Dynamic&lt;NSLineBreakMode&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .lineBreakMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var minimumScaleFactor: BindingParser&lt;Dynamic&lt;CGFloat&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .minimumScaleFactor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var numberOfLines: BindingParser&lt;Dynamic&lt;Int&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .numberOfLines(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var preferredMaxLayoutWidth: BindingParser&lt;Dynamic&lt;CGFloat&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .preferredMaxLayoutWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var shadowColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .shadowColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var shadowOffset: BindingParser&lt;Dynamic&lt;CGSize&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .shadowOffset(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var text: BindingParser&lt;Dynamic&lt;String&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .text(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var textAlignment: BindingParser&lt;Dynamic&lt;NSTextAlignment&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .textAlignment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	static var textColor: BindingParser&lt;Dynamic&lt;UIColor&gt;, Label.Binding, Downcast&gt; { return .init(extract: { if case .textColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLabelBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: LongPressGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, LongPressGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asLongPressGestureRecognizerBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowableMovement: BindingParser&lt;Dynamic&lt;CGFloat&gt;, LongPressGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .allowableMovement(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLongPressGestureRecognizerBinding() }) }
	static var minimumPressDuration: BindingParser&lt;Dynamic&lt;CFTimeInterval&gt;, LongPressGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .minimumPressDuration(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLongPressGestureRecognizerBinding() }) }
	static var numberOfTapsRequired: BindingParser&lt;Dynamic&lt;Int&gt;, LongPressGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .numberOfTapsRequired(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLongPressGestureRecognizerBinding() }) }
	static var numberOfTouchesRequired: BindingParser&lt;Dynamic&lt;Int&gt;, LongPressGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .numberOfTouchesRequired(let x) = $0 { return x } else { return nil } }, upcast: { $0.asLongPressGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: NavigationBarBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asNavigationBarBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;PositionAndMetrics, UIImage?&gt;&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .backgroundImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var backIndicatorImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .backIndicatorImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var backIndicatorTransitionMaskImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .backIndicatorTransitionMaskImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var barStyle: BindingParser&lt;Dynamic&lt;UIBarStyle&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .barStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var barTintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .barTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var isTranslucent: BindingParser&lt;Dynamic&lt;Bool&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .isTranslucent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var items: BindingParser&lt;Dynamic&lt;StackMutation&lt;NavigationItemConvertible&gt;&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .items(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var shadowImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .shadowImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var tintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .tintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var titleTextAttributes: BindingParser&lt;Dynamic&lt;[NSAttributedString.Key: Any]&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .titleTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var titleVerticalPositionAdjustment: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIBarMetrics, CGFloat&gt;&gt;, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .titleVerticalPositionAdjustment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didPop: BindingParser&lt;(UINavigationBar, UINavigationItem) -&gt; Void, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .didPop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var didPush: BindingParser&lt;(UINavigationBar, UINavigationItem) -&gt; Void, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .didPush(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var position: BindingParser&lt;(UIBarPositioning) -&gt; UIBarPosition, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .position(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var shouldPop: BindingParser&lt;(UINavigationBar, UINavigationItem) -&gt; Bool, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .shouldPop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
	static var shouldPush: BindingParser&lt;(UINavigationBar, UINavigationItem) -&gt; Bool, NavigationBar.Binding, Downcast&gt; { return .init(extract: { if case .shouldPush(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationBarBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: NavigationControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asNavigationControllerBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationBar: BindingParser&lt;Constant&lt;NavigationBar&gt;, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .navigationBar(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var hidesBarsOnSwipe: BindingParser&lt;Dynamic&lt;Bool&gt;, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .hidesBarsOnSwipe(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var hidesBarsOnTap: BindingParser&lt;Dynamic&lt;Bool&gt;, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .hidesBarsOnTap(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var hidesBarsWhenKeyboardAppears: BindingParser&lt;Dynamic&lt;Bool&gt;, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .hidesBarsWhenKeyboardAppears(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var hidesBarsWhenVerticallyCompact: BindingParser&lt;Dynamic&lt;Bool&gt;, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .hidesBarsWhenVerticallyCompact(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var isNavigationBarHidden: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;Bool&gt;&gt;, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .isNavigationBarHidden(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var isToolbarHidden: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;Bool&gt;&gt;, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .isToolbarHidden(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var stack: BindingParser&lt;Dynamic&lt;StackMutation&lt;ViewControllerConvertible&gt;&gt;, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .stack(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var poppedToCount: BindingParser&lt;SignalInput&lt;Int&gt;, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .poppedToCount(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var animationController: BindingParser&lt;(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .animationController(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var interactionController: BindingParser&lt;(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning?, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .interactionController(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var preferredInterfaceOrientation: BindingParser&lt;(_ navigationController: UINavigationController) -&gt; UIInterfaceOrientation, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .preferredInterfaceOrientation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var supportedInterfaceOrientations: BindingParser&lt;(_ navigationController: UINavigationController) -&gt; UIInterfaceOrientationMask, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .supportedInterfaceOrientations(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var didShow: BindingParser&lt;(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -&gt; Void, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .didShow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
	static var willShow: BindingParser&lt;(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -&gt; Void, NavigationController.Binding, Downcast&gt; { return .init(extract: { if case .willShow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationControllerBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: NavigationItemBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, NavigationItem.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asNavigationItemBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backBarButtonItem: BindingParser&lt;Dynamic&lt;BarButtonItemConvertible?&gt;, NavigationItem.Binding, Downcast&gt; { return .init(extract: { if case .backBarButtonItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationItemBinding() }) }
	static var hidesBackButton: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;Bool&gt;&gt;, NavigationItem.Binding, Downcast&gt; { return .init(extract: { if case .hidesBackButton(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationItemBinding() }) }
	static var leftBarButtonItems: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;[BarButtonItemConvertible]&gt;&gt;, NavigationItem.Binding, Downcast&gt; { return .init(extract: { if case .leftBarButtonItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationItemBinding() }) }
	static var leftItemsSupplementBackButton: BindingParser&lt;Dynamic&lt;Bool&gt;, NavigationItem.Binding, Downcast&gt; { return .init(extract: { if case .leftItemsSupplementBackButton(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationItemBinding() }) }
	static var prompt: BindingParser&lt;Dynamic&lt;String?&gt;, NavigationItem.Binding, Downcast&gt; { return .init(extract: { if case .prompt(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationItemBinding() }) }
	static var rightBarButtonItems: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;[BarButtonItemConvertible]&gt;&gt;, NavigationItem.Binding, Downcast&gt; { return .init(extract: { if case .rightBarButtonItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationItemBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;String&gt;, NavigationItem.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationItemBinding() }) }
	static var titleView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, NavigationItem.Binding, Downcast&gt; { return .init(extract: { if case .titleView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asNavigationItemBinding() }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: PageControlBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, PageControl.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asPageControlBinding() }) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var currentPage: BindingParser&lt;Dynamic&lt;Int&gt;, PageControl.Binding, Downcast&gt; { return .init(extract: { if case .currentPage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageControlBinding() }) }
	static var currentPageIndicatorTintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, PageControl.Binding, Downcast&gt; { return .init(extract: { if case .currentPageIndicatorTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageControlBinding() }) }
	static var defersCurrentPageDisplay: BindingParser&lt;Dynamic&lt;Bool&gt;, PageControl.Binding, Downcast&gt; { return .init(extract: { if case .defersCurrentPageDisplay(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageControlBinding() }) }
	static var numberOfPages: BindingParser&lt;Dynamic&lt;Int&gt;, PageControl.Binding, Downcast&gt; { return .init(extract: { if case .numberOfPages(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageControlBinding() }) }
	static var pageIndicatorTintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, PageControl.Binding, Downcast&gt; { return .init(extract: { if case .pageIndicatorTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageControlBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var updateCurrentPageDisplay: BindingParser&lt;Signal&lt;Void&gt;, PageControl.Binding, Downcast&gt; { return .init(extract: { if case .updateCurrentPageDisplay(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageControlBinding() }) }

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: PageViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asPageViewControllerBinding() }) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationOrientation: BindingParser&lt;Constant&lt;UIPageViewController.NavigationOrientation&gt;, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .navigationOrientation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	static var pageSpacing: BindingParser&lt;Constant&lt;CGFloat&gt;, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .pageSpacing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	static var spineLocation: BindingParser&lt;Constant&lt;UIPageViewController.SpineLocation&gt;, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .spineLocation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	static var transitionStyle: BindingParser&lt;Constant&lt;UIPageViewController.TransitionStyle&gt;, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .transitionStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isDoubleSided: BindingParser&lt;Dynamic&lt;Bool&gt;, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .isDoubleSided(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	static var pageData: BindingParser&lt;Dynamic&lt;Animatable&lt;[Downcast.PageDataType], UIPageViewController.NavigationDirection&gt;&gt;, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .pageData(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var changeCurrentPage: BindingParser&lt;Signal&lt;Animatable&lt;Int, UIPageViewController.NavigationDirection&gt;&gt;, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .changeCurrentPage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var pageChanged: BindingParser&lt;SignalInput&lt;(index: Int, data: Downcast.PageDataType)&gt;, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .pageChanged(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var constructPage: BindingParser&lt;(Downcast.PageDataType) -&gt; ViewControllerConvertible, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .constructPage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	static var didFinishAnimating: BindingParser&lt;(UIPageViewController, Bool, [UIViewController], Bool) -&gt; Void, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didFinishAnimating(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	static var interfaceOrientationForPresentation: BindingParser&lt;(UIPageViewController) -&gt; UIInterfaceOrientation, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .interfaceOrientationForPresentation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	static var spineLocationFor: BindingParser&lt;(UIPageViewController, UIInterfaceOrientation) -&gt; UIPageViewController.SpineLocation, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .spineLocationFor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	static var supportedInterfaceOrientations: BindingParser&lt;(UIPageViewController) -&gt; UIInterfaceOrientationMask, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .supportedInterfaceOrientations(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
	static var willTransitionTo: BindingParser&lt;(UIPageViewController, [UIViewController]) -&gt; Void, PageViewController&lt;Downcast.PageDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willTransitionTo(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPageViewControllerBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: PanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, PanGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asPanGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var maximumNumberOfTouches: BindingParser&lt;Dynamic&lt;Int&gt;, PanGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .maximumNumberOfTouches(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPanGestureRecognizerBinding() }) }
	static var minimumNumberOfTouches: BindingParser&lt;Dynamic&lt;Int&gt;, PanGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .minimumNumberOfTouches(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPanGestureRecognizerBinding() }) }
	static var translation: BindingParser&lt;Dynamic&lt;CGPoint&gt;, PanGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .translation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPanGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: PinchGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, PinchGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asPinchGestureRecognizerBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var scale: BindingParser&lt;Dynamic&lt;CGFloat&gt;, PinchGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .scale(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPinchGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: RotationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, RotationGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asRotationGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var rotation: BindingParser&lt;Dynamic&lt;CGFloat&gt;, RotationGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .rotation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asRotationGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ScreenEdgePanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ScreenEdgePanGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asScreenEdgePanGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var edges: BindingParser&lt;Dynamic&lt;UIRectEdge&gt;, ScreenEdgePanGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .edges(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScreenEdgePanGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ScrollViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asScrollViewBinding() }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var panGestureRecognizerStyles: BindingParser&lt;Constant&lt;PanGestureRecognizer&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .panGestureRecognizerStyles(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var pinchGestureRecognizerStyles: BindingParser&lt;Constant&lt;PinchGestureRecognizer&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .pinchGestureRecognizerStyles(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alwaysBounceHorizontal: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .alwaysBounceHorizontal(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var alwaysBounceVertical: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .alwaysBounceVertical(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var bounces: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .bounces(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var bouncesZoom: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .bouncesZoom(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var canCancelContentTouches: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .canCancelContentTouches(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var contentInset: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .contentInset(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var contentInsetAdjustmentBehavior: BindingParser&lt;Dynamic&lt;UIScrollView.ContentInsetAdjustmentBehavior&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .contentInsetAdjustmentBehavior(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var contentOffset: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;CGPoint&gt;&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .contentOffset(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var contentSize: BindingParser&lt;Dynamic&lt;CGSize&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .contentSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var decelerationRate: BindingParser&lt;Dynamic&lt;UIScrollView.DecelerationRate&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .decelerationRate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var delaysContentTouches: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .delaysContentTouches(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var indicatorStyle: BindingParser&lt;Dynamic&lt;UIScrollView.IndicatorStyle&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .indicatorStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var isDirectionalLockEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .isDirectionalLockEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var isPagingEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .isPagingEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var isScrollEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .isScrollEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var maximumZoomScale: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .maximumZoomScale(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var minimumZoomScale: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .minimumZoomScale(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var refreshControl: BindingParser&lt;Dynamic&lt;UIRefreshControl?&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .refreshControl(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var scrollIndicatorInsets: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .scrollIndicatorInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var scrollsToTop: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .scrollsToTop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var showsHorizontalScrollIndicator: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .showsHorizontalScrollIndicator(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var showsVerticalScrollIndicator: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .showsVerticalScrollIndicator(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var zoomScale: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .zoomScale(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var flashScrollIndicators: BindingParser&lt;Signal&lt;Void&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .flashScrollIndicators(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var scrollRectToVisible: BindingParser&lt;Signal&lt;(rect: CGRect, animated: Bool)&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .scrollRectToVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var zoom: BindingParser&lt;Signal&lt;(rect: CGRect, animated: Bool)&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .zoom(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var userDidScroll: BindingParser&lt;SignalInput&lt;CGPoint&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .userDidScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didEndDecelerating: BindingParser&lt;(UIScrollView) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didEndDecelerating(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var didEndDragging: BindingParser&lt;(UIScrollView, Bool) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didEndDragging(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var didEndScrollingAnimation: BindingParser&lt;(UIScrollView) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didEndScrollingAnimation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var didEndZooming: BindingParser&lt;(UIScrollView, UIView?, CGFloat) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didEndZooming(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var didScroll: BindingParser&lt;(UIScrollView, CGPoint) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var didScrollToTop: BindingParser&lt;(UIScrollView) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didScrollToTop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var didZoom: BindingParser&lt;(UIScrollView) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didZoom(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var shouldScrollToTop: BindingParser&lt;(_ scrollView: UIScrollView) -&gt; Bool, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .shouldScrollToTop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var viewForZooming: BindingParser&lt;(_ scrollView: UIScrollView) -&gt; UIView?, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .viewForZooming(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var willBeginDecelerating: BindingParser&lt;(UIScrollView) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .willBeginDecelerating(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var willBeginDragging: BindingParser&lt;(UIScrollView) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .willBeginDragging(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var willBeginZooming: BindingParser&lt;(UIScrollView, UIView?) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .willBeginZooming(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var willEndDragging: BindingParser&lt;(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;) -&gt; Void, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .willEndDragging(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: SearchBarBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asSearchBarBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: BindingParser&lt;Constant&lt;TextInputTraits&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .textInputTraits(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;PositionAndMetrics, UIImage?&gt;&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .backgroundImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var barStyle: BindingParser&lt;Dynamic&lt;UIBarStyle&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .barStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var image: BindingParser&lt;Dynamic&lt;ScopedValues&lt;IconAndControlState, UIImage?&gt;&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .image(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var inputAccessoryView: BindingParser&lt;Dynamic&lt;UIView?&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .inputAccessoryView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var isTranslucent: BindingParser&lt;Dynamic&lt;Bool&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .isTranslucent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var placeholder: BindingParser&lt;Dynamic&lt;String&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .placeholder(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var positionAdjustment: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UISearchBar.Icon, UIOffset&gt;&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .positionAdjustment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var prompt: BindingParser&lt;Dynamic&lt;String&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .prompt(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var scopeBarButtonBackgroundImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, UIImage?&gt;&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .scopeBarButtonBackgroundImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var scopeBarButtonDividerImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;LeftRightControlState, UIImage?&gt;&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .scopeBarButtonDividerImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var scopeBarButtonTitleTextAttributes: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, [NSAttributedString.Key: Any]?&gt;&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .scopeBarButtonTitleTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var scopeButtonTitles: BindingParser&lt;Dynamic&lt;[String]?&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .scopeButtonTitles(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var searchFieldBackgroundImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, UIImage?&gt;&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .searchFieldBackgroundImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var searchFieldBackgroundPositionAdjustment: BindingParser&lt;Dynamic&lt;UIOffset&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .searchFieldBackgroundPositionAdjustment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var searchTextPositionAdjustment: BindingParser&lt;Dynamic&lt;UIOffset&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .searchTextPositionAdjustment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var selectedScopeButtonIndex: BindingParser&lt;Dynamic&lt;Int&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .selectedScopeButtonIndex(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var showCancelButton: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;Bool&gt;&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .showCancelButton(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var showsBookmarkButton: BindingParser&lt;Dynamic&lt;Bool&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .showsBookmarkButton(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var showsScopeBar: BindingParser&lt;Dynamic&lt;Bool&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .showsScopeBar(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var showsSearchResultsButton: BindingParser&lt;Dynamic&lt;Bool&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .showsSearchResultsButton(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var text: BindingParser&lt;Dynamic&lt;String&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .text(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var tintColor: BindingParser&lt;Dynamic&lt;UIColor&gt;, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .tintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var bookmarkButtonClicked: BindingParser&lt;(UISearchBar) -&gt; Void, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .bookmarkButtonClicked(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var cancelButtonClicked: BindingParser&lt;(UISearchBar) -&gt; Void, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .cancelButtonClicked(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var textDidBeginEditing: BindingParser&lt;(UISearchBar) -&gt; Void, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .textDidBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var textDidChange: BindingParser&lt;(UISearchBar) -&gt; Void, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .textDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var textDidEndEditing: BindingParser&lt;(UISearchBar) -&gt; Void, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .textDidEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var position: BindingParser&lt;(UIBarPositioning) -&gt; UIBarPosition, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .position(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var resultsListButtonClicked: BindingParser&lt;(UISearchBar) -&gt; Void, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .resultsListButtonClicked(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var searchButtonClicked: BindingParser&lt;(UISearchBar) -&gt; Void, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .searchButtonClicked(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var selectedScopeButtonIndexDidChange: BindingParser&lt;(UISearchBar, Int) -&gt; Void, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .selectedScopeButtonIndexDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var shouldBeginEditing: BindingParser&lt;(UISearchBar) -&gt; Bool, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .shouldBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var shouldChangeText: BindingParser&lt;(UISearchBar, NSRange, String) -&gt; Bool, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .shouldChangeText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
	static var shouldEndEditing: BindingParser&lt;(UISearchBar) -&gt; Bool, SearchBar.Binding, Downcast&gt; { return .init(extract: { if case .shouldEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSearchBarBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: SliderBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Slider.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asSliderBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isContinuous: BindingParser&lt;Dynamic&lt;Bool&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .isContinuous(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var maximumTrackImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, UIImage?&gt;&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .maximumTrackImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var maximumTrackTintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .maximumTrackTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var maximumValue: BindingParser&lt;Dynamic&lt;Float&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .maximumValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var maximumValueImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .maximumValueImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var minimumTrackImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, UIImage?&gt;&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .minimumTrackImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var minimumTrackTintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .minimumTrackTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var minimumValue: BindingParser&lt;Dynamic&lt;Float&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .minimumValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var minimumValueImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .minimumValueImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var thumbImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, UIImage?&gt;&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .thumbImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var thumbTintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .thumbTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var value: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;Float&gt;&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .value(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: SplitViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asSplitViewControllerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var backgroundView: BindingParser&lt;Constant&lt;View&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .backgroundView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var maximumPrimaryColumnWidth: BindingParser&lt;Dynamic&lt;CGFloat&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .maximumPrimaryColumnWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var minimumPrimaryColumnWidth: BindingParser&lt;Dynamic&lt;CGFloat&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .minimumPrimaryColumnWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var preferredDisplayMode: BindingParser&lt;Dynamic&lt;UISplitViewController.DisplayMode&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .preferredDisplayMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var preferredPrimaryColumnWidthFraction: BindingParser&lt;Dynamic&lt;CGFloat&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .preferredPrimaryColumnWidthFraction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var presentsWithGesture: BindingParser&lt;Dynamic&lt;Bool&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .presentsWithGesture(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var primaryViewController: BindingParser&lt;Dynamic&lt;ViewControllerConvertible&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .primaryViewController(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var secondaryViewController: BindingParser&lt;Dynamic&lt;ViewControllerConvertible&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .secondaryViewController(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var shouldShowSecondary: BindingParser&lt;Dynamic&lt;Bool&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .shouldShowSecondary(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var dismissedSecondary: BindingParser&lt;SignalInput&lt;Void&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .dismissedSecondary(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var displayModeButton: BindingParser&lt;SignalInput&lt;BarButtonItemConvertible?&gt;, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .displayModeButton(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var collapseSecondary: BindingParser&lt;(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -&gt; Bool, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .collapseSecondary(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var preferredInterfaceOrientation: BindingParser&lt;(UISplitViewController) -&gt; UIInterfaceOrientation, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .preferredInterfaceOrientation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var primaryViewControllerForCollapsing: BindingParser&lt;(UISplitViewController) -&gt; UIViewController?, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .primaryViewControllerForCollapsing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var primaryViewControllerForExpanding: BindingParser&lt;(UISplitViewController) -&gt; UIViewController?, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .primaryViewControllerForExpanding(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var separateSecondary: BindingParser&lt;(UISplitViewController, _ fromPrimaryViewController: UIViewController) -&gt; UIViewController?, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .separateSecondary(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var showPrimaryViewController: BindingParser&lt;(UISplitViewController, _ show: UIViewController, _ sender: Any?) -&gt; Bool, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .showPrimaryViewController(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var showSecondaryViewController: BindingParser&lt;(UISplitViewController, _ show: UIViewController, _ sender: Any?) -&gt; Bool, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .showSecondaryViewController(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var supportedInterfaceOrientations: BindingParser&lt;(UISplitViewController) -&gt; UIInterfaceOrientationMask, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .supportedInterfaceOrientations(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var targetDisplayModeForAction: BindingParser&lt;(UISplitViewController) -&gt; UISplitViewController.DisplayMode, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .targetDisplayModeForAction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
	static var willChangeDisplayMode: BindingParser&lt;(UISplitViewController, UISplitViewController.DisplayMode) -&gt; Void, SplitViewController.Binding, Downcast&gt; { return .init(extract: { if case .willChangeDisplayMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewControllerBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: SwipeGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, SwipeGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asSwipeGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var direction: BindingParser&lt;Dynamic&lt;UISwipeGestureRecognizer.Direction&gt;, SwipeGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .direction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSwipeGestureRecognizerBinding() }) }
	static var numberOfTouchesRequired: BindingParser&lt;Dynamic&lt;Int&gt;, SwipeGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .numberOfTouchesRequired(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSwipeGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: SwitchBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Switch.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asSwitchBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isOn: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;Bool&gt;&gt;, Switch.Binding, Downcast&gt; { return .init(extract: { if case .isOn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSwitchBinding() }) }
	static var offImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, Switch.Binding, Downcast&gt; { return .init(extract: { if case .offImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSwitchBinding() }) }
	static var onImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, Switch.Binding, Downcast&gt; { return .init(extract: { if case .onImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSwitchBinding() }) }
	static var onTintColor: BindingParser&lt;Dynamic&lt;UIColor&gt;, Switch.Binding, Downcast&gt; { return .init(extract: { if case .onTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSwitchBinding() }) }
	static var thumbTintColor: BindingParser&lt;Dynamic&lt;UIColor&gt;, Switch.Binding, Downcast&gt; { return .init(extract: { if case .thumbTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSwitchBinding() }) }
	static var tintColor: BindingParser&lt;Dynamic&lt;UIColor&gt;, Switch.Binding, Downcast&gt; { return .init(extract: { if case .tintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSwitchBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
extension BindingParser where Downcast: TabBarControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTabBarControllerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tabBar: BindingParser&lt;Constant&lt;TabBar&lt;Downcast.ItemIdentifierType&gt;&gt;, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .tabBar(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var customizableItems: BindingParser&lt;Dynamic&lt;Set&lt;Downcast.ItemIdentifierType&gt;&gt;, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .customizableItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var items: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;[Downcast.ItemIdentifierType]&gt;&gt;, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .items(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectItem: BindingParser&lt;Signal&lt;Downcast.ItemIdentifierType&gt;, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var animationControllerForTransition: BindingParser&lt;(UITabBarController, UIViewController, Downcast.ItemIdentifierType, UIViewController, Downcast.ItemIdentifierType) -&gt; UIViewControllerAnimatedTransitioning?, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .animationControllerForTransition(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var didEndCustomizing: BindingParser&lt;(UITabBarController, [UIViewController], [Downcast.ItemIdentifierType], Bool) -&gt; Void, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didEndCustomizing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var didSelect: BindingParser&lt;(UITabBarController, UIViewController, Downcast.ItemIdentifierType) -&gt; Void, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didSelect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var interactionControllerForAnimation: BindingParser&lt;(UITabBarController, UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning?, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .interactionControllerForAnimation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var preferredInterfaceOrientationForPresentation: BindingParser&lt;(UITabBarController) -&gt; UIInterfaceOrientation, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .preferredInterfaceOrientationForPresentation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var shouldSelect: BindingParser&lt;(UITabBarController, UIViewController, Downcast.ItemIdentifierType) -&gt; Bool, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldSelect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var supportedInterfaceOrientations: BindingParser&lt;(UITabBarController) -&gt; UIInterfaceOrientationMask, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .supportedInterfaceOrientations(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var tabConstructor: BindingParser&lt;(Downcast.ItemIdentifierType) -&gt; ViewControllerConvertible, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .tabConstructor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var willBeginCustomizing: BindingParser&lt;(UITabBarController, [UIViewController], [Downcast.ItemIdentifierType]) -&gt; Void, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willBeginCustomizing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
	static var willEndCustomizing: BindingParser&lt;(UITabBarController, [UIViewController], [Downcast.ItemIdentifierType], Bool) -&gt; Void, TabBarController&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willEndCustomizing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarControllerBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: TabBarItemBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TabBarItem.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTabBarItemBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var systemItem: BindingParser&lt;Constant&lt;UITabBarItem.SystemItem?&gt;, TabBarItem.Binding, Downcast&gt; { return .init(extract: { if case .systemItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarItemBinding() }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var badgeColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, TabBarItem.Binding, Downcast&gt; { return .init(extract: { if case .badgeColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarItemBinding() }) }
	static var badgeTextAttributes: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIControl.State, [NSAttributedString.Key : Any]?&gt;&gt;, TabBarItem.Binding, Downcast&gt; { return .init(extract: { if case .badgeTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarItemBinding() }) }
	static var badgeValue: BindingParser&lt;Dynamic&lt;String?&gt;, TabBarItem.Binding, Downcast&gt; { return .init(extract: { if case .badgeValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarItemBinding() }) }
	static var selectedImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, TabBarItem.Binding, Downcast&gt; { return .init(extract: { if case .selectedImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarItemBinding() }) }
	static var titlePositionAdjustment: BindingParser&lt;Dynamic&lt;UIOffset&gt;, TabBarItem.Binding, Downcast&gt; { return .init(extract: { if case .titlePositionAdjustment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarItemBinding() }) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: TabBarBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTabBarBinding() }) }
		
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .backgroundImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var barStyle: BindingParser&lt;Dynamic&lt;UIBarStyle&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .barStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var barTintColor: BindingParser&lt;Dynamic&lt;UIColor&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .barTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var isTranslucent: BindingParser&lt;Dynamic&lt;Bool&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .isTranslucent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var itemPositioning: BindingParser&lt;Dynamic&lt;UITabBar.ItemPositioning&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .itemPositioning(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var items: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;[Downcast.ItemIdentifierType]&gt;&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .items(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var itemSpacing: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .itemSpacing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var itemWidth: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .itemWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var selectionIndicatorImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionIndicatorImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var shadowImage: BindingParser&lt;Dynamic&lt;UIImage?&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shadowImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var tintColor: BindingParser&lt;Dynamic&lt;UIColor&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .tintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var unselectedItemTintColor: BindingParser&lt;Dynamic&lt;UIColor&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .unselectedItemTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var customizingItems: BindingParser&lt;Signal&lt;SetOrAnimate&lt;[Downcast.ItemIdentifierType]?&gt;&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .customizingItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var selectItem: BindingParser&lt;Signal&lt;Downcast.ItemIdentifierType&gt;, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginCustomizing: BindingParser&lt;(UITabBar, [UITabBarItem], [Downcast.ItemIdentifierType]) -&gt; Void, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didBeginCustomizing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var didEndCustomizing: BindingParser&lt;(UITabBar, [UITabBarItem], [Downcast.ItemIdentifierType], Bool) -&gt; Void, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didEndCustomizing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var didSelectItem: BindingParser&lt;(UITabBar, UITabBarItem, Downcast.ItemIdentifierType) -&gt; Void, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didSelectItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var itemConstructor: BindingParser&lt;(Downcast.ItemIdentifierType) -&gt; TabBarItemConvertible, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .itemConstructor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var willBeginCustomizing: BindingParser&lt;(UITabBar, [UITabBarItem], [Downcast.ItemIdentifierType]) -&gt; Void, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willBeginCustomizing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
	static var willEndCustomizing: BindingParser&lt;(UITabBar, [UITabBarItem], [Downcast.ItemIdentifierType], Bool) -&gt; Void, TabBar&lt;Downcast.ItemIdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willEndCustomizing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabBarBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: TableViewCellBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTableViewCellBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var cellStyle: BindingParser&lt;Constant&lt;UITableViewCell.CellStyle&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .cellStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var contentView: BindingParser&lt;Constant&lt;View&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .contentView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var detailLabel: BindingParser&lt;Constant&lt;Label&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .detailLabel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var imageView: BindingParser&lt;Constant&lt;ImageView&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .imageView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var textLabel: BindingParser&lt;Constant&lt;Label&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .textLabel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var accessoryType: BindingParser&lt;Dynamic&lt;UITableViewCell.AccessoryType&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .accessoryType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var accessoryView: BindingParser&lt;Dynamic&lt;ViewConvertible&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .accessoryView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var backgroundView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .backgroundView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var editingAccessoryType: BindingParser&lt;Dynamic&lt;UITableViewCell.AccessoryType&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .editingAccessoryType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var editingAccessoryView: BindingParser&lt;Dynamic&lt;ViewConvertible&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .editingAccessoryView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var focusStyle: BindingParser&lt;Dynamic&lt;UITableViewCell.FocusStyle&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .focusStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var indentationLevel: BindingParser&lt;Dynamic&lt;Int&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .indentationLevel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var indentationWidth: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .indentationWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var isEditing: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;Bool&gt;&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .isEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var isHighlighted: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;Bool&gt;&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .isHighlighted(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var isSelected: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;Bool&gt;&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .isSelected(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var multipleSelectionBackgroundView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .multipleSelectionBackgroundView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var selectedBackgroundView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .selectedBackgroundView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var separatorInset: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .separatorInset(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var shouldIndentWhileEditing: BindingParser&lt;Dynamic&lt;Bool&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .shouldIndentWhileEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	static var showsReorderControl: BindingParser&lt;Dynamic&lt;Bool&gt;, TableViewCell.Binding, Downcast&gt; { return .init(extract: { if case .showsReorderControl(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewCellBinding() }) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension TableViewBinding {
	static func tableStructure&lt;S: Sequence&gt;(in bindings: S) throws -&gt; TableSectionState&lt;RowDataType&gt; where S.Element == TableView&lt;RowDataType&gt;.Binding {
		var found: TableSectionState&lt;RowDataType&gt;? = nil
		for b in bindings {
			if case .tableData(let x) = b {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				let values = x.values
				var sections = TableSectionState&lt;RowDataType&gt;()
				for v in values {
					v.value.apply(to: &amp;sections)
				}
				found = sections
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

extension BindingParser where Downcast: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTableViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tableViewStyle: BindingParser&lt;Constant&lt;UITableView.Style&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .tableViewStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMultipleSelection: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsMultipleSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var allowsMultipleSelectionDuringEditing: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsMultipleSelectionDuringEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var allowsSelection: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var allowsSelectionDuringEditing: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsSelectionDuringEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var backgroundView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .backgroundView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var cellLayoutMarginsFollowReadableWidth: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .cellLayoutMarginsFollowReadableWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var estimatedRowHeight: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .estimatedRowHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var estimatedSectionFooterHeight: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .estimatedSectionFooterHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var estimatedSectionHeaderHeight: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .estimatedSectionHeaderHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var isEditing: BindingParser&lt;Signal&lt;SetOrAnimate&lt;Bool&gt;&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .isEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var remembersLastFocusedIndexPath: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .remembersLastFocusedIndexPath(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var rowHeight: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .rowHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sectionFooterHeight: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sectionFooterHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sectionHeaderHeight: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sectionHeaderHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sectionIndexBackgroundColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sectionIndexBackgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sectionIndexColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sectionIndexColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sectionIndexMinimumDisplayRowCount: BindingParser&lt;Dynamic&lt;Int&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sectionIndexMinimumDisplayRowCount(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sectionIndexTitles: BindingParser&lt;Dynamic&lt;[String]?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sectionIndexTitles(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sectionIndexTrackingBackgroundColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sectionIndexTrackingBackgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var separatorColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .separatorColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var separatorEffect: BindingParser&lt;Dynamic&lt;UIVisualEffect?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .separatorEffect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var separatorInset: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .separatorInset(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var separatorInsetReference: BindingParser&lt;Dynamic&lt;UITableView.SeparatorInsetReference&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .separatorInsetReference(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var separatorStyle: BindingParser&lt;Dynamic&lt;UITableViewCell.SeparatorStyle&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .separatorStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var tableData: BindingParser&lt;Dynamic&lt;TableSectionAnimatable&lt;Downcast.RowDataType&gt;&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .tableData(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var tableFooterView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .tableFooterView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var tableHeaderView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .tableHeaderView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var deselectRow: BindingParser&lt;Signal&lt;SetOrAnimate&lt;IndexPath&gt;&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .deselectRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var scrollToNearestSelectedRow: BindingParser&lt;Signal&lt;SetOrAnimate&lt;UITableView.ScrollPosition&gt;&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .scrollToNearestSelectedRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var scrollToRow: BindingParser&lt;Signal&lt;SetOrAnimate&lt;TableScrollPosition&gt;&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .scrollToRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var selectRow: BindingParser&lt;Signal&lt;SetOrAnimate&lt;TableScrollPosition?&gt;&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var selectionDidChange: BindingParser&lt;SignalInput&lt;[TableRow&lt;Downcast.RowDataType&gt;]?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var userDidScrollToRow: BindingParser&lt;SignalInput&lt;TableRow&lt;Downcast.RowDataType&gt;&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .userDidScrollToRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var visibleRowsChanged: BindingParser&lt;SignalInput&lt;[TableRow&lt;Downcast.RowDataType&gt;]&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .visibleRowsChanged(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var accessoryButtonTapped: BindingParser&lt;(UITableView, TableRow&lt;Downcast.RowDataType&gt;) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .accessoryButtonTapped(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var canEditRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .canEditRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var canFocusRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .canFocusRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var canMoveRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .canMoveRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var canPerformAction: BindingParser&lt;(_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;, _ sender: Any?) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .canPerformAction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var cellConstructor: BindingParser&lt;(_ identifier: String?, _ rowSignal: SignalMulti&lt;Downcast.RowDataType&gt;) -&gt; TableViewCellConvertible, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .cellConstructor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var cellIdentifier: BindingParser&lt;(TableRow&lt;Downcast.RowDataType&gt;) -&gt; String?, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .cellIdentifier(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var commit: BindingParser&lt;(UITableView, UITableViewCell.EditingStyle, TableRow&lt;Downcast.RowDataType&gt;) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .commit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var dataMissingCell: BindingParser&lt;(IndexPath) -&gt; TableViewCellConvertible, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .dataMissingCell(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didDeselectRow: BindingParser&lt;(UITableView, TableRow&lt;Downcast.RowDataType&gt;) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didDeselectRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didEndDisplayingCell: BindingParser&lt;(UITableView, UITableViewCell, TableRow&lt;Downcast.RowDataType&gt;) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didEndDisplayingCell(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didEndDisplayingFooter: BindingParser&lt;(UITableView, UIView, Int) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didEndDisplayingFooter(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didEndDisplayingHeader: BindingParser&lt;(UITableView, UIView, Int) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didEndDisplayingHeader(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didEndEditingRow: BindingParser&lt;(UITableView, TableRow&lt;Downcast.RowDataType&gt;?) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didEndEditingRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didHightlightRow: BindingParser&lt;(UITableView, TableRow&lt;Downcast.RowDataType&gt;) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didHightlightRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didSelectRow: BindingParser&lt;(UITableView, TableRow&lt;Downcast.RowDataType&gt;) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didSelectRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didUnhighlightRow: BindingParser&lt;(UITableView, TableRow&lt;Downcast.RowDataType&gt;) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didUnhighlightRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didUpdateFocus: BindingParser&lt;(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didUpdateFocus(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var editActionsForRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; [UITableViewRowAction]?, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .editActionsForRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var editingStyleForRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; UITableViewCell.EditingStyle, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .editingStyleForRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var estimatedHeightForFooter: BindingParser&lt;(_ tableView: UITableView, _ section: Int) -&gt; CGFloat, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .estimatedHeightForFooter(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var estimatedHeightForHeader: BindingParser&lt;(_ tableView: UITableView, _ section: Int) -&gt; CGFloat, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .estimatedHeightForHeader(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var estimatedHeightForRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; CGFloat, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .estimatedHeightForRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var footerHeight: BindingParser&lt;(_ tableView: UITableView, _ section: Int) -&gt; CGFloat, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .footerHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var footerView: BindingParser&lt;(_ tableView: UITableView, _ section: Int, _ title: String?) -&gt; ViewConvertible?, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .footerView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var headerHeight: BindingParser&lt;(_ tableView: UITableView, _ section: Int) -&gt; CGFloat, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .headerHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var headerView: BindingParser&lt;(_ tableView: UITableView, _ section: Int, _ title: String?) -&gt; ViewConvertible?, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .headerView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var heightForRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; CGFloat, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .heightForRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var indentationLevelForRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; Int, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .indentationLevelForRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var indexPathForPreferredFocusedView: BindingParser&lt;(UITableView) -&gt; IndexPath, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .indexPathForPreferredFocusedView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var moveRow: BindingParser&lt;(UITableView, TableRow&lt;Downcast.RowDataType&gt;, IndexPath) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .moveRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var shouldHighlightRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldHighlightRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var shouldIndentWhileEditingRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldIndentWhileEditingRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var shouldShowMenuForRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldShowMenuForRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var shouldUpdateFocus: BindingParser&lt;(UITableView, UITableViewFocusUpdateContext) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldUpdateFocus(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var targetIndexPathForMoveFromRow: BindingParser&lt;(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -&gt; IndexPath, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .targetIndexPathForMoveFromRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var titleForDeleteConfirmationButtonForRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; String?, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .titleForDeleteConfirmationButtonForRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var willBeginEditingRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willBeginEditingRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var willDeselectRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; IndexPath?, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willDeselectRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var willDisplayFooter: BindingParser&lt;(_ tableView: UITableView, _ section: Int, _ view: UIView) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willDisplayFooter(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var willDisplayHeader: BindingParser&lt;(_ tableView: UITableView, _ section: Int, _ view: UIView) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willDisplayHeader(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var willDisplayRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;, _ cell: UITableViewCell) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willDisplayRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var willSelectRow: BindingParser&lt;(_ tableView: UITableView, _ tableRowData: TableRow&lt;Downcast.RowDataType&gt;) -&gt; IndexPath?, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willSelectRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: TapGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TapGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTapGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var numberOfTapsRequired: BindingParser&lt;Dynamic&lt;Int&gt;, TapGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .numberOfTapsRequired(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTapGestureRecognizerBinding() }) }
	static var numberOfTouchesRequired: BindingParser&lt;Dynamic&lt;Int&gt;, TapGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .numberOfTouchesRequired(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTapGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: TextFieldBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TextField.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTextFieldBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: BindingParser&lt;Constant&lt;TextInputTraits&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .textInputTraits(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsFontSizeToFitWidth: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .adjustsFontSizeToFitWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var allowsEditingTextAttributes: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .allowsEditingTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var attributedPlaceholder: BindingParser&lt;Dynamic&lt;NSAttributedString?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .attributedPlaceholder(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var attributedText: BindingParser&lt;Dynamic&lt;NSAttributedString?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .attributedText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var background: BindingParser&lt;Dynamic&lt;UIImage?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .background(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var borderStyle: BindingParser&lt;Dynamic&lt;UITextField.BorderStyle&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .borderStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var clearButtonMode: BindingParser&lt;Dynamic&lt;UITextField.ViewMode&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .clearButtonMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var clearsOnBeginEditing: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .clearsOnBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var clearsOnInsertion: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .clearsOnInsertion(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var defaultTextAttributes: BindingParser&lt;Dynamic&lt;[NSAttributedString.Key: Any]&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .defaultTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var disabledBackground: BindingParser&lt;Dynamic&lt;UIImage?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .disabledBackground(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var font: BindingParser&lt;Dynamic&lt;UIFont?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .font(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var inputAccessoryView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .inputAccessoryView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var inputView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .inputView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var leftView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .leftView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var leftViewMode: BindingParser&lt;Dynamic&lt;UITextField.ViewMode&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .leftViewMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var minimumFontSize: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .minimumFontSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var placeholder: BindingParser&lt;Dynamic&lt;String?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .placeholder(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var rightView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .rightView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var rightViewMode: BindingParser&lt;Dynamic&lt;UITextField.ViewMode&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .rightViewMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var text: BindingParser&lt;Dynamic&lt;String&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .text(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var textAlignment: BindingParser&lt;Dynamic&lt;NSTextAlignment&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .textAlignment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var textColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .textColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var typingAttributes: BindingParser&lt;Dynamic&lt;[NSAttributedString.Key: Any]?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .typingAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var resignFirstResponder: BindingParser&lt;Signal&lt;Void&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .resignFirstResponder(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginEditing: BindingParser&lt;(_ textField: UITextField) -&gt; Void, TextField.Binding, Downcast&gt; { return .init(extract: { if case .didBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var didChange: BindingParser&lt;(_ textField: UITextField) -&gt; Void, TextField.Binding, Downcast&gt; { return .init(extract: { if case .didChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var didEndEditing: BindingParser&lt;(_ textField: UITextField) -&gt; Void, TextField.Binding, Downcast&gt; { return .init(extract: { if case .didEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var didEndEditingWithReason: BindingParser&lt;(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -&gt; Void, TextField.Binding, Downcast&gt; { return .init(extract: { if case .didEndEditingWithReason(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var shouldBeginEditing: BindingParser&lt;(_ textField: UITextField) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .shouldBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var shouldChangeCharacters: BindingParser&lt;(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .shouldChangeCharacters(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var shouldClear: BindingParser&lt;(_ textField: UITextField) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .shouldClear(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var shouldEndEditing: BindingParser&lt;(_ textField: UITextField) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .shouldEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var shouldReturn: BindingParser&lt;(_ textField: UITextField) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .shouldReturn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
}

#endif

#if os(iOS)

extension TextInputTraits.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0 }) }
	
	static var autocapitalizationType: BindingParser&lt;Dynamic&lt;UITextAutocapitalizationType&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .autocapitalizationType(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var autocorrectionType: BindingParser&lt;Dynamic&lt;UITextAutocorrectionType&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .autocorrectionType(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var enablesReturnKeyAutomatically: BindingParser&lt;Dynamic&lt;Bool&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .enablesReturnKeyAutomatically(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var isSecureTextEntry: BindingParser&lt;Dynamic&lt;Bool&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .isSecureTextEntry(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var keyboardAppearance: BindingParser&lt;Dynamic&lt;UIKeyboardAppearance&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .keyboardAppearance(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var keyboardType: BindingParser&lt;Dynamic&lt;UIKeyboardType&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .keyboardType(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var returnKeyType: BindingParser&lt;Dynamic&lt;UIReturnKeyType&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .returnKeyType(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var smartDashesType: BindingParser&lt;Dynamic&lt;UITextSmartDashesType&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .smartDashesType(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var smartInsertDeleteType: BindingParser&lt;Dynamic&lt;UITextSmartInsertDeleteType&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .smartInsertDeleteType(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var smartQuotesType: BindingParser&lt;Dynamic&lt;UITextSmartQuotesType&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .smartQuotesType(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var spellCheckingType: BindingParser&lt;Dynamic&lt;UITextSpellCheckingType&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .spellCheckingType(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
	static var textContentType: BindingParser&lt;Dynamic&lt;UITextContentType&gt;, TextInputTraits.Binding, TextInputTraits.Binding&gt; { return .init(extract: { if case .textContentType(let x) = $0 { return x } else { return nil } }, upcast: { $0 }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: TextViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TextView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTextViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: BindingParser&lt;Constant&lt;TextInputTraits&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .textInputTraits(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsEditingTextAttributes: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .allowsEditingTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var attributedText: BindingParser&lt;Dynamic&lt;NSAttributedString&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .attributedText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var clearsOnInsertion: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .clearsOnInsertion(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var dataDetectorTypes: BindingParser&lt;Dynamic&lt;UIDataDetectorTypes&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .dataDetectorTypes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var font: BindingParser&lt;Dynamic&lt;UIFont?&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .font(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var inputAccessoryView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .inputAccessoryView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var inputView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .inputView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isEditable: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isEditable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isSelectable: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isSelectable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var linkTextAttributes: BindingParser&lt;Dynamic&lt;[NSAttributedString.Key: Any]&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .linkTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var selectedRange: BindingParser&lt;Dynamic&lt;NSRange&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .selectedRange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var text: BindingParser&lt;Dynamic&lt;String&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .text(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var textAlignment: BindingParser&lt;Dynamic&lt;NSTextAlignment&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .textAlignment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var textColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .textColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var textContainerInset: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .textContainerInset(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var typingAttributes: BindingParser&lt;Dynamic&lt;[NSAttributedString.Key: Any]&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .typingAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var scrollRangeToVisible: BindingParser&lt;Signal&lt;NSRange&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .scrollRangeToVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginEditing: BindingParser&lt;(UITextView) -&gt; Void, TextView.Binding, Downcast&gt; { return .init(extract: { if case .didBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var didChange: BindingParser&lt;(UITextView) -&gt; Void, TextView.Binding, Downcast&gt; { return .init(extract: { if case .didChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var didChangeSelection: BindingParser&lt;(UITextView) -&gt; Void, TextView.Binding, Downcast&gt; { return .init(extract: { if case .didChangeSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var didEndEditing: BindingParser&lt;(UITextView) -&gt; Void, TextView.Binding, Downcast&gt; { return .init(extract: { if case .didEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var shouldBeginEditing: BindingParser&lt;(UITextView) -&gt; Bool, TextView.Binding, Downcast&gt; { return .init(extract: { if case .shouldBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var shouldChangeText: BindingParser&lt;(UITextView, NSRange, String) -&gt; Bool, TextView.Binding, Downcast&gt; { return .init(extract: { if case .shouldChangeText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var shouldEndEditing: BindingParser&lt;(UITextView) -&gt; Bool, TextView.Binding, Downcast&gt; { return .init(extract: { if case .shouldEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var shouldInteractWithAttachment: BindingParser&lt;(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -&gt; Bool, TextView.Binding, Downcast&gt; { return .init(extract: { if case .shouldInteractWithAttachment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var shouldInteractWithURL: BindingParser&lt;(UITextView, URL, NSRange, UITextItemInteraction) -&gt; Bool, TextView.Binding, Downcast&gt; { return .init(extract: { if case .shouldInteractWithURL(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ToolbarBinding {
	// You can easily convert the `Binding` cases 'to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asToolbarBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;PositionAndMetrics, UIImage?&gt;&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .backgroundImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var barStyle: BindingParser&lt;Dynamic&lt;UIBarStyle&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .barStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var barTintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .barTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var isTranslucent: BindingParser&lt;Dynamic&lt;Bool&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .isTranslucent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var items: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;[BarButtonItemConvertible]&gt;&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .items(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var shadowImage: BindingParser&lt;Dynamic&lt;ScopedValues&lt;UIBarPosition, UIImage?&gt;&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .shadowImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var tintColor: BindingParser&lt;Dynamic&lt;UIColor?&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .tintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var position: BindingParser&lt;(UIBarPositioning) -&gt; UIBarPosition, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .position(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asViewControllerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationItem: BindingParser&lt;Constant&lt;NavigationItem&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .navigationItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var additionalSafeAreaInsets: BindingParser&lt;Dynamic&lt;UIEdgeInsets&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .additionalSafeAreaInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var children: BindingParser&lt;Dynamic&lt;[ViewControllerConvertible]&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .children(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var definesPresentationContext: BindingParser&lt;Dynamic&lt;Bool&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .definesPresentationContext(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var edgesForExtendedLayout: BindingParser&lt;Dynamic&lt;UIRectEdge&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .edgesForExtendedLayout(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var extendedLayoutIncludesOpaqueBars: BindingParser&lt;Dynamic&lt;Bool&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .extendedLayoutIncludesOpaqueBars(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var hidesBottomBarWhenPushed: BindingParser&lt;Dynamic&lt;Bool&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .hidesBottomBarWhenPushed(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var isEditing: BindingParser&lt;Signal&lt;SetOrAnimate&lt;Bool&gt;&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .isEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var isModalInPopover: BindingParser&lt;Dynamic&lt;Bool&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .isModalInPopover(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var modalPresentationCapturesStatusBarAppearance: BindingParser&lt;Dynamic&lt;Bool&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .modalPresentationCapturesStatusBarAppearance(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var modalPresentationStyle: BindingParser&lt;Dynamic&lt;UIModalPresentationStyle&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .modalPresentationStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var modalTransitionStyle: BindingParser&lt;Dynamic&lt;UIModalTransitionStyle&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .modalTransitionStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var preferredContentSize: BindingParser&lt;Dynamic&lt;CGSize&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .preferredContentSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var providesPresentationContextTransitionStyle: BindingParser&lt;Dynamic&lt;Bool&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .providesPresentationContextTransitionStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var restorationClass: BindingParser&lt;Dynamic&lt;UIViewControllerRestoration.Type?&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .restorationClass(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var restorationIdentifier: BindingParser&lt;Dynamic&lt;String?&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .restorationIdentifier(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var tabBarItem: BindingParser&lt;Dynamic&lt;TabBarItemConvertible&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .tabBarItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;String&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var toolbarItems: BindingParser&lt;Dynamic&lt;SetOrAnimate&lt;[BarButtonItemConvertible]&gt;&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .toolbarItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var transitioningDelegate: BindingParser&lt;Dynamic&lt;UIViewControllerTransitioningDelegate&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .transitioningDelegate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	static var view: BindingParser&lt;Dynamic&lt;ViewConvertible&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .view(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var present: BindingParser&lt;Signal&lt;Animatable&lt;ModalPresentation?, ()&gt;&gt;, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .present(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var childrenLayout: BindingParser&lt;([UIView]) -&gt; Layout, ViewController.Binding, Downcast&gt; { return .init(extract: { if case .childrenLayout(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewControllerBinding() }) }
}

#endif

#if os(iOS)

extension BindingParser where Downcast: ViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, View.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var layer: BindingParser&lt;Constant&lt;Layer&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .layer(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alpha: BindingParser&lt;Dynamic&lt;(CGFloat)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .alpha(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var backgroundColor: BindingParser&lt;Dynamic&lt;(UIColor?)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .backgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var clearsContextBeforeDrawing: BindingParser&lt;Dynamic&lt;(Bool)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .clearsContextBeforeDrawing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var clipsToBounds: BindingParser&lt;Dynamic&lt;(Bool)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .clipsToBounds(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var contentMode: BindingParser&lt;Dynamic&lt;(UIView.ContentMode)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .contentMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var gestureRecognizers: BindingParser&lt;Dynamic&lt;[GestureRecognizerConvertible]&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .gestureRecognizers(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var horizontalContentCompressionResistancePriority: BindingParser&lt;Dynamic&lt;UILayoutPriority&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .horizontalContentCompressionResistancePriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var horizontalContentHuggingPriority: BindingParser&lt;Dynamic&lt;UILayoutPriority&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .horizontalContentHuggingPriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var isExclusiveTouch: BindingParser&lt;Dynamic&lt;(Bool)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .isExclusiveTouch(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var isHidden: BindingParser&lt;Dynamic&lt;(Bool)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .isHidden(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var isMultipleTouchEnabled: BindingParser&lt;Dynamic&lt;(Bool)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .isMultipleTouchEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var isOpaque: BindingParser&lt;Dynamic&lt;(Bool)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .isOpaque(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var isUserInteractionEnabled: BindingParser&lt;Dynamic&lt;(Bool)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .isUserInteractionEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var layout: BindingParser&lt;Dynamic&lt;Layout&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .layout(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var layoutMargins: BindingParser&lt;Dynamic&lt;(UIEdgeInsets)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .layoutMargins(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var mask: BindingParser&lt;Dynamic&lt;(ViewConvertible?)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .mask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var motionEffects: BindingParser&lt;Dynamic&lt;([UIMotionEffect])&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .motionEffects(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var preservesSuperviewLayoutMargins: BindingParser&lt;Dynamic&lt;(Bool)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .preservesSuperviewLayoutMargins(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var restorationIdentifier: BindingParser&lt;Dynamic&lt;String?&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .restorationIdentifier(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var semanticContentAttribute: BindingParser&lt;Dynamic&lt;(UISemanticContentAttribute)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .semanticContentAttribute(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var tag: BindingParser&lt;Dynamic&lt;Int&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .tag(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var tintAdjustmentMode: BindingParser&lt;Dynamic&lt;(UIView.TintAdjustmentMode)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .tintAdjustmentMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var tintColor: BindingParser&lt;Dynamic&lt;(UIColor)&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .tintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var verticalContentCompressionResistancePriority: BindingParser&lt;Dynamic&lt;UILayoutPriority&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .verticalContentCompressionResistancePriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var verticalContentHuggingPriority: BindingParser&lt;Dynamic&lt;UILayoutPriority&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .verticalContentHuggingPriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var becomeFirstResponder: BindingParser&lt;Signal&lt;Void&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .becomeFirstResponder(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var endEditing: BindingParser&lt;Signal&lt;Bool&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .endEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(iOS)

extension BindingParser where Downcast: WindowBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Window.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asWindowBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var frame: BindingParser&lt;Dynamic&lt;CGRect&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .frame(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var rootViewController: BindingParser&lt;Dynamic&lt;ViewControllerConvertible&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .rootViewController(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var screen: BindingParser&lt;Dynamic&lt;UIScreen&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .screen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var windowLevel: BindingParser&lt;Dynamic&lt;UIWindow.Level&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .windowLevel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var makeKey: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .makeKey(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBecomeVisible: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didBecomeVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didBecomeHidden: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didBecomeHidden(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didBecomeKey: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didBecomeKey(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didResignKey: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didResignKey(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var keyboardWillShow: BindingParser&lt;SignalInput&lt;[AnyHashable: Any]?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .keyboardWillShow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var keyboardDidShow: BindingParser&lt;SignalInput&lt;[AnyHashable: Any]?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .keyboardDidShow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var keyboardWillHide: BindingParser&lt;SignalInput&lt;[AnyHashable: Any]?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .keyboardWillHide(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var keyboardDidHide: BindingParser&lt;SignalInput&lt;[AnyHashable: Any]?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .keyboardDidHide(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var keyboardWillChangeFrame: BindingParser&lt;SignalInput&lt;[AnyHashable: Any]?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .keyboardWillChangeFrame(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var keyboardDidChangeFrame: BindingParser&lt;SignalInput&lt;[AnyHashable: Any]?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .keyboardDidChangeFrame(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif
</string>
		<key>MockServices.swift:content</key>
		<string>import Foundation

class MockFileService: FileService {
	enum FileError: Error {
		case notFound
	}
	static let appSupport = URL(fileURLWithPath: "/Application Support/")
	var files: [URL: Data] = [:]
	
	func applicationSupportURL() throws -&gt; URL {
		return MockFileService.appSupport
	}
	
	func data(contentsOf url: URL) throws -&gt; Data {
		guard let file = files[url] else { throw FileError.notFound }
		return file
	}
	
	func writeData(_ data: Data, to url: URL) throws {
		files[url] = data
	}
	
	func fileExists(at url: URL) -&gt; Bool {
		return files[url] != nil
	}
}</string>
		<key>TableViewTests.swift:content</key>
		<string>import XCTest

class TableViewTests: XCTestCase {
	
	var services: Services!
	var doc: DocumentAdapter!
	var navState: NavViewState!
	var tableState: TableViewState!
	
	var tableBindings: [TableView&lt;String&gt;.Binding] = []
	var rightBarButtonBindings: [BarButtonItem.Binding] = []
	
	override func setUp() {
		services = Services(fileService: MockFileService())
		doc = DocumentAdapter(document: Document(services: services))
		navState = NavViewState()
		tableState = TableViewState()

		let viewControllerBindings = try! ViewController.consumeBindings(from: tableViewController(tableState, navState, doc))
		let navigationItemBindings = try! NavigationItem.consumeBindings(from: ViewController.constantValue(for: .navigationItem, in: viewControllerBindings))
		rightBarButtonBindings = try! BarButtonItem.consumeBindings(from: NavigationItem.latestValue(for: .rightBarButtonItems, in: navigationItemBindings).value.first!)
		tableBindings = try! TableView&lt;String&gt;.consumeBindings(from: ViewController.latestValue(for: .view, in: viewControllerBindings))
	}
	
	override func tearDown() {
	}
	
	func testInitialTableRows() throws {
		let tableState = try TableView&lt;String&gt;.Binding.tableStructure(in: tableBindings)
		XCTAssertEqual(Array(tableState.values?.first?.values ?? []), Document.initialContents().rows)
	}
	
	func testCreateRow() throws {
		let targetAction = try BarButtonItem.argument(for: .action, in: rightBarButtonBindings)
		
		switch targetAction {
		case .singleTarget(let input): input.send(nil)
		default: fatalError()
		}
		
		let tableState = try TableView&lt;String&gt;.Binding.tableStructure(in: tableBindings)
		XCTAssertEqual(Array(tableState.values?.first?.values ?? []), Document.initialContents().rows + ["4"])
	}
	
	func testDeleteRow() throws {
		let commit = try TableView&lt;String&gt;.argument(for: .commit, in: tableBindings)
		commit(UITableView(), .delete, TableRow&lt;String&gt;(indexPath: IndexPath(row: 0, section: 0), data: "1"))
		
		let tableState = try TableView&lt;String&gt;.Binding.tableStructure(in: tableBindings)
		var expected = Document.initialContents().rows
		expected.remove(at: 0)
		XCTAssertEqual(Array(tableState.values?.first?.values ?? []), expected)
	}
}</string>
	</dict>
	<key>Identifier</key>
	<string>com.cocoawithlove.views-unit.cocoaTouchApplicationUnitTestBundle</string>
	<key>Kind</key>
	<string>Xcode.Xcode3.ProjectTemplateUnitKind</string>
	<key>Nodes</key>
	<array>
		<string>CwlViews_iOSTesting.swift:comments</string>
		<string>CwlViews_iOSTesting.swift:imports:importProject</string>
		<string>CwlViews_iOSTesting.swift:content</string>
		<string>MockServices.swift:comments</string>
		<string>MockServices.swift:imports:importProject</string>
		<string>MockServices.swift:content</string>
		<string>TableViewTests.swift:comments</string>
		<string>TableViewTests.swift:imports:importProject</string>
		<string>TableViewTests.swift:content</string>
	</array>
	<key>Targets</key>
	<array>
		<dict>
			<key>TargetIdentifier</key>
			<string>com.apple.dt.cocoaTouchApplicationUnitTestBundleTarget</string>
			<key>TargetIdentifierToBeTested</key>
			<string>com.apple.dt.cocoaTouchApplicationTarget</string>
		</dict>
	</array>
</dict>
</plist>
