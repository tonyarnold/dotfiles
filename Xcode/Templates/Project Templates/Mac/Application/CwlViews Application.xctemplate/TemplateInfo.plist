<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Ancestors</key>
	<array>
		<string>com.apple.dt.unit.cocoaApplicationBase</string>
		<string>com.apple.dt.unit.osxBase</string>
	</array>
	<key>Concrete</key>
	<integer>1</integer>
	<key>Definitions</key>
	<dict>
		<key>*:imports:importAppKit</key>
		<string>import AppKit</string>
		<key>*:imports:importFoundation</key>
		<string>import Foundation</string>
		<key>Assets.xcassets</key>
		<dict>
			<key>AssetGeneration</key>
			<array>
				<dict>
					<key>Name</key>
					<string>AppIcon</string>
					<key>Platforms</key>
					<dict>
						<key>macOS</key>
						<string>true</string>
					</dict>
					<key>Type</key>
					<string>appicon</string>
				</dict>
			</array>
			<key>Path</key>
			<string>Images.xcassets</string>
			<key>SortOrder</key>
			<integer>100</integer>
		</dict>
		<key>Dependencies/CwlSignal.swift</key>
		<dict>
			<key>Beginning</key>
			<string>//
//  This file is part of a concatenation of the CwlSignal framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlSignal
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-05-11 02:03:24 +0000 from the following files:
//   CwlSignal.swift
//   CwlSignalChannel.swift
//   CwlSignalCocoa.swift
//   CwlSignalExtensions.swift
//   CwlSignalReactive.swift

import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

/// This protocol allows transformations that apply to `Signal` types to be applied to a type that exposes a signal.
protocol SignalInterface {
	associatedtype OutputValue
	var signal: Signal&lt;OutputValue&gt; { get }
}

/// This protocol allows transformations that apply to `Signal` types to be applied to a type that exposes a signal.
protocol SignalInputInterface {
	associatedtype InputValue
	var input: SignalInput&lt;InputValue&gt; { get }
}

#if DEBUG_LOGGING
	// NOTE: This is thread unsafe. There should really be a lock around access and logging.
	var globalCount: Int = 0
#endif

/// A composable, one-way, potentially asynchronous, FIFO communication channel that delivers a sequence of `Result&lt;OutputValue, SignalEnd&gt;`.
///
/// In conjunction with various transformation functions, this class forms the core of a reactive programming system. Try the playgrounds for a better walkthrough of concepts and usage.
///
/// # Terminology
///
/// The word "signal" may be used in a number of ways, so keep in mind:
///	- `Signal`: refers to this class
///	- signal graph: one or more `Signal` instances, connected together, from `SignalInput` to `SignalOutput`
///	- signal: the sequence of `Result` instances, from activation to close, that pass through a signal graph
class Signal&lt;OutputValue&gt;: SignalInterface {
	typealias Result = Swift.Result&lt;OutputValue, SignalEnd&gt;
	enum Next {
		case none
		case single(Result)
		case array(Array&lt;Result&gt;)
	}
	
	// # GOALS
	//
	// The primary design goals for this implementation are:
	//	1. All possible actions on `Signal` itself are threadsafe (no possible action results in undefined or corrupt memory behavior for internal data)
	// 2. Deadlocks on internally created mutexes will never occur.
	//	3. Values will never be delivered out-of-order.
	//	4. After a disconnection and reconnection, only values from the latest connection will be delivered.
	//	5. Loopback (sending to an antecedent input from a subsequent signal handler) and attempts at re-entrancy to any closure in the graph are permitted. Attempted re-entrancy delivery is simply queued to be delivered after any in-flight behavior completes.
	//
	// That's quite a list of goals but it's largely covered by two ideas:
	//	1. No user code is ever invoked inside a `Signal` internal mutex
	//	2. Delivery to a `Signal` includes the "predecessor" and the "activationCount". If either fail to match the internal state of the `Signal`, then the delivery is out-of-date and can be discarded.
	//
	// The first of these points is ensured through the use of `itemProcessing`, `holdCount` and `DeferredWork`. The `itemProcessing` and `holdCount` block a queue while out-of-mutex work is performed. The `DeferredWork` defers work to be performed later, once the stack has unwound and no mutexes are held.
	// This ensures that no problematic work is performed inside a mutex but it means that we often have "in-flight" work occurring outside a mutex that might no longer be valid. So we need to combine this work identifiers that allow us to reject out-of-date work. That's where the second point becomes important.
	// The "activationCount" for an `Signal` changes any time a manual input control is generated (`SignalInput`/`SignalMergedInput`), any time a first predecessor is added or any time there are predecessors connected and the `delivery` state changes to or from `.disabled`. Combined with the fact that it is not possible to disconnect and re-add the same predecessor to a multi-input Signal (SignalMergedInput or SignalCombiner) this guarantees any messages from out-of-date but still in-flight deliveries are ignored.
	//
	// # LIMITS TO THREADSAFETY
	//
	// While all actions on `Signal` are threadsafe, there are some points to keep in mind:
	//   1. Threadsafe means that the internal members of the `Signal` class will remain threadsafe and your own closures will always be serially and non-reentrantly invoked on the provided `Exec` context. However, this doesn't mean that work you perform in processing closures is always threadsafe; shared references or mutable captures in your closures will still require mutual exclusion.
	//   2. Delivery of signal values is guaranteed to be in-order and within appropriate mutexes but is not guaranteed to be executed on the sending thread. If subsequent results are sent to a `Signal` from a second thread while the `Signal` is processing a previous result from a first thread the subsequent result will be *queued* and handled on the *first* thread once it completes processing the earlier values.
	//   3. Handlers, captured values and state values will be released *outside* all contexts or mutexes. If you capture an object with `deinit` behavior in a processing closure, you must apply any synchronization context yourself.
	
	// MARK: - Signal static construction functions
	
	/// Create a manual input/output pair where values sent to the `SignalInput` are passed through the `Signal` output.
	///
	/// - returns: a (`SignalInput`, `Signal`) tuple being the input and output for this stage in the signal pipeline.
	static func create() -&gt; (input: SignalInput&lt;OutputValue&gt;, signal: Signal&lt;OutputValue&gt;) {
		let s = Signal&lt;OutputValue&gt;()
		s.activationCount = 1
		return (SignalInput(signal: s, activationCount: s.activationCount), s)
	}
	
	/// A version of created that creates a `SignalMultiInput` instead of a `SignalInput`.
	///
	/// - Returns: the (input, signal)
	static func createMultiInput() -&gt; (input: SignalMultiInput&lt;OutputValue&gt;, signal: Signal&lt;OutputValue&gt;) {
		let s = Signal&lt;OutputValue&gt;()
		var dw = DeferredWork()
		s.mutex.sync { s.updateActivationInternal(andInvalidateAllPrevious: true, dw: &amp;dw) }
		dw.runWork()
		return (SignalMultiInput(signal: s), s)
	}
	
	/// A version of created that creates a `SignalMergedInput` instead of a `SignalInput`.
	///
	/// - Returns: the (input, signal)
	static func createMergedInput(onLastInputClosed: SignalEnd? = nil, onDeinit: SignalEnd = .cancelled) -&gt; (input: SignalMergedInput&lt;OutputValue&gt;, signal: Signal&lt;OutputValue&gt;) {
		let s = Signal&lt;OutputValue&gt;()
		var dw = DeferredWork()
		s.mutex.sync { s.updateActivationInternal(andInvalidateAllPrevious: true, dw: &amp;dw) }
		dw.runWork()
		return (SignalMergedInput(signal: s, onLastInputClosed: onLastInputClosed, onDeinit: onDeinit), s)
	}
	
	/// Similar to `create`, in that it creates a "head" for the graph but rather than immediately providing a `SignalInput`, this function calls the `activationChange` function when the signal graph is activated and provides the newly created `SignalInput` at that time. When the graph deactivates, `nil` is sent to the `activationChange` function. If a subsequent reactivation occurs, the new `SignalInput` for the re-activation is provided.
	///
	/// - Parameters:
	///   - context: the `activationChange` will be invoked in this context
	///   - activationChange: receives inputs on activation and nil on each deactivation
	/// - Returns: the constructed `Signal`
	static func generate(context: Exec = .direct, _ activationChange: @escaping (_ input: SignalInput&lt;OutputValue&gt;?) -&gt; Void) -&gt; Signal&lt;OutputValue&gt; {
		let s = Signal&lt;OutputValue&gt;()
		let nis = Signal&lt;Any?&gt;()
		s.newInputSignal = (nis, nis.subscribe(context: context) { r in
			if case .success(let v) = r {
				activationChange(v as? SignalInput&lt;OutputValue&gt;)
			}
		})
		return s
	}
	
	/// Constructs a `SignalMulti` with an array of "activation" values and a closing error.
	///
	/// - Parameters:
	///   - values: an array of values
	///   - end: the closing condition for the `Signal`
	/// - Returns: a `SignalMulti`
	static func preclosed&lt;S: Sequence&gt;(sequence: S, end: SignalEnd = .complete) -&gt; SignalMulti&lt;OutputValue&gt; where S.Iterator.Element == OutputValue {
		return SignalMulti&lt;OutputValue&gt;(processor: Signal&lt;OutputValue&gt;().attach { (s, dw) in
			SignalMultiProcessor(source: s, values: (Array(sequence), end), userUpdated: false, activeWithoutOutputs: .always, dw: &amp;dw, context: .direct, updater: { a, p, r in ([], nil) })
		})
	}
	
	/// Constructs a `SignalMulti` with a single activation value and a closing error.
	///
	/// - Parameters:
	///   - value: a single value
	///   - end: the closing condition for the `Signal`
	/// - Returns: a `SignalMulti`
	static func preclosed(_ values: OutputValue..., end: SignalEnd = .complete) -&gt; SignalMulti&lt;OutputValue&gt; {
		return preclosed(sequence: values, end: end)
	}
	
	/// Constructs a `SignalMulti` that is already closed with an error.
	///
	/// - Parameter end: the closing condition for the `Signal`
	/// - Returns: a `SignalMulti`
	static func preclosed(end: SignalEnd = .complete) -&gt; SignalMulti&lt;OutputValue&gt; {
		return SignalMulti&lt;OutputValue&gt;(processor: Signal&lt;OutputValue&gt;().attach { (s, dw) in
			SignalMultiProcessor(source: s, values: ([], end), userUpdated: false, activeWithoutOutputs: .always, dw: &amp;dw, context: .direct, updater: { a, p, r in ([], nil) })
		})
	}
	
	// MARK: - Signal transformation functions
	
	var signal: Signal&lt;OutputValue&gt; { return self }
	
	/// Appends a `SignalOutput` listener to the value emitted from this `Signal`. The output will "activate" this `Signal` and all direct antecedents in the graph (which may start lazy operations deferred until activation).
	///
	/// - Parameters:
	///   - context: context: the `Exec` context used to invoke the `handler`
	///   - handler: the function invoked for each received `Result`
	/// - Returns: the created `SignalOutput` (if released, the subscription will be cancelled).
	final func subscribe(context: Exec = .direct, _ handler: @escaping (Result) -&gt; Void) -&gt; SignalOutput&lt;OutputValue&gt; {
		return attach { (s, dw) in
			SignalOutput&lt;OutputValue&gt;(source: s, dw: &amp;dw, context: context, handler: handler)
		}
	}
	
	/// A version of `subscribe` that retains the `SignalOutput` internally, keeping the signal graph alive. The `SignalOutput` is cancelled and released if the signal closes or if the handler returns `false` after any signal.
	///
	/// NOTE: this subscriber deliberately creates a reference counted loop. If the signal is never closed and the handler never returns false, it will result in a memory leak. This function should be used only when `self` is guaranteed to close or the handler `false` condition is guaranteed.
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received and if returns `false`, the output will be cancelled and released
	final func subscribeWhile(context: Exec = .direct, _ handler: @escaping (Result) -&gt; Bool) {
		_ = attach { (s, dw) in
			var handlerRetainedOutput: SignalOutput&lt;OutputValue&gt;? = nil
			let output = SignalOutput&lt;OutputValue&gt;(source: s, dw: &amp;dw, context: context, handler: { r in
				withExtendedLifetime(handlerRetainedOutput) {}
				if !handler(r) || r.isFailure {
					handlerRetainedOutput?.cancel()
					handlerRetainedOutput = nil
				}
			})
			handlerRetainedOutput = output
			return output
		}
	}
	
	/// Appends a disconnected `SignalJunction` to this `Signal` so outputs can be repeatedly joined and disconnected from this graph in the future.
	///
	/// - Returns: the `SignalJunction&lt;OutputValue&gt;`
	final func junction() -&gt; SignalJunction&lt;OutputValue&gt; {
		return attach { (s, dw) -&gt; SignalJunction&lt;OutputValue&gt; in
			return SignalJunction&lt;OutputValue&gt;(source: s, dw: &amp;dw)
		}
	}
	
	/// Appends an immediately activated handler that captures any activation values from this `Signal`. The captured values can be accessed from the `SignalCapture&lt;OutputValue&gt;` using the `activation()` function. The `SignalCapture&lt;OutputValue&gt;` can then be joined to further `Signal`s using the `bind(to:)` function on the `SignalCapture&lt;OutputValue&gt;`.
	///
	/// - Returns: the handler than can be used to obtain activation values and bind to subsequent nodes.
	final func capture() -&gt; SignalCapture&lt;OutputValue&gt; {
		return attach { (s, dw) -&gt; SignalCapture&lt;OutputValue&gt; in
			SignalCapture&lt;OutputValue&gt;(source: s, dw: &amp;dw)
		}
	}
	
	/// Appends a handler function that transforms the value emitted from this `Signal` into a new `Signal`.
	///
	/// - Parameters:
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: the function invoked for each received `Result`
	/// - Returns: the created `Signal`
	final func transform&lt;U&gt;(context: Exec = .direct, _ processor: @escaping (Result) -&gt; Signal&lt;U&gt;.Next) -&gt; Signal&lt;U&gt; {
		return Signal&lt;U&gt;(processor: attach { (s, dw) in
			SignalTransformer&lt;OutputValue, U&gt;(source: s, dw: &amp;dw, context: context, processor)
		}).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that transforms the value emitted from this `Signal` into a new `Signal`.
	///
	/// - Parameters:
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: the function invoked for each received `Result`
	/// - Returns: the created `Signal`
	final func transformActivation&lt;U&gt;(context: Exec = .direct, activation: @escaping (Result) -&gt; Signal&lt;U&gt;.Next, _ processor: @escaping (Result) -&gt; Signal&lt;U&gt;.Next) -&gt; Signal&lt;U&gt; {
		return Signal&lt;U&gt;(processor: attach { (s, dw) in
			SignalActivationTransformer&lt;OutputValue, U&gt;(source: s, dw: &amp;dw, context: context, activationProcessor: activation, processor)
		}).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that transforms the value emitted from this `Signal` into a new `Signal`.
	///
	/// - Parameters:
	///   - initialState: the initial value for a state value associated with the handler. This value is retained and if the signal graph is deactivated, the state value is reset to this value.
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: the function invoked for each received `Result`
	/// - Returns: the transformed output `Signal`
	final func transform&lt;S, U&gt;(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Result) -&gt; Signal&lt;U&gt;.Next) -&gt; Signal&lt;U&gt; {
		return Signal&lt;U&gt;(processor: attach { (s, dw) in
			SignalTransformerWithState&lt;OutputValue, U, S&gt;(source: s, initialState: initialState, dw: &amp;dw, context: context, processor)
		}).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that receives inputs from this and another `Signal&lt;U&gt;`. The `handler` function applies any transformation it wishes an emits a (potentially) third `Signal` type.
	///
	/// - Parameters:
	///   - second:   the other `Signal` that is, along with `self` used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self` or `second` as `EitherResult2&lt;OutputValue, U&gt;` (an enum which may contain either `.result1` or `.result2` corresponding to `self` or `second`) and sends results to an `SignalNext&lt;V&gt;`.
	/// - Returns: an `Signal&lt;V&gt;` which is the result stream from the `SignalNext&lt;V&gt;` passed to the `handler`.
	final func combine&lt;U: SignalInterface, V&gt;(_ second: U, context: Exec = .direct, _ processor: @escaping (EitherResult2&lt;OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;V&gt;.Next) -&gt; Signal&lt;V&gt; {
		return Signal&lt;EitherResult2&lt;OutputValue, U.OutputValue&gt;&gt;(processor: self.attach { (s1, dw) -&gt; SignalCombiner&lt;OutputValue, EitherResult2&lt;OutputValue, U.OutputValue&gt;&gt; in
			SignalCombiner(source: s1, dw: &amp;dw, context: .direct, processor: EitherResult2&lt;OutputValue, U.OutputValue&gt;.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -&gt; SignalCombiner&lt;U.OutputValue, EitherResult2&lt;OutputValue, U.OutputValue&gt;&gt; in
			SignalCombiner(source: s2, dw: &amp;dw, context: .direct, processor: EitherResult2&lt;OutputValue, U.OutputValue&gt;.result2)
		}).transform(context: context, Signal.successProcessor(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that receives inputs from this and two other `Signal`s. The `handler` function applies any transformation it wishes an emits a (potentially) fourth `Signal` type.
	///
	/// - Parameters:
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second` or `third` as `EitherResult3&lt;OutputValue, U, V&gt;` (an enum which may contain either `.result1`, `.result2` or `.result3` corresponding to `self`, `second` or `third`) and sends results to an `SignalNext&lt;W&gt;`.
	/// - Returns: an `Signal&lt;W&gt;` which is the result stream from the `SignalNext&lt;W&gt;` passed to the `handler`.
	final func combine&lt;U: SignalInterface, V: SignalInterface, W&gt;(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;) -&gt; Signal&lt;W&gt;.Next) -&gt; Signal&lt;W&gt; {
		return Signal&lt;EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt;(processor: self.attach { (s1, dw) -&gt; SignalCombiner&lt;OutputValue, EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt; in
			SignalCombiner(source: s1, dw: &amp;dw, context: .direct, processor: EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -&gt; SignalCombiner&lt;U.OutputValue, EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt; in
			SignalCombiner(source: s2, dw: &amp;dw, context: .direct, processor: EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -&gt; SignalCombiner&lt;V.OutputValue, EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt; in
			SignalCombiner(source: s3, dw: &amp;dw, context: .direct, processor: EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;.result3)
		}).transform(context: context, Signal.successProcessor(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that receives inputs from this and three other `Signal`s. The `handler` function applies any transformation it wishes an emits a (potentially) fifth `Signal` type.
	///
	/// - Parameters:
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - fourth: the fourth `Signal`, after `self`, `second` and `third`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second`, `third` or `fourth` as `EitherResult4&lt;OutputValue, U, V, W&gt;` (an enum which may contain either `.result1`, `.result2`, `.result3` or `.result4` corresponding to `self`, `second`, `third` or `fourth`) and sends results to an `SignalNext&lt;X&gt;`.
	/// - Returns: an `Signal&lt;X&gt;` which is the result stream from the `SignalNext&lt;X&gt;` passed to the `handler`.
	final func combine&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;) -&gt; Signal&lt;X&gt;.Next) -&gt; Signal&lt;X&gt; {
		return Signal&lt;EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt;(processor: self.attach { (s1, dw) -&gt; SignalCombiner&lt;OutputValue, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt; in
			SignalCombiner(source: s1, dw: &amp;dw, context: .direct, processor: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -&gt; SignalCombiner&lt;U.OutputValue, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt; in
			SignalCombiner(source: s2, dw: &amp;dw, context: .direct, processor: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -&gt; SignalCombiner&lt;V.OutputValue, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt; in
			SignalCombiner(source: s3, dw: &amp;dw, context: .direct, processor: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;.result3)
		}).addPreceeding(processor: fourth.signal.attach { (s4, dw) -&gt; SignalCombiner&lt;W.OutputValue, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt; in
			SignalCombiner(source: s4, dw: &amp;dw, context: .direct, processor: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;.result4)
		}).transform(context: context, Signal.successProcessor(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that receives inputs from this and four other `Signal`s. The `handler` function applies any transformation it wishes an emits a (potentially) sixth `Signal` type.
	///
	/// - Parameters:
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - fourth: the fourth `Signal`, after `self`, `second` and `third`, used as input to the `handler`
	///   - fifth: the fifth `Signal`, after `self`, `second`, `third` and `fourth`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second`, `third`, `fourth` or `fifth` as `EitherResult5&lt;OutputValue, U, V, W, X&gt;` (an enum which may contain either `.result1`, `.result2`, `.result3`, `.result4` or  `.result5` corresponding to `self`, `second`, `third`, `fourth` or `fifth`) and sends results to an `SignalNext&lt;Y&gt;`.
	/// - Returns: an `Signal&lt;Y&gt;` which is the result stream from the `SignalNext&lt;Y&gt;` passed to the `handler`.
	final func combine&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;) -&gt; Signal&lt;Y&gt;.Next) -&gt; Signal&lt;Y&gt; {
		return Signal&lt;EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt;(processor: self.attach { (s1, dw) -&gt; SignalCombiner&lt;OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s1, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -&gt; SignalCombiner&lt;U.OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s2, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -&gt; SignalCombiner&lt;V.OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s3, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result3)
		}).addPreceeding(processor: fourth.signal.attach { (s4, dw) -&gt; SignalCombiner&lt;W.OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s4, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result4)
		}).addPreceeding(processor: fifth.signal.attach { (s5, dw) -&gt; SignalCombiner&lt;X.OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s5, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result5)
		}).transform(context: context, Signal.successProcessor(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Similar to `combine(second:context:handler:)` with an additional "state" value.
	///
	/// - Parameters:
	///   - initialState: the initial value of a "state" value passed into the closure on each invocation. The "state" will be reset to this value if the `Signal` deactivates.
	///   - second:   the other `Signal` that is, along with `self` used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self` or `second` as `EitherResult2&lt;OutputValue, U&gt;` (an enum which may contain either `.result1` or `.result2` corresponding to `self` or `second`) and sends results to an `SignalNext&lt;V&gt;`.
	/// - Returns: an `Signal&lt;V&gt;` which is the result stream from the `SignalNext&lt;V&gt;` passed to the `handler`.
	final func combine&lt;S, U: SignalInterface, V&gt;(_ second: U, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult2&lt;OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;V&gt;.Next) -&gt; Signal&lt;V&gt; {
		return Signal&lt;EitherResult2&lt;OutputValue, U.OutputValue&gt;&gt;(processor: self.attach { (s1, dw) -&gt; SignalCombiner&lt;OutputValue, EitherResult2&lt;OutputValue, U.OutputValue&gt;&gt; in
			SignalCombiner(source: s1, dw: &amp;dw, context: .direct, processor: EitherResult2&lt;OutputValue, U.OutputValue&gt;.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -&gt; SignalCombiner&lt;U.OutputValue, EitherResult2&lt;OutputValue, U.OutputValue&gt;&gt; in
			SignalCombiner(source: s2, dw: &amp;dw, context: .direct, processor: EitherResult2&lt;OutputValue, U.OutputValue&gt;.result2)
		}).transform(initialState: initialState, context: context, Signal.successProcessorWithState(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Similar to `combine(second:third:context:handler:)` with an additional "state" value.
	///
	/// - Parameters:
	///   - initialState: the initial value of a "state" value passed into the closure on each invocation. The "state" will be reset to this value if the `Signal` deactivates.
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second` or `third` as `EitherResult3&lt;OutputValue, U, V&gt;` (an enum which may contain either `.result1`, `.result2` or `.result3` corresponding to `self`, `second` or `third`) and sends results to an `SignalNext&lt;W&gt;`.
	/// - Returns: an `Signal&lt;W&gt;` which is the result stream from the `SignalNext&lt;W&gt;` passed to the `handler`.
	final func combine&lt;S, U: SignalInterface, V: SignalInterface, W&gt;(_ second: U, _ third: V, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;) -&gt; Signal&lt;W&gt;.Next) -&gt; Signal&lt;W&gt; {
		return Signal&lt;EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt;(processor: self.attach { (s1, dw) -&gt; SignalCombiner&lt;OutputValue, EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt; in
			SignalCombiner(source: s1, dw: &amp;dw, context: .direct, processor: EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -&gt; SignalCombiner&lt;U.OutputValue, EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt; in
			SignalCombiner(source: s2, dw: &amp;dw, context: .direct, processor: EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -&gt; SignalCombiner&lt;V.OutputValue, EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt; in
			SignalCombiner(source: s3, dw: &amp;dw, context: .direct, processor: EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;.result3)
		}).transform(initialState: initialState, context: context, Signal.successProcessorWithState(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Similar to `combine(second:third:fourth:context:handler:)` with an additional "state" value.
	///
	/// - Parameters:
	///   - initialState: the initial value of a "state" value passed into the closure on each invocation. The "state" will be reset to this value if the `Signal` deactivates.
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - fourth: the fourth `Signal`, after `self`, `second` and `third`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second`, `third` or `fourth` as `EitherResult4&lt;OutputValue, U, V, W&gt;` (an enum which may contain either `.result1`, `.result2`, `.result3` or `.result4` corresponding to `self`, `second`, `third` or `fourth`) and sends results to an `SignalNext&lt;X&gt;`.
	/// - Returns: an `Signal&lt;X&gt;` which is the result stream from the `SignalNext&lt;X&gt;` passed to the `handler`.
	final func combine&lt;S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(_ second: U, _ third: V, _ fourth: W, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;) -&gt; Signal&lt;X&gt;.Next) -&gt; Signal&lt;X&gt; {
		return Signal&lt;EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt;(processor: self.attach { (s1, dw) -&gt; SignalCombiner&lt;OutputValue, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt; in
			SignalCombiner(source: s1, dw: &amp;dw, context: .direct, processor: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -&gt; SignalCombiner&lt;U.OutputValue, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt; in
			SignalCombiner(source: s2, dw: &amp;dw, context: .direct, processor: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -&gt; SignalCombiner&lt;V.OutputValue, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt; in
			SignalCombiner(source: s3, dw: &amp;dw, context: .direct, processor: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;.result3)
		}).addPreceeding(processor: fourth.signal.attach { (s4, dw) -&gt; SignalCombiner&lt;W.OutputValue, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt; in
			SignalCombiner(source: s4, dw: &amp;dw, context: .direct, processor: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;.result4)
		}).transform(initialState: initialState, context: context, Signal.successProcessorWithState(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Similar to `combine(second:third:fourth:fifthcontext:handler:)` with an additional "state" value.
	///
	/// - Parameters:
	///   - initialState: the initial value of a "state" value passed into the closure on each invocation. The "state" will be reset to this value if the `Signal` deactivates.
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - fourth: the fourth `Signal`, after `self`, `second` and `third`, used as input to the `handler`
	///   - fifth: the fifth `Signal`, after `self`, `second`, `third` and `fourth`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second`, `third`, `fourth` or `fifth` as `EitherResult5&lt;OutputValue, U, V, W, X&gt;` (an enum which may contain either `.result1`, `.result2`, `.result3`, `.result4` or  `.result5` corresponding to `self`, `second`, `third`, `fourth` or `fifth`) and sends results to an `SignalNext&lt;Y&gt;`.
	/// - Returns: an `Signal&lt;Y&gt;` which is the result stream from the `SignalNext&lt;Y&gt;` passed to the `handler`.
	final func combine&lt;S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;) -&gt; Signal&lt;Y&gt;.Next) -&gt; Signal&lt;Y&gt; {
		return Signal&lt;EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt;(processor: self.attach { (s1, dw) -&gt; SignalCombiner&lt;OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s1, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -&gt; SignalCombiner&lt;U.OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s2, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -&gt; SignalCombiner&lt;V.OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s3, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result3)
		}).addPreceeding(processor: fourth.signal.attach { (s4, dw) -&gt; SignalCombiner&lt;W.OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s4, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result4)
		}).addPreceeding(processor: fifth.signal.attach { (s5, dw) -&gt; SignalCombiner&lt;X.OutputValue, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; in
			SignalCombiner(source: s5, dw: &amp;dw, context: .direct, processor: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;.result5)
		}).transform(initialState: initialState, context: context, Signal.successProcessorWithState(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` immediately activates its antecedents and is "continuous" (multiple listeners can be attached to the `SignalMulti` and each new listener immediately receives the most recently sent value on "activation").
	///
	/// NOTE: this is the canonical "shared value" signal
	///
	/// - parameter initialValues: the immediate value sent to any listeners that connect *before* the first value is sent through this `Signal`
	/// - returns: a continuous `SignalMulti`
	final func continuous(initialValue: OutputValue) -&gt; SignalMulti&lt;OutputValue&gt; {
		return SignalMulti&lt;OutputValue&gt;(processor: attach { (s, dw) in
			SignalMultiProcessor(source: s, values: ([initialValue], nil), userUpdated: false, activeWithoutOutputs: .always, dw: &amp;dw, context: .direct, updater: { a, p, r -&gt; (Array&lt;OutputValue&gt;, SignalEnd?) in
				let previous: (Array&lt;OutputValue&gt;, SignalEnd?) = (a, p)
				switch r {
				case .success(let v): a = [v]
				case .failure(let e): a = []; p = e
				}
				return previous
			})
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` immediately activates its antecedents and is "continuous" (multiple listeners can be attached to the `SignalMulti` and each new listener immediately receives the most recently sent value on "activation"). Any listeners that connect before the first signal is received will receive no value on "activation".
	///
	/// NOTE: this is the canonical "shared results" signal
	///
	/// - returns: a continuous `SignalMulti`
	final func continuous() -&gt; SignalMulti&lt;OutputValue&gt; {
		return SignalMulti&lt;OutputValue&gt;(processor: attach { (s, dw) in
			SignalMultiProcessor(source: s, values: ([], nil), userUpdated: false, activeWithoutOutputs: .always, dw: &amp;dw, context: .direct, updater: { a, p, r -&gt; (Array&lt;OutputValue&gt;, SignalEnd?) in
				let previous: (Array&lt;OutputValue&gt;, SignalEnd?) = (a, p)
				switch r {
				case .success(let v): a = [v]; p = nil
				case .failure(let e): a = []; p = e
				}
				return previous
			})
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` does not immediately activate (it waits until an output activates it normally). The first activator receives no cached values but does start the signal. If a value is received, subsequent activators will receive the most recent value. Depending on the `discardOnDeactivate` behavior, the cached value may be discarded (resetting the entire signal to its deactivated state) or the cached value might be retained for delivery to any future listeners.
	///
	/// NOTE: this signal is intended for lazily loaded, shared resources.
	///
	/// - returns: a continuous `SignalMulti`
	final func continuousWhileActive(discardOnDeactivate: Bool = true) -&gt; SignalMulti&lt;OutputValue&gt; {
		return SignalMulti&lt;OutputValue&gt;(processor: attach { (s, dw) in
			SignalMultiProcessor(source: s, values: ([], nil), userUpdated: false, activeWithoutOutputs: discardOnDeactivate ? .never : .ifNonEmpty, dw: &amp;dw, context: .direct, updater: { a, p, r -&gt; (Array&lt;OutputValue&gt;, SignalEnd?) in
				let previous: (Array&lt;OutputValue&gt;, SignalEnd?) = (a, p)
				switch r {
				case .success(let v): a = [v]; p = nil
				case .failure(let e): a = []; p = e
				}
				return previous
			})
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` immediately activates its antecedents and offers full "playback" (multiple listeners can be attached to the `SignalMulti` and each new listener receives the entire history of values previously sent through this `Signal` upon "activation").
	///
	/// - returns: a playback `SignalMulti`
	final func playback() -&gt; SignalMulti&lt;OutputValue&gt; {
		return SignalMulti&lt;OutputValue&gt;(processor: attach { (s, dw) in
			SignalMultiProcessor(source: s, values: ([], nil), userUpdated: false, activeWithoutOutputs: .always, dw: &amp;dw, context: .direct, updater: { a, p, r -&gt; (Array&lt;OutputValue&gt;, SignalEnd?) in
				switch r {
				case .success(let v): a.append(v)
				case .failure(let e): p = e
				}
				return ([], nil)
			})
		})
	}
	
	/// Appends a new `Signal` to this `Signal`. The new `Signal` immediately activates its antecedents and caches any values it receives until this the new `Signal` itself is activated â at which point it sends all prior values upon "activation" and subsequently reverts to passthough.
	///
	/// NOTE: this is intended for greedily started signals that might start emitting before the listeners connect.
	///
	/// - Parameter precached: start the cache with some initial values to which subsequent values will be added (default: nil)
	/// - Returns: a "cache until active" `Signal`.
	final func cacheUntilActive(precached: [OutputValue]? = nil) -&gt; Signal&lt;OutputValue&gt; {
		return Signal&lt;OutputValue&gt;(processor: attach { (s, dw) in
			SignalCacheUntilActive(source: s, precached: precached, dw: &amp;dw)
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. While multiple listeners are permitted, there is no caching, activation signal or other changes inherent in this new `Signal` â newly connected listeners will receive only those values sent after they connect.
	///
	/// NOTE: this is intended for shared signals where new values are important but previous values are not
	///
	/// - returns: a "multicast" `SignalMulti`.
	final func multicast() -&gt; SignalMulti&lt;OutputValue&gt; {
		return SignalMulti&lt;OutputValue&gt;(processor: attach { (s, dw) in
			SignalMultiProcessor(source: s, values: ([], nil), userUpdated: false, activeWithoutOutputs: .never, dw: &amp;dw, context: .direct, updater: nil)
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` immediately activates its antecedents. Every time a value is received, it is passed to an "updater" which creates an array of activation values and an error that will be used for any new listeners.
	/// Consider this as an operator that allows the creation of a custom "bring-up-to-speed" value for new listeners.
	///
	/// - Parameters:
	///   - initialValues: activation values used when *before* any incoming value is received (if you wan't to specify closed as well, use `preclosed` instead)
	///   - context: the execution context where the `updater` will run
	///   - updater: run for each incoming `Result` to update the buffered activation values
	/// - Returns: a `SignalMulti` with custom activation
	final func customActivation(initialValues: Array&lt;OutputValue&gt; = [], context: Exec = .direct, _ updater: @escaping (_ cachedValues: inout Array&lt;OutputValue&gt;, _ cachedError: inout SignalEnd?, _ incoming: Result) -&gt; Void) -&gt; SignalMulti&lt;OutputValue&gt; {
		return SignalMulti&lt;OutputValue&gt;(processor: attach { (s, dw) in
			SignalMultiProcessor(source: s, values: (initialValues, nil), userUpdated: true, activeWithoutOutputs: .always, dw: &amp;dw, context: context) { (bufferedValues: inout Array&lt;OutputValue&gt;, bufferedError: inout SignalEnd?, incoming: Result) -&gt; (Array&lt;OutputValue&gt;, SignalEnd?) in
				let oldActivationValues = bufferedValues
				let oldError = bufferedError
				updater(&amp;bufferedValues, &amp;bufferedError, incoming)
				return (oldActivationValues, oldError)
			}
		})
	}
	
	/// This operator applies a reducing function to the stream of incoming values, reducing down to a single, internal `State` value.
	///
	/// A value of the same `State` type is emitted on each iteration, although it is not required to be the same value. Having the return value be potentially different to the internal state isn't standard "reduction semantics" but it enables differential notifications, rather than whole state notifications.
	///
	/// This operator combines aspects of `transform` and `customActivation` into a single operation, transforming the incoming message into state values by combining with a cached state value (that also serves as the activation value).
	///
	/// - Parameters:
	///   - initialState: initial activation value for the stream and internal state for the reducer
	///   - context: execution context where `reducer` will run
	///   - reducer: the function that combines the state with incoming values and emits differential updates
	/// - Returns: a `SignalMulti&lt;State&gt;`
	final func reduce&lt;State&gt;(initialState: State, context: Exec = .direct, _ reducer: @escaping (_ state: State, _ message: OutputValue) throws -&gt; State) -&gt; SignalMulti&lt;State&gt; {
		return SignalMulti&lt;State&gt;(processor: attach { (s, dw) in
			return SignalReducer&lt;OutputValue, State&gt;(source: s, state: initialState, end: nil, dw: &amp;dw, context: context) { (state: State, message: Signal&lt;OutputValue&gt;.Result) -&gt; Signal&lt;State&gt;.Result in
				switch message {
				case .success(let m): return Swift.Result { try reducer(state, m) }.mapError(SignalEnd.other)
				case .failure(let e): return .failure(e)
				}
			}
		})
	}
	
	/// This operator applies a reducing function to the stream of incoming values, reducing down to a single, internal `State` value.
	///
	/// A value of the same `State` type is emitted on each iteration, although it is not required to be the same value. Having the return value be potentially different to the internal state isn't standard "reduction semantics" but it enables differential notifications, rather than whole state notifications.
	///
	/// This operator combines aspects of `transform` and `customActivation` into a single operation, transforming the incoming message into state values by combining with a cached state value (that also serves as the activation value).
	///
	/// - Parameters:
	///   - initialState: initial activation value for the stream and internal state for the reducer
	///   - context: execution context where `reducer` will run
	///   - reducer: the function that combines the state with incoming values and emits differential updates
	/// - Returns: a `SignalMulti&lt;State&gt;`
	final func reduce&lt;State&gt;(context: Exec = .direct, initializer: @escaping (_ message: OutputValue) throws -&gt; State?, _ reducer: @escaping (_ state: State, _ message: OutputValue) throws -&gt; State) -&gt; SignalMulti&lt;State&gt; {
		return SignalMulti&lt;State&gt;(processor: attach { (s, dw) in
			let ini: SignalReducer&lt;OutputValue, State&gt;.Initializer = { message in
				switch message {
				case .success(let m): return Swift.Result { try initializer(m) }.mapError(SignalEnd.other)
				case .failure(let e): return .failure(e)
				}
			}
			return SignalReducer&lt;OutputValue, State&gt;(source: s, initializer: ini, end: nil, dw: &amp;dw, context: context) { (state: State, message: Signal&lt;OutputValue&gt;.Result) -&gt; Signal&lt;State&gt;.Result in
				switch message {
				case .success(let m): return Swift.Result { try reducer(state, m) }.mapError(SignalEnd.other)
				case .failure(let e): return .failure(e)
				}
			}
		})
	}
	
	// MARK: - Signal private properties
	
	// A struct that stores data associated with the current handler. Under the `Signal` mutex, if the `itemProcessing` flag is acquired, the fields of this struct are filled in using `Signal` and `SignalHandler` data and the contents of the struct can be used by the current thread *outside* the mutex.
	private struct ItemContext&lt;OutputValue&gt; {
		let context: Exec
		let synchronous: Bool
		let handler: (Result) -&gt; Void
		let activationCount: Int
		
		init(context: Exec, synchronous: Bool, handler: @escaping (Result) -&gt; Void, activationCount: Int) {
			self.activationCount = activationCount
			self.context = context
			self.synchronous = synchronous
			self.handler = handler
		}
	}
	
	#if DEBUG_LOGGING
		var count: Int = {
			globalCount += 1
			return globalCount
		}()
	#endif
	
	// Protection for all mutable members on this class and any attached `signalHandler`.
	// NOTE 1: This mutex may be shared between synchronous serially connected `Signal`s (for memory and performance efficiency).
	// NOTE 2: It is noted that a `DispatchQueue` mutex would be preferrable since it respects libdispatch's QoS, however, it is not possible (as of Swift 4) to use `DispatchQueue` as a mutex without incurring a heap allocated closure capture so `PThreadMutex` is used instead to avoid a factor of 10 performance loss.
	fileprivate final var mutex: PThreadMutex
	
	// The graph can be disconnected and reconnected and various actions may occur outside locks, it's helpful to determine which actions are no longer relevant. The `Signal` controls this through `delivery` and `activationCount`. The `delivery` controls the basic lifecycle of a simple connected graph through 4 phases: `.disabled` (pre-connection) -&gt; `.sychronous` (connecting) -&gt; `.normal` (connected) -&gt; `.disabled` (disconnected).
	fileprivate final var delivery = SignalDelivery.disabled { didSet { handlerContextNeedsRefresh = true } }
	
	// The graph can be disconnected and reconnected and various actions may occur outside locks, it's helpful to determine which actions are no longer relevant because they are associated with a phase of a previous connection.
	// When connected to a preceeding `SignalPredecessor`, `activationCount` is incremented on each connection and disconnection to ensure that actions associated with a previous phase of a previous connection are rejected. 
	// When connected to a preceeding `SignalInput`, `activationCount` is incremented solely when a new `SignalInput` is attached or the current input is invalidated (joined using an `SignalJunction`).
	fileprivate final var activationCount: Int = 0 { didSet { handlerContextNeedsRefresh = true } }
	
	// If there is a preceeding `Signal` in the graph, its `SignalProcessor` is stored in this variable. Note that `SignalPredecessor` is always an instance of `SignalProcessor`.
	/// If Swift gains an `OrderedSet` type, it should be used here in place of this `Set` and the `sortedPreceeding` accessor, below.
	fileprivate final var preceeding: Set&lt;OrderedSignalPredecessor&gt;
	
	// The destination of this `Signal`. This value is `nil` on construction.
	fileprivate final weak var signalHandler: SignalHandler&lt;OutputValue&gt;? = nil { didSet { handlerContextNeedsRefresh = true } }
	
	fileprivate final var handlerContextNeedsRefresh = true
	
	// Queue of values pending dispatch (NOTE: the current `item` is not stored in the queue)
	// Normally the queue is FIFO but when an `Signal` has multiple inputs, the "activation" from each input will be considered before any post-activation inputs.
	private final var queue = Deque&lt;Result&gt;()
	
	// A `holdCount` may indefinitely block the queue for one of two reasons:
	// 1. a `SignalNext` is retained outside its handler function for asynchronous processing of an item
	// 2. a `SignalCapture` handler has captured the activation but a `Signal` to receive the remainder is not currently connected
	// Accordingly, the `holdCount` should only have a value in the range [0, 2]
	private final var holdCount: UInt8 = 0
	
	// When a `Result` is popped from the queue and the handler is being invoked, the `itemProcessing` is set to `true`. The effect is equivalent to `holdCount`.
	private final var itemProcessing: Bool = false
	
	// Notifications for the inverse of `delivery == .disabled`, accessed exclusively through the `generate` constructor. Can be used for lazy construction/commencement, resetting to initial state on graph disconnect and reconnect or cleanup after graph deletion.
	// A signal is used here instead of a simple function callback since re-entrancy-safe queueing and context delivery are needed.
	// WARNING: this is actually a (Signal&lt;SignalInput&lt;OutputValue&gt;?&gt;, SignalEndpont&lt;SignalInput&lt;OutputValue&gt;?&gt;)? but we use `Any` to avoid huge optimization overheads.
	private final var newInputSignal: (Signal&lt;Any?&gt;, SignalOutput&lt;Any?&gt;)? = nil
	
	// A monotonically increasing counter that is incremented every time the set of connected, preceeding handlers changes. This value is used to reject predecessors that are not up-to-date with the latest graph structure (i.e. have been asynchronously removed or invalidated).
	private final var preceedingCount: Int = 0
	
	// This is a cache of values that can be read outside the lock by the current owner of the `itemProcessing` flag.
	private final var handlerContext = ItemContext&lt;OutputValue&gt;(context: .direct, synchronous: false, handler: { _ in }, activationCount: 0)
	
	// MARK: - Signal private functions
	
	// Invokes `removeAllPreceedingInternal` if and only if the `forDisconnector` matches the current `preceeding.first`
	//
	// - Parameter forDisconnector: the disconnector requesting this change
	// - Returns: if the predecessor matched, then a new `SignalInput&lt;OutputValue&gt;` for this `Signal`, otherwise `nil`.
	fileprivate final func newInput(forDisconnector: SignalProcessor&lt;OutputValue, OutputValue&gt;) -&gt; SignalInput&lt;OutputValue&gt;? {
		var dw = DeferredWork()
		let result = mutex.sync { () -&gt; SignalInput&lt;OutputValue&gt;? in
			if preceeding.count == 1, let p = preceeding.first?.base, p === forDisconnector {
				removeAllPreceedingInternal(dw: &amp;dw)
				return SignalInput(signal: self, activationCount: activationCount)
			} else {
				return nil
			}
		}
		dw.runWork()
		return result
	}
	
	/// If this `Signal` can attach a new handler, this function runs the provided closure (which is expected to construct and set the new handler) and returns the handler. If this `Signal` can't attach a new handler, returns the result of running the closure inside the mutex of a separate preclosed `Signal`.
	///
	/// This method serves three purposes:
	///	1) It enforces the idea that the `signalHandler` should be constructed under this `Signal`'s mutex, providing the `DeferredWork` required by the `signalHandler` constructor interface.
	///	2) It enforces the rule that multiple listen attempts should be immediately closed with a `.duplicate` error
	///	3) It allows abstraction over the actual `Signal` used for attachment (self for single listener and a newly created `Signal` for multi listener).
	///
	/// - Parameter constructor: the handler constructor function
	/// - Returns: the result from the constructor (typically an SignalHandler)
	fileprivate func attach&lt;R&gt;(constructor: (Signal&lt;OutputValue&gt;, inout DeferredWork) -&gt; R) -&gt; R where R: SignalHandler&lt;OutputValue&gt; {
		var dw = DeferredWork()
		let result: R? = mutex.sync {
			self.signalHandler == nil ? constructor(self, &amp;dw) : nil
		}
		dw.runWork()
		if let r = result {
			return r
		} else {
			preconditionFailure("Multiple outputs added to single listener Signal.")
		}
	}
	
	/// Avoids complications with non-reentrant 
	///
	/// - Parameter context: the context upon which `asyncRelativeContext` will be called
	/// - Returns: possibly `self`, possibly `self` a transform that shifts to the `asyncRelativeContext`.
	fileprivate func returnToGlobalIfNeeded(context: Exec) -&gt; Signal&lt;OutputValue&gt; {
		if context.type.isImmediateAlways || context.type.isReentrant {
			return self
		} else {
			return self.transform(context: context.relativeAsync(), { .single($0) })
		}
	}
	
	/// Constructor for a `Signal` that is the output for a `SignalProcessor`.
	///
	/// - Parameter processor: input source for this `Signal`
	fileprivate init&lt;U&gt;(processor: SignalProcessor&lt;U, OutputValue&gt;) {
		preceedingCount += 1
		preceeding = [processor.wrappedWithOrder(preceedingCount)]
		
		if processor.successorsShareMutex {
			mutex = processor.source.mutex
		} else {
			mutex = PThreadMutex()
		}
		
		#if DEBUG_LOGGING
			print("\(type(of: self)): \(self.count) created")
		#endif
		
		if !(self is SignalMulti&lt;OutputValue&gt;) {
			var dw = DeferredWork()
			mutex.sync {
				// Since this function must be used only in cases where the processor is *also* new, this can't be `duplicate` or `loop`
				try! processor.outputAddedSuccessorInternal(self, param: nil, activationCount: nil, dw: &amp;dw)
			}
			dw.runWork()
		}
	}
	
	// Connects this `Signal` to a preceeding SignalPredecessor. Other connection functions must go through this.
	//
	// - Parameters:
	//   - newPreceeding: the preceeding SignalPredecessor to add
	//   - param: this function may invoke `outputAddedSuccessorInternal` internally. If it does this `param` will be passed as the `param` for that function.
	//   - dw: required
	// - Throws: any error from `outputAddedSuccessorInternal` invoked on `newPreceeding`
	fileprivate final func addPreceedingInternal(_ newPreceeding: SignalPredecessor, param: Any?, dw: inout DeferredWork) throws {
		preceedingCount += 1
		let wrapped = newPreceeding.wrappedWithOrder(preceedingCount)
		preceeding.insert(wrapped)
		
		do {
			try newPreceeding.outputAddedSuccessorInternal(self, param: param, activationCount: (delivery.isDisabled || preceeding.count == 1) ? Optional&lt;Int&gt;.none : Optional&lt;Int&gt;(activationCount), dw: &amp;dw)
			if !delivery.isDisabled, preceeding.count == 1 {
				updateActivationInternal(andInvalidateAllPrevious: true, dw: &amp;dw)
				if !delivery.isSynchronous {
					let ac = activationCount
					dw.append {
						var dw = DeferredWork()
						self.mutex.sync {
							if ac == self.activationCount {
								newPreceeding.outputCompletedActivationSuccessorInternal(self, dw: &amp;dw)
							}
						}
						dw.runWork()
					}
				}
			}
		} catch {
			preceeding.remove(wrapped)
			throw error
		}
	}
	
	// Removes a (potentially) non-unique predecessor. Used only from `SignalMergeSet` and `SignalMergeProcessor`. This is one of two, independent, functions for removing preceeding. The other being `removeAllPreceedingInternal`.
	//
	// - Parameters:
	//   - oldPreceeding: the predecessor to remove
	//   - dw: required
	fileprivate final func removePreceedingWithoutInterruptionInternal(_ oldPreceeding: SignalPredecessor, dw: inout DeferredWork) -&gt; Bool {
		if preceeding.remove(oldPreceeding.wrappedWithOrder(0)) != nil {
			oldPreceeding.outputRemovedSuccessorInternal(self, dw: &amp;dw)
			return true
		}
		return false
	}
	
	// Removes all predecessors and invalidate all previous inputs. This is one of two, independent, functions for removing preceeding. The other being `removePreceedingWithoutInterruptionInternal`.
	//
	// - Parameters:
	//   - oldPreceeding: the predecessor to remove
	//   - dw: required
	fileprivate final func removeAllPreceedingInternal(dw: inout DeferredWork) {
		if preceeding.count &gt; 0 {
			dw.append { [preceeding] in withExtendedLifetime(preceeding) {} }
			
			// Careful to use *sorted* preceeding to propagate graph changes deterministically
			sortedPreceedingInternal.forEach { $0.base.outputRemovedSuccessorInternal(self, dw: &amp;dw) }
			preceeding = []
		}
		updateActivationInternal(andInvalidateAllPrevious: true, dw: &amp;dw)
	}
	
	// The primary `send` function (although the `push` functions do also send).
	// Sends `result`, assuming `fromInput` matches the current `self.input` and `self.delivery` is enabled
	//
	// - Parameters:
	//   - result: the value or error to pass to any attached handler
	//   - predecessor: the `SignalInput` or `SignalNext` delivering the handler
	//   - activationCount: the activation count from the predecessor to match against internal value
	//   - activated: whether the predecessor is already in `normal` delivery mode
	// - Returns: `nil` on success. Non-`nil` values include `SignalSendError.disconnected` if the `predecessor` or `activationCount` fail to match, `SignalSendError.inactive` if the current `delivery` state is `.disabled`.
	@discardableResult fileprivate final func send(result: Result, predecessor: Unmanaged&lt;AnyObject&gt;?, activationCount: Int, activated: Bool) -&gt; SignalSendError? {
		mutex.unbalancedLock()
		
		guard isCurrent(predecessor, activationCount) else {
			mutex.unbalancedUnlock()
			
			// Retain the result past the end of the lock
			withExtendedLifetime(result) {}
			return SignalSendError.disconnected
		}
		
		switch delivery {
		case .normal:
			if holdCount == 0 &amp;&amp; itemProcessing == false {
				assert(queue.isEmpty)
				break
			} else {
				queue.append(result)
				mutex.unbalancedUnlock()
				return nil
			}
		case .synchronous(let count):
			if activated {
				queue.append(result)
				mutex.unbalancedUnlock()
				return nil
			} else if count == 0, holdCount == 0, itemProcessing == false {
				break
			} else {
				queue.insert(result, at: count)
				delivery = .synchronous(count + 1)
				mutex.unbalancedUnlock()
				return nil
			}
		case .disabled:
			mutex.unbalancedUnlock()
			
			// Retain the result past the end of the lock
			withExtendedLifetime(result) {}
			return SignalSendError.inactive
		}
		
		assert(holdCount == 0 &amp;&amp; itemProcessing == false)
		
		if handlerContextNeedsRefresh {
			var dw = DeferredWork()
			let hasHandler = refreshItemContextInternal(&amp;dw)
			if hasHandler {
				itemProcessing = true
			}
			mutex.unbalancedUnlock()
			
			// We need to be extremely careful that any previous handlers, replaced in the `refreshItemContextInternal` function are released *here* if we're going to re-enter the lock and that we've *already* acquired the `itemProcessing` Bool. There's a little bit of dancing around in this `if handlerContextNeedsRefresh` block to ensure these two things are true.
			dw.runWork()
			
			if !hasHandler {
				return SignalSendError.inactive
			}
		} else {
			itemProcessing = true
			mutex.unbalancedUnlock()
		}
		
		dispatch(result)
		return nil
	}
	
	// A secondary send function used to push values and possibly and end-of-stream error onto the `newInputSignal`. The push is not handled immediately but is deferred until the `DeferredWork` runs. Since values are *always* queued, this is less efficient than `send` but it avoids re-entrancy into self if the `newInputSignal` immediately tries to send values back to us.
	//
	// - Parameters:
	//   - values: pushed onto this `Signal`'s queue
	//   - end: pushed onto this `Signal`'s queue
	//   - activationCount: activationCount of the sender (must match the internal value)
	//   - dw: used to dispatch the signal safely outside the parent's mutex
	fileprivate final func push(values: Array&lt;OutputValue&gt;, end: SignalEnd?, activationCount: Int, activated: Bool, dw: inout DeferredWork) {
		mutex.sync {
			guard self.activationCount == activationCount else { return }
			pushInternal(values: values, end: end, activated: activated, dw: &amp;dw)
		}
	}
	
	// A secondary send function used to push activation values and activation errors. Since values are *always* queued, this is less efficient than `send` but it can safely be invoked inside mutexes.
	//
	// - Parameters:
	//   - values: pushed onto this `Signal`'s queue
	//   - end: pushed onto this `Signal`'s queue
	//   - dw: used to dispatch the signal safely outside the parent's mutex
	fileprivate final func pushInternal(values: Array&lt;OutputValue&gt;, end: SignalEnd?, activated: Bool, dw: inout DeferredWork) {
		assert(mutex.unbalancedTryLock() == false)
		
		guard values.count &gt; 0 || end != nil else {
			dw.append {
				withExtendedLifetime(values) {}
				withExtendedLifetime(end) {}
			}
			return
		}
		
		if !activated, case .synchronous(let count) = delivery {
			assert(count == 0)
			delivery = .synchronous(values.count + (end != nil ? 1 : 0))
		}
		
		for v in values {
			queue.append(.success(v))
		}
		if let e = end {
			queue.append(.failure(e))
		}
		
		resumeIfPossibleInternal(dw: &amp;dw)
	}
	
	// Used in SignalCapture.handleSynchronousToNormalInternal to handle a situation where a deactivation and reactivation occurs *while* `itemProcessing` so the next capture is in the queue instead of being captured. This function extracts the queued value for capture before transition to normal.
	//
	// - Returns: the queued items under the synchronous count.
	fileprivate final func pullQueuedSynchronousInternal() -&gt; (values: Array&lt;OutputValue&gt;, end: SignalEnd?) {
		if case .synchronous(let count) = delivery, count &gt; 0 {
			var values = Array&lt;OutputValue&gt;()
			var end: SignalEnd? = nil
			for _ in 0..&lt;count {
				switch queue.removeFirst() {
				case .success(let v): values.append(v)
				case .failure(let e): end = e
				}
			}
			delivery = .synchronous(0)
			return (values, end)
		}
		return ([], nil)
	}
	
	// Increment the `holdCount`
	fileprivate final func blockInternal() {
		assert(mutex.unbalancedTryLock() == false)
		assert(holdCount &lt;= 1)
		holdCount += 1
	}
	
	// Decrement the `holdCount`, if the `activationCountAtBlock` provided matches `self.activationCount`
	//
	// NOTE: the caller must resume processing if holdCount reaches zero and there are queued items.
	///
	/// - Parameter activationCountAtBlock: must match the internal value or the block request will be ignored
	fileprivate final func unblockInternal(activationCountAtBlock: Int) {
		guard self.activationCount == activationCountAtBlock else { return }
		assert(mutex.unbalancedTryLock() == false)
		assert(holdCount &gt;= 1 &amp;&amp; holdCount &lt;= 2)
		holdCount -= 1
	}
	
	// If the holdCount is zero and there are queued items, increments the hold count immediately and starts processing in the deferred work.
	///
	/// - Parameter dw: required
	fileprivate final func resumeIfPossibleInternal(dw: inout DeferredWork) {
		if holdCount == 0, itemProcessing == false, !queue.isEmpty {
			if !refreshItemContextInternal(&amp;dw) {
				// The weakly held handler has asynchronously released.
				return
			}
			itemProcessing = true
			dw.append {
				if let r = self.pop() {
					self.dispatch(r)
				}
			}
		}
	}
	
	// Decrement the `holdCount`, if the `activationCount` provided matches `self.activationCount` and resume processing if the `holdCount` reaches zero and there are items in the queue.
	///
	/// - Parameter activationCount: must match the internal value or the block request will be ignored
	fileprivate final func unblock(activationCountAtBlock: Int) {
		var dw = DeferredWork()
		mutex.sync {
			unblockInternal(activationCountAtBlock: activationCountAtBlock)
			resumeIfPossibleInternal(dw: &amp;dw)
		}
		dw.runWork()
	}
	
	// Changes the value of the `self.delivery` instance variable and handles associated lifecycle updates (like incrementing the activation count).
	//
	/// - Parameters:
	///   - newDelivery: new value for `self.delivery`
	///   - dw: required
	fileprivate final func changeDeliveryInternal(newDelivery: SignalDelivery, dw: inout DeferredWork) {
		assert(mutex.unbalancedTryLock() == false)
		assert(newDelivery.isDisabled != delivery.isDisabled || newDelivery.isSynchronous != delivery.isSynchronous)
		
		#if DEBUG_LOGGING
			print("\(type(of: self)): \(self.count) delivery changed from \(delivery) to \(newDelivery)")
		#endif
		
		let oldDelivery = delivery
		delivery = newDelivery
		switch delivery {
		case .normal:
			if oldDelivery.isSynchronous {
				// Careful to use *sorted* preceeding to propagate graph changes deterministically
				for p in sortedPreceedingInternal {
					p.base.outputCompletedActivationSuccessorInternal(self, dw: &amp;dw)
				}
			}
			resumeIfPossibleInternal(dw: &amp;dw)
			newInputSignal?.0.push(values: [SignalInput(signal: self, activationCount: activationCount)], end: nil, activationCount: 0, activated: true, dw: &amp;dw)
		case .synchronous:
			if preceeding.count &gt; 0 {
				updateActivationInternal(andInvalidateAllPrevious: false, dw: &amp;dw)
			}
		case .disabled:
			updateActivationInternal(andInvalidateAllPrevious: true, dw: &amp;dw)
			_ = newInputSignal?.0.push(values: [Optional&lt;SignalInput&lt;OutputValue&gt;&gt;.none], end: nil, activationCount: 0, activated: true, dw: &amp;dw)
		}
	}
	
	/// Constructor for signal graph head. Called from `create`.
	private init() {
		mutex = PThreadMutex()
		preceeding = []
		
		#if DEBUG_LOGGING
			print("\(type(of: self)): \(self.count) created")
		#endif
	}
	
	// Need to close the `newInputSignal` and detach from all predecessors on deinit.
	deinit {
		newInputSignal?.0.send(result: .failure(.cancelled), predecessor: nil, activationCount: 0, activated: true)
		
		var dw = DeferredWork()
		mutex.sync {
			removeAllPreceedingInternal(dw: &amp;dw)
		}
		dw.runWork()
	}
	
	// Internal wrapper used by the `combine` functions to ignore error `Results` (which would only be due to graph changes between internal nodes) and process the values with the user handler.
	//
	// - Parameter handler: the user handler
	@discardableResult private static func successProcessor&lt;U, V&gt;(_ processor: @escaping (U) -&gt; Signal&lt;V&gt;.Next) -&gt; (Signal&lt;U&gt;.Result) -&gt; Signal&lt;V&gt;.Next {
		return { (r: Signal&lt;U&gt;.Result) in
			switch r {
			case .success(let v): return processor(v)
			case .failure(let e): return .single(.failure(e))
			}
		}
	}
	
	// Internal wrapper used by the `combine(initialState:...)` functions to ignore error `Results` (which would only be due to graph changes between internal nodes) and process the values with the user handler.
	//
	// - Parameter handler: the user handler
	@discardableResult private static func successProcessorWithState&lt;S, U, V&gt;(_ processor: @escaping (inout S, U) -&gt; Signal&lt;V&gt;.Next) -&gt; (inout S, Signal&lt;U&gt;.Result) -&gt; Signal&lt;V&gt;.Next {
		return { (s: inout S, r: Signal&lt;U&gt;.Result) in
			switch r {
			case .success(let v): return processor(&amp;s, v)
			case .failure(let e): return .single(.failure(e))
			}
		}
	}
	
	/// Returns a copy of the preceeding set, sorted by "order". This allows deterministic sending of results through the graph â older connections are prioritized over newer.
	private var sortedPreceedingInternal: Array&lt;OrderedSignalPredecessor&gt; {
		return preceeding.sorted(by: { (a, b) -&gt; Bool in
			return a.order &lt; b.order
		})
	}
	
	// A wrapper around addPreceedingInternal for use outside the mutex. Only used by the `combine` functions (which is why it returns `self` â it's a syntactic convenience in those methods).
	//
	// - Parameter processor: the preceeding SignalPredecessor to add
	// - Returns: self (for syntactic convenience in the `combine` methods)
	private final func addPreceeding(processor: SignalPredecessor) -&gt; Signal&lt;OutputValue&gt; {
		var dw = DeferredWork()
		mutex.sync {
			// Since this is for use only by the `combine` functions, it cann't be `duplicate` or `loop`
			try! addPreceedingInternal(processor, param: nil, dw: &amp;dw)
		}
		dw.runWork()
		return self
	}
	
	// Increment the activation count.
	//
	// - Parameters:
	//   - andInvalidateAllPrevious: if true, removes all items from the queue (should be false only when transitioning from synchronous to normal).
	//   - dw: required
	private final func updateActivationInternal(andInvalidateAllPrevious: Bool, dw: inout DeferredWork) {
		assert(mutex.unbalancedTryLock() == false)
		
		activationCount = activationCount &amp;+ 1
		
		if andInvalidateAllPrevious {
			let oldItems = Array&lt;Result&gt;(queue)
			dw.append { withExtendedLifetime(oldItems) {} }
			queue.removeAll()
			holdCount = 0
		} else {
			assert(holdCount == 0)
		}
		
		switch delivery {
		case .synchronous:
			if andInvalidateAllPrevious, let h = signalHandler {
				// Any outstanding end activation won't resolve now so we need to apply it directly.
				h.endActivationInternal(dw: &amp;dw)
				return
			}
			fallthrough
		case .normal:
			// Careful to use *sorted* preceeding to propagate graph changes deterministically
			for p in sortedPreceedingInternal {
				p.base.outputActivatedSuccessorInternal(self, activationCount: activationCount, dw: &amp;dw)
			}
		case .disabled:
			// Careful to use *sorted* preceeding to propagate graph changes deterministically
			for p in sortedPreceedingInternal {
				p.base.outputDeactivatedSuccessorInternal(self, dw: &amp;dw)
			}
		}
	}
	
	// Tests whether a `Result` from a `predecessor` with `activationCount` should be accepted or rejected.
	//
	// - Parameters:
	//   - predecessor: the source of the `Result`
	//   - activationCount: the `activationCount` when the source was connected
	// - Returns: true if `preceeding` contains `predecessor` and `self.activationCount` matches `activationCount`
	private final func isCurrent(_ predecessor: Unmanaged&lt;AnyObject&gt;?, _ activationCount: Int) -&gt; Bool {
		if activationCount != self.activationCount {
			return false
		}
		if preceeding.count == 1, let expected = preceeding.first?.base {
			return predecessor?.takeUnretainedValue() === expected
		} else if preceeding.count == 0 {
			return predecessor == nil
		}
		
		guard let p = predecessor?.takeUnretainedValue() as? SignalPredecessor else { return false }
		return preceeding.contains(p.wrappedWithOrder(0))
	}
	
	// The `handlerContext` holds information uniquely used by the currently processing item so it can be read outside the mutex. This may only be called immediately before calling `blockInternal` to start a processing item (e.g. from `send` or `resume`.
	//
	// - Parameter dw: required
	// - Returns: false if the `signalHandler` was `nil`, true otherwise.
	private final func refreshItemContextInternal(_ dw: inout DeferredWork) -&gt; Bool {
		assert(mutex.unbalancedTryLock() == false)
		assert(holdCount == 0 &amp;&amp; itemProcessing == false)
		if handlerContextNeedsRefresh {
			if let h = signalHandler {
				dw.append { [handlerContext] in withExtendedLifetime(handlerContext) {} }
				handlerContext = ItemContext(context: h.context, synchronous: delivery.isSynchronous, handler: h.handler, activationCount: activationCount)
				handlerContextNeedsRefresh = false
			} else {
				return false
			}
		}
		return true
	}
	
	// Sets the `handlerContext` back to an "idle" state (releasing any handler closure and setting `activationCount` to zero.
	// This function may be called only from `specializedSyncPop` or `pop`.
	///
	/// - Returns: an empty/idle `ItemContext`
	private final func clearItemContextInternalToExternal(itemOnly: Bool) {
		assert(mutex.unbalancedTryLock() == false)
		itemProcessing = false
		
		if itemOnly {
			mutex.unbalancedUnlock()
		} else {
			var dw = DeferredWork()
			let oldContext = handlerContext
			handlerContext = ItemContext&lt;OutputValue&gt;(context: .direct, synchronous: false, handler: { _ in }, activationCount: 0)
			resumeIfPossibleInternal(dw: &amp;dw)
			mutex.unbalancedUnlock()
			withExtendedLifetime(oldContext) {}
			dw.runWork()
		}
	}
	
	// Invoke the user handler and deactivates the `Signal` if `result` is a `failure`.
	//
	// - Parameter result: passed to the `handlerContext.handler`
	private final func invokeHandler(_ result: Result) {
		handlerContext.handler(result)
		if case .failure = result {
			var dw = DeferredWork()
			mutex.sync {
				if handlerContext.activationCount == activationCount, !delivery.isDisabled {
					signalHandler?.deactivateInternal(dueToLackOfOutputs: false, dw: &amp;dw)
				}
			}
			dw.runWork()
		}
	}
	
	// Dispatches the `result` to the current handler in the appropriate context then pops the next `result` and attempts to invoke the handler with the next result (if any)
	//
	// - Parameter result: for sending to the handler
	private final func dispatch(_ result: Result) {
		#if DEBUG_LOGGING
			print("\(type(of: self)): \(self.count) emitted \(result))")
		#endif

		if case .direct = handlerContext.context {
			invokeHandler(result)
			specializedSyncPop()
		} else if handlerContext.context.type.isImmediateInCurrentContext {
			for r in sequence(first: result, next: { _ in self.pop() }) {
				invokeHandler(r)
			}
		} else if handlerContext.synchronous {
			for r in sequence(first: result, next: { _ in self.pop() }) {
				handlerContext.context.invokeSync{ invokeHandler(r) }
			}
		} else {
			handlerContext.context.invoke {
				for r in sequence(first: result, next: { _ in self.pop() }) {
					self.invokeHandler(r)
				}
			}
		}
	}
	
	/// Gets the next item from the queue for processing and updates the `ItemContext`.
	///
	/// - Returns: the next result for processing, if any
	private final func pop() -&gt; Result? {
		mutex.unbalancedLock()
		assert(itemProcessing == true)
		
		guard !handlerContextNeedsRefresh else {
			clearItemContextInternalToExternal(itemOnly: false)
			return nil
		}
		
		if !queue.isEmpty, holdCount == 0 {
			switch delivery {
			case .synchronous(let count) where count == 0: break
			case .synchronous(let count):
				delivery = .synchronous(count - 1)
				fallthrough
			default:
				let result = queue.removeFirst()
				mutex.unbalancedUnlock()
				return result
			}
		}
		
		clearItemContextInternalToExternal(itemOnly: true)
		return nil
	}
	
	/// An optimized version of `pop(_:)` used when context is .direct. The semantics are slightly different: this doesn't pop a result off the queue... rather, it looks to see if there's anything in the queue and handles it internally if there is. This allows optimization for the expected case where there's nothing in the queue.
	private final func specializedSyncPop() {
		mutex.unbalancedLock()
		assert(itemProcessing == true)
		
		if handlerContextNeedsRefresh {
			clearItemContextInternalToExternal(itemOnly: false)
		} else if !queue.isEmpty {
			mutex.unbalancedUnlock()
			while let r = pop() {
				invokeHandler(r)
			}
		} else {
			itemProcessing = false
			mutex.unbalancedUnlock()
		}
	}
}

/// `SignalMulti&lt;OutputValue&gt;` is the only subclass of `Signal&lt;OutputValue&gt;`. It represents a `Signal&lt;OutputValue&gt;` that allows attaching multiple listeners (a normal `Signal&lt;OutputValue&gt;` is "single owner" and will immediately close any subsequent listeners after the first with a `SignalBindError.duplicate` error).
/// This class is not constructed directly but is instead created from one of the `SignalMulti&lt;OutputValue&gt;` returning functions on `Signal&lt;OutputValue&gt;`, including `playback()`, `multicast()` and `continuous()`.
final class SignalMulti&lt;OutputValue&gt;: Signal&lt;OutputValue&gt; {
	private let spawnSingle: (SignalPredecessor) -&gt; Signal&lt;OutputValue&gt;
	
	fileprivate override init&lt;U&gt;(processor: SignalProcessor&lt;U, OutputValue&gt;) {
		assert(processor.multipleOutputsPermitted, "Construction of SignalMulti from a single output processor is illegal.")
		spawnSingle = { proc in
			let p = proc as! SignalProcessor&lt;U, OutputValue&gt;
			return Signal&lt;OutputValue&gt;(processor: p).returnToGlobalIfNeeded(context: p.context)
		}
		super.init(processor: processor)
	}
	
	fileprivate override func attach&lt;R&gt;(constructor: (Signal&lt;OutputValue&gt;, inout DeferredWork) -&gt; R) -&gt; R where R: SignalHandler&lt;OutputValue&gt; {
		return spawnSingle(preceeding.first!.base).attach(constructor: constructor)
	}
}

/// An `SignalInput` is used to send values to the "head" `Signal`s in a signal graph. It is created using the `Signal&lt;T&gt;.create()` function.
class SignalInput&lt;InputValue&gt;: Lifetime, SignalInputInterface {
	fileprivate final weak var signal: Signal&lt;InputValue&gt;?
	fileprivate final let activationCount: Int
	
	var input: SignalInput&lt;InputValue&gt; { return self }
	
	// Create a new `SignalInput` (usually created by the `Signal&lt;T&gt;.create` function)
	//
	// - Parameters:
	//   - signal: the destination signal
	//   - activationCount: to be sent with each send to the signal
	fileprivate init(signal: Signal&lt;InputValue&gt;, activationCount: Int) {
		self.signal = signal
		self.activationCount = activationCount
	}
	
	/// The primary signal sending function
	///
	/// - Parameter result: the value or error to send, composed as a `Result`
	/// - Returns: `nil` on success. Non-`nil` values include `SignalSendError.disconnected` if the `predecessor` or `activationCount` fail to match, `SignalSendError.inactive` if the current `delivery` state is `.disabled`.
	@discardableResult
	func send(result: Result&lt;InputValue, SignalEnd&gt;) -&gt; SignalSendError? {
		guard let s = signal else { return SignalSendError.disconnected }
		return s.send(result: result, predecessor: nil, activationCount: activationCount, activated: true)
	}
	
	/// The purpose for this method is to obtain a true `SignalInput` (instead of a `SignalMultiInput` or `SignalMergedInput`. A true `SignalInput` is faster for multiple send operations and is needed internally by the `bind` methods.
	/// The base `SignalInput` implementation returns `self`.
	func singleInput() -&gt; SignalInput&lt;InputValue&gt; {
		return self
	}
	
	/// Implementation of `Lifetime` that sends a `SignalComplete.cancelled`. You wouldn't generally invoke this yourself; it's intended to be invoked if the `SignalInput` owner is released and the `SignalInput` is no longer retained.
	func cancel() {
		send(result: .failure(.cancelled))
	}
	
	fileprivate func cancelOnDeinit() {
		cancel()
	}
	
	deinit {
		cancelOnDeinit()
	}
}

// If `Signal&lt;OutputValue&gt;` is a delivery channel, then `SignalHandler` is the destination to which it delivers.
// While the base `SignalHandler&lt;OutputValue&gt;` is not "abstract" in any technical sense, it doesn't do anything by default and offers no members. Subclasses include `SignalOutput` (the user "exit" point for signal results), `SignalProcessor` (used for transforming signals between instances of `Signal&lt;OutputValue&gt;`), `SignalJunction` (for enabling dynamic graph connection and disconnections).
// `SignalHandler&lt;OutputValue&gt;` is never directly created or held by users of the CwlSignal library. It is implicitly created when one of the listening or transformation methods on `Signal&lt;OutputValue&gt;` are invoked.
class SignalHandler&lt;OutputValue&gt; {
	fileprivate final let source: Signal&lt;OutputValue&gt;
	fileprivate final let context: Exec
	fileprivate final var handler: (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void { didSet { source.handlerContextNeedsRefresh = true } }
	
	// Base constructor sets the `source`, `context` and `handler` and implicitly activates if required.
	//
	// - Parameters:
	//   - source: a `SignalHandler` is attached to its predecessor `Signal` for its lifetime
	//   - dw: used for performing activation outside any enclosing mutex, if necessary
	//   - context: where the `handler` function should be invoked
	fileprivate init(source: Signal&lt;OutputValue&gt;, dw: inout DeferredWork, context: Exec) {
		// Must be passed a `Signal` that does not already have a `signalHandler`
		assert(source.signalHandler == nil &amp;&amp; source.mutex.unbalancedTryLock() == false)
		
		self.source = source
		self.context = context
		self.handler = { _ in }
		
		// Connect to the `Signal`
		source.signalHandler = self
		
		// Set the initial handler
		self.handler = initialHandlerInternal()
		
		#if DEBUG_LOGGING
			print("\(type(of: self)): created as the processor for \(source.count)")
		#endif
		
		// Propagate immediately
		if activeWithoutOutputsInternal {
			if activateInternal(dw: &amp;dw) {
				let count = self.source.activationCount
				dw.append { self.endActivation(activationCount: count) }
			}
		}
	}
	
	// Default behavior does nothing prior to activation
	fileprivate func initialHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		return { _ in }
	}
	
	// Convenience wrapper around the mutex from the `Signal` which is used to protect the handler
	//
	// - Parameter execute: the work to perform inside the mutex
	// - Returns: the result from the `execute closure
	// - Throws: basic rethrow from the `execute` closure
	fileprivate final func sync&lt;OutputValue&gt;(execute: () throws -&gt; OutputValue) rethrows -&gt; OutputValue {
		source.mutex.unbalancedLock()
		defer { source.mutex.unbalancedUnlock() }
		return try execute()
	}
	
	// True if this node activates predecessors even when it has no active successors
	fileprivate var activeWithoutOutputsInternal: Bool {
		assert(source.mutex.unbalancedTryLock() == false)
		return false
	}
	
	deinit {
		var dw = DeferredWork()
		sync {
			if !source.delivery.isDisabled {
				source.changeDeliveryInternal(newDelivery: .disabled, dw: &amp;dw)
			}
			source.signalHandler = nil
		}
		dw.runWork()
	}
	
	// As an optimization, successive `Signal`s are placed under the *same* mutex as any preceeding `.sync` `SignalHandler`s
	// `SignalJunction`, `SignalCombiner`, `SignalCapture` and `SignalMultiInputProcessor` all returns `false` since they involve either changing connectivity or multiple connectivity.
	fileprivate var successorsShareMutex: Bool {
		if case .direct = context {
			return true
		} else {
			return false
		}
	}
	
	// Activation changes the delivery, based on whether there are preceeding `Signal`s.
	// If delivery is changed to synchronous, `endActivation` must be called in the deferred work.
	///
	/// - Parameter dw: required
	/// - Returns: true if a transition to `.synchronous` occurred
	fileprivate final func activateInternal(dw: inout DeferredWork) -&gt; Bool {
		assert(source.mutex.unbalancedTryLock() == false)
		if source.delivery.isDisabled {
			source.changeDeliveryInternal(newDelivery: .synchronous(0), dw: &amp;dw)
			return true
		}
		return false
	}
	
	// Completes the transition to `.normal` delivery at the end of the `.synchronous` stage.
	///
	/// - Parameter dw: required
	fileprivate final func endActivationInternal(dw: inout DeferredWork) {
		if source.delivery.isSynchronous {
			handleSynchronousToNormalInternal(dw: &amp;dw)
			source.changeDeliveryInternal(newDelivery: .normal, dw: &amp;dw)
		}
	}
	
	// Completes the transition to `.normal` delivery at the end of the `.synchronous` stage.
	///
	/// - Parameter activationCount: must match the internal value or the attempt will be rejected
	fileprivate final func endActivation(activationCount: Int) {
		var dw = DeferredWork()
		sync {
			guard source.activationCount == activationCount else { return }
			endActivationInternal(dw: &amp;dw)
		}
		dw.runWork()
	}
	
	// If this property returns false, attempts to connect more than one output will be rejected. The rejection information is used primarily by SignalJunction which performs disconnect and bind as two separate steps so it needs the rejection to ensure two threads haven't tried to bind simultaneously.
	fileprivate var multipleOutputsPermitted: Bool {
		return false
	}
	
	// Override point invoked from `endActivationInternal` used in `SignalCapture`
	// - Parameter dw: required
	fileprivate func handleSynchronousToNormalInternal(dw: inout DeferredWork) {
	}
	
	// Changes delivery to disabled *and* resets the handler to the initial handler.
	// - Parameter dw: required
	fileprivate final func deactivateInternal(dueToLackOfOutputs: Bool, dw: inout DeferredWork) {
		assert(source.mutex.unbalancedTryLock() == false)
		if !activeWithoutOutputsInternal || !dueToLackOfOutputs {
			source.changeDeliveryInternal(newDelivery: .disabled, dw: &amp;dw)
			dw.append { [handler] in
				withExtendedLifetime(handler) {}
				
				// Outputs may release themselves on deactivation so we need to keep ourselves alive until outside the lock
				withExtendedLifetime(self) {}
			}
			if !activeWithoutOutputsInternal {
				handler = initialHandlerInternal()
			} else {
				handler = { _ in }
			}
		}
	}
}

// A hashable wrapper around an SignalPredecessor existential that also embeds an order value to allow ordering
// NOTE 1: the order is *not* part of the equality or hashValue so a wrapper can be created with an arbitrary order to test for the presence of a given SignalPredecessor.
// NOTE 2: if Swift gains an OrderedSet, it might be possible to replace this with `Hashable` conformance on `SignalPredecessor`.
fileprivate struct OrderedSignalPredecessor: Hashable {
	let base: SignalPredecessor
	let order: Int
	init(base: SignalPredecessor, order: Int) {
		self.base = base
		self.order = order
	}
	
	func hash(into hasher: inout Hasher) {
		hasher.combine(Int(bitPattern: Unmanaged&lt;AnyObject&gt;.passUnretained(base).toOpaque()))
	}
	
	static func ==(lhs: OrderedSignalPredecessor, rhs: OrderedSignalPredecessor) -&gt; Bool {
		return lhs.base === rhs.base
	}
}

// A protocol used for communicating from successor `Signal`s to predecessor `SignalProcessor`s in the signal graph.
// Used for connectivity and activation.
fileprivate protocol SignalPredecessor: class {
	func outputActivatedSuccessorInternal(_ successor: AnyObject, activationCount: Int, dw: inout DeferredWork)
	func outputCompletedActivationSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork)
	func outputDeactivatedSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork)
	func outputAddedSuccessorInternal(_ successor: AnyObject, param: Any?, activationCount: Int?, dw: inout DeferredWork) throws
	func outputRemovedSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork)
	func predecessorsSuccessorInternal(loopCheck: AnyObject) -&gt; Bool
	func outputSignals&lt;U&gt;(ofType: U.Type) -&gt; [Signal&lt;U&gt;]
	var loopCheckValue: AnyObject { get }
	func wrappedWithOrder(_ order: Int) -&gt; OrderedSignalPredecessor
}

// Easy construction of a hashable wrapper around an SignalPredecessor existential
extension SignalPredecessor {
	func wrappedWithOrder(_ order: Int) -&gt; OrderedSignalPredecessor {
		return OrderedSignalPredecessor(base: self, order: order)
	}
}

// All `Signal`s, except those with output handlers, are fed to another `Signal`. A `SignalProcessor` is how this is done. This is the abstract base for all handlers that connect to another `Signal`. The default implementation can only connect to a single output (concrete subclass `SignalMultiprocessor` is used for multiple outputs) but a majority of the architecture for any number of outputs is contained in this class.
// This class allows its outputs to have a different value type compared to the Signal for this class, although only SignalTransformer, SignalTransformerWithState and SignalCombiner take advantage â all other subclasses derive from SignalProcessor&lt;OutputValue, OutputValue&gt;.
class SignalProcessor&lt;OutputValue, U&gt;: SignalHandler&lt;OutputValue&gt;, SignalPredecessor {
	typealias OutputsArray = Array&lt;(destination: Weak&lt;Signal&lt;U&gt;&gt;, activationCount: Int?)&gt;
	var outputs = OutputsArray()
	
	// Common implementation for a nextHandlerInternal. Currently used only from SignalCacheUntilActive and SignalCombiner
	//
	// - Parameters:
	//   - processor: the `SignalProcessor` instance
	//   - transform: the transformation applied from input to output
	// - Returns: a function usable as the return value to `nextHandlerInternal`
	fileprivate static func simpleNext(processor: SignalProcessor&lt;OutputValue, U&gt;, transform: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Result&lt;U, SignalEnd&gt;) -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(processor.source.mutex.unbalancedTryLock() == false)
		guard let output = processor.outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return processor.initialHandlerInternal() }
		let activated = processor.source.delivery.isNormal
		let predecessor: Unmanaged&lt;AnyObject&gt;? = Unmanaged.passUnretained(processor)
		return { [weak outputSignal] r in
			outputSignal?.send(result: transform(r), predecessor: predecessor, activationCount: ac, activated: activated)
		}
	}
	
	// Determines if a `Signal` is one of the current outputs.
	//
	// - Parameter signal: possible output
	// - Returns: true if `signal` is contained in the outputs
	fileprivate final func isOutputInternal(_ signal: Signal&lt;U&gt;) -&gt; Int? {
		assert(signal.mutex.unbalancedTryLock() == false)
		for (i, o) in outputs.enumerated() {
			if let d = o.destination.value, d === signal {
				return i
			}
		}
		return nil
	}
	
	/// Identity used for checking loops (needs to be the mutex since the mutex is shared vertically through the graph, any traversal looking for potential loops could deadlock before noticing a loop with any other value)
	fileprivate final var loopCheckValue: AnyObject { return source.mutex }
	
	// Performs a depth-first graph traversal looking for the specified `SignalPredecessor`
	//
	// - Parameter contains: the search value
	// - Returns: true if `contains` was found, false otherwise
	func predecessorsSuccessorInternal(loopCheck: AnyObject) -&gt; Bool {
		// Only check the value when successors don't share the mutex (i.e. when we have a boundary of some kind).
		if !successorsShareMutex &amp;&amp; loopCheck === self.loopCheckValue {
			return true
		}
		var result = false
		runSuccesorAction {
			// Don't need to traverse sortedPreceeding (unsorted is fine for an ancestor check)
			for p in source.preceeding {
				if p.base.predecessorsSuccessorInternal(loopCheck: loopCheck) {
					result = true
					return
				}
			}
		}
		return result
	}
	
	/// Returns the list of outputs, assuming they match the provided type. This method is used when attempting to remove a SignalMulti from the list of inputs to a SignalInputMulti since the whole list of outputs may need to be searched to find one that's actually connected to the SignalInputMulti.
	///
	/// - Parameter ofType: specifies the input type of the SignalInputMulti (it will always match but we follow the type system, rather than force matching.
	/// - Returns: a strong array of outputs
	func outputSignals&lt;U&gt;(ofType: U.Type) -&gt; [Signal&lt;U&gt;] {
		return sync {
			return outputs.compactMap { $0.destination.value as? Signal&lt;U&gt; }
		}
	}
	
	
	// Pushes activation values to newly joined outputs. By default, there is no activation so this function is intended to be overridden. Currently overridden by `SignalMultiProcessor` and `SignalCacheUntilActive`.
	//
	// - Parameters:
	//   - index: identifies the output
	//   - dw: required by pushInternal
	fileprivate func sendActivationToOutputInternal(index: Int, dw: inout DeferredWork) {
	}
	
	// When an output changes activation, this function is called.
	//
	// - Parameters:
	//   - index: index of the activation changed output
	//   - activationCount: new count received
	//   - dw: required
	// - Returns: any response from `activateInternal` (true if started activating)
	fileprivate final func updateOutputInternal(index: Int, activationCount: Int?, dw: inout DeferredWork) -&gt; Bool {
		assert(source.mutex.unbalancedTryLock() == false)
		assert(outputs[index].activationCount != activationCount)
		
		let previous = anyActiveOutputsInternal
		
		outputs[index].activationCount = activationCount
		dw.append { [handler] in withExtendedLifetime(handler) {} }
		handler = nextHandlerInternal()
		
		var result = false
		if activationCount != nil {
			sendActivationToOutputInternal(index: index, dw: &amp;dw)
			result = activateInternal(dw: &amp;dw)
		} else if activationCount == nil &amp;&amp; !source.delivery.isDisabled &amp;&amp; !activeWithoutOutputsInternal {
			var anyStillActive = false
			for o in outputs {
				if o.activationCount != nil {
					anyStillActive = true
					break
				}
			}
			if !anyStillActive {
				deactivateInternal(dueToLackOfOutputs: true, dw: &amp;dw)
			}
		}
		
		if activationCount != nil, !previous {
			firstOutputActivatedInternal(dw: &amp;dw)
		} else if activationCount == nil, !anyActiveOutputsInternal {
			lastOutputDeactivatedInternal(dw: &amp;dw)
		}
		return result
	}
	
	// Helper function that applies the mutex around the supplied function, if needed.
	//
	// - parameter action: function to be run inside the mutex
	private final func runSuccesorAction(action: () -&gt; Void) {
		if successorsShareMutex {
			action()
		} else {
			sync { action() }
		}
	}
	
	/// Helper function used before and after activation to determine if this handler should activate or deactivated.
	private final var anyActiveOutputsInternal: Bool {
		assert(source.mutex.unbalancedTryLock() == false)
		for o in outputs {
			if o.destination.value != nil &amp;&amp; o.activationCount != nil {
				return true
			}
		}
		return false
	}
	
	/// Overrideable function to attach behaviors to activation by an output
	///
	/// - parameter dw: required
	fileprivate func firstOutputActivatedInternal(dw: inout DeferredWork) {
	}
	
	/// Overrideable function to attach behaviors to deactivation by an output
	///
	/// - parameter dw: required
	fileprivate func lastOutputDeactivatedInternal(dw: inout DeferredWork) {
	}
	
	/// Overrideable function to attach behaviors to output removal
	///
	/// - parameter dw: required
	fileprivate func lastOutputRemovedInternal(dw: inout DeferredWork) {
	}
	
	// Invoked from successor `Signal`s when they activate
	//
	// - Parameters:
	//   - successor: a `Signal` (must be a Signal&lt;U&gt;)
	//   - activationCount: new activation count value for the `Signal`
	//   - dw: required
	fileprivate final func outputActivatedSuccessorInternal(_ successor: AnyObject, activationCount: Int, dw: inout DeferredWork) {
		runSuccesorAction {
			guard let sccr = successor as? Signal&lt;U&gt; else { fatalError() }
			if let i = isOutputInternal(sccr) {
				_ = updateOutputInternal(index: i, activationCount: activationCount, dw: &amp;dw)
			}
		}
	}
	
	// Invoked from successor when it completes activation and transitions to `.normal` delivery
	//
	// - Parameters:
	//   - successor: the successor whose activation status has changed (must be a Signal&lt;U&gt;)
	//   - dw: required
	func outputCompletedActivationSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork) {
		runSuccesorAction {
			guard let sccr = successor as? Signal&lt;U&gt; else { fatalError() }
			if let _ = isOutputInternal(sccr), case .synchronous = source.delivery {
				endActivationInternal(dw: &amp;dw)
			}
		}
	}
	
	// Invoked from successor `Signal`s when they deactivate
	//
	// - Parameters:
	//   - successor: must be a Signal&lt;U&gt;
	//   - dw: required
	fileprivate final func outputDeactivatedSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork) {
		runSuccesorAction {
			guard let sccr = successor as? Signal&lt;U&gt; else { fatalError() }
			if let i = self.isOutputInternal(sccr) {
				_ = updateOutputInternal(index: i, activationCount: nil, dw: &amp;dw)
			}
		}
	}
	
	// Overrideable function to receive additional information when a successor attaches. Used by SignalJunction and SignalCapture to pass "onEnd" closures via the successor into the mutex. It shouldn't be possible to pass a parameter unless one is expected, so the default implementation is a `fatalError`.
	//
	// - parameter param: usually a closure.
	fileprivate func handleParamFromSuccessor(param: Any) {
		fatalError()
	}
	
	// Typical processors *don't* need to check their predecessors for a loop (only junctions do)
	fileprivate var needsPredecessorCheck: Bool {
		return false
	}
	
	// A successor connected
	//
	// - Parameters:
	//   - successor: must be a Signal&lt;U&gt;
	//   - param: see `handleParamFromSuccessor`
	//   - activationCount: initial activation count to use
	//   - dw: required
	// - Throws: a possible SignalBindError if there's a connection failure.
	fileprivate final func outputAddedSuccessorInternal(_ successor: AnyObject, param: Any?, activationCount: Int?, dw: inout DeferredWork) throws {
		var error: SignalBindError&lt;OutputValue&gt;? = nil
		runSuccesorAction {
			guard outputs.isEmpty || multipleOutputsPermitted else {
				error = SignalBindError&lt;OutputValue&gt;.duplicate(nil)
				return
			}
			guard let sccr = successor as? Signal&lt;U&gt; else { fatalError() }
			
			if needsPredecessorCheck, let predecessor = sccr.signalHandler as? SignalPredecessor {
				// Don't need to traverse sortedPreceeding (unsorted is fine for an ancestor check)
				for p in source.preceeding {
					if p.base.predecessorsSuccessorInternal(loopCheck: predecessor.loopCheckValue) {
						// Throw an error here and trigger the preconditionFailure outside the lock (otherwise precondition catching tests may deadlock).
						error = SignalBindError&lt;OutputValue&gt;.loop
						dw.append { preconditionFailure("Signals must not be joined in a loop.") }
						return
					}
				}
			}
			
			outputs.append((destination: Weak(sccr), activationCount: nil))

			#if DEBUG_LOGGING
				print("\(type(of: sccr)): \(sccr.count) added as successor to \(source.count)")
			#endif
			
			if let p = param {
				handleParamFromSuccessor(param: p)
			}
			
			if let ac = activationCount {
				if updateOutputInternal(index: outputs.count - 1, activationCount: ac, dw: &amp;dw) {
					let count = self.source.activationCount
					dw.append { self.endActivation(activationCount: count) }
				}
			}
		}
		if let e = error {
			throw e
		}
	}
	
	// Called when a successor is removed
	//
	// - Parameters:
	//   - successor: must be a Signal&lt;U&gt;
	//   - dw: required
	fileprivate final func outputRemovedSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork) {
		runSuccesorAction {
			guard let sccr = successor as? Signal&lt;U&gt; else { fatalError() }
			for i in outputs.indices.reversed() {
				let match: Bool
				if let d = outputs[i].destination.value, d === sccr {
					match = true
				} else {
					match = false
				}
				if match || outputs[i].destination.value == nil {
					if outputs[i].activationCount != nil {
						_ = updateOutputInternal(index: i, activationCount: nil, dw: &amp;dw)
					}
					outputs.remove(at: i)

					#if DEBUG_LOGGING
						print("\(type(of: sccr)): \(sccr.count) removed as successor from \(source.count)")
					#endif
					
					if outputs.isEmpty {
						lastOutputRemovedInternal(dw: &amp;dw)
					}
				}
			}
		}
	}
	
	/// Default handler should not be used
	fileprivate func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		preconditionFailure()
	}
}

private extension Exec {
	var isImmediateNonDirect: Bool {
		if case .direct = self {
			return false
		}
		return type.isImmediateAlways
	}
}

private enum ActiveWithoutOutputs {
	case always
	case never
	case ifNonEmpty
	
	func active(valuesIsEmpty: Bool) -&gt; Bool {
		switch self {
		case .always: return true
		case .never: return false
		case .ifNonEmpty where valuesIsEmpty: return false
		case .ifNonEmpty: return true
		}
	}
}

// Implementation of a processor that can output to multiple `Signal`s. Used by `continuous(initial:)`, `continuous`, `continuousWhileActive`, `playback`, `multicast`, `customActivation` and `preclosed`.
fileprivate final class SignalMultiProcessor&lt;OutputValue&gt;: SignalProcessor&lt;OutputValue, OutputValue&gt; {
	typealias Updater = (_ activationValues: inout Array&lt;OutputValue&gt;, _ preclosed: inout SignalEnd?, _ result: Result&lt;OutputValue, SignalEnd&gt;) -&gt; (Array&lt;OutputValue&gt;, SignalEnd?)
	let updater: Updater?
	var activationValues: Array&lt;OutputValue&gt;
	var preclosed: SignalEnd?
	let userUpdated: Bool
	let activeWithoutOutputs: ActiveWithoutOutputs
	
	// Rather than using different subclasses for each of the "multi" `Signal`s, this one subclass is used for all. However, that requires a few different parameters to enable different behaviors.
	//
	// - Parameters:
	//   - source: the predecessor signal
	//   - values: the initial activation values and error
	//   - userUpdated: whether the `updater` is user-supplied and needs value-copying to ensure thread-safety
	//   - activeWithoutOutputs: whether the handler should immediately activate
	//   - dw: required
	//   - context: where the `updater` will be run
	//   - updater: when a new source is received, updates the cached activation values and error
	init(source: Signal&lt;OutputValue&gt;, values: (Array&lt;OutputValue&gt;, SignalEnd?), userUpdated: Bool, activeWithoutOutputs: ActiveWithoutOutputs, dw: inout DeferredWork, context: Exec, updater: Updater?) {
		precondition((values.1 == nil &amp;&amp; values.0.isEmpty) || updater != nil, "Non empty activation values requires always active.")
		self.updater = (userUpdated &amp;&amp; context.isImmediateNonDirect) ? updater.map { u in { a, b, c in context.invokeSync { u(&amp;a, &amp;b, c) } } } : updater
		self.activationValues = values.0
		self.preclosed = values.1
		self.userUpdated = userUpdated
		self.activeWithoutOutputs = activeWithoutOutputs
		super.init(source: source, dw: &amp;dw, context: context)
	}
	
	// Multicast and continuousWhileActive are not preactivated but all others are not.
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(source.mutex.unbalancedTryLock() == false)
		return activeWithoutOutputs.active(valuesIsEmpty: activationValues.isEmpty) &amp;&amp; preclosed == nil
	}
	
	// Multiprocessor can handle multiple outputs
	fileprivate override var multipleOutputsPermitted: Bool {
		return true
	}
	
	// Any values or errors are sent on activation.
	//
	// - Parameters:
	//   - index: identifies the output
	//   - dw: required
	fileprivate final override func sendActivationToOutputInternal(index: Int, dw: inout DeferredWork) {
		guard !activationValues.isEmpty || preclosed != nil else { return }
		
		// Push as *not* activated (i.e. this is the activation)
		outputs[index].destination.value?.pushInternal(values: activationValues, end: preclosed, activated: false, dw: &amp;dw)
	}
	
	// Multiprocessors are (usually â not multicast) preactivated and may cache the values or errors
	// - Returns: a function to use as the handler prior to activation
	fileprivate override func initialHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		return { [weak self] r in
			guard let self = self else { return }
			_ = self.updater?(&amp;self.activationValues, &amp;self.preclosed, r)
		}
	}
	
	// On result, update any activation values.
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		
		// There's a tricky point here: for multicast, we only want to send to outputs that were connected *before* we started sending this value; otherwise values could be sent to the wrong outputs following asychronous graph manipulations.
		// HOWEVER, when activation values exist, we must ensure that any output that was sent the *old* activation values will receive this new value *regardless* of when it connects.
		// To balance these needs, the outputs array is copied here for "multicast" but isn't copied until immediately after updating the `activationValues` in all other cases
		// There's an additional assumption: (updater == nil) is only possible for "multicast"
		var outs: OutputsArray? = updater != nil ? nil : outputs
		
		let activated = source.delivery.isNormal
		
		// NOTE: the output signals in the `outs` array are already weakly retained
		return { [weak self] r in
			guard let self = self else { return }
			
			if let u = self.updater {
				if self.userUpdated {
					var values = [OutputValue]()
					var error: SignalEnd?
					
					// Mutably copy the activation values and error
					self.sync {
						values = self.activationValues
						error = self.preclosed
					}
					
					// Perform the update on the copies
					let expired = u(&amp;values, &amp;error, r)
					
					// Change the authoritative activation values and error
					self.sync {
						self.activationValues = values
						self.preclosed = error
						
						if outs == nil {
							outs = self.outputs
						}
					}
					
					// Make sure any reference to the originals is released *outside* the mutex
					withExtendedLifetime(expired) {}
				} else {
					var expired: (Array&lt;OutputValue&gt;, SignalEnd?)? = nil
					
					// Perform the update on the copies
					self.sync {
						expired = u(&amp;self.activationValues, &amp;self.preclosed, r)
						
						if outs == nil {
							outs = self.outputs
						}
					}
					
					// Make sure any expired content is released *outside* the mutex
					withExtendedLifetime(expired) {}
				}
			}
			
			// Send the result *before* changing the authoritative activation values and error
			let predecessor: Unmanaged&lt;AnyObject&gt;? = Unmanaged.passUnretained(self)
			for o in outs ?? [] {
				if let d = o.destination.value, let ac = o.activationCount {
					d.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
				}
			}
		}
	}
}

// Implementation of a processor that combines SignalTransformerWithState and SignalMultiProcessor functionality into a single processor (avoiding the need for a clumsy state sharing arrangement if the two are separate).
fileprivate final class SignalReducer&lt;OutputValue, State&gt;: SignalProcessor&lt;OutputValue, State&gt; {
	typealias Initializer = (_ message: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Result&lt;State?, SignalEnd&gt;
	typealias Reducer = (_ state: State, _ message: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Result&lt;State, SignalEnd&gt;
	enum StateOrInitializer {
		case state(State)
		case initializer(Initializer)
	}
	let reducer: Reducer
	var stateOrInitializer: StateOrInitializer
	var end: SignalEnd?
	
	init(source: Signal&lt;OutputValue&gt;, state: State, end: SignalEnd?, dw: inout DeferredWork, context: Exec, reducer: @escaping Reducer) {
		self.reducer = context.isImmediateNonDirect ? { a, b in context.invokeSync { reducer(a, b) } } : reducer
		self.end = end
		self.stateOrInitializer = .state(state)
		super.init(source: source, dw: &amp;dw, context: context)
	}
	
	init(source: Signal&lt;OutputValue&gt;, initializer: @escaping Initializer, end: SignalEnd?, dw: inout DeferredWork, context: Exec, reducer: @escaping Reducer) {
		self.reducer = context.isImmediateNonDirect ? { a, b in context.invokeSync { reducer(a, b) } } : reducer
		self.end = end
		self.stateOrInitializer = .initializer(initializer)
		super.init(source: source, dw: &amp;dw, context: context)
	}
	
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(source.mutex.unbalancedTryLock() == false)
		return end == nil
	}
	
	fileprivate override var multipleOutputsPermitted: Bool {
		return true
	}
	
	fileprivate final override func sendActivationToOutputInternal(index: Int, dw: inout DeferredWork) {
		guard case .state(let state) = stateOrInitializer else { return }
		
		// Push as *not* activated (i.e. this is the activation)
		outputs[index].destination.value?.pushInternal(values: [state], end: end, activated: false, dw: &amp;dw)
	}
	
	// Multiprocessors are (usually â not multicast) preactivated and may cache the values or errors
	// - Returns: a function to use as the handler prior to activation
	override func initialHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		return { [weak self] r in
			guard let self = self else { return }
			
			// Copy the state under the mutex
			let stateOrInitializer = self.sync { self.stateOrInitializer }
			
			let next: Result&lt;State, SignalEnd&gt;
			switch stateOrInitializer {
			case .state(let state): next = self.reducer(state, r)
			case .initializer(let initializer):
				switch initializer(r) {
				case .success(nil): return
				case .success(let s?): next = .success(s)
				case .failure(let e): next = .failure(e)
				}
			}
			
			// Apply the change to the authoritative version under the mutex
			self.sync {
				switch next {
				case .success(let v): self.stateOrInitializer = .state(v)
				case .failure(let e): self.end = e
				}
			}
			
			// Ensure any old references are released outside the mutex
			withExtendedLifetime(stateOrInitializer) {}
		}
	}
	
	// On result, update any activation values.
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		
		let activated = source.delivery.isNormal
		return { [weak self] r in
			guard let self = self else { return }
			
			// Copy the state under the mutex
			let stateOrInitializer = self.sync { self.stateOrInitializer }
			
			let next: Result&lt;State, SignalEnd&gt;
			switch stateOrInitializer {
			case .state(let state): next = self.reducer(state, r)
			case .initializer(let initializer):
				switch initializer(r) {
				case .success(nil): return
				case .success(let s?): next = .success(s)
				case .failure(let e): next = .failure(e)
				}
			}
			
			// Apply the change to the authoritative version under the mutex
			var outputs: OutputsArray = []
			var result = Signal&lt;State&gt;.Result.failure(.complete)
			self.sync {
				switch next {
				case .success(let v):
					self.stateOrInitializer = .state(v)
					result = .success(v)
				case .failure(let e):
					self.end = e
					result = .failure(e)
				}
				outputs = self.outputs
			}
			
			// Ensure any old references are released outside the mutex
			withExtendedLifetime(stateOrInitializer) {}
			
			let predecessor: Unmanaged&lt;AnyObject&gt;? = Unmanaged.passUnretained(self)
			for o in outputs {
				if let d = o.destination.value, let ac = o.activationCount {
					d.send(result: result, predecessor: predecessor, activationCount: ac, activated: activated)
				}
			}
		}
	}
}

// A handler which starts receiving `Signal`s immediately and caches them until an output connects
fileprivate final class SignalCacheUntilActive&lt;OutputValue&gt;: SignalProcessor&lt;OutputValue, OutputValue&gt; {
	var cachedValues: Array&lt;OutputValue&gt;
	var cachedEnd: SignalEnd? = nil
	
	// Construct a SignalCacheUntilActive handler
	//
	// - Parameters:
	//   - source: the predecessor signal
	//   - dw: required
	init(source: Signal&lt;OutputValue&gt;, precached: [OutputValue]?, dw: inout DeferredWork) {
		cachedValues = precached ?? []
		super.init(source: source, dw: &amp;dw, context: .direct)
	}
	
	// Is always active
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(source.mutex.unbalancedTryLock() == false)
		return true
	}
	
	// Sends the cached values when an output connects
	//
	// - Parameters:
	//   - index: identifies the output
	//   - dw: required
	fileprivate final override func sendActivationToOutputInternal(index: Int, dw: inout DeferredWork) {
		guard !cachedValues.isEmpty || cachedEnd != nil else { return }
		
		// Push as *not* activated (i.e. this is the activation)
		outputs[index].destination.value?.pushInternal(values: cachedValues, end: cachedEnd, activated: false, dw: &amp;dw)
	}
	
	/// Caches values prior to an output connecting
	// - Returns: a function to use as the handler prior to activation
	override func initialHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		return { [weak self] r in
			switch r {
			case .success(let v): self?.cachedValues.append(v)
			case .failure(let e): self?.cachedEnd = e
			}
		}
	}
	
	// Clears the cache immediately after an output connects
	//
	// - Parameter dw: required
	fileprivate override func firstOutputActivatedInternal(dw: inout DeferredWork) {
		let tuple = (self.cachedValues, self.cachedEnd)
		self.cachedValues = []
		self.cachedEnd = nil
		dw.append { withExtendedLifetime(tuple) {} }
	}
	
	// Once an output is connected, the handler function is a basic passthrough
	// - Returns: a function to use as the handler after activation
	override func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		return SignalProcessor.simpleNext(processor: self) { r in r }
	}
}

// A transformer applies a user transformation to any signal. It's the typical "between two `Signal`s" handler.
fileprivate final class SignalTransformer&lt;OutputValue, U&gt;: SignalProcessor&lt;OutputValue, U&gt; {
	typealias UserProcessorType = (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next
	let userProcessor: UserProcessorType
	
	// Constructs a `SignalTransformer`
	//
	// - Parameters:
	//   - source: the predecessor signal
	//   - dw: required
	//   - context: where the `handler` will be invoked
	//   - processor: the user supplied processing function
	init(source: Signal&lt;OutputValue&gt;, dw: inout DeferredWork, context: Exec, _ processor: @escaping UserProcessorType) {
		self.userProcessor = context.isImmediateNonDirect ? { a in context.invokeSync { processor(a) } } : processor
		super.init(source: source, dw: &amp;dw, context: context)
	}
	
	/// Invoke the user handler and block if the `next` gains an additional reference count in the process.
	// - Returns: a function to use as the handler after activation
	override func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let predecessor: Unmanaged&lt;AnyObject&gt;? = Unmanaged.passUnretained(self)
		let activated = source.delivery.isNormal
		return { [userProcessor, weak outputSignal] r in
			let transformedResult = userProcessor(r)
			
			switch transformedResult {
			case .none: break
			case .single(let r):
				if let os = outputSignal {
					os.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
				}
			case .array(let a):
				if let os = outputSignal {
					for r in a {
						os.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
					}
				}
			}
		}
	}
}

// A transformer applies a user transformation to any signal. It's the typical "between two `Signal`s" handler.
fileprivate final class SignalActivationTransformer&lt;OutputValue, U&gt;: SignalProcessor&lt;OutputValue, U&gt; {
	typealias UserProcessorType = (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next
	let activationProcessor: UserProcessorType
	let userProcessor: UserProcessorType
	var useActivation: Bool = false
	
	// Constructs a `SignalTransformer`
	//
	// - Parameters:
	//   - source: the predecessor signal
	//   - dw: required
	//   - context: where the `handler` will be invoked
	//   - processor: the user supplied processing function
	init(source: Signal&lt;OutputValue&gt;, dw: inout DeferredWork, context: Exec, activationProcessor: @escaping UserProcessorType, _ processor: @escaping UserProcessorType) {
		self.activationProcessor = context.isImmediateNonDirect ? { a in context.invokeSync { activationProcessor(a) } } : activationProcessor
		self.userProcessor = context.isImmediateNonDirect ? { a in context.invokeSync { processor(a) } } : processor
		super.init(source: source, dw: &amp;dw, context: context)
	}
	
	override func initialHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		useActivation = true
		return super.initialHandlerInternal()
	}
	
	override func handleSynchronousToNormalInternal(dw: inout DeferredWork) {
		useActivation = false
		handler = nextHandlerInternal()
	}
	
	/// Invoke the user handler and block if the `next` gains an additional reference count in the process.
	// - Returns: a function to use as the handler after activation
	override func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let predecessor: Unmanaged&lt;AnyObject&gt;? = Unmanaged.passUnretained(self)
		return { [useActivation, userProcessor, activationProcessor, weak outputSignal] r in
			let transformedResult: Signal&lt;U&gt;.Next
			if useActivation {
				transformedResult = activationProcessor(r)
			} else {
				transformedResult = userProcessor(r)
			}
			
			switch transformedResult {
			case .none: break
			case .single(let r):
				if let os = outputSignal {
					os.send(result: r, predecessor: predecessor, activationCount: ac, activated: !useActivation)
				}
			case .array(let a):
				if let os = outputSignal {
					for r in a {
						os.send(result: r, predecessor: predecessor, activationCount: ac, activated: !useActivation)
					}
				}
			}
		}
	}
}

/// Same as `SignalTransformer` plus a `state` value that is passed `inout` to the handler each time so state can be safely retained between invocations. This `state` value is reset to its `initialState` if the signal graph is deactivated.
fileprivate final class SignalTransformerWithState&lt;OutputValue, U, S&gt;: SignalProcessor&lt;OutputValue, U&gt; {
	typealias UserProcessorType = (inout S, Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next
	let userProcessor: UserProcessorType
	let initialState: S
	
	// Constructs a `SignalTransformer`
	//
	// - Parameters:
	//   - source: the predecessor signal
	//   - initialState: initial value to use for the "state" passed to the processing handler on each iteration
	//   - dw: required
	//   - context: where the `handler` will be invoked
	//   - processor: the user supplied processing function
	init(source: Signal&lt;OutputValue&gt;, initialState: S, dw: inout DeferredWork, context: Exec, _ processor: @escaping (inout S, Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next) {
		self.userProcessor = context.isImmediateNonDirect ? { a, b in context.invokeSync { processor(&amp;a, b) } } : processor
		self.initialState = initialState
		super.init(source: source, dw: &amp;dw, context: context)
	}
	
	// Invoke the user handler and block if the `next` gains an additional reference count in the process.
	// - Returns: a function to use as the handler after activation
	override func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let activated = source.delivery.isNormal
		let predecessor: Unmanaged&lt;AnyObject&gt;? = Unmanaged.passUnretained(self)
		
		/// Every time the handler is recreated, the `state` value is initialized from the `initialState`.
		var state = initialState
		
		return { [userProcessor, weak outputSignal] r in
			let transformedResult = userProcessor(&amp;state, r)
			
			switch transformedResult {
			case .none: break
			case .single(let r):
				if let os = outputSignal {
					os.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
				}
			case .array(let a):
				if let os = outputSignal {
					for r in a {
						os.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
					}
				}
			}
		}
	}
}

/// A processor used by `combine(...)` to transform incoming `Signal`s into the "combine" type. The handler function is typically just a wrap of the preceeding `Result` in a `EitherResultX.resultY`. Other than that, it's a basic passthrough transformer that returns `false` to `successorsShareMutex`.
fileprivate final class SignalCombiner&lt;OutputValue, U&gt;: SignalProcessor&lt;OutputValue, U&gt; {
	let combineProcessor: (Result&lt;OutputValue, SignalEnd&gt;) -&gt; U
	
	// Constructs a `SignalCombiner`
	//
	// - Parameters:
	//   - source: the predecessor signal
	//   - dw: required
	//   - context: where the `handler` will be invoked
	//   - processor: the user supplied processing function
	init(source: Signal&lt;OutputValue&gt;, dw: inout DeferredWork, context: Exec, processor: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; U) {
		self.combineProcessor = context.isImmediateNonDirect ? { a in context.invokeSync { processor(a) } } : processor
		super.init(source: source, dw: &amp;dw, context: context)
	}
	
	/// Only one predecessor in a multi-predecessor scenario can share its mutex.
	fileprivate override var successorsShareMutex: Bool {
		return false
	}
	
	/// Simple application of the handler
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		return SignalProcessor.simpleNext(processor: self) { [combineProcessor] r in Result&lt;U, SignalEnd&gt;.success(combineProcessor(r)) }
	}
}

// Common implementation of bind behavior used by `SignalJunction` and `SignalCapture`.
//
// - Parameters:
//   - processor: the `SignalJuction` or `SignalCapture`
//   - disconnect: receiver for a new `SignalInput` when the junction is disconnected.
//   - to: destination of the bind
//   - optionalEndHandler: passed as the `param` to `addPreceedingInternal`
// - Throws: and `addPreceedingInternal` error or other `SignalBindError&lt;OutputValue&gt;.cancelled` errors if weak properties can't strongified.
fileprivate func bindFunction&lt;OutputValue&gt;(processor: SignalProcessor&lt;OutputValue, OutputValue&gt;, disconnect: () -&gt; SignalInput&lt;OutputValue&gt;?, to input: SignalInput&lt;OutputValue&gt;, optionalEndHandler: Any?) throws {
	var dw = DeferredWork()
	defer { dw.runWork() }
	assert(!(input is SignalMultiInput&lt;OutputValue&gt;))
	if let nextSignal = input.signal {
		try nextSignal.mutex.sync { () throws -&gt; () in
			guard input.activationCount == nextSignal.activationCount else {
				throw SignalBindError&lt;OutputValue&gt;.cancelled
			}
			nextSignal.removeAllPreceedingInternal(dw: &amp;dw)
			do {
				try nextSignal.addPreceedingInternal(processor, param: optionalEndHandler, dw: &amp;dw)
			} catch {
				switch error {
				case SignalBindError&lt;OutputValue&gt;.duplicate:
					throw SignalBindError&lt;OutputValue&gt;.duplicate(SignalInput&lt;OutputValue&gt;(signal: nextSignal, activationCount: nextSignal.activationCount))
				default: throw error
				}
			}
		}
	} else {
		throw SignalBindError&lt;OutputValue&gt;.cancelled
	}
}

/// A junction is a point in the signal graph that can be disconnected and reconnected at any time. Constructed implicitly by calling `bind(to:...)` or explicitly by calling `junction()` on an `Signal`.
class SignalJunction&lt;OutputValue&gt;: SignalProcessor&lt;OutputValue, OutputValue&gt;, Lifetime {
	typealias Handler = (SignalJunction&lt;OutputValue&gt;, SignalEnd, SignalInput&lt;OutputValue&gt;) -&gt; ()
	private var disconnectOnEnd: Handler? = nil
	
	// Constructs a "bind" handler
	//
	// - Parameters:
	//   - source: the predecessor signal
	//   - dw: required
	init(source: Signal&lt;OutputValue&gt;, dw: inout DeferredWork) {
		super.init(source: source, dw: &amp;dw, context: .direct)
	}
	
	// Can't share mutex since successor may swap between different graphs
	fileprivate override var successorsShareMutex: Bool {
		return false
	}
	
	// Typical processors *don't* need to check their predecessors for a loop (only junctions do)
	fileprivate override var needsPredecessorCheck: Bool {
		return true
	}
	
	// If a `disconnectOnEnd` handler is configured, then `failure` signals are not sent through the junction. Instead, the junction is disconnected and the `disconnectOnEnd` function is given an opportunity to handle the `SignalJunction` (`self`) and `SignalInput` (from the `disconnect`).
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let activated = source.delivery.isNormal
		let predecessor: Unmanaged&lt;AnyObject&gt;? = Unmanaged.passUnretained(self)
		let disconnectAction = disconnectOnEnd
		return { [weak outputSignal, weak self] r in
			if let d = disconnectAction, case .failure(let e) = r, let s = self, let input = s.disconnect() {
				d(s, e, input)
			} else {
				_ = outputSignal?.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
			}
		}
	}
	
	/// Disconnects the succeeding `Signal` (if any).
	///
	/// - returns: the new `SignalInput` for the succeeding `Signal` (if any `Signal` was connected) otherwise nil. If the `SignalInput` value is non-nil and is released, the succeeding `Signal` will be closed.
	func disconnect() -&gt; SignalInput&lt;OutputValue&gt;? {
		var previous: SignalJunction&lt;OutputValue&gt;.Handler? = nil
		let result = sync { () -&gt; Signal&lt;OutputValue&gt;? in
			previous = disconnectOnEnd
			return outputs.first?.destination.value
			}?.newInput(forDisconnector: self)
		withExtendedLifetime(previous) {}
		return result
	}
	
	/// Implementation of `Lifetime` simply invokes a `disconnect()`
	func cancel() {
		_ = disconnect()
	}
	
	// Implementation of `Lifetime` requires `cancel` is called in the `deinit`
	deinit {
		cancel()
	}
	
	// The `disconnectOnEnd` needs to be set inside the mutex, if-and-only-if a successor connects successfully. To allow this to work, the desired `disconnectOnEnd` function is passed into this function via the `outputAddedSuccessorInternal` called from `addPreceedingInternal` in the `bindFunction`.
	//
	// - Parameter param: received through `addPreceedingInternal` â should be the onEnd handler from `bind(to:resend:onEnd:)`
	fileprivate override func handleParamFromSuccessor(param: Any) {
		if let p = param as? SignalJunction&lt;OutputValue&gt;.Handler {
			disconnectOnEnd = p
		}
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameter to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalJunction` will still be `disconnect`ed.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind&lt;U: SignalInputInterface&gt;(to: U) throws where U.InputValue == OutputValue {
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.input.singleInput(), optionalEndHandler: nil)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalJunction` will still be `disconnect`ed.
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalJunction` and the input created by calling `disconnect` on it.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind&lt;U: SignalInputInterface&gt;(to: U, onEnd: @escaping SignalJunction&lt;OutputValue&gt;.Handler) throws where U.InputValue == OutputValue {
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.input.singleInput(), optionalEndHandler: onEnd)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameter to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalJunction` will still be `disconnect`ed.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind(to: SignalMergedInput&lt;OutputValue&gt;, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false) throws {
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.singleInput(closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate), optionalEndHandler: nil)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalJunction` will still be `disconnect`ed.
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalJunction` and the input created by calling `disconnect` on it.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind(to: SignalMergedInput&lt;OutputValue&gt;, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false, onEnd: @escaping (SignalJunction&lt;OutputValue&gt;, Error, SignalInput&lt;OutputValue&gt;) -&gt; ()) throws {
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.singleInput(closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate), optionalEndHandler: onEnd)
	}
	
	/// Disconnect and reconnect to the same input, to deliberately deactivate and reactivate. If `disconnect` returns `nil`, no further action will be taken. Any error attempting to reconnect will be sent to the input.
	func rebind() {
		if let input = disconnect() {
			do {
				try bind(to: input)
			} catch {
				input.send(result: .failure(.other(error)))
			}
		}
	}
	
	/// Disconnect and reconnect to the same input, to deliberately deactivate and reactivate. If `disconnect` returns `nil`, no further action will be taken. Any error attempting to reconnect will be sent to the input.
	///
	/// - Parameter onEnd: passed through to `bind`
	func rebind(onEnd: @escaping SignalJunction&lt;OutputValue&gt;.Handler) {
		if let input = disconnect() {
			do {
				try bind(to: input, onEnd: onEnd)
			} catch {
				input.send(result: .failure(.other(error)))
			}
		}
	}
}

// Used to hold the handler function for onEnd behavior for `SignalCapture`
private struct SignalCaptureParam&lt;OutputValue&gt; {
	let resend: SignalActivationSelection
	let disconnectOnEnd: SignalCapture&lt;OutputValue&gt;.Handler?
}

/// A "capture" handler separates activation signals (those sent immediately on connection) from normal signals. This allows activation signals to be handled separately or removed from the stream entirely.
/// NOTE: this handler *blocks* delivery between capture and connecting to the output. Signals sent in the meantime are queued.
final class SignalCapture&lt;OutputValue&gt;: SignalProcessor&lt;OutputValue, OutputValue&gt;, Lifetime {
	struct FailedToEmit: Error {}
	typealias Handler = (SignalCapture&lt;OutputValue&gt;, SignalEnd, SignalInput&lt;OutputValue&gt;) -&gt; ()
	
	private var resend: SignalActivationSelection = .none
	private var capturedEnd: SignalEnd? = nil
	private var capturedValues: [OutputValue] = []
	private var blockActivationCount: Int = 0
	private var disconnectOnEnd: SignalCapture&lt;OutputValue&gt;.Handler? = nil
	
	// Constructs a capture handler
	//
	// - Parameters:
	//   - source: the predecessor signal
	//   - dw: required
	fileprivate init(source: Signal&lt;OutputValue&gt;, dw: inout DeferredWork) {
		super.init(source: source, dw: &amp;dw, context: .direct)
	}
	
	// Once an output is connected, `SignalCapture` becomes a no-special-behaviors passthrough handler.
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(super.source.mutex.unbalancedTryLock() == false)
		return outputs.count &gt; 0 ? false : true
	}
	
	/// Accessor for any captured values. Activation signals captured can be accessed through this property between construction and activating an output (after that point, capture signals are cleared).
	///
	/// - Returns: and array of values (which may be empty) and an optional error, which are the signals received during activation.
	var values: [OutputValue] {
		return sync {
			return capturedValues
		}
	}
	
	/// Accessor for any captured error. Activation signals captured can be accessed through this property between construction and activating an output (after that point, capture signals are cleared).
	///
	/// - Returns: and array of values (which may be empty) and an optional error, which are the signals received during activation.
	var end: SignalEnd? {
		return sync {
			return capturedEnd
		}
	}
	
	/// Accessor for the last captured value, if any.
	///
	/// - Returns: the last captured value
	/// - Throws: if no captured value but captured end, the `SignalEnd` is thrown. If neither value nor end, `SignalCapture.FailedToEmit` is thrown.
	func get() throws -&gt; OutputValue {
		return try sync {
			if let last = capturedValues.last {
				return last
			} else if let end = capturedEnd {
				throw end
			} else {
				throw FailedToEmit()
			}
		}
	}
	
	/// Accessor for the last captured value, if any.
	///
	/// - Returns: the last captured value
	/// - Throws: if no captured value but captured end, the `SignalEnd` is thrown. If neither value nor end, `SignalCapture.FailedToEmit` is thrown.
	func peek() -&gt; OutputValue? {
		return sync { capturedValues.last }
	}
	
	// Since this node operates as a junction, it cannot share mutex
	fileprivate override var successorsShareMutex: Bool {
		return false
	}
	
	// Typical processors *don't* need to check their predecessors for a loop (only junctions do)
	fileprivate override var needsPredecessorCheck: Bool {
		return true
	}
	
	// The initial behavior is to capture
	// - Returns: a function to use as the handler prior to activation
	fileprivate override func initialHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		guard outputs.isEmpty else { return { r in } }
		
		assert(super.source.mutex.unbalancedTryLock() == false)
		capturedEnd = nil
		capturedValues = []
		return { [weak self] r in
			guard let s = self else { return }
			switch r {
			case .success(let v):
				s.capturedValues.append(v)
			case .failure(let e): s.capturedEnd = e
			}
		}
	}
	
	// After the initial "capture" phase, the queue is blocked, causing any non-activation signals to queue.
	// - Parameter dw: required
	fileprivate override func handleSynchronousToNormalInternal(dw: inout DeferredWork) {
		if outputs.isEmpty {
			let (vs, err) = super.source.pullQueuedSynchronousInternal()
			capturedValues.append(contentsOf: vs)
			if let e = err {
				capturedEnd = e
			}
			super.source.blockInternal()
			blockActivationCount = super.source.activationCount
		}
	}
	
	// If this handler disconnected, then it reactivates and reverts to being a "capture".
	// - Parameter dw: required
	fileprivate override func lastOutputRemovedInternal(dw: inout DeferredWork) {
		guard super.source.delivery.isDisabled else { return }
		
		// While a capture has an output connected â even an inactive output â it doesn't self-activate. When the last output is removed, we need to re-activate.
		dw.append { [handler] in withExtendedLifetime(handler) {} }
		handler = initialHandlerInternal()
		if activateInternal(dw: &amp;dw) {
			let count = super.source.activationCount
			dw.append { self.endActivation(activationCount: count) }
		}
	}
	
	// When an output activates, if `sendAsNormal` is true, the new output is sent any captured values. In all cases, the captured values are cleared at this point and the queue is unblocked.
	// - Parameter dw: required
	fileprivate override func firstOutputActivatedInternal(dw: inout DeferredWork) {
		if resend != .none, let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount {
			// Don't deliver errors if `disconnectOnEnd` is set
			if let d = disconnectOnEnd, let e = capturedEnd {
				// NOTE: we use the successors "internal" functon here since this is always called from successor's `updateActivationInternal` function
				// Push as *activated* (i.e. this is deferred from activation to normal)
				switch resend {
				case .all: outputSignal.pushInternal(values: capturedValues, end: nil, activated: false, dw: &amp;dw)
				case .deferred: outputSignal.pushInternal(values: capturedValues, end: nil, activated: true, dw: &amp;dw)
				case .first:
					outputSignal.pushInternal(values: capturedValues.first.map { [$0] } ?? [], end: nil, activated: false, dw: &amp;dw)
					outputSignal.pushInternal(values: Array(capturedValues.dropFirst()), end: nil, activated: true, dw: &amp;dw)
				case .last:
					outputSignal.pushInternal(values: capturedValues.last.map { [$0] } ?? [], end: nil, activated: false, dw: &amp;dw)
				case .none:
					fatalError("Unreachable")
				}
				
				dw.append {
					// We need to use a specialized version of disconnect that ensures another disconnect hasn't happened in the meantime. Since it's theoretically possible that this handler could be disconnected and reconnected in the meantime (or deactivated and reactivated) we need to check the output and activationCount to ensure everything's still the same.
					var previous: SignalCapture&lt;OutputValue&gt;.Handler? = nil
					let input = self.sync { () -&gt; Signal&lt;OutputValue&gt;? in
						if let o = self.outputs.first, let os = o.destination.value, os === outputSignal, ac == o.activationCount {
							previous = self.disconnectOnEnd
							return os
						} else {
							return nil
						}
					}?.newInput(forDisconnector: self)
					withExtendedLifetime(previous) {}
					if let i = input {
						d(self, e, i)
					}
				}
			} else {
				// NOTE: we use the successors "internal" functon here since this is always called from successor's `updateActivationInternal` function
				// Push as *activated* (i.e. this is deferred from activation to normal)
				switch resend {
				case .all: outputSignal.pushInternal(values: capturedValues, end: capturedEnd, activated: false, dw: &amp;dw)
				case .deferred: outputSignal.pushInternal(values: capturedValues, end: capturedEnd, activated: true, dw: &amp;dw)
				case .first:
					outputSignal.pushInternal(values: capturedValues.first.map { [$0] } ?? [], end: nil, activated: false, dw: &amp;dw)
					outputSignal.pushInternal(values: Array(capturedValues.dropFirst()), end: capturedEnd, activated: true, dw: &amp;dw)
				case .last:
					outputSignal.pushInternal(values: capturedValues.last.map { [$0] } ?? [], end: capturedEnd, activated: false, dw: &amp;dw)
				case .none:
					fatalError("Unreachable")
				}
			}
		}
		super.source.unblockInternal(activationCountAtBlock: blockActivationCount)
		super.source.resumeIfPossibleInternal(dw: &amp;dw)
		let tuple = (self.capturedValues, self.capturedEnd)
		self.capturedValues = []
		self.capturedEnd = nil
		dw.append { withExtendedLifetime(tuple) {} }
	}
	
	// Like a `SignalJunction`, a capture can respond to an error by disconnecting instead of delivering.
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(super.source.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let activated = super.source.delivery.isNormal
		let predecessor: Unmanaged&lt;AnyObject&gt;? = Unmanaged.passUnretained(self)
		let disconnectAction = disconnectOnEnd
		return { [weak outputSignal, weak self] r in
			if let d = disconnectAction, case .failure(let e) = r, let s = self, let input = s.disconnect() {
				d(s, e, input)
			} else {
				_ = outputSignal?.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
			}
		}
	}
	
	/// Disconnects the succeeding `Signal` (if any).
	///
	/// - returns: the new `SignalInput` for the succeeding `Signal` (if any `Signal` was connected) otherwise nil. If the `SignalInput` value is non-nil and is released, the succeeding `Signal` will be closed.
	func disconnect() -&gt; SignalInput&lt;OutputValue&gt;? {
		var previous: SignalCapture&lt;OutputValue&gt;.Handler? = nil
		let result = sync { () -&gt; Signal&lt;OutputValue&gt;? in
			previous = disconnectOnEnd
			return outputs.first?.destination.value
			}?.newInput(forDisconnector: self)
		withExtendedLifetime(previous) {}
		return result
	}
	
	/// Implementation of `Lifetime` simply invokes a `disconnect()`
	func cancel() {
		_ = self.disconnect()
	}
	
	// Implementation of `Lifetime` requires `cancel` is called in the `deinit`
	deinit {
		cancel()
	}
	
	// The `disconnectOnEnd` needs to be set inside the mutex, if-and-only-if a successor connects successfully. To allow this to work, the desired `disconnectOnEnd` function is passed into this function via the `outputAddedSuccessorInternal` called from `addPreceedingInternal` in the `bindFunction`.
	//
	// - Parameter param: received through `addPreceedingInternal` â should be the onEnd handler from `bind(to:resend:onEnd:)`
	fileprivate override func handleParamFromSuccessor(param: Any) {
		if let p = param as? SignalCaptureParam&lt;OutputValue&gt; {
			disconnectOnEnd = p.disconnectOnEnd
			resend = p.resend
		}
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalCapture` will still be `disconnect`ed.
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind&lt;U: SignalInputInterface&gt;(to: U, resend: SignalActivationSelection = .none) throws where U.InputValue == OutputValue {
		let param = SignalCaptureParam&lt;OutputValue&gt;(resend: resend, disconnectOnEnd: nil)
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.input.singleInput(), optionalEndHandler: param)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalCapture` will still be `disconnect`ed.
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalCapture` and the input created by calling `disconnect` on it.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind&lt;U: SignalInputInterface&gt;(to: U, resend: SignalActivationSelection = .none, onEnd: @escaping SignalCapture&lt;OutputValue&gt;.Handler) throws where U.InputValue == OutputValue {
		let param = SignalCaptureParam&lt;OutputValue&gt;(resend: resend, disconnectOnEnd: onEnd)
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.input.singleInput(), optionalEndHandler: param)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalCapture` will still be `disconnect`ed.
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind(to: SignalMergedInput&lt;OutputValue&gt;, resend: SignalActivationSelection = .none, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool) throws {
		let param = SignalCaptureParam&lt;OutputValue&gt;(resend: resend, disconnectOnEnd: nil)
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.singleInput(closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate), optionalEndHandler: param)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalCapture` will still be `disconnect`ed.
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalCapture` and the input created by calling `disconnect` on it.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind(to: SignalMergedInput&lt;OutputValue&gt;, resend: SignalActivationSelection = .none, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool, onEnd: @escaping SignalCapture&lt;OutputValue&gt;.Handler) throws {
		let param = SignalCaptureParam&lt;OutputValue&gt;(resend: resend, disconnectOnEnd: onEnd)
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.singleInput(closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate), optionalEndHandler: param)
	}
	
	/// Appends a `Signal` that will resume the stream interrupted by the `SignalCapture`.
	///
	/// - Parameters:
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	/// - returns: the created `Signal`
	func resume(resend: SignalActivationSelection = .none) -&gt; Signal&lt;OutputValue&gt; {
		let (input, output) = Signal&lt;OutputValue&gt;.create()
		// This could be `duplicate` but that's a precondition failure
		try! bind(to: input, resend: resend)
		return output
	}
	
	/// Appends a `Signal` that will resume the stream interrupted by the `SignalCapture`.
	///
	/// - Parameters:
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalCapture` and the input created by calling `disconnect` on it.
	/// - returns: the created `SignalOutput`
	func resume(resend: SignalActivationSelection = .none, onEnd: @escaping SignalCapture&lt;OutputValue&gt;.Handler) -&gt; Signal&lt;OutputValue&gt; {
		let (input, output) = Signal&lt;OutputValue&gt;.create()
		// This could be `duplicate` but that's a precondition failure
		try! bind(to: input, resend: resend, onEnd: onEnd)
		return output
	}
}

/// When an input to a `SignalMergedInput` sends an error, this behavior determines the effect on the merge set and its output
///
/// - none: the input signal is removed from the merge set but the error is not propagated through to the output.
/// - errors: if the error is not an instance of `SignalComplete`, then the error is propagated through to the output. This is the default.
/// - close: any error, including `SignalEnd.complete`, is progagated through to the output
enum SignalEndPropagation {
	case none
	case errors
	case all
	
	/// Determines whether the error should be sent or if the input should be removed instead.
	///
	/// - Parameter error: sent from one of the inputs
	/// - Returns: if `false`, the input that sent the error should be removed but the error should not be sent. If `true`, the error should be sent to the `SignalMergedInput`'s output (whether or not the input is removed is then determined by the `removeOnDeactivate` property).
	func shouldPropagateEnd(_ end: SignalEnd) -&gt; Bool {
		switch self {
		case .none: return false
		case .errors: return end.isOther
		case .all: return true
		}
	}
}

// A handler that apples the different rules required for inputs to a `SignalMergedInput`.
fileprivate class SignalMultiInputProcessor&lt;InputValue&gt;: SignalProcessor&lt;InputValue, InputValue&gt; {
	let closePropagation: SignalEndPropagation
	let removeOnDeactivate: Bool
	
	// The input is added here to keep it alive at least as long as there are active inputs. You can `cancel` an input to remove all active inputs.
	let multiInput: SignalMultiInput&lt;InputValue&gt;
	
	// Constructs a `SignalMultiInputProcessor`
	//
	// - Parameters:
	//   - signal: destination of the `SignalMergedInput`
	//   - closePropagation: rules to use when this processor handles an error
	//   - removeOnDeactivate: behavior to apply on deactivate
	//   - mergedInput: the mergedInput that manages this processor
	//   - dw: required
	init(source: Signal&lt;InputValue&gt;, multiInput: SignalMultiInput&lt;InputValue&gt;, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool, dw: inout DeferredWork) {
		self.multiInput = multiInput
		self.closePropagation = closePropagation
		self.removeOnDeactivate = removeOnDeactivate
		super.init(source: source, dw: &amp;dw, context: .direct)
	}
	
	// Can't share mutex since predecessor may swap between different graphs
	fileprivate override var successorsShareMutex: Bool {
		return false
	}
	
	// If `removeOnDeactivate` is true, then deactivating this `Signal` removes it from the set
	//
	// - parameter dw: required
	fileprivate override func lastOutputDeactivatedInternal(dw: inout DeferredWork) {
		if removeOnDeactivate {
			guard let output = outputs.first, let os = output.destination.value, let ac = output.activationCount else { return }
			os.mutex.sync {
				guard os.activationCount == ac else { return }
				_ = os.removePreceedingWithoutInterruptionInternal(self, dw: &amp;dw)
			}
		}
	}
	
	// The handler is largely a passthrough but allso applies `sourceClosesOutput` logic â removing error sending signals that don't close the output.
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -&gt; (Result&lt;InputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let activated = source.delivery.isNormal
		let predecessor: Unmanaged&lt;AnyObject&gt;? = Unmanaged.passUnretained(self)
		let propagation = closePropagation
		return { [weak outputSignal, weak self] r in
			if case .failure(let e) = r, !propagation.shouldPropagateEnd(e), let os = outputSignal, let s = self {
				var dw = DeferredWork()
				os.mutex.sync {
					guard os.activationCount == ac else { return }
					_ = os.removePreceedingWithoutInterruptionInternal(s, dw: &amp;dw)
					s.multiInput.checkForLastInputRemovedInternal(signal: os, dw: &amp;dw)
				}
				dw.runWork()
			} else {
				_ = outputSignal?.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
			}
		}
	}
}

/// The `SignalMultiInput` class is used as a persistent, rebindable input to a `Signal`.
/// You can use `SignalMultiInput` as the parameter to `bind(to:)` multiple times, versus `SignalInput` for which subsequent uses after the first will have no effect.
/// When sending an error to `SignalMultiInput`, the preceeding branch of the signal graph will be disconnected but the close will not be propagated to the output signal. This is in accordance with the idea that `SignalMultiInput` is a shared interface â the `SignalMultiInput` remains until all inputs are closed and the `SignalMultiInput` itself is released.
// If you need more precise control about whether incoming signals have the ability to close the outgoing signal, use the `SignalMergedInput` subclass â the default behavior of `SignalMergedInput` is to propgate "unexpected" errors (non-`SignalComplete` errors).
/// Another difference is that a `SignalInput` is invalidated when the graph deactivates whereas `SignalMultiInput` remains valid.
class SignalMultiInput&lt;InputValue&gt;: SignalInput&lt;InputValue&gt; {
	// Constructs a `SignalMergedInput` (typically called from `Signal&lt;InputValue&gt;.createMergedInput`)
	//
	// - Parameter signal: the destination `Signal`
	fileprivate init(signal: Signal&lt;InputValue&gt;) {
		super.init(signal: signal, activationCount: 0)
	}
	
	/// Connect a new predecessor to the `Signal`
	///
	/// - Parameters:
	///   - source: the `Signal` to connect as a new predecessor
	///   - closePropagation: behavior to use when `source` sends an error. See `SignalEndPropagation` for more.
	///   - removeOnDeactivate: if true, then when the output is deactivated, this source will be removed from the merge set. If false, then the source will remain connected through deactivation.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func add&lt;U: SignalInterface&gt;(_ source: U) where U.OutputValue == InputValue {
		self.add(source, closePropagation: .none)
	}
	
	// See the comments on the override in `SignalMergedInput`
	fileprivate func add&lt;U: SignalInterface&gt;(_ source: U, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false) where U.OutputValue == InputValue {
		guard let sig = signal else { return }
		let processor = source.signal.attach { (s, dw) -&gt; SignalMultiInputProcessor&lt;InputValue&gt; in
			SignalMultiInputProcessor&lt;InputValue&gt;(source: s, multiInput: self, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate, dw: &amp;dw)
		}
		var dw = DeferredWork()
		sig.mutex.sync {
			// This can't be `duplicate` since this a a new processor but `loop` is a precondition failure
			try! sig.addPreceedingInternal(processor, param: nil, dw: &amp;dw)
		}
		dw.runWork()
	}
	
	private func remove(mp: SignalMultiInputProcessor&lt;InputValue&gt;, from sig: Signal&lt;InputValue&gt;) -&gt; Bool {
		var dw = DeferredWork()
		let result = sig.mutex.sync { () -&gt; Bool in
			let r = sig.removePreceedingWithoutInterruptionInternal(mp, dw: &amp;dw)
			checkForLastInputRemovedInternal(signal: sig, dw: &amp;dw)
			return r
		}
		dw.runWork()
		return result
	}
	
	/// Removes a predecessor from the merge set
	///
	/// NOTE: if the predecessor is a `SignalMulti` with multiple connections to the merge set, only the first match will be removed.
	///
	/// - Parameter source: the predecessor to remove
	final func remove&lt;U: SignalInterface&gt;(_ source: U) where U.OutputValue == InputValue {
		guard let targetSignal = signal else { return }
		
		let sourceSignal = source.signal
		if let multi = sourceSignal as? SignalMulti&lt;InputValue&gt; {
			let signals = multi.preceeding.first!.base.outputSignals(ofType: InputValue.self)
			let mergeProcessors = signals.compactMap { s in
				s.mutex.sync { s.signalHandler as? SignalMultiInputProcessor&lt;InputValue&gt; }
			}
			for mp in mergeProcessors {
				if remove(mp: mp, from: targetSignal) {
					break
				}
			}
		} else {
			if let mp = sourceSignal.mutex.sync(execute: { sourceSignal.signalHandler as? SignalMultiInputProcessor&lt;InputValue&gt; }) {
				_ = remove(mp: mp, from: targetSignal)
			}
		}
	}
	
	// Overridden by SignalMergeSet to send an error immediately upon last input removed
	fileprivate func checkForLastInputRemovedInternal(signal: Signal&lt;InputValue&gt;, dw: inout DeferredWork) {
	}
	
	/// Connects a new `SignalInput&lt;InputValue&gt;` to `self`. A single input may be faster than a multi-input over multiple `send` operations.
	override func singleInput() -&gt; SignalInput&lt;InputValue&gt; {
		let (input, signal) = Signal&lt;InputValue&gt;.create()
		self.add(signal)
		return input
	}
	
	/// The primary signal sending function
	///
	/// NOTE: on `SignalMultiInput` this is a relatively low performance convenience method; it calls `singleInput()` on each send. If you plan to send multiple results, it is more efficient to call `singleInput()`, retain the `SignalInput` that creates and call `SignalInput` on that single input.
	///
	/// - Parameter result: the value or error to send, composed as a `Result`
	/// - Returns: `nil` on success. Non-`nil` values include `SignalSendError.disconnected` if the `predecessor` or `activationCount` fail to match, `SignalSendError.inactive` if the current `delivery` state is `.disabled`.
	final override func send(result: Result&lt;InputValue, SignalEnd&gt;) -&gt; SignalSendError? {
		return singleInput().send(result: result)
	}
	
	/// Implementation of `Lifetime` removes all inputs and sends a `SignalComplete.cancelled` to the destination.
	final override func cancel() {
		guard let sig = signal else { return }
		var dw = DeferredWork()
		sig.mutex.sync {
			sig.removeAllPreceedingInternal(dw: &amp;dw)
			sig.pushInternal(values: [], end: SignalEnd.cancelled, activated: true, dw: &amp;dw)
		}
		dw.runWork()
	}
}

/// A SignalMergeSet is a very similar to a SignalMultiInput but offering additional customization as expected by common transformations. The reason why this customization is not offered directly on `SignalMultiInput` is that these are behavior customizations you don't generally want to expose in an interface.
///
/// In particular:
///	* The SignalMergeSet can be configured to send a specific Error (e.g. SignalEnd.complete) when the last input is removed. This is helpful when merging a specific set of inputs and running until they're all complete.
///	* The SignalMergeSet can be configured to send a specific Error on deinit (i.e. when there are no inputs and the class is not otherwise retained). SignalMultiInput sends a `.cancelled` in this scenario but SignalMergeSet sends a `.closed` and can be configured to send something else as desired.
///	* A SignalMultiInput rejects all attempts to send errors through it (closes, cancels, or otherwise) and merely disconnects the input that sent the error. A SignalMergeSet can be configured to similar reject all (`.none`) or it can permit all (`.all`), or permit only non-close errors (`.errors`). The latter is the *default* for SignalMultiInput (except when using `singleInput` which keeps the `.none` behavior). This default marks a difference in behavior, relative to SignalMultiInput, which always uses `.none`.
/// Exposing `SignalMergedInput` in an interface is not particularly common. It is typically used for internal subgraphs where specific control is required.
///
/// WARNING: `SignalMergedInput` changes the default `SignalEndPropagation` behavior from `.none` to `.errors`. This is because `SignalMergedInput` is primarily used for implementing transformations like `flatMap` which expect this type of propagation.
class SignalMergedInput&lt;InputValue&gt;: SignalMultiInput&lt;InputValue&gt; {
	fileprivate let onLastInputClosed: SignalEnd?
	fileprivate let onDeinit: SignalEnd
	
	fileprivate init(signal: Signal&lt;InputValue&gt;, onLastInputClosed: SignalEnd? = nil, onDeinit: SignalEnd = .cancelled) {
		self.onLastInputClosed = onLastInputClosed
		self.onDeinit = onDeinit
		super.init(signal: signal)
	}
	
	/// Changes the default closePropagation to `.all`
	override func add&lt;U: SignalInterface&gt;(_ source: U) where U.OutputValue == InputValue {
		self.add(source, closePropagation: .errors, removeOnDeactivate: false)
	}
	
	fileprivate override func checkForLastInputRemovedInternal(signal sig: Signal&lt;InputValue&gt;, dw: inout DeferredWork) {
		if sig.preceeding.count == 0, let e = onLastInputClosed {
			sig.pushInternal(values: [], end: e, activated: true, dw: &amp;dw)
		}
	}
	
	/// Connect a new predecessor to the `Signal`
	///
	/// - Parameters:
	///   - source: the `Signal` to connect as a new predecessor
	///   - closePropagation: behavior to use when `source` sends an error. See `SignalEndPropagation` for more.
	///   - removeOnDeactivate: f true, then when the output is deactivated, this source will be removed from the merge set. If false, then the source will remain connected through deactivation.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	override func add&lt;U: SignalInterface&gt;(_ source: U, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false) where U.OutputValue == InputValue {
		super.add(source, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
	}
	
	/// Creates a new `SignalInput`/`Signal` pair, immediately adds the `Signal` to this `SignalMergedInput` and returns the `SignalInput`.
	///
	/// - Parameters:
	///   - closePropagation: passed to `add(_:closePropagation:removeOnDeactivate:) internally
	///   - removeOnDeactivate: passed to `add(_:closePropagation:removeOnDeactivate:) internally
	/// - Returns: the `SignalInput` that will now feed into this `SignalMergedInput`.
	final func singleInput(closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false) -&gt; SignalInput&lt;InputValue&gt; {
		let (input, signal) = Signal&lt;InputValue&gt;.create()
		self.add(signal, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
		return input
	}
	
	/// Connects a new `SignalInput&lt;InputValue&gt;` to `self`. A single input may be faster than a multi-input over multiple `send` operations.
	override func singleInput() -&gt; SignalInput&lt;InputValue&gt; {
		let (input, signal) = Signal&lt;InputValue&gt;.create()
		self.add(signal, closePropagation: .none, removeOnDeactivate: false)
		return input
	}
	
	// SignalMergeSet suppresses the standard cancel on deinit behavior in favor of sending its own chosen error.
	fileprivate override func cancelOnDeinit() {
		guard let sig = signal else { return }
		var dw = DeferredWork()
		sig.mutex.sync {
			sig.pushInternal(values: [], end: onDeinit, activated: true, dw: &amp;dw)
		}
		dw.runWork()
	}
}

/// The primary "exit point" for a signal graph. `SignalOutput` provides two important functions:
///	1. a `handler` function which receives signal values and errors
///	2. upon connecting to the graph, `SignalOutput` "activates" the signal graph (which allows sending through the graph to occur and may trigger some "on activation" behavior).
/// This class is instantiated by calling `subscribe` on any `Signal`.
final class SignalOutput&lt;OutputValue&gt;: SignalHandler&lt;OutputValue&gt;, Lifetime {
	private let userHandler: (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void
	
	/// Constructor called from `subscribe`
	///
	/// - Parameters:
	///   - signal: the source signal
	///   - dw: required
	///   - context: where `handler` will be run
	///   - handler: invoked when a new signal is received
	fileprivate init(source: Signal&lt;OutputValue&gt;, dw: inout DeferredWork, context: Exec, handler: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void) {
		self.userHandler = context.isImmediateNonDirect ? { a in context.invokeSync { handler(a) } } : handler
		super.init(source: source, dw: &amp;dw, context: context)
	}
	
	// Can't have an `output` so this intial handler is the *only* handler
	// - Returns: a function to use as the handler prior to activation
	fileprivate override func initialHandlerInternal() -&gt; (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void {
		assert(source.mutex.unbalancedTryLock() == false)
		return { [userHandler] r in
			userHandler(r)
		}
	}
	
	// A `SignalOutput` is active until closed (receives a `failure` signal)
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(source.mutex.unbalancedTryLock() == false)
		return true
	}
	
	/// A simple test for whether this output has received an error, yet. Not generally needed (responding to state changes is best done through the handler function itself).
	var isClosed: Bool {
		return sync { source.delivery.isDisabled }
	}
	
	/// Implementatation of `Lifetime` forces deactivation
	func cancel() {
		var dw = DeferredWork()
		sync { if !source.delivery.isDisabled { deactivateInternal(dueToLackOfOutputs: false, dw: &amp;dw) } }
		dw.runWork()
	}
	
	// This is likely redundant but it's required by `Lifetime`
	deinit {
		cancel()
	}
}

@available(*, deprecated, message:"Renamed to SignalOutput")
typealias SignalEndpoint&lt;T&gt; = SignalOutput&lt;T&gt;

/// Reflects the activation state of a `Signal`
/// - normal: Signal will deliver results according to the default behavior of the processing context
/// - disabled: Signal is closed or otherwise inactive. Attempts to send new sseiignals will have no effect. context
/// - synchronous: Signal will attempt to deliver the first `Int` results in the queue synchronously. Results received from synchronous predecessors prior to the completion of activation will be inserted in the queue at the `Int` index and the `Int` value increased. Results received from predecessors with other states will be appended at the end of the queue. context
fileprivate enum SignalDelivery {
	case normal
	case disabled
	case synchronous(Int)
	
	var isDisabled: Bool { if case .disabled = self { return true } else { return false } }
	var isSynchronous: Bool { if case .synchronous = self { return true } else { return false } }
	var isNormal: Bool { if case .normal = self { return true } else { return false } }
}

@available(*, unavailable, message: "SignalEnd[.closed|.cancelled], SignalSendError[.disconnected|.inactive] or SignalReactiveError.timeout instead")
typealias SignalError = SignalEnd

@available(*, unavailable, message: "SignalEnd instead")
typealias SignalComplete = SignalEnd

/// An enum used to represent the two "expected" end-of-stream cases.
///
/// - complete:  indicates the end-of-stream was reached by calling close
/// - cancelled: indicates the end-of-stream was reached because an input was disconnected or cancelled
///
/// There may be rare cases where `.cancelled` indicates a scenario you might want to handle specially but for all handling within the CwlSignal framework, these two are treated identically â this is expected to be the common situation in user code. There are situations where `.cancelled` may indicate programmer error (i.e. failure to retain `SignalInput` correctly) so distinguishing between the two may be important for debugging.
///
/// NOTE: SignalEnd conforms to `Equatable` but this comparison merely matches cases on this enum (any two errors will compare "equal").
///
/// See also: `isSignalComplete` on `Error` and `Result&lt;T, SignalEnd&gt;` for easily testing if a given `Error` or `Result` contains a `SignalComplete`.
enum SignalEnd: Error, Equatable {
	case complete
	case cancelled
	case other(Error)
	
	var isOther: Bool {
		if case .other = self { return true } else { return false }
	}
	var isComplete: Bool {
		if case .complete = self { return true } else { return false }
	}
	var isCancelled: Bool {
		if case .cancelled = self { return true } else { return false }
	}
	var otherError: Error? {
		if case .other(let e) = self { return e } else { return nil }
	}
	
	static func == (lhs: SignalEnd, rhs: SignalEnd) -&gt; Bool {
		switch (lhs, rhs) {
		case (.complete, .complete): return true
		case (.cancelled, .cancelled): return true
		case (.other, .other): return true
		default: return false
		}
	}
}

/// For `capture`, it is possible to resend any captured values on resume. This type describe the ways which this can be done.
///
/// NOTE: this applies to captured *values*. Any captured `SignalEnd` will always be emitted in the same manner as the previous value.
///
/// - all: all values are resent as "activation values (exactly as they were captured)
/// - deferred: all values are resent as "normal" values (not activation values)
/// - first: the first captured value is sent as an "activation" value but the remainder are send as "normal" values
/// - last: all except the last captured value is dropped and the last value is emitted as an "activation" value
/// - none: no captured values are emitted
enum SignalActivationSelection {
	case all
	case deferred
	case first
	case last
	case none
}

/// Possible send-failure return results when sending to a `SignalInput`. This type is used as a discardable return type so it does not need to conform to Swift.Error.
///
/// - disconnected:  the signal input has been disconnected from its target signal
/// - inactive:  the signal graph is not activated (no outputs in the graph) and the Result was not sent
enum SignalSendError {
	case disconnected
	case inactive
}

/// Attempts to bind a `SignalInput` to a bindable handler (`SignalMergeSet`, `SignalJunction` or `SignalCapture`) can fail in two different ways.
/// - cancelled: the destination `SignalInput`/`SignalMergeSet` was no longer the active input for its `Signal` (either its `Signal` is joined to something else or `Signal` has been deactivated, invalidating old inputs)
/// - duplicate(`SignalInput&lt;OutputValue&gt;`): the source `Signal` already had an output connected and doesn't support multiple outputs so the bind failed. If the bind destination was a single `SignalInput` then that `SignalInput` was consumed by the attempt so the associated value will be a new `SignalInput` replacing the old one.
enum SignalBindError&lt;OutputValue&gt;: Error {
	case cancelled
	case loop
	case duplicate(SignalInput&lt;OutputValue&gt;?)
}

/// Used by the Signal&lt;OutputValue&gt;.combine(second:context:handler:) method
enum EitherResult2&lt;U, V&gt; {
	case result1(Signal&lt;U&gt;.Result)
	case result2(Signal&lt;V&gt;.Result)
}

/// Used by the Signal&lt;OutputValue&gt;.combine(second:third:context:handler:) method
enum EitherResult3&lt;U, V, W&gt; {
	case result1(Signal&lt;U&gt;.Result)
	case result2(Signal&lt;V&gt;.Result)
	case result3(Signal&lt;W&gt;.Result)
}

/// Used by the Signal&lt;OutputValue&gt;.combine(second:third:fourth:context:handler:) method
enum EitherResult4&lt;U, V, W, X&gt; {
	case result1(Signal&lt;U&gt;.Result)
	case result2(Signal&lt;V&gt;.Result)
	case result3(Signal&lt;W&gt;.Result)
	case result4(Signal&lt;X&gt;.Result)
}

/// Used by the Signal&lt;OutputValue&gt;.combine(second:third:fourth:fifth:context:handler:) method
enum EitherResult5&lt;U, V, W, X, Y&gt; {
	case result1(Signal&lt;U&gt;.Result)
	case result2(Signal&lt;V&gt;.Result)
	case result3(Signal&lt;W&gt;.Result)
	case result4(Signal&lt;X&gt;.Result)
	case result5(Signal&lt;Y&gt;.Result)
}


import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

/// A `SignalChannel` forms a basic wrapper around a `SignalInput`/`Signal` pair and exists for syntactic convenience when building a series of pipeline stages and returning the head and tail of the pipeline.
///
/// e.g.: let (input, output) = Signal&lt;Int&gt;.channel().map { $0 + 1 }.subscribe { print($0) }
///
/// Every transform in the CwlSignal library that can be applied to `Signal&lt;Interface.OutputValue&gt;` can also be applied to `SignalChannel&lt;Interface.OutputValue&gt;`. Where possible, the result is another `SignalChannel` so the result can be immediately transformed again.
struct SignalChannel&lt;InputInterface: SignalInputInterface, Interface: SignalInterface&gt; {
	let input: InputInterface
	let signal: Interface
	init(input: InputInterface, signal: Interface) { (self.input, self.signal) = (input, signal) }
}

extension SignalChannel {
	/// Append an additional `Signal` stage in the `SignalChannel` pipeline, returning a new SignalChannel that combines the `input` from `self` and the `signal` from the new stage.
	///
	/// - Parameter compose: a transformation that takes `signal` from `self` and returns a new `Signal`.
	/// - Returns: a `SignalChannel` combining `input` and the result from `compose`.
	/// - Throws: rethrows the contents of the `compose` closure.
	func next&lt;Next&gt;(_ compose: (Signal&lt;Interface.OutputValue&gt;) throws -&gt; Next) rethrows -&gt; SignalChannel&lt;InputInterface, Next&gt; {
		return try SignalChannel&lt;InputInterface, Next&gt;(input: input, signal: compose(signal.signal))
	}
	
	/// Similar to `next` but producing a new stage that is *not* a `Signal` and returning `input` and this new stage as a tuple.
	///
	/// - Parameter compose: a transformation that takes `signal` from `self` and returns a new value.
	/// - Returns: a tuple combining `input` and the result from `compose`.
	/// - Throws: rethrows the contents of the `compose` closure.
	func final&lt;U&gt;(_ compose: (Signal&lt;Interface.OutputValue&gt;) throws -&gt; U) rethrows -&gt; (input: InputInterface, output: U) {
		return try (input, compose(signal.signal))
	}
	
	/// Similar to `next` but consuming (not returning) the result from the `compose` function. The result is simply `input` from `self`. Typically used when `bind(to:)` is invoked, linking the output of this channel to another signal graph.
	///
	/// - Parameter compose: a transformation that takes `signal` from `self` and returns `Void`.
	/// - Returns: `input` from `self`
	/// - Throws: rethrows the contents of the `compose` closure.
	func consume(_ compose: (Signal&lt;Interface.OutputValue&gt;) throws -&gt; ()) rethrows -&gt; InputInterface {
		try compose(signal.signal)
		return input
	}
	
	/// A `SignalChannel` is essentially a tuple. This property explodes the contents as a convenience in some scenarios.
	var tuple: (input: InputInterface, signal: Interface) { return (input: input, signal: signal) }
}

typealias Input&lt;Value&gt; = SignalChannel&lt;SignalInput&lt;Value&gt;, Signal&lt;Value&gt;&gt;
typealias MultiInput&lt;Value&gt; = SignalChannel&lt;SignalMultiInput&lt;Value&gt;, Signal&lt;Value&gt;&gt;
typealias MergedInput&lt;Value&gt; = SignalChannel&lt;SignalMergedInput&lt;Value&gt;, Signal&lt;Value&gt;&gt;

typealias MultiOutput&lt;Value&gt; = SignalChannel&lt;SignalInput&lt;Value&gt;, SignalMulti&lt;Value&gt;&gt;
typealias MultiInputMultiOutput&lt;Value&gt; = SignalChannel&lt;SignalMultiInput&lt;Value&gt;, SignalMulti&lt;Value&gt;&gt;
typealias MergedInputMultiOutput&lt;Value&gt; = SignalChannel&lt;SignalMergedInput&lt;Value&gt;, SignalMulti&lt;Value&gt;&gt;

extension SignalChannel { 
	init&lt;Value&gt;() where SignalInput&lt;Value&gt; == InputInterface, Signal&lt;Value&gt; == Interface {
		self = Signal&lt;Value&gt;.channel()
	}
	init&lt;Value&gt;() where SignalMultiInput&lt;Value&gt; == InputInterface, Signal&lt;Value&gt; == Interface {
		self = Signal&lt;Value&gt;.multiChannel()
	}
	init&lt;Value&gt;() where SignalMergedInput&lt;Value&gt; == InputInterface, Signal&lt;Value&gt; == Interface {
		self = Signal&lt;Value&gt;.mergedChannel()
	}
}

extension Signal {
	/// This function is used for starting SignalChannel pipelines with a `SignalInput`
	static func channel() -&gt; SignalChannel&lt;SignalInput&lt;OutputValue&gt;, Signal&lt;OutputValue&gt;&gt; {
		let (input, signal) = Signal&lt;OutputValue&gt;.create()
		return SignalChannel&lt;SignalInput&lt;OutputValue&gt;, Signal&lt;OutputValue&gt;&gt;(input: input, signal: signal)
	}
	
	/// This function is used for starting SignalChannel pipelines with a `SignalMultiInput`
	static func multiChannel() -&gt; SignalChannel&lt;SignalMultiInput&lt;OutputValue&gt;, Signal&lt;OutputValue&gt;&gt; {
		let (input, signal) = Signal&lt;OutputValue&gt;.createMultiInput()
		return SignalChannel&lt;SignalMultiInput&lt;OutputValue&gt;, Signal&lt;OutputValue&gt;&gt;(input: input, signal: signal)
	}
	
	/// This function is used for starting SignalChannel pipelines with a `SignalMergedInput`
	static func mergedChannel(onLastInputClosed: SignalEnd? = nil, onDeinit: SignalEnd = .cancelled) -&gt; SignalChannel&lt;SignalMergedInput&lt;OutputValue&gt;, Signal&lt;OutputValue&gt;&gt; {
		let (input, signal) = Signal&lt;OutputValue&gt;.createMergedInput(onLastInputClosed: onLastInputClosed, onDeinit: onDeinit)
		return SignalChannel&lt;SignalMergedInput&lt;OutputValue&gt;, Signal&lt;OutputValue&gt;&gt;(input: input, signal: signal)
	}
}

// Implementation of Signal.swift
extension SignalChannel {
	func subscribe(context: Exec = .direct, _ handler: @escaping (Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Void) -&gt; (input: InputInterface, output: SignalOutput&lt;Interface.OutputValue&gt;) {
		let tuple = final { $0.subscribe(context: context, handler) }
		return (input: tuple.input, output: tuple.output)
	}
	
	func subscribeWhile(context: Exec = .direct, _ handler: @escaping (Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Bool) -&gt; InputInterface {
		return final { $0.subscribeWhile(context: context, handler) }.input
	}
	
	func junction() -&gt; (input: InputInterface, junction: SignalJunction&lt;Interface.OutputValue&gt;) {
		let tuple = final { $0.junction() }
		return (input: tuple.input, junction: tuple.output)
	}
	
	func transform&lt;U&gt;(context: Exec = .direct, _ processor: @escaping (Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.transform(context: context, processor) }
	}
	
	func transformActivation&lt;U&gt;(context: Exec = .direct, activation: @escaping (Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next, _ processor: @escaping (Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.transformActivation(context: context, activation: activation, processor) }
	}
	
	func transform&lt;S, U&gt;(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.transform(initialState: initialState, context: context, processor) }
	}
	
	func combine&lt;U: SignalInterface, V&gt;(_ second: U, context: Exec = .direct, _ processor: @escaping (EitherResult2&lt;Interface.OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;V&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;V&gt;&gt; {
		return next { $0.combine(second, context: context, processor) }
	}
	
	func combine&lt;U: SignalInterface, V: SignalInterface, W&gt;(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (EitherResult3&lt;Interface.OutputValue, U.OutputValue, V.OutputValue&gt;) -&gt; Signal&lt;W&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;W&gt;&gt; {
		return next { $0.combine(second, third, context: context, processor) }
	}
	
	func combine&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (EitherResult4&lt;Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;) -&gt; Signal&lt;X&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;X&gt;&gt; {
		return next { $0.combine(second, third, fourth, context: context, processor) }
	}
	
	func combine&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (EitherResult5&lt;Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;) -&gt; Signal&lt;Y&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Y&gt;&gt; {
		return next { $0.combine(second, third, fourth, fifth, context: context, processor) }
	}
	
	func combine&lt;S, U: SignalInterface, V&gt;(initialState: S, _ second: U, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult2&lt;Interface.OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;V&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;V&gt;&gt; {
		return next { $0.combine(second, initialState: initialState, context: context, processor) }
	}
	
	func combine&lt;S, U: SignalInterface, V: SignalInterface, W&gt;(initialState: S, _ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult3&lt;Interface.OutputValue, U.OutputValue, V.OutputValue&gt;) -&gt; Signal&lt;W&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;W&gt;&gt; {
		return next { $0.combine(second, third, initialState: initialState, context: context, processor) }
	}
	
	func combine&lt;S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(initialState: S, _ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult4&lt;Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;) -&gt; Signal&lt;X&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;X&gt;&gt; {
		return next { $0.combine(second, third, fourth, initialState: initialState, context: context, processor) }
	}
	
	func combine&lt;S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(initialState: S, _ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult5&lt;Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;) -&gt; Signal&lt;Y&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Y&gt;&gt; {
		return next { $0.combine(second, third, fourth, fifth, initialState: initialState, context: context, processor) }
	}
	
	func continuous(initialValue: Interface.OutputValue) -&gt; SignalChannel&lt;InputInterface, SignalMulti&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.continuous(initialValue: initialValue) }
	}
	
	func continuous() -&gt; SignalChannel&lt;InputInterface, SignalMulti&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.continuous() }
	}
	
	func continuousWhileActive() -&gt; SignalChannel&lt;InputInterface, SignalMulti&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.continuousWhileActive() }
	}
	
	func playback() -&gt; SignalChannel&lt;InputInterface, SignalMulti&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.playback() }
	}
	
	func cacheUntilActive() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.cacheUntilActive() }
	}
	
	func multicast() -&gt; SignalChannel&lt;InputInterface, SignalMulti&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.multicast() }
	}
	
	func multicast(sequence: [SignalInput&lt;Interface.OutputValue&gt;]) -&gt; InputInterface {
		return final {
			let multi = $0.multicast()
			for i in sequence {
				multi.bind(to: i)
			}
		}.input
	}
	
	func multicast(_ interfaces: SignalInput&lt;Interface.OutputValue&gt;...) -&gt; InputInterface {
		return multicast(sequence: interfaces)
	}
	
	func customActivation(initialValues: Array&lt;Interface.OutputValue&gt; = [], context: Exec = .direct, _ updater: @escaping (_ cachedValues: inout Array&lt;Interface.OutputValue&gt;, _ cachedEnd: inout SignalEnd?, _ incoming: Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Void) -&gt; SignalChannel&lt;InputInterface, SignalMulti&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.customActivation(initialValues: initialValues, context: context, updater) }
	}
	
	func reduce&lt;State&gt;(initialState: State, context: Exec = .direct, _ reducer: @escaping (_ state: State, _ message: Interface.OutputValue) throws -&gt; State) -&gt; SignalChannel&lt;InputInterface, SignalMulti&lt;State&gt;&gt; {
		return next { $0.reduce(initialState: initialState, context: context, reducer) }
	}
	
	func capture() -&gt; (input: InputInterface, capture: SignalCapture&lt;Interface.OutputValue&gt;) {
		let tuple = final { $0.capture() }
		return (input: tuple.input, capture: tuple.output)
	}
}

// Implementation of SignalExtensions.swift
extension SignalChannel {
	func dropActivation() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.dropActivation() }
	}
	
	func deferActivation() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.deferActivation() }
	}
	
	func subscribeUntilEnd(context: Exec = .direct, _ handler: @escaping (Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Void) -&gt; InputInterface {
		return final { $0.subscribeUntilEnd(context: context, handler) }.input
	}
	
	func subscribeValues(context: Exec = .direct, _ handler: @escaping (Interface.OutputValue) -&gt; Void) -&gt; (input: InputInterface, output: SignalOutput&lt;Interface.OutputValue&gt;) {
		let tuple = final { $0.subscribeValues(context: context, handler) }
		return (input: tuple.input, output: tuple.output)
	}
	
	func subscribeValuesUntilEnd(context: Exec = .direct, _ handler: @escaping (Interface.OutputValue) -&gt; Void) -&gt; InputInterface {
		signal.subscribeValuesUntilEnd(context: context, handler)
		return input
	}
	
	func subscribeValuesWhile(context: Exec = .direct, _ handler: @escaping (Interface.OutputValue) -&gt; Bool) -&gt; InputInterface {
		signal.subscribeValuesWhile(context: context, handler)
		return input
	}
	
	func stride(count: Int, initialSkip: Int = 0) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.stride(count: count, initialSkip: initialSkip) }
	}
	
	func transformValues&lt;U&gt;(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) -&gt; Signal&lt;U&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.transformValues(context: context, processor) }
	}

	func transformValues&lt;S, U&gt;(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Interface.OutputValue) -&gt; Signal&lt;U&gt;.Next) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.transformValues(initialState: initialState, context: context, processor) }
	}
	
	func transformFlatten&lt;U&gt;(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, SignalMergedInput&lt;U&gt;) -&gt; ()) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.transformFlatten(closePropagation: closePropagation, context: context, processor) }
	}
	
	func transformFlatten&lt;S, U&gt;(initialState: S, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ processor: @escaping (inout S, Interface.OutputValue, SignalMergedInput&lt;U&gt;) -&gt; ()) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.transformFlatten(initialState: initialState, closePropagation: closePropagation, context: context, processor) }
	}
	
	func valueDurations&lt;DurationInterface: SignalInterface&gt;(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ duration: @escaping (Interface.OutputValue) -&gt; DurationInterface) -&gt; SignalChannel&lt;InputInterface, Signal&lt;(Int, Interface.OutputValue?)&gt;&gt; {
		return next { $0.valueDurations(closePropagation: closePropagation, context: context, duration) }
	}
	
	func valueDurations&lt;DurationInterface: SignalInterface, V&gt;(initialState: V, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ duration: @escaping (inout V, Interface.OutputValue) -&gt; DurationInterface) -&gt; SignalChannel&lt;InputInterface, Signal&lt;(Int, Interface.OutputValue?)&gt;&gt; {
		return next { $0.valueDurations(initialState: initialState, closePropagation: closePropagation, context: context, duration) }
	}
	
	func toggle(initialState: Bool = false) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Bool&gt;&gt; {
		return next { $0.toggle(initialState: initialState) }
	}
	
	func optional() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue?&gt;&gt; {
		return next { $0.optional() }
	}
	
	func optionalToArray&lt;U&gt;() -&gt; SignalChannel&lt;InputInterface, Signal&lt;[U]&gt;&gt; where Interface.OutputValue == Optional&lt;U&gt; {
		return next { $0.optionalToArray() }
	}
	
	func bind&lt;Target&gt;(to interface: Target) -&gt; InputInterface where Target: SignalInputInterface, Target.InputValue == Interface.OutputValue {
		return final { $0.bind(to: interface) }.input
	}
	
	func bind(to: SignalMergedInput&lt;Interface.OutputValue&gt;, closePropagation: SignalEndPropagation = .none, removeOnDeactivate: Bool = false) -&gt; InputInterface {
		signal.signal.bind(to: to, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
		return input
	}

	func flatMapBind&lt;Output: SignalInterface, Input: SignalInputInterface&gt;(to interface: Output, _ transform: @escaping (Output.OutputValue) -&gt; Input) -&gt; InputInterface where Input.InputValue == Interface.OutputValue {
		return final { $0.flatMapBind(to: interface, transform) }.input
	}
	
	
	func cacheLatest() -&gt; (input: InputInterface, output: SignalLatest&lt;Interface.OutputValue&gt;) {
		let tuple = final { SignalLatest(signal: $0) }
		return (input: tuple.input, output: tuple.output)
	}
}

// Implementation of SignalReactive.swift
extension SignalChannel {
	func buffer&lt;Boundaries: SignalInterface&gt;(boundaries: Boundaries) -&gt; SignalChannel&lt;InputInterface, Signal&lt;[Interface.OutputValue]&gt;&gt; {
		return next { $0.buffer(boundaries: boundaries) }
	}
	
	func buffer&lt;Boundaries: SignalInterface&gt;(windows: Boundaries) -&gt; SignalChannel&lt;InputInterface, Signal&lt;[Interface.OutputValue]&gt;&gt; where Boundaries.OutputValue: SignalInterface {
		return next { $0.buffer(windows: windows) }
	}
	
	func buffer(count: UInt, skip: UInt) -&gt; SignalChannel&lt;InputInterface, Signal&lt;[Interface.OutputValue]&gt;&gt; {
		return next { $0.buffer(count: count, skip: skip) }
	}
	
	func buffer(interval: DispatchTimeInterval, count: Int = Int.max, continuous: Bool = true, context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;[Interface.OutputValue]&gt;&gt; {
		return next { $0.buffer(interval: interval, count: count, continuous: continuous, context: context) }
	}
	
	func buffer(count: UInt) -&gt; SignalChannel&lt;InputInterface, Signal&lt;[Interface.OutputValue]&gt;&gt; {
		return next { $0.buffer(count: count, skip: count) }
	}
	
	func buffer(interval: DispatchTimeInterval, timeshift: DispatchTimeInterval, context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;[Interface.OutputValue]&gt;&gt; {
		return next { $0.buffer(interval: interval, timeshift: timeshift, context: context) }
	}
	
	func compact&lt;U&gt;() -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; where Interface.OutputValue == Optional&lt;U&gt; {
		return next { $0.compact() }
	}
		
	func compactMap&lt;U&gt;(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -&gt; U?) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.compactMap(context: context, processor) }
	}
	
	func compactMap&lt;S, U&gt;(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Interface.OutputValue) throws -&gt; U?) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.compactMap(initialState: initialState, context: context, processor) }
	}

	func compactMapActivation&lt;U&gt;(select: SignalActivationSelection, context: Exec = .direct, activation: @escaping (Interface.OutputValue) throws -&gt; U?, remainder: @escaping (Interface.OutputValue) throws -&gt; U?) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.compactMapActivation(select: select, context: context, activation: activation, remainder: remainder) }
	}
	
	func compactMapActivation(select: SignalActivationSelection, context: Exec = .direct, activation: @escaping (Interface.OutputValue) throws -&gt; Interface.OutputValue?) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.compactMapActivation(select: select, context: context, activation: activation) }
	}
	
	func flatten&lt;V&gt;() -&gt; SignalChannel&lt;InputInterface, Signal&lt;V&gt;&gt; where Interface.OutputValue: SignalInterface, Interface.OutputValue.OutputValue == V {
		return next { $0.flatten() }
	}
	
	func flatMap&lt;Content: SignalInterface&gt;(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -&gt; Content) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Content.OutputValue&gt;&gt; {
		return next { $0.flatMap(context: context, processor) }
	}
	
	func flatMapFirst&lt;Content: SignalInterface&gt;(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -&gt; Content) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Content.OutputValue&gt;&gt; {
		return next { $0.flatMapFirst(context: context, processor) }
	}
	
	func flatMapLatest&lt;Content: SignalInterface&gt;(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -&gt; Content) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Content.OutputValue&gt;&gt; {
		return next { $0.flatMapLatest(context: context, processor) }
	}
	
	func flatMap&lt;Content: SignalInterface, V&gt;(initialState: V, context: Exec = .direct, _ processor: @escaping (inout V, Interface.OutputValue) throws -&gt; Content) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Content.OutputValue&gt;&gt; {
		return next { $0.flatMap(initialState: initialState, context: context, processor) }
	}
	
	func concatMap&lt;Content: SignalInterface&gt;(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -&gt; Content) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Content.OutputValue&gt;&gt; {
		return next { $0.concatMap(context: context, processor) }
	}
	
	func groupBy&lt;U: Hashable&gt;(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -&gt; U) -&gt; SignalChannel&lt;InputInterface, Signal&lt;(U, Signal&lt;Interface.OutputValue&gt;)&gt;&gt; {
		return next { $0.groupBy(context: context, processor) }
	}
	
	func mapErrors(context: Exec = .direct, _ processor: @escaping (SignalEnd) -&gt; SignalEnd) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.mapErrors(context: context, processor) }
	}
	
	func keyPath&lt;U&gt;(_ keyPath: KeyPath&lt;Interface.OutputValue, U&gt;) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.keyPath(keyPath) }
	}
	
	func map&lt;U&gt;(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -&gt; U) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.map(context: context, processor) }
	}
	
	func map&lt;U, V&gt;(initialState: V, context: Exec = .direct, _ processor: @escaping (inout V, Interface.OutputValue) throws -&gt; U) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.map(initialState: initialState, context: context, processor) }
	}
	
	func scan&lt;U&gt;(initialState: U, context: Exec = .direct, _ processor: @escaping (U, Interface.OutputValue) throws -&gt; U) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.scan(initialState: initialState, context: context, processor) }
	}
	
	func window&lt;Boundaries: SignalInterface&gt;(boundaries: Boundaries) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Signal&lt;Interface.OutputValue&gt;&gt;&gt; {
		return next { $0.window(boundaries: boundaries) }
	}
	
	func window&lt;Boundaries: SignalInterface&gt;(windows: Boundaries) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Signal&lt;Interface.OutputValue&gt;&gt;&gt; where Boundaries.OutputValue: SignalInterface {
		return next { $0.window(windows: windows) }
	}
	
	func window(count: UInt, skip: UInt) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Signal&lt;Interface.OutputValue&gt;&gt;&gt; {
		return next { $0.window(count: count, skip: skip) }
	}
	
	func window(interval: DispatchTimeInterval, count: Int = Int.max, continuous: Bool = true, context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Signal&lt;Interface.OutputValue&gt;&gt;&gt; {
		return next { $0.window(interval: interval, count: count, continuous: continuous, context: context) }
	}
	
	func window(count: UInt) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Signal&lt;Interface.OutputValue&gt;&gt;&gt; {
		return next { $0.window(count: count, skip: count) }
	}
	
	func window(interval: DispatchTimeInterval, timeshift: DispatchTimeInterval, context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Signal&lt;Interface.OutputValue&gt;&gt;&gt; {
		return next { $0.window(interval: interval, timeshift: timeshift, context: context) }
	}
	
	func debounce(interval: DispatchTimeInterval, flushOnClose: Bool = false, context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.debounce(interval: interval, flushOnClose: flushOnClose, context: context) }
	}
	
	func throttleFirst(interval: DispatchTimeInterval, context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.throttleFirst(interval: interval, context: context) }
	}
}

extension SignalChannel where Interface.OutputValue: Hashable {
	func distinct() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.distinct() }
	}
}

extension SignalChannel where Interface.OutputValue: Equatable {
	func distinctUntilChanged() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.distinctUntilChanged() }
	}
}

extension SignalChannel {
	func distinctUntilChanged(context: Exec = .direct, compare: @escaping (Interface.OutputValue, Interface.OutputValue) throws -&gt; Bool) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.distinctUntilChanged(context: context, compare: compare) }
	}
	
	func elementAt(_ index: UInt) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.elementAt(index) }
	}
	
	func filter(context: Exec = .direct, matching: @escaping (Interface.OutputValue) throws -&gt; Bool) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.filter(context: context, matching: matching) }
	}
	
	func ofType&lt;U&gt;(_ type: U.Type) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.ofType(type) }
	}
	
	func first(context: Exec = .direct, matching: @escaping (Interface.OutputValue) throws -&gt; Bool = { _ in true }) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.first(context: context, matching: matching) }
	}
	
	func single(context: Exec = .direct, matching: @escaping (Interface.OutputValue) throws -&gt; Bool = { _ in true }) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.single(context: context, matching: matching) }
	}
	
	func ignoreElements&lt;U&gt;(outputType: U.Type = U.self) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.ignoreElements(outputType: outputType) }
	}
	
	func last(context: Exec = .direct, matching: @escaping (Interface.OutputValue) throws -&gt; Bool = { _ in true }) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.last(context: context, matching: matching) }
	}
	
	func sample&lt;Trigger: SignalInterface&gt;(_ trigger: Trigger) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; where Trigger.OutputValue == () {
		return next { $0.sample(trigger) }
	}
	
	func throttleFirst&lt;Trigger: SignalInterface&gt;(_ trigger: Trigger) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; where Trigger.OutputValue == () {
		return next { $0.throttleFirst(trigger) }
	}
	
	func withLatestFrom&lt;Interface: SignalInterface&gt;(_ sample: Interface) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.withLatestFrom(sample) }
	}
	
	func withLatestFrom&lt;Other: SignalInterface, R&gt;(_ sample: Other, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, Other.OutputValue) throws -&gt; R) -&gt; SignalChannel&lt;InputInterface, Signal&lt;R&gt;&gt; {
		return next { $0.withLatestFrom(sample, context: context, processor) }
	}
	
	func skip(_ count: Int) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.skip(count) }
	}
	
	func skipLast(_ count: Int) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.skipLast(count) }
	}
	
	func take(_ count: Int) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.take(count) }
	}
	
	func takeLast(_ count: Int) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.takeLast(count) }
	}
	
	func combineLatestWith&lt;U: SignalInterface, V&gt;(_ second: U, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, U.OutputValue) throws -&gt; V) -&gt; SignalChannel&lt;InputInterface, Signal&lt;V&gt;&gt; {
		return next { $0.combineLatestWith(second, context: context, processor) }
	}
	
	func combineLatestWith&lt;U: SignalInterface, V: SignalInterface, W&gt;(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, U.OutputValue, V.OutputValue) throws -&gt; W) -&gt; SignalChannel&lt;InputInterface, Signal&lt;W&gt;&gt; {
		return next { $0.combineLatestWith(second, third, context: context, processor) }
	}
	
	func combineLatestWith&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue) throws -&gt; X) -&gt; SignalChannel&lt;InputInterface, Signal&lt;X&gt;&gt; {
		return next { $0.combineLatestWith(second, third, fourth, context: context, processor) }
	}
	
	func combineLatestWith&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue) throws -&gt; Y) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Y&gt;&gt; {
		return next { $0.combineLatestWith(second, third, fourth, fifth, context: context, processor) }
	}
	
	func intersect&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(withRight: U, leftEnd: @escaping (Interface.OutputValue) -&gt; V, rightEnd: @escaping (U.OutputValue) -&gt; W, context: Exec = .direct, _ processor: @escaping ((Interface.OutputValue, U.OutputValue)) -&gt; X) -&gt; SignalChannel&lt;InputInterface, Signal&lt;X&gt;&gt; {
		return next { $0.intersect(withRight: withRight, leftEnd: leftEnd, rightEnd: rightEnd, context: context, processor) }
	}
	
	func groupIntersect&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(withRight: U, leftEnd: @escaping (Interface.OutputValue) -&gt; V, rightEnd: @escaping (U.OutputValue) -&gt; W, context: Exec = .direct, _ processor: @escaping ((Interface.OutputValue, Signal&lt;U.OutputValue&gt;)) -&gt; X) -&gt; SignalChannel&lt;InputInterface, Signal&lt;X&gt;&gt; {
		return next { $0.groupIntersect(withRight: withRight, leftEnd: leftEnd, rightEnd: rightEnd, context: context, processor) }
	}
	
	func merge(_ sources: Signal&lt;Interface.OutputValue&gt;...) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.merge(sequence: sources) }
	}
	
	func merge&lt;S: Sequence&gt;(sequence: S) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; where S.Iterator.Element == Signal&lt;Interface.OutputValue&gt; {
		return next { $0.merge(sequence: sequence) }
	}
	
	func startWith&lt;S: Sequence&gt;(sequence: S) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; where S.Iterator.Element == Interface.OutputValue {
		return next { $0.startWith(sequence: sequence) }
	}
	
	func startWith(_ values: Interface.OutputValue...) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.startWith(sequence: values) }
	}
	
	func endWith&lt;U: Sequence&gt;(_ sequence: U, conditional: @escaping (SignalEnd) -&gt; SignalEnd? = { e in e }) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; where U.Iterator.Element == Interface.OutputValue {
		return next { $0.endWith(sequence: sequence, conditional: conditional) }
	}
	
	func endWith(_ values: Interface.OutputValue..., conditional: @escaping (SignalEnd) -&gt; SignalEnd? = { e in e }) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.endWith(sequence: values, conditional: conditional) }
	}
	
	func switchLatest&lt;U&gt;() -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; where Interface.OutputValue: Signal&lt;U&gt; {
		return next { $0.switchLatest() }
	}

	func zipWith&lt;U: SignalInterface&gt;(_ second: U) -&gt; SignalChannel&lt;InputInterface, Signal&lt;(Interface.OutputValue, U.OutputValue)&gt;&gt; {
		return next { $0.zipWith(second) }
	}
	
	func zipWith&lt;U: SignalInterface, V: SignalInterface&gt;(_ second: U, _ third: V) -&gt; SignalChannel&lt;InputInterface, Signal&lt;(Interface.OutputValue, U.OutputValue, V.OutputValue)&gt;&gt; {
		return next { $0.zipWith(second, third) }
	}
	
	func zipWith&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface&gt;(_ second: U, _ third: V, _ fourth: W) -&gt; SignalChannel&lt;InputInterface, Signal&lt;(Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)&gt;&gt; {
		return next { $0.zipWith(second, third, fourth) }
	}
	
	func zipWith&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X) -&gt; SignalChannel&lt;InputInterface, Signal&lt;(Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)&gt;&gt; {
		return next { $0.zipWith(second, third, fourth, fifth) }
	}
	
	func catchError(context: Exec = .direct, recover: @escaping (SignalEnd) -&gt; Signal&lt;Interface.OutputValue&gt;) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.catchError(context: context, recover: recover) }
	}
	
	func retry&lt;U&gt;(_ initialState: U, context: Exec = .direct, shouldRetry: @escaping (inout U, SignalEnd) -&gt; DispatchTimeInterval?) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.retry(initialState, context: context, shouldRetry: shouldRetry) }
	}
	
	func retry(count: Int, delayInterval: DispatchTimeInterval, context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.retry(count: count, delayInterval: delayInterval, context: context) }
	}
	
	func delay&lt;U&gt;(initialState: U, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (inout U, Interface.OutputValue) -&gt; DispatchTimeInterval) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.delay(initialState: initialState, closePropagation: closePropagation, context: context, offset: offset) }
	}
	
	func delay(interval: DispatchTimeInterval, context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.delay(interval: interval, context: context) }
	}
	
	func delay&lt;U&gt;(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (Interface.OutputValue) -&gt; Signal&lt;U&gt;) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.delay(closePropagation: closePropagation, context: context, offset: offset) }
	}
	
	func delay&lt;U, V&gt;(initialState: V, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (inout V, Interface.OutputValue) -&gt; Signal&lt;U&gt;) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.delay(initialState: initialState, closePropagation: closePropagation, context: context, offset: offset) }
	}
	
	func onActivate(context: Exec = .direct, _ handler: @escaping () -&gt; ()) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.onActivate(context: context, handler) }
	}
	
	func onDeactivate(context: Exec = .direct, _ handler: @escaping () -&gt; ()) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.onDeactivate(context: context, handler) }
	}
	
	func onResult(context: Exec = .direct, _ handler: @escaping (Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; ()) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.onResult(context: context, handler) }
	}
	
	func onValue(context: Exec = .direct, _ handler: @escaping (Interface.OutputValue) -&gt; ()) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.onValue(context: context, handler) }
	}
	
	func onError(context: Exec = .direct, _ handler: @escaping (SignalEnd) -&gt; ()) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.onError(context: context, handler) }
	}

	func debug(logPrefix: String = "", file: String = #file, line: Int = #line) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.debug(logPrefix: logPrefix, file: file, line: line) }
	}
	
	func materialize() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Result&lt;Interface.OutputValue, SignalEnd&gt;&gt;&gt; {
		return next { $0.materialize() }
	}
	
	func timeInterval(context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Double&gt;&gt; {
		return next { $0.timeInterval(context: context) }
	}
	
	func timeout(interval: DispatchTimeInterval, resetOnValue: Bool = true, context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.timeout(interval: interval, resetOnValue: resetOnValue, context: context) }
	}
	
	func timestamp(context: Exec = .direct) -&gt; SignalChannel&lt;InputInterface, Signal&lt;(Interface.OutputValue, DispatchTime)&gt;&gt; {
		return next { $0.timestamp(context: context) }
	}
	
	func all(context: Exec = .direct, test: @escaping (Interface.OutputValue) -&gt; Bool) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Bool&gt;&gt; {
		return next { $0.all(context: context, test: test) }
	}
	
	func find(context: Exec = .direct, test: @escaping (Interface.OutputValue) -&gt; Bool) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Bool&gt;&gt; {
		return next { $0.find(context: context, test: test) }
	}
	
	func findIndex(context: Exec = .direct, test: @escaping (Interface.OutputValue) -&gt; Bool) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Int?&gt;&gt; {
		return next { $0.findIndex(context: context, test: test) }
	}
}

extension SignalChannel where Interface.OutputValue: Equatable {
	func find(value: Interface.OutputValue) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Bool&gt;&gt; {
		return next { $0.find(value: value) }
	}
}

extension SignalChannel {
	func defaultIfEmpty(value: Interface.OutputValue) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.defaultIfEmpty(value: value) }
	}
	
	func switchIfEmpty(alternate: Signal&lt;Interface.OutputValue&gt;) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.switchIfEmpty(alternate: alternate) }
	}
}

extension SignalChannel where Interface.OutputValue: Equatable {
	func sequenceEqual(to: Signal&lt;Interface.OutputValue&gt;) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Bool&gt;&gt; {
		return next { $0.sequenceEqual(to: to) }
	}
}

extension SignalChannel {
	func skipUntil&lt;U: SignalInterface&gt;(_ other: U) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.skipUntil(other) }
	}
	
	func skipWhile(context: Exec = .direct, condition: @escaping (Interface.OutputValue) throws -&gt; Bool) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.skipWhile(context: context, condition: condition) }
	}
	
	func skipWhile&lt;U&gt;(initialState initial: U, context: Exec = .direct, condition: @escaping (inout U, Interface.OutputValue) throws -&gt; Bool) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.skipWhile(initialState: initial, context: context, condition: condition) }
	}
	
	func takeUntil&lt;U: SignalInterface&gt;(_ other: U) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.takeUntil(other) }
	}
	
	func takeWhile(context: Exec = .direct, condition: @escaping (Interface.OutputValue) throws -&gt; Bool) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.takeWhile(context: context, condition: condition) }
	}
	
	func takeWhile&lt;U&gt;(initialState initial: U, context: Exec = .direct, condition: @escaping (inout U, Interface.OutputValue) throws -&gt; Bool) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.takeWhile(initialState: initial, context: context, condition: condition) }
	}
	
	func foldAndFinalize&lt;U, V&gt;(_ initial: V, context: Exec = .direct, finalize: @escaping (V) throws -&gt; U?, fold: @escaping (V, Interface.OutputValue) throws -&gt; V) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.foldAndFinalize(initial, context: context, finalize: finalize, fold: fold) }
	}
}

extension SignalChannel where Interface.OutputValue: BinaryInteger {
	func average() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.average() }
	}
}

extension SignalChannel {
	func concat(_ other: Signal&lt;Interface.OutputValue&gt;) -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.concat(other) }
	}
	
	func count() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Int&gt;&gt; {
		return next { $0.count() }
	}
}

extension SignalChannel where Interface.OutputValue: Comparable {
	func min() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.min() }
	}
	
	func max() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.max() }
	}
}

extension SignalChannel {
	func aggregate&lt;U&gt;(_ initial: U, context: Exec = .direct, fold: @escaping (U, Interface.OutputValue) -&gt; U) -&gt; SignalChannel&lt;InputInterface, Signal&lt;U&gt;&gt; {
		return next { $0.aggregate(initial, context: context, fold: fold) }
	}
}

extension SignalChannel where Interface.OutputValue: Numeric {
	func sum() -&gt; SignalChannel&lt;InputInterface, Signal&lt;Interface.OutputValue&gt;&gt; {
		return next { $0.sum() }
	}
}

import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

/// Instances of `SignalActionTarget` can be used as the "target" of Cocoa "target-action" events and the result will be emitted as a signal.
/// Instance of this class are owned by the output `signal` so if you're holding onto the signal, you can drop references to this class itself.
class SignalActionTarget: NSObject, SignalInterface {
	// Ownership note: we are owned by the output signal so we only weakly retain it.
	private weak var stored: SignalMulti&lt;Any?&gt;? = nil
	private var input: SignalInput&lt;Any?&gt;? = nil
	
	/// The `signal` emits the actions received
	var signal: Signal&lt;Any?&gt; {
		// If there's a current signal output, return it
		if let so = stored {
			return so
		}
		
		let s = Signal&lt;Any?&gt;.generate { i in self.input = i }.continuous()
		stored = s
		return s
	}
	
	/// Receiver function for the target-action events
	///
	/// - Parameter sender: typical target-action "sender" parameter
	@IBAction func cwlSignalAction(_ sender: Any?) {
		_ = input?.send(value: sender)
	}
	
	/// Convenience accessor for `#selector(SignalActionTarget&lt;Value&gt;.cwlSignalAction(_:))`
	static var selector: Selector { return #selector(SignalActionTarget.cwlSignalAction(_:)) }
}

/// Like `SignalActionTarget` but with a second action method connected to the same target. Useful for situations like NSTableView targets which send single-click and double-click to the same target.
class SignalDoubleActionTarget: SignalActionTarget {
	// Ownership note: we are owned by the output signal so we only weakly retain it.
	private weak var secondStored: SignalMulti&lt;Any?&gt;? = nil
	private var secondInput: SignalInput&lt;Any?&gt;? = nil

	/// The `signal` emits the actions received
	var secondSignal: SignalMulti&lt;Any?&gt; {
		// If there's a current signal output, return it
		if let so = secondStored {
			return so
		}
		
		// Otherwise, create a new one
		let s = Signal&lt;Any?&gt;.generate { i in self.secondInput = i }.continuous()
		secondStored = s
		return s
	}

	/// Receiver function for "secondary" target-action events
	///
	/// - Parameter sender: typical target-action "sender" parameter
	@IBAction func cwlSignalSecondAction(_ sender: Any?) {
		_ = secondInput?.send(value: sender)
	}
	
	/// Convenience accessor for `#selector(SignalDoubleActionTarget&lt;Value&gt;.cwlSignalSecondAction(_:))`
	static var secondSelector: Selector { return #selector(SignalDoubleActionTarget.cwlSignalSecondAction(_:)) }
}

/// This enum contains errors that might be emitted by `signalKeyValueObserving`
///
/// - missingChangeDictionary: the observation failed to supply a change dictionary
enum SignalObservingError: Error {
	case missingChangeDictionary
}

/// Observe a property via key-value-observing and emit the changes as a Signal&lt;OutputValue&gt; on the condition that the emitted `Any` value can be dynamically cast (`as?`) to `OutputValue`
///
/// - Parameters:
///   - source: will have `addObserver(_:forKeyPath:options:context:)` invoked on it
///   - keyPath: passed to `addObserver(_:forKeyPath:options:context:)`
///   - initial: if true, NSKeyValueObservingOptions.initial is included in the options passed to `addObserver(_:forKeyPath:options:context:)`
/// - Returns: a signal which emits the observation results that match the expected type
extension Signal {
	static func keyValueObserving&lt;Source: NSObject&gt;(_ source: Source, keyPath: KeyPath&lt;Source, OutputValue&gt;, initial: Bool = true) -&gt; Signal&lt;OutputValue&gt; {
		var observer: NSObjectProtocol?
		return Signal&lt;OutputValue&gt;.generate { [weak source] (input: SignalInput&lt;OutputValue&gt;?) -&gt; Void in
			guard let i = input, let s = source else {
				observer = nil
				return
			}
			let options = NSKeyValueObservingOptions.new.union(initial ? NSKeyValueObservingOptions.initial : NSKeyValueObservingOptions())
			observer = s.observe(keyPath, options: options) { (object, value) in
				if let nv = value.newValue {
					i.send(nv)
				}
			}
			withExtendedLifetime(observer) {}
		}
	}
}

extension Signal where OutputValue == Notification {
	/// Observe a notification
	///
	/// - Parameters:
	///   - center: the NotificationCenter where addObserver will be invoked (`NotificationCenter.default` is the default)
	///   - name: the Notification.Name to observer (nil is default)
	///   - object: the object to observer (nil is default)
	/// - Returns: a signal which emits the observation results
	static func notifications(from center: NotificationCenter = NotificationCenter.default, name: Notification.Name? = nil, object: AnyObject? = nil) -&gt; Signal&lt;OutputValue&gt; {
		var observerObject: NSObjectProtocol?
		return Signal&lt;Notification&gt;.generate { [weak object] input in
			if let o = observerObject {
				NotificationCenter.default.removeObserver(o)
			}
			if let i = input {
				observerObject = center.addObserver(forName: name, object: object, queue: nil) { n in
					i.send(value: n)
				}
			}
		}
	}
}

@available(*, deprecated, message: "Use Signal&lt;Notification&gt;.notifications")
func signalFromNotifications(center: NotificationCenter = NotificationCenter.default, name: Notification.Name? = nil, object: AnyObject? = nil) -&gt; Signal&lt;Notification&gt; {
	return Signal.notifications(from: center, name: name, object: object)
}

extension Signal {
	/// Attaches a SignalOutput that applies all values to a target NSObject using key value coding via the supplied keyPath. The property must match the runtime type of the Signal signal values or a precondition failure will be raised.
	///
	/// - Parameters:
	///   - context: the execution context where the setting will occur
	///   - target: the object upon which `setValue(_:forKeyPath:)` will be invoked
	///   - keyPath: passed to `setValue(_:forKeyPath:)`
	/// - Returns: the `SignalOutput` created by this action (releasing the output will cease any further setting)
	func kvcSetter(context: Exec, target: NSObject, keyPath: String) -&gt; SignalOutput&lt;OutputValue&gt; {
		return subscribeValues(context: context) { [weak target] (value: OutputValue) -&gt; Void in
			target?.setValue(value, forKeyPath: keyPath)
		}
	}
}

extension Signal where OutputValue == Date {
	/// A convenience wrapper around Signal.interval that emits a Date
	///
	/// - Parameters:
	///   - interval: time between emitted Date values (default is 1 second)
	///   - initialInterval: time until first emitted Date value (default is zero)
	/// - Returns: a `Signal&lt;Date&gt;` that emits according to the described intervals
	static func date(_ interval: DispatchTimeInterval = .seconds(1), initial initialInterval: DispatchTimeInterval? = .seconds(0), context: Exec = .direct) -&gt; Signal&lt;OutputValue&gt; {
		return Signal&lt;Int&gt;.interval(interval, initial: initialInterval, context: context).transform { r in
			switch r {
			case .success: return .value(Date())
			case .failure(let e): return .end(e)
			}
		}
	}
}

import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

// All transformations on a Signal are built on top of the following functions, implemented in CwlSignal.swift
extension SignalInterface {
	func subscribe(context: Exec = .direct, _ handler: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void) -&gt; SignalOutput&lt;OutputValue&gt; {
		return signal.subscribe(context: context, handler)
	}
	func subscribeWhile(context: Exec = .direct, _ handler: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Bool) {
		return signal.subscribeWhile(context: context, handler)
	}
	func junction() -&gt; SignalJunction&lt;OutputValue&gt; {
		return signal.junction()
	}
	func transform&lt;U&gt;(context: Exec = .direct, _ processor: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next) -&gt; Signal&lt;U&gt; {
		return signal.transform(context: context, processor)
	}
	func transformActivation&lt;U&gt;(context: Exec = .direct, activation: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next, _ processor: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next) -&gt; Signal&lt;U&gt; {
		return signal.transformActivation(context: context, activation: activation, processor)
	}
	func transform&lt;S, U&gt;(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next) -&gt; Signal&lt;U&gt; {
		return signal.transform(initialState: initialState, context: context, processor)
	}
	func combine&lt;U: SignalInterface, V&gt;(_ second: U, context: Exec = .direct, _ processor: @escaping (EitherResult2&lt;OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;V&gt;.Next) -&gt; Signal&lt;V&gt; {
		return signal.combine(second, context: context, processor)
	}
	func combine&lt;U: SignalInterface, V: SignalInterface, W&gt;(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;) -&gt; Signal&lt;W&gt;.Next) -&gt; Signal&lt;W&gt; {
		return signal.combine(second, third, context: context, processor)
	}
	func combine&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;) -&gt; Signal&lt;X&gt;.Next) -&gt; Signal&lt;X&gt; {
		return signal.combine(second, third, fourth, context: context, processor)
	}
	func combine&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;) -&gt; Signal&lt;Y&gt;.Next) -&gt; Signal&lt;Y&gt; {
		return signal.combine(second, third, fourth, fifth, context: context, processor)
	}
	func combine&lt;S, U: SignalInterface, V&gt;(_ second: U, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult2&lt;OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;V&gt;.Next) -&gt; Signal&lt;V&gt; {
		return signal.combine(second, initialState: initialState, context: context, processor)
	}
	func combine&lt;S, U: SignalInterface, V: SignalInterface, W&gt;(_ second: U, _ third: V, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;) -&gt; Signal&lt;W&gt;.Next) -&gt; Signal&lt;W&gt; {
		return signal.combine(second, third, initialState: initialState, context: context, processor)
	}
	func combine&lt;S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(_ second: U, _ third: V, _ fourth: W, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;) -&gt; Signal&lt;X&gt;.Next) -&gt; Signal&lt;X&gt; {
		return signal.combine(second, third, fourth, initialState: initialState, context: context, processor)
	}
	func combine&lt;S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;) -&gt; Signal&lt;Y&gt;.Next) -&gt; Signal&lt;Y&gt; {
		return signal.combine(second, third, fourth, fifth, initialState: initialState, context: context, processor)
	}
	func continuous(initialValue: OutputValue) -&gt; SignalMulti&lt;OutputValue&gt; {
		return signal.continuous(initialValue: initialValue)
	}
	func continuous() -&gt; SignalMulti&lt;OutputValue&gt; {
		return signal.continuous()
	}
	func continuousWhileActive() -&gt; SignalMulti&lt;OutputValue&gt; {
		return signal.continuousWhileActive()
	}
	func playback() -&gt; SignalMulti&lt;OutputValue&gt; {
		return signal.playback()
	}
	func cacheUntilActive() -&gt; Signal&lt;OutputValue&gt; {
		return signal.cacheUntilActive()
	}
	func multicast() -&gt; SignalMulti&lt;OutputValue&gt; {
		return signal.multicast()
	}
	func customActivation(initialValues: Array&lt;OutputValue&gt; = [], context: Exec = .direct, _ updater: @escaping (_ cachedValues: inout Array&lt;OutputValue&gt;, _ cachedError: inout SignalEnd?, _ incoming: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void) -&gt; SignalMulti&lt;OutputValue&gt; {
		return signal.customActivation(initialValues: initialValues, context: context, updater)
	}
	func reduce&lt;State&gt;(initialState: State, context: Exec = .direct, _ reducer: @escaping (_ state: State, _ message: OutputValue) throws -&gt; State) -&gt; SignalMulti&lt;State&gt; {
		return signal.reduce(initialState: initialState, context: context, reducer)
	}
	func capture() -&gt; SignalCapture&lt;OutputValue&gt; {
		return signal.capture()
	}
}

extension Signal {
	// Like `create` but also provides a trailing closure to transform the `Signal` normally returned from `create` and in its place, return the result of the transformation.
	//
	// - Parameter compose: a trailing closure which receices the `Signal` as a parameter and any result is returned as the second tuple parameter from this function
	// - Returns: a (`SignalInput`, U) tuple where `SignalInput` is the input to the signal graph and `U` is the return value from the `compose` function.
	// - Throws: rethrows any error from the closure
	static func create&lt;U&gt;(compose: (Signal&lt;OutputValue&gt;) throws -&gt; U) rethrows -&gt; (input: SignalInput&lt;OutputValue&gt;, composed: U) {
		let (i, s) = Signal&lt;OutputValue&gt;.create()
		return (i, try compose(s))
	}
	
	/// A version of `generate` that retains the latest `input` so it doesn't automatically close the signal when the input falls out of scope. This enables a generator that never closes (lives until deactivation).
	///
	/// - Parameters:
	///   - context: the `activationChange` will be invoked in this context
	///   - activationChange: receives inputs on activation and nil on each deactivation
	/// - Returns: the constructed `Signal`
	static func retainedGenerate(context: Exec = .direct, activationChange: @escaping (SignalInput&lt;OutputValue&gt;?) -&gt; Void) -&gt; Signal&lt;OutputValue&gt; {
		var latestInput: SignalInput&lt;OutputValue&gt;? = nil
		return .generate(context: context) { input in
			latestInput = input
			withExtendedLifetime(latestInput) {}
			activationChange(input)
		}
	}
	
	/// Change the default execution to an asynchronous context â typically the global concurrent queue.
	///
	/// This transformation exists as an optimization to multiple stages that must all run in the same queue (for thread-safety reasons) but also want to run asynchronously (to avoid blocking main or calling queues). e.g.:
	/// ```
	/// signal
	///    .map(context: myAsyncQueue) { v in work1(v) }
	///    .map(context: myAsyncQueue) { v in work2(v) }
	/// ```
	///
	/// The executation will not stay on `myAsyncQueue` between these stages... `Signal` must exit any non-reentrant context at the end of a processing stage as part of its thread safety rules. This means that execution through this pipeline takes the following path:
	///
	/// 1. asynchronously transfer to `myAsyncQueue` and run work1
	/// 2. asynchronously transfer to the dispatch global concurrent queue to leave `myAsyncQueue`
	/// 3. asynchronously transfer to `myAsyncQueue` and run work2
	/// 4. asynchronously transfer to the dispatch global concurrent queue to leave `myAsyncQueue`
	///
	/// This involves 4 asynchronous transfers, each of which has a latency of about 5 microseconds, leading to 20 microseconds minimum latency and a maximum throughput of 50 000 per second, when `work1` and `work2` are trivial.
	///
	/// Instead consider the following:
	/// ```
	/// signal
	///    .scheduleAsync()
	///    .map(context: mySyncQueue) { v in work1(v) }
	///    .map(context: mySyncQueue) { v in work2(v) }
	/// ```
	///
	/// Values travelling through this pipeline:
	/// 1. asynchronously transfer to the dispatch global concurrent queue
	/// 2. synchronously invoke on `mySyncQueue` and run work1
	/// 3. synchronously invoke on `mySyncQueue` and run work2
	///
	/// This pipeline offers the same thread safety â `work1` and `work2` are still invoked on the same serial queue â and is still asynchronous. But this arrangement involves 1 asynchronous transfer and 2 synchronous queue invocations, leading to around 7 microseconds minimum latency and a maximum throughput of nearly 150 000 per second, when `work1` and `work2` are trivial ââ around 3 times faster (an advantage that increases for pipelines with more stages).
	///
	/// NOTE: there is no equivalent `scheduleMain` for transferring back to the main thread because the `Exec.main` context is reentrant (checks the current thread and directly invokes if `Thread.isMainThread` returns `true`) so `Signal` does not need to exit the context at the end of each pipeline stage. This function primarily exists to optimize DispatchQueues (e.g. `Exec.asyncQueue`) which are not reentrant.
	///
	/// - Parameter relativeTo: the global scheduling will be achieved by calling `relativeAsync` on this context.
	/// - Parameter qos: used as a parameter to `relativeAsync` to override the `QoSClass`, if desired. Default: `nil`
	/// - Returns: a signal which is transferred to an async context.
	func scheduleAsync(relativeTo: Exec = .direct, qos: DispatchQoS.QoSClass? = nil) -&gt; Signal&lt;OutputValue&gt; {
		return transform(context: relativeTo.relativeAsync(qos: qos), Signal&lt;OutputValue&gt;.Next.single)
	}
}

extension SignalInputInterface {
	/// A convenience version of `send` that wraps a value in `Result.success` before sending
	///
	/// - Parameter value: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(result: Signal&lt;InputValue&gt;.Result) {
		input.send(result: result)
	}
	
	/// A convenience version of `send` that wraps a value in `Result.success` before sending
	///
	/// - Parameter value: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(value: InputValue) {
		input.send(result: .success(value))
	}
	
	/// A convenience version of `send` that wraps a value in `Result.success` before sending
	///
	/// - Parameter value: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(_ values: InputValue...) {
		let i = self.input
		for v in values {
			i.send(result: .success(v))
		}
	}
	
	/// A convenience version of `send` that wraps a value in `Result.success` before sending
	///
	/// - Parameter value: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send&lt;S: Sequence&gt;(sequence: S) where S.Iterator.Element == InputValue {
		let i = self.input
		for v in sequence {
			i.send(result: .success(v))
		}
	}
	
	/// A convenience version of `send` that wraps an error in `Result.failure` before sending
	///
	/// - Parameter error: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(error: Error) {
		input.send(result: .failure(.other(error)))
	}
	
	/// A convenience version of `send` that wraps an error in `Result.failure` before sending
	///
	/// - Parameter error: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(end: SignalEnd) {
		input.send(result: .failure(end))
	}
	
	/// Sends a `Result.failure(SignalEnd.complete)`
	///
	/// - Returns: the return value from the underlying `send(result:)` function
	func complete() {
		input.send(result: .failure(.complete))
	}

	@available(*, deprecated, message: "Renamed `complete`")
	func close() {
		complete()
	}
}

extension Signal.Next {
	static func value(_ value: OutputValue) -&gt; Signal&lt;OutputValue&gt;.Next {
		return .single(.success(value))
	}
	
	static func value(_ value: OutputValue, end: SignalEnd) -&gt; Signal&lt;OutputValue&gt;.Next {
		return .array([.success(value), .failure(end)])
	}
	
	static func values(_ value: OutputValue...) -&gt; Signal&lt;OutputValue&gt;.Next {
		return .array(value.map { Signal&lt;OutputValue&gt;.Result.success($0) })
	}
	
	static func values(_ value: OutputValue..., end: SignalEnd) -&gt; Signal&lt;OutputValue&gt;.Next {
		return .array(value.map { Signal&lt;OutputValue&gt;.Result.success($0) }.appending(.failure(end)))
	}
	
	static func values&lt;OutputValue, S: Sequence&gt;(sequence: S) -&gt; Signal&lt;OutputValue&gt;.Next where S.Element == OutputValue {
		return .array(sequence.map { Signal&lt;OutputValue&gt;.Result.success($0) })
	}
	
	static func values&lt;OutputValue, S: Sequence&gt;(sequence: S, end: SignalEnd) -&gt; Signal&lt;OutputValue&gt;.Next where S.Element == OutputValue {
		return .array(sequence.map { Signal&lt;OutputValue&gt;.Result.success($0) }.appending(.failure(end)))
	}
	
	static func error(_ error: Error) -&gt; Signal&lt;OutputValue&gt;.Next {
		return .single(.failure(.other(error)))
	}
	
	static func end(_ end: SignalEnd) -&gt; Signal&lt;OutputValue&gt;.Next {
		return .single(.failure(end))
	}
	
	static func complete() -&gt; Signal&lt;OutputValue&gt;.Next {
		return .single(.failure(.complete))
	}
}

/// Used by the Signal&lt;OutputValue&gt;.combine(second:context:handler:) method
enum EitherValue2&lt;U, V&gt; {
	case value1(U)
	case value2(V)
}

/// Used by the Signal&lt;OutputValue&gt;.combine(second:third:context:handler:) method
enum EitherValue3&lt;U, V, W&gt; {
	case value1(U)
	case value2(V)
	case value3(W)
}

/// Used by the Signal&lt;OutputValue&gt;.combine(second:third:fourth:context:handler:) method
enum EitherValue4&lt;U, V, W, X&gt; {
	case value1(U)
	case value2(V)
	case value3(W)
	case value4(X)
}

/// Used by the Signal&lt;OutputValue&gt;.combine(second:third:fourth:fifth:context:handler:) method
enum EitherValue5&lt;U, V, W, X, Y&gt; {
	case value1(U)
	case value2(V)
	case value3(W)
	case value4(X)
	case value5(Y)
}

extension SignalInterface {
	/// Removes any activation from the signal. Useful in cases when you only want *changes*, not the latest value.
	func dropActivation() -&gt; Signal&lt;OutputValue&gt; {
		let pair = Signal&lt;OutputValue&gt;.create()
		try! signal.capture().bind(to: pair.input)
		return pair.signal
	}
	
	/// Causes any activation to be deferred past activation time to the "normal" phase. This avoids the synchronous send rules normally used for activation signals an allows this initial signal to be asynchronously delivered.
	func deferActivation() -&gt; Signal&lt;OutputValue&gt; {
		let pair = Signal&lt;OutputValue&gt;.create()
		try! signal.capture().bind(to: pair.input, resend: .deferred)
		return pair.signal
	}
	
	/// Appends a handler function that transforms the value emitted from this `Signal` into a new `Signal`.
	///
	/// - Parameters:
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: the function invoked for each received `Result`
	/// - Returns: the created `Signal`
	func transformValues&lt;U&gt;(context: Exec = .direct, _ processor: @escaping (OutputValue) -&gt; Signal&lt;U&gt;.Next) -&gt; Signal&lt;U&gt; {
		return transform(context: context) { r in
			switch r {
			case .success(let v): return processor(v)
			case .failure(let e): return .single(.failure(e))
			}
		}
	}
	
	/// Appends a handler function that transforms the value emitted from this `Signal` into a new `Signal`.
	///
	/// - Parameters:
	///   - initialState: the initial value for a state value associated with the handler. This value is retained and if the signal graph is deactivated, the state value is reset to this value.
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: the function invoked for each received `Result`
	/// - Returns: the transformed output `Signal`
	func transformValues&lt;S, U&gt;(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, OutputValue) -&gt; Signal&lt;U&gt;.Next) -&gt; Signal&lt;U&gt; {
		return transform(initialState: initialState, context: context) { s, r in
			switch r {
			case .success(let v): return processor(&amp;s, v)
			case .failure(let e): return .single(.failure(e))
			}
		}
	}

	/// Maps values from self or second to EitherValue2 and merges into a single stream.
	///
	/// - Parameter second: another signal
	/// - Returns: Signal&lt;EitherValue2&lt;OutputValue, U.OutputValue&gt;&gt;
	func combineValues&lt;U: SignalInterface&gt;(_ second: U, closePropagation: SignalEndPropagation = .errors) -&gt; Signal&lt;EitherValue2&lt;OutputValue, U.OutputValue&gt;&gt; {
		return signal.combine(second.signal, initialState: (false, false)) { (closed: inout (Bool, Bool), either: EitherResult2&lt;OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;EitherValue2&lt;OutputValue, U.OutputValue&gt;&gt;.Next in
			switch either {
			case .result1(.failure(let e)):
				if closed.1 || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.0 = true
				return .none
			case .result2(.failure(let e)):
				if closed.0 || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.1 = true
				return .none
			case .result1(.success(let v)): return .value(.value1(v))
			case .result2(.success(let v)): return .value(.value2(v))
			}
		}
	}

	func combineValues&lt;U: SignalInterface, V: SignalInterface&gt;(_ second: U, _ third: V, closePropagation: SignalEndPropagation = .errors) -&gt; Signal&lt;EitherValue3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt; {
		return signal.combine(second.signal, third.signal, initialState: (false, false, false)) { (closed: inout (Bool, Bool, Bool), either: EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;) -&gt; Signal&lt;EitherValue3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;&gt;.Next in
			switch either {
			case .result1(.failure(let e)):
				if (closed.1 &amp;&amp; closed.2) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.0 = true
				return .end(e)
			case .result2(.failure(let e)):
				if (closed.0 &amp;&amp; closed.2) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.1 = true
				return .end(e)
			case .result3(.failure(let e)):
				if (closed.0 &amp;&amp; closed.1) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.2 = true
				return .end(e)
			case .result1(.success(let v)): return .value(.value1(v))
			case .result2(.success(let v)): return .value(.value2(v))
			case .result3(.success(let v)): return .value(.value3(v))
			}
		}
	}
	
	func combineValues&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface&gt;(_ second: U, _ third: V, fourth: W, closePropagation: SignalEndPropagation = .errors) -&gt; Signal&lt;EitherValue4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt; {
		return signal.combine(second.signal, third.signal, fourth.signal, initialState: (false, false, false, false)) { (closed: inout (Bool, Bool, Bool, Bool), either: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;) -&gt; Signal&lt;EitherValue4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;&gt;.Next in
			switch either {
			case .result1(.failure(let e)):
				if (closed.1 &amp;&amp; closed.2 &amp;&amp; closed.3) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.0 = true
				return .end(e)
			case .result2(.failure(let e)):
				if (closed.0 &amp;&amp; closed.2 &amp;&amp; closed.3) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.1 = true
				return .end(e)
			case .result3(.failure(let e)):
				if (closed.0 &amp;&amp; closed.1 &amp;&amp; closed.3) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.2 = true
				return .end(e)
			case .result4(.failure(let e)):
				if (closed.0 &amp;&amp; closed.1 &amp;&amp; closed.2) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.3 = true
				return .end(e)
			case .result1(.success(let v)): return .value(.value1(v))
			case .result2(.success(let v)): return .value(.value2(v))
			case .result3(.success(let v)): return .value(.value3(v))
			case .result4(.success(let v)): return .value(.value4(v))
			}
		}
	}
	
	func combineValues&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X, closePropagation: SignalEndPropagation = .errors) -&gt; Signal&lt;EitherValue5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt; {
		return signal.combine(second.signal, third.signal, fourth.signal, fifth.signal, initialState: (false, false, false, false, false)) { (closed: inout (Bool, Bool, Bool, Bool, Bool), either: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;) -&gt; Signal&lt;EitherValue5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;&gt;.Next in
			switch either {
			case .result1(.failure(let e)):
				if (closed.1 &amp;&amp; closed.2 &amp;&amp; closed.3 &amp;&amp; closed.4) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.0 = true
				return .end(e)
			case .result2(.failure(let e)):
				if (closed.0 &amp;&amp; closed.2 &amp;&amp; closed.3 &amp;&amp; closed.4) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.1 = true
				return .end(e)
			case .result3(.failure(let e)):
				if (closed.0 &amp;&amp; closed.1 &amp;&amp; closed.3 &amp;&amp; closed.4) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.2 = true
				return .end(e)
			case .result4(.failure(let e)):
				if (closed.0 &amp;&amp; closed.1 &amp;&amp; closed.2 &amp;&amp; closed.4) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.3 = true
				return .end(e)
			case .result5(.failure(let e)):
				if (closed.0 &amp;&amp; closed.1 &amp;&amp; closed.2 &amp;&amp; closed.3) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.4 = true
				return .end(e)
			case .result1(.success(let v)): return .value(.value1(v))
			case .result2(.success(let v)): return .value(.value2(v))
			case .result3(.success(let v)): return .value(.value3(v))
			case .result4(.success(let v)): return .value(.value4(v))
			case .result5(.success(let v)): return .value(.value5(v))
			}
		}
	}

	/// A version of `subscribe` that retains the `SignalOutput` internally, keeping the signal graph alive. The `SignalOutput` is cancelled and released when the signal closes.
	///
	/// NOTE: this subscriber deliberately creates a reference counted loop. If the signal is never closed, it will result in a memory leak. This function should be used only when `self` is guaranteed to close.
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received and if returns `false`, the output will be cancelled and released
	func subscribeUntilEnd(context: Exec = .direct, _ handler: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; Void) {
		return signal.subscribeWhile(context: context, { (result: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Bool in
			handler(result)
			return true
		})
	}
	
	/// A convenience version of `subscribe` that only invokes the `processor` on `Result.success`
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received
	/// - Returns: the `SignalOutput` created by this function
	func subscribeValues(context: Exec = .direct, _ handler: @escaping (OutputValue) -&gt; Void) -&gt; SignalOutput&lt;OutputValue&gt; {
		return signal.subscribe(context: context) { r in
			if case .success(let v) = r {
				handler(v)
			}
		}
	}
	
	/// A convenience version of `subscribeUntilEnd` that only invokes the `processor` on `Result.success`
	///
	/// NOTE: this subscriber deliberately creates a reference counted loop. If the signal is never closed, it will result in a memory leak. This function should be used only when `self` is guaranteed to close.
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received and if returns `false`, the output will be cancelled and released
	func subscribeValuesUntilEnd(context: Exec = .direct, _ handler: @escaping (OutputValue) -&gt; Void) {
		signal.subscribeUntilEnd(context: context) { r in
			if case .success(let v) = r {
				handler(v)
			}
		}
	}
	
	/// A convenience version of `subscribeWhile` that only invokes the `processor` on `Result.success`
	///
	/// NOTE: this subscriber deliberately creates a reference counted loop. If the signal is never closed and the handler never returns false, it will result in a memory leak. This function should be used only when `self` is guaranteed to close or the handler `false` condition is guaranteed.
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received and if returns `false`, the output will be cancelled and released
	func subscribeValuesWhile(context: Exec = .direct, _ handler: @escaping (OutputValue) -&gt; Bool) {
		signal.subscribeWhile(context: context) { r in
			if case .success(let v) = r {
				return handler(v)
			} else {
				return false
			}
		}
	}
	
	/// Returns a signal that drops an `initial` number of values from the start of the stream and emits the next value and every `count`-th value after that.
	///
	/// - Parameters:
	///   - count: number of values beteen emissions
	///   - initialSkip: number of values before the first emission
	/// - Returns: the strided signal
	func stride(count: Int, initialSkip: Int = 0) -&gt; Signal&lt;OutputValue&gt; {
		return signal.transform(initialState: count - initialSkip - 1) { (state: inout Int, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v) where state &gt;= count - 1:
				state = 0
				return .value(v)
			case .success:
				state += 1
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// A signal transform function that, instead of creating plain values and emitting them to a `SignalNext`, creates entire signals and adds them to a `SignalMergedInput`. The output of the merge set (which contains the merged output from all of the created signals) forms the signal returned from this function.
	///
	/// NOTE: this function is primarily used for implementing various Reactive X operators.
	///
	/// - Parameters:
	///   - closePropagation: whether signals added to the merge set will close the output
	///   - context: the context where the processor will run
	///   - processor: performs work with values from this `Signal` and the `SignalMergedInput` used for output
	/// - Returns: output of the merge set
	func transformFlatten&lt;U&gt;(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ processor: @escaping (OutputValue, SignalMergedInput&lt;U&gt;) throws -&gt; ()) -&gt; Signal&lt;U&gt; {
		return transformFlatten(initialState: (), closePropagation: closePropagation, context: context, { (state: inout (), value: OutputValue, mergedInput: SignalMergedInput&lt;U&gt;) in try processor(value, mergedInput) })
	}
	
	/// A signal transform function that, instead of creating plain values and emitting them to a `SignalNext`, creates entire signals and adds them to a `SignalMergedInput`. The output of the merge set (which contains the merged output from all of the created signals) forms the signal returned from this function.
	///
	/// NOTE: this function is primarily used for implementing various Reactive X operators.
	///
	/// - Parameters:
	///   - initialState: initial state for the state parameter passed into the processor
	///   - closePropagation: whether signals added to the merge set will close the output
	///   - context: the context where the processor will run
	///   - processor: performs work with values from this `Signal` and the `SignalMergedInput` used for output
	/// - Returns: output of the merge set
	func transformFlatten&lt;S, U&gt;(initialState: S, closePropagation: SignalEndPropagation = .errors, context: Exec = .direct, _ processor: @escaping (inout S, OutputValue, SignalMergedInput&lt;U&gt;) throws -&gt; ()) -&gt; Signal&lt;U&gt; {
		let (mergedInput, result) = Signal&lt;U&gt;.createMergedInput()
		var end: SignalEnd? = nil
		let outerSignal = signal.transform(initialState: initialState, context: context) { (state: inout S, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			switch r {
			case .success(let v):
				do {
					try processor(&amp;state, v, mergedInput)
					return .none
				} catch {
					end = .other(error)
					return .error(error)
				}
			case .failure(let e):
				end = e
				return .end(e)
			}
		}
		
		// Keep the merge set alive at least as long as self
		mergedInput.add(outerSignal, closePropagation: closePropagation)
		
		return result.transform(initialState: nil) { [weak mergedInput] (onDelete: inout OnDelete?, r: Result&lt;U, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			if onDelete == nil {
				onDelete = OnDelete {
					end = nil
				}
			}
			switch r {
			case .success(let v): return .value(v)
			case .failure(.cancelled):
				// If the `mergedInput` is `nil` at this point, that means that this `.cancelled` comes from the `mergedInput`, not one of its inputs. We'd prefer in that case to emit the `outerSignal`'s `closeError` rather than follow the `shouldPropagateEnd` logic.
				return .end(mergedInput == nil ? (end ?? .cancelled) : .cancelled)
			case .failure(let e):
				return .end(closePropagation.shouldPropagateEnd(e) ? e : (end ?? .cancelled))
			}
		}
	}

	/// A utility function, used by ReactiveX implementations, that generates "window" durations in single signal from the values in self and a "duration" function that returns duration signals for each value.
	///
	/// - Parameters:
	///   - closePropagation: passed through to the underlying `transformFlatten` call (unlikely to make much different in expected use cases of this function)
	///   - context: the context where `duration` will be invoked
	///   - duration: for each value emitted by `self`, emit a signal
	/// - Returns: a signal of two element tuples
	func valueDurations&lt;Interface: SignalInterface&gt;(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ duration: @escaping (OutputValue) -&gt; Interface) -&gt; Signal&lt;(Int, OutputValue?)&gt; {
		return valueDurations(initialState: (), closePropagation: closePropagation, context: context, { (state: inout (), value: OutputValue) -&gt; Interface in duration(value) })
	}

	/// A utility function, used by ReactiveX implementations, that generates "window" durations in single signal from the values in self and a "duration" function that returns duration signals for each value.
	///
	/// - Parameters:
	///   - initialState: initial state for the state parameter passed into the processor
	///   - closePropagation: passed through to the underlying `transformFlatten` call (unlikely to make much different in expected use cases of this function)
	///   - context: the context where `duration` will be invoked
	///   - duration: for each value emitted by `self`, emit a signal
	/// - Returns: a signal of two element tuples
	func valueDurations&lt;Interface: SignalInterface, V&gt;(initialState: V, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ duration: @escaping (inout V, OutputValue) -&gt; Interface) -&gt; Signal&lt;(Int, OutputValue?)&gt; {
		return transformFlatten(initialState: (index: 0, userState: initialState), closePropagation: closePropagation, context: context) { (state: inout (index: Int, userState: V), v: OutputValue, mergedInput: SignalMergedInput&lt;(Int, OutputValue?)&gt;) in
			let count = state.index
			let innerSignal = duration(&amp;state.userState, v).transform { (innerResult: Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Signal&lt;(Int, OutputValue?)&gt;.Next in
				switch innerResult {
				case .success: return .none
				case .failure(let e): return .value((count, nil), end: e)
				}
			}
			let prefixedInnerSignal = Signal&lt;(Int, OutputValue?)&gt;.preclosed((count, Optional(v))).combine(innerSignal) { (r: EitherResult2&lt;(Int, OutputValue?), (Int, OutputValue?)&gt;) -&gt; Signal&lt;(Int, OutputValue?)&gt;.Next in
				switch r {
				case .result1(.success(let v)): return .value(v)
				case .result1(.failure): return .none
				case .result2(.success(let v)): return .value(v)
				case .result2(.failure(let e)): return .end(e)
				}
			}

			mergedInput.add(prefixedInnerSignal, closePropagation: .none)
			state.index += 1
		}
	}
	
	/// A continuous signal which alternates between true and false values each time it receives a value.
	///
	/// - Parameter initialState: before receiving the first value
	/// - Returns: the alternating, continuous signal
	func toggle(initialState: Bool = false) -&gt; Signal&lt;Bool&gt; {
		return reduce(initialState: initialState) { (state: Bool, input: OutputValue) -&gt; Bool in
			return !state
		}
	}

	/// A convenience transform to turn a signal of optional values into an signal of array values with one or zero elements.
	///
	/// - Returns: an array signal
	func optionalToArray&lt;U&gt;() -&gt; Signal&lt;[U]&gt; where OutputValue == Optional&lt;U&gt; {
		return signal.transform { (optional: Result&lt;U?, SignalEnd&gt;) -&gt; Signal&lt;[U]&gt;.Next in
			switch optional {
			case .success(.some(let v)): return .value([v])
			case .success: return .value([])
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// A convenience transform to turn a signal of optional values into an signal of array values with one or zero elements.
	///
	/// - Returns: an array signal
	func optional() -&gt; Signal&lt;OutputValue?&gt; {
		return signal.transform { (optional: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue?&gt;.Next in
			return .single(optional.map { $0 as OutputValue? })
		}
	}
	
	/// Joins this `Signal` to a destination `SignalInput`
	///
	/// WARNING: if you bind to a previously joined or otherwise inactive instance of the base `SignalInput` class, this function will have no effect. To get underlying errors, use `junction().bind(to: input)` instead.
	///
	/// - Parameters:
	///   - to: target `SignalInput` to which this signal will be added
	func bind&lt;InputInterface&gt;(to interface: InputInterface) where InputInterface: SignalInputInterface, InputInterface.InputValue == OutputValue {
		let input = interface.input
		if let multiInput = input as? SignalMultiInput&lt;OutputValue&gt; {
			multiInput.add(signal)
		} else {
			_ = try? signal.junction().bind(to: input)
		}
	}
	
	/// Joins this `Signal` to a destination `SignalMergedInput`
	///
	/// - Parameters:
	///   - to: target `SignalMultiInput` to which this signal will be added
	func bind(to input: SignalMergedInput&lt;OutputValue&gt;, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = true) {
		input.add(signal, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
	}

	func flatMapBind&lt;Interface: SignalInterface, InputInterface: SignalInputInterface&gt;(to interface: Interface, _ transform: @escaping (Interface.OutputValue) -&gt; InputInterface) where InputInterface.InputValue == OutputValue {
		let j = junction()
		interface.subscribeUntilEnd { result in
			switch result {
			case .success(let v): _ = try? j.bind(to: transform(v))
			case .failure: _ = j.disconnect()
			}
		}
	}
	
	/// Joins this `Signal` to a destination `SignalMultiInput` and returns a `Lifetime` that, when cancelled, will remove the `Signal` from the `SignalMultiInput` again.
	///
	/// - Parameters:
	///   - to: target `SignalMultiInput` to which this signal will be added
	/// - Returns: a `Lifetime` that will undo the bind if cancelled or released
	func cancellableBind&lt;InputInterface&gt;(to interface: InputInterface) -&gt; Lifetime where InputInterface: SignalInputInterface, InputInterface.InputValue == OutputValue {
		let input = interface.input
		if let multiInput = input as? SignalMultiInput&lt;OutputValue&gt; {
			let sig = signal
			multiInput.add(sig)
			return OnDelete { [weak multiInput, weak sig] in
				guard let mi = multiInput, let s = sig else { return }
				mi.remove(s)
			}
		} else {
			let j = signal.junction()
			_ = try? j.bind(to: input)
			return j
		}
	}
	
	/// Joins this `Signal` to a destination `SignalMultiInput` and returns a `Lifetime` that, when cancelled, will remove the `Signal` from the `SignalMultiInput` again.
	///
	/// - Parameters:
	///   - to: target `SignalMultiInput` to which this signal will be added
	/// - Returns: a `Lifetime` that will undo the bind if cancelled or released
	func cancellableBind(to input: SignalMergedInput&lt;OutputValue&gt;, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = true) -&gt; Lifetime {
		let sig = signal
		input.add(sig, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
		return OnDelete { [weak input, weak sig] in
			guard let i = input, let s = sig else { return }
			i.remove(s)
		}
	}

	/// - Returns: a signal where value in the sequence is accompanied by its zero-indexed position in the sequence
	func enumerated() -&gt; Signal&lt;(offset: Int, element: OutputValue)&gt; {
		return transform(initialState: -1) { index, result in
			index += 1
			return .single(result.map { (offset: index, element: $0) })
		}
	}
	
	/// Given an array of source Signals, returns a single, merged Signal where each value is a tuple of the index in the array and the element from the corresponding source signal. 
	///
	/// - Parameter sequence: an sequence of SignalInterfaces
	/// - Returns: a merged signal of (offset, element) tuples
	static func indexed&lt;S: Sequence&gt;(_ sequence: S) -&gt; Signal&lt;(offset: Int, element: OutputValue)&gt; where S.Element: SignalInterface, OutputValue == S.Element.OutputValue {
		return Signal&lt;(offset: Int, element: OutputValue)&gt;.merge(sequence: sequence.enumerated().map { offset, s in s.map { (offset: offset, element: $0) } })
	}
}

/// This class is used for disconnecting and reconnecting a preceeding signal subgraph from the succeeding signal subgraph. This is useful in cases where you have a generating signal that will automatically pause itself when disconnected (like `Signal.interval`) and you want to disconnect it and reconnect to take advantage of that pause and restart functionality.
/// Internally, this class is a wrapper around a `SignalJunction` (which disconnects the succeeding graph) and a `Signal` (which is the head of the succeeding graph) and 
struct SignalReconnector&lt;OutputValue&gt;: Lifetime {
	let queue = PThreadMutex()
	var disconnectedInput: SignalInput&lt;OutputValue&gt;?
	let junction: SignalJunction&lt;OutputValue&gt;
	
	mutating func reconnect() {
		let input = queue.sync { () -&gt; SignalInput&lt;OutputValue&gt;? in
			let di = disconnectedInput
			disconnectedInput = nil
			return di
		}
		if let i = input {
			_ = try? junction.bind(to: i)
		}
	}
	
	mutating func cancel() {
		junction.cancel()
		queue.sync {
			disconnectedInput?.cancel()
			disconnectedInput = nil
		}
	}
	
	mutating func disconnect() {
		if let i = junction.disconnect() {
			queue.sync {
				disconnectedInput = i
			}
		}
	}
	
	init(preceeding: Signal&lt;OutputValue&gt;, succeeding: SignalInput&lt;OutputValue&gt;, initiallyConnected: Bool = true) {
		disconnectedInput = succeeding
		junction = preceeding.junction()
		if initiallyConnected {
			reconnect()
		}
	}
}

extension SignalInterface {
	/// Create a `SignalReconnector` and a downstream `Signal`. The `SignalReconnector` is used for disconnecting and reconnecting the downstream signal from `self`. This is useful in cases where `self` is a generating signal that automatically pauses itself when disconnected from all outputs (like `Signal.interval`) and you want to take advantage of that pause and restart functionality.
	///
	/// - Parameter initiallyConnected: should the downstream signal be connected when this function returns
	/// - Returns: a tuple of `SignalReconnector` and `Signal`. The reconnector disconnects `self` (upstream) from the `Signal` in the tuple (downstream). 
	func reconnector(initiallyConnected: Bool = true) -&gt; (SignalReconnector&lt;OutputValue&gt;, Signal&lt;OutputValue&gt;) {
		let (i, s) = Signal&lt;OutputValue&gt;.create()
		return (SignalReconnector&lt;OutputValue&gt;(preceeding: signal, succeeding: i, initiallyConnected: initiallyConnected), s)
	}
}

/// This wrapper around `SignalOutput` saves the last received value from the signal so that it can be 'polled' (read synchronously from an arbitrary execution context). This class ensures thread-safety on the read operation.
///
/// The typical use-case for this type of class is in the implementation of delegate methods and similar callback functions that must synchronously return a value.
///
/// Note that there is a semantic difference between this class which is intended to be left active for some time and polled periodically and `SignalCapture` which captures the *activation* value (leaving it running for a duration is pointless). For that reason, the standalone `peek()` function actually uses `SignalCapture` rather than this class (`SignalCapture` is more consistent in the presence of multi-threaded updates since there is no possibility of asychronous updates between creation and reading).
///
/// However, `SignalCapture` can only read activation values (not regular values). Additionally, `peek()` will be less efficient than this class if multiple reads are required since the `SignalCapture` is created and thrown away each time.
///
/// **WARNING**: this class should be avoided where possible since it removes the "reactive" part of reactive programming (changes in the polled value must be detected through other means, usually another subscriber to the underlying `Signal`).
///
final class SignalLatest&lt;OutputValue&gt;: Lifetime {
	var output: SignalOutput&lt;OutputValue&gt;? = nil
	var latest: Result&lt;OutputValue, SignalEnd&gt;? = nil
	let mutex = Exec.syncQueue()
	
	init(signal: Signal&lt;OutputValue&gt;) {
		output = signal.subscribe(context: mutex) { [weak self] r in
			self?.latest = r
		}
	}
	
	var latestResult: Result&lt;OutputValue, SignalEnd&gt;? {
		return mutex.invokeSync { latest }
	}
	
	var latestValue: OutputValue? {
		return mutex.invokeSync { latest?.value }
	}
	
	func cancel() {
		output?.cancel()
	}
}

/// A SignalCapture subscribes to a signal and records any synchronously emitted "activation" values.
/// If there is no value to return or the value can't be emitted synchronously, this error may be returned.
struct SignalCaptureFailedToEmit: Error {}

extension SignalInterface {
	/// Appends a `SignalLatest` listener to the value emitted from this `Signal`. `SignalLatest` adds an output to the signal and remembers the latest result emitted. This latest result can be accessed in a thread-safe way, using `latestValue` or `latestResult`.
	func cacheLatest() -&gt; SignalLatest&lt;OutputValue&gt; {
		return SignalLatest(signal: signal)
	}
	
	/// Internally creates a `SignalCapture` which reads the latest activation value and is immediately discarded.
	///
	/// NOTE: if you're not specifically interested in activation values or you're performing multiple times, the
	/// performance of `cacheLatest` is better.
	///
	/// - Returns: the latest captured value, if any
	/// - Throws: if no value is emitted but a `SignalEnd` is emitted, then the `SignalEnd` will be thrown. If no value or end is emitted, a `SignalCapture.FailedToEmit` error will be thrown.
	func peek() -&gt; OutputValue? {
		return signal.capture().peek()
	}
}

extension SignalCapture: SignalInterface {
	var signal: Signal&lt;OutputValue&gt; { return resume() }
}

extension Result where Failure == SignalEnd {
	/// A minor convenience so that parameters requesting a `Result` can be passed `.signalComplete`
	static var signalComplete: Result&lt;Success, SignalEnd&gt; { return Result&lt;Success, SignalEnd&gt;.failure(.complete) }
	
	/// A convenience extension on `Result` to test if it wraps a `SignalComplete`
	var isComplete: Bool {
		switch self {
		case .failure(.complete): return true
		default: return false
		}
	}
}

import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

#if swift(&gt;=4)
#else
	typealias Numeric = IntegerArithmetic &amp; ExpressibleByIntegerLiteral
	typealias BinaryInteger = IntegerArithmetic &amp; ExpressibleByIntegerLiteral
#endif

/// Errors used by the Reactive extensions on Signal.
/// - timeout: used to close the stream when the Signal.timeout function reaches its limit.
enum SignalReactiveError: Error {
	case timeout
}

extension SignalInterface {
	/// - Note: the [Reactive X operator "Create"](http://reactivex.io/documentation/operators/create.html) is considered unnecessary, given the `CwlSignal.Signal.generate` and `CwlSignal.Signal.create` methods.
	
	/// - Note: the [Reactive X operator "Defer"](http://reactivex.io/documentation/operators/defer.html) is considered not applicable, given the different semantics of "activation" with `CwlSignal.Signal`. If `Defer`-like behavior is desired, either a method that constructs and returns a new `Signal` graph should be used (if a truly distinct graph is desired) or `CwlSignal.Signal.generate` should be used (if wait-until-activated behavior is desired).
}

extension Signal {
	/// Implementation of [Reactive X operator "From"](http://reactivex.io/documentation/operators/from.html) in the context of the Swift `Sequence`
	///
	/// See also: `preclosed(:)`, which is a shareable activation sequence
	/// See also: `just(:)`, which offers the same functionality but accepts a variable argument list instead of a sequence
	///
	/// NOTE: it is possible to specify a `nil` error to have the signal remain at the end of the sequence.
	///
	/// - parameter values: A Swift `Sequence` that generates the signal values.
	/// - parameter end: The error with which to close the sequence. Can be `nil` to leave the sequence (default: `SignalEnd.complete`)
	/// - parameter context: the `Exec` where the `SequenceType` will be enumerated (default: .direct).
	/// - returns: a signal that emits `values` and then closes
	static func from&lt;S: Sequence&gt;(_ sequence: S, end: SignalEnd? = .complete, context: Exec = .direct) -&gt; Signal&lt;OutputValue&gt; where S.Iterator.Element == OutputValue {
		if let e = end {
			return generate(context: context) { input in
				guard let i = input else { return }
				for v in sequence {
					if let _ = i.send(result: .success(v)) {
						break
					}
				}
				i.send(end: e)
			}
		} else {
			return retainedGenerate(context: context) { input in
				guard let i = input else { return }
				for v in sequence {
					if let _ = i.send(result: .success(v)) {
						break
					}
				}
			}
		}
	}

	/// Implementation of [Reactive X operator "Never"](http://reactivex.io/documentation/operators/empty-never-throw.html)
	///
	/// Implemented as `.from([], end: nil)`
	///
	/// - returns: a non-sending, non-closing signal of the desired type
	static func never() -&gt; Signal&lt;OutputValue&gt; {
		return .from([], end: nil)
	}
	
	/// - Implementation of [Reactive X operator "Just"](http://reactivex.io/documentation/operators/just.html)
	///
	/// See also: `from(:)`, which sends a sequence of values (optionally on a specific context)
	/// See also: `preclosed(:)`, which is a shareable activation sequence
	///
	/// - Parameters:
	///   - value: the value to send
	///   - end: if non-nil, sent after value to close the stream 
	/// - Returns: a signal that will emit `value` and (optionally) close
	static func just(_ values: OutputValue..., end: SignalEnd? = .complete) -&gt; Signal&lt;OutputValue&gt; {
		return .from(values, end: end)
	}

	/// - Implementation of [Reactive X operator "Throw"](http://reactivex.io/documentation/operators/empty-never-throw.html)
	///
	/// See also: `from(:)`, which sends a sequence of values (optionally on a specific context)
	/// See also: `preclosed(:)`, which is a shareable activation sequence
	///
	/// - Parameters:
	///   - value: the value to send
	///   - end: if non-nil, sent after value to close the stream 
	/// - Returns: a signal that will emit `value` and (optionally) close
	static func error(_ error: Error) -&gt; Signal&lt;OutputValue&gt; {
		return Signal&lt;OutputValue&gt;.from([], end: .other(error))
	}

	/// - Implementation of [Reactive X operator "Empty"](http://reactivex.io/documentation/operators/empty-never-throw.html)
	///
	/// See also: `from(:)`, which sends a sequence of values (optionally on a specific context)
	///
	/// - Returns: a signal that will emit no values and then close
	static func empty() -&gt; Signal&lt;OutputValue&gt; {
		return Signal&lt;OutputValue&gt;.from([])
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "To"](http://reactivex.io/documentation/operators/to.html) in the context of the Swift `Sequence`
	///
	/// WARNING: Because it blocks the receiving thread, and because it undermines the principle of *reactive* programming, this function should only be used in specific circumstances.
	///
	/// `SignalSequence` subscribes to `self` and blocks. This means that if any earlier signals in the graph force processing on the same context where `SignalSequence` is iterated, a deadlock may occur between the iteration and the signal processing.
	/// This function is safe only when you can guarantee all parts of the signal graph are independent of the blocking context.
	func toSequence() -&gt; SignalSequence&lt;OutputValue&gt; {
		return SignalSequence&lt;OutputValue&gt;(signal)
	}
}

/// Represents a Signal&lt;OutputValue&gt; converted to a synchronously iterated sequence. Values can be obtained using typical SequenceType actions. The error that ends the sequence is available through the `error` property.
class SignalSequence&lt;OutputValue&gt;: Sequence, IteratorProtocol {
	typealias GeneratorType = SignalSequence&lt;OutputValue&gt;
	typealias ElementType = OutputValue
	
	let semaphore = DispatchSemaphore(value: 0)
	let context = Exec.syncQueue()
	var output: SignalOutput&lt;OutputValue&gt;? = nil
	
	var queued: Array&lt;OutputValue&gt; = []
	
	/// Error type property is `nil` before the end of the signal is reached and contains the error used to close the signal in other cases
	var end: SignalEnd?
	
	// Only intended to be constructed by `Signal.toSequence`
	//
	// - Parameter signal: the signal whose values will be iterated by this sequence
	init(_ signal: Signal&lt;OutputValue&gt;) {
		output = signal.subscribe(context: context) { [weak self] (r: Result&lt;OutputValue, SignalEnd&gt;) in
			guard let s = self else { return }
			switch r {
			case .success(let v):
				s.queued.append(v)
				s.semaphore.signal()
			case .failure(let e):
				s.end = e
				s.semaphore.signal()
			}
		}
	}
	
	/// Stops listening to the signal and set the error value to SignalComplete.cancelled
	func cancel() {
		context.invokeSync {
			self.end = .cancelled
			self.output?.cancel()
			self.semaphore.signal()
		}
	}
	
	/// Implementation of GeneratorType method.
	func next() -&gt; OutputValue? {
		_ = semaphore.wait(timeout: DispatchTime.distantFuture)
		return context.invokeSync { [weak self] () -&gt; OutputValue? in
			guard let s = self else { return nil }
			if !s.queued.isEmpty {
				return s.queued.removeFirst()
			} else {
				// Signal the sempahore so that `nil` can be fetched again.
				s.semaphore.signal()
				return nil
			}
		}
	}
	
	deinit {
		if end == nil {
			semaphore.signal()
		}
	}
}

extension SignalInterface where OutputValue == Int {

	/// Implementation of [Reactive X operator "Interval"](http://reactivex.io/documentation/operators/interval.html)
	///
	/// - Parameters:
	///   - interval: duration between values
	///   - initialInterval: duration until first value
	///   - context: execution context where the timer will run
	/// - Returns: the interval signal
	static func interval(_ interval: DispatchTimeInterval = .seconds(1), initial initialInterval: DispatchTimeInterval? = nil, context: Exec = .global) -&gt; Signal&lt;Int&gt; {
		// We need to protect the `count` variable and make sure that out-of-date timers don't update it so we use a `serialized` context for the `generate` and the timers, since the combination of the two will ensure that these requirements are met.
		let serialContext = context.serialized()
		var timer: Lifetime? = nil
		var count = 0
		
		return Signal&lt;Int&gt;.generate(context: serialContext) { input in
			guard let i = input else {
				timer?.cancel()
				count = 0
				return
			}
			
			let repeater = {
				timer = serialContext.periodicTimer(interval: interval) {
					i.send(value: count)
					count += 1
				}
			}
			
			if let initial = initialInterval {
				if initial == .seconds(0) {
					i.send(value: count)
					count += 1
					repeater()
				} else {
					timer = serialContext.singleTimer(interval: initial) {
						i.send(value: count)
						count += 1
						repeater()
					}
				}
			} else {
				repeater()
			}
		}
	}
}

extension SignalInterface {
	/// - Note: the [Reactive X operator `Range`](http://reactivex.io/documentation/operators/range.html) is considered unnecessary, given that ranges are already handled by `from(:)`.
}

extension Signal {
	/// Implementation of [Reactive X operator "Repeat"](http://reactivex.io/documentation/operators/repeat.html) for a Swift `CollectionType`
	///
	/// - Parameters:
	///   - values: A Swift `CollectionType` that generates the signal values.
	///   - count: the number of times that `values` will be repeated.
	///   - context: the `Exec` where the `SequenceType` will be enumerated.
	/// - Returns: a signal that emits `values` a `count` number of times and then closes
	static func repeatCollection&lt;C: Collection&gt;(_ values: C, count: Int, context: Exec = .direct) -&gt; Signal&lt;OutputValue&gt; where C.Iterator.Element == OutputValue {
		return generate(context: context) { input in
			guard let i = input else { return }
			for _ in 0..&lt;count {
				for v in values {
					if i.send(result: .success(v)) != nil {
						break
					}
				}
			}
			i.complete()
		}
	}
	
	/// Implementation of [Reactive X operator "Start"](http://reactivex.io/documentation/operators/start.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `f` will be evaluated (default: .direct).
	///   - f: a function that is run to generate the value.
	/// - Returns: a signal that emits a single value emitted from a function
	static func start(context: Exec = .direct, f: @escaping () -&gt; OutputValue) -&gt; Signal&lt;OutputValue&gt; {
		return Signal.generate(context: context) { input in
			guard let i = input else { return }
			i.send(value: f())
			i.complete()
		}
	}
	
	/// Implementation of [Reactive X operator "Timer"](http://reactivex.io/documentation/operators/timer.html)
	///
	/// - Parameters:
	///   - interval: the time until the value is sent.
	///   - value: the value that will be sent before closing the signal (if `nil` then the signal will simply be closed at the end of the timer)
	///   - context: execution context where the timer will be run
	/// - Returns: the timer signal
	static func timer(interval: DispatchTimeInterval, value: OutputValue? = nil, context: Exec = .global) -&gt; Signal&lt;OutputValue&gt; {
		var timer: Lifetime? = nil
		return Signal&lt;OutputValue&gt;.generate(context: context) { input in
			if let i = input {
				timer = context.singleTimer(interval: interval) {
					if let v = value {
						i.send(value: v)
					}
					i.complete()
				}
			} else {
				timer?.cancel()
			}
		}
	}
}
	
extension SignalInterface {
	/// A shared function for emitting a boundary signal usable by the timed, non-overlapping buffer/window functions buffer(timeshift:count:continuous:behavior:) or window(timeshift:count:continuous:behavior:)
	///
	/// - Parameters:
	///   - interval: maximum duration between boundaries
	///   - count: maximum number of signal values between boundaries
	///   - continuous: timer is paused immediately after a boundary until the next value is received
	///   - context: execution context where the timer will be run
	/// - Returns: the boundary signal
	private func timedCountedBoundary(interval: DispatchTimeInterval, count: Int, continuous: Bool, context: Exec) -&gt; Signal&lt;Void&gt; {
		// An interval signal
		let intSig = Signal.interval(interval, context: context)
		
		if count == Int.max {
			// If number of values per boundary is infinite, then all we need is the timer signal
			return intSig.map { v in () }
		}
		
		// The interval signal may need to be disconnectable so create a junction
		let intervalJunction = intSig.junction()
		let (initialInput, sig) = Signal&lt;Int&gt;.create()
		
		// Continuous signals don't really need the junction. Just connect it immediately and ignore it.
		if continuous {
			// Both `intervalJunction` and `initialInput` are newly created so this can't be an error
			try! intervalJunction.bind(to: initialInput)
		}
		
		return combine(sig, initialState: (0, nil)) { (state: inout (count: Int, timerInput: SignalInput&lt;Int&gt;?), cr: EitherResult2&lt;OutputValue, Int&gt;) -&gt; Signal&lt;Void&gt;.Next in
			var send = false
			switch cr {
			case .result1(.success):
				// Count the values received per window
				state.count += 1
				
				// If we hit `count` values, trigger the boundary signal
				if state.count == count {
					send = true
				} else if !continuous, let i = state.timerInput {
					// If we're not continuous, make sure the timer is connected
					do {
						try intervalJunction.bind(to: i)
					} catch {
						return .end(.other(error))
					}
				}
			case .result1(.failure(let e)):
				// If there's an error on the `self` signal, forward it on.
				return .end(e)
			case .result2(.success):
				// When the timer fires, trigger the boundary signal
				send = true
			case .result2(.failure(let e)):
				// If there's a timer error, close
				return .end(e)
			}
			
			if send {
				// Reset the count and â if not continuous â disconnect the timer until we receive a signal from `self`
				state.count = 0
				if !continuous {
					state.timerInput = intervalJunction.disconnect()
				}
				
				// Send the boundary signal
				return .value(())
			} else {
				return .none
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for non-overlapping/no-gap buffers.
	///
	/// - Parameter boundaries: when this `Signal` sends a value, the buffer is emitted and cleared
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `boundaries`
	func buffer&lt;Interface: SignalInterface&gt;(boundaries: Interface) -&gt; Signal&lt;[OutputValue]&gt; {
		return combine(boundaries, initialState: [OutputValue]()) { (buffer: inout [OutputValue], cr: EitherResult2&lt;OutputValue, Interface.OutputValue&gt;) -&gt; Signal&lt;[OutputValue]&gt;.Next in
			switch cr {
			case .result1(.success(let v)):
				buffer.append(v)
				return .none
			case .result1(.failure(let e)):
				let b = buffer
				buffer.removeAll()
				return .value(b, end: e)
			case .result2(.success):
				let b = buffer
				buffer.removeAll()
				return .value(b)
			case .result2(.failure(let e)):
				let b = buffer
				buffer.removeAll()
				return .value(b, end: e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for buffers with overlap or gaps between.
	///
	/// - Parameter windows: a "windows" signal (one that describes a series of times and durations). Each value `Signal` in the stream starts a new buffer and when the value `Signal` closes, the buffer is emitted.
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func buffer&lt;Interface: SignalInterface&gt;(windows: Interface) -&gt; Signal&lt;[OutputValue]&gt; where Interface.OutputValue: SignalInterface {
		return combine(windows.valueDurations { s in s }, initialState: [Int: [OutputValue]]()) { (buffers: inout [Int: [OutputValue]], cr: EitherResult2&lt;OutputValue, (Int, Interface.OutputValue?)&gt;) -&gt; Signal&lt;[OutputValue]&gt;.Next in
			switch cr {
			case .result1(.success(let v)):
				for index in buffers.keys {
					buffers[index]?.append(v)
				}
				return .none
			case .result1(.failure(let e)):
				let values = buffers.map { $0.1 }
				buffers.removeAll()
				return .values(sequence: values, end: e)
			case .result2(.success(let index, .some)):
				buffers[index] = []
				return .none
			case .result2(.success(let index, .none)):
				if let b = buffers[index] {
					buffers.removeValue(forKey: index)
					return .value(b)
				}
				return .none
			case .result2(.failure(let e)):
				let values = buffers.map { $0.1 }
				buffers.removeAll()
				return .values(sequence: values, end: e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for buffers of fixed length and a fixed number of values separating starts.
	///
	/// - Parameters:
	///   - count: the number of separate values to accumulate before emitting an array of values
	///   - skip: the stride between the start of each new buffer (can be smaller than `count`, resulting in overlapping buffers)
	/// - Returns: a signal where the values are arrays of length `count` of values from `self`, with start values separated by `skip`
	func buffer(count: UInt, skip: UInt) -&gt; Signal&lt;[OutputValue]&gt; {
		if count == 0 {
			return Signal&lt;[OutputValue]&gt;.preclosed()
		}
		
		let multi = multicast()
		
		// Create the two listeners to the "multi" signal carefully so that the window signal is *first* (so it reaches the buffer before the value signal)
		let windowSignal = multi.stride(count: Int(skip)).map { _ in
			// `count - 1` is the index of the count-th element but since `valuesSignal` will resolve before this, we need to fire 1 element sooner, hence `count - 2`
			multi.elementAt(count - 2).ignoreElements(outputType: OutputValue.self)
		}
		
		return multi.buffer(windows: windowSignal)
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for non-overlapping, periodic buffer start times and possibly limited buffer sizes.
	///
	/// - Parameters:
	///   - interval: number of seconds between the start of each buffer
	///   - count: the number of separate values to accumulate before emitting an array of values
	///   - continuous: if `true` (default), the `timeshift` periodic timer runs continuously (empty buffers may be emitted if a timeshift elapses without any source signals). If `false`, the periodic timer does start until the first value is received from the source and the periodic timer is paused when a buffer is emitted.
	///   - context: context where the timer will be run
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows
	func buffer(interval: DispatchTimeInterval, count: Int = Int.max, continuous: Bool = true, context: Exec = .direct) -&gt; Signal&lt;[OutputValue]&gt; {
		let multi = multicast()
		
		// Create the two listeners to the "multi" signal carefully so that the raw signal is *first* (so it reaches the buffer before the boundary signal)
		let valuesSignal = multi.map { v in v }
		let boundarySignal = multi.timedCountedBoundary(interval: interval, count: count, continuous: continuous, context: context)
		
		return valuesSignal.buffer(boundaries: boundarySignal)
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for non-overlapping buffers of fixed length.
	///
	/// - Note: this is just a convenience wrapper around `buffer(count:skip:)` where `skip` equals `count`.
	///
	/// - Parameter count: the number of separate values to accumulate before emitting an array of values
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `count`
	func buffer(count: UInt) -&gt; Signal&lt;[OutputValue]&gt; {
		return buffer(count: count, skip: count)
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for periodic buffer start times and fixed duration buffers.
	///
	/// - Note: this is just a convenience wrapper around `buffer(windows:behaviors)` where the `windows` signal contains `timerSignal` signals contained in a `Signal.interval` signal.
	///
	/// - Parameters:
	///   - interval: the duration of each buffer, in seconds.
	///   - timeshift: the number of seconds between the start of each buffer (if smaller than `interval`, buffers will overlap).
	///   - context: context where the timer will be run
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func buffer(interval: DispatchTimeInterval, timeshift: DispatchTimeInterval, context: Exec = .direct) -&gt; Signal&lt;[OutputValue]&gt; {
		return buffer(windows: Signal.interval(timeshift, initial: .seconds(0), context: context).map { v in Signal&lt;Void&gt;.timer(interval: interval, context: context) })
	}
	
	/// Implementation of map and filter. Essentially a flatMap but instead of flattening over child `Signal`s like the standard Reactive implementation, this flattens over child `Optional`s.
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func compact&lt;U&gt;() -&gt; Signal&lt;U&gt; where OutputValue == Optional&lt;U&gt; {
		return transform() { (r: Result&lt;Optional&lt;U&gt;, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			switch r {
			case .success(.some(let v)): return .value(v)
			case .success: return .none
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of map and filter. Essentially a flatMap but instead of flattening over child `Signal`s like the standard Reactive implementation, this flattens over child `Optional`s.
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func compactMap&lt;U&gt;(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -&gt; U?) -&gt; Signal&lt;U&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			switch r {
			case .success(let v):
				do {
					if let u = try processor(v) {
						return .value(u)
					}
					return .none
				} catch {
					return .end(.other(error))
				}
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of map and filter. Essentially a flatMap but instead of flattening over child `Signal`s like the standard Reactive implementation, this flattens over child `Optional`s.
	///
	/// - Parameters:
	///   - initialState: an initial value for a state parameter that will be passed to the processor on each iteration.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func compactMap&lt;S, U&gt;(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, OutputValue) throws -&gt; U?) -&gt; Signal&lt;U&gt; {
		return transform(initialState: initialState, context: context) { (s: inout S, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			switch r {
			case .success(let v):
				do {
					if let u = try processor(&amp;s, v) {
						return .value(u)
					}
					return .none
				} catch {
					return .end(.other(error))
				}
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// An implementation of compactMap that allows the "activation" values of the sequence to be mapped using a different function.
	///
	/// - Parameters:
	///   - select: chooses which parts of the activation sequence (first value, last value or all values) should be passed through the `activation` function (NOTE: if `.last` is used, all but the most recent value is discarded). Default: `.all`
	///   - context: the `Exec` where `activation` will be evaluated (default: .direct).
	///   - activation: processing closure for activation values
	///   - remainder: processing closure for all `normal` values (and activation values after the first, if `.first` is passed as the `select` argument)
	/// - Returns: a `Signal` where all the activation values have been transformed by `activation` and all other values have been transformed by `remained`. Any error is emitted in the output without change.
	func compactMapActivation&lt;U&gt;(select: SignalActivationSelection = .all, context: Exec = .direct, activation: @escaping (OutputValue) throws -&gt; U?, remainder: @escaping (OutputValue) throws -&gt; U?) -&gt; Signal&lt;U&gt; {
		
		let preceeding: Signal&lt;OutputValue&gt;
		if case .all = select {
			preceeding = self.signal
		} else {
			preceeding = self.capture().resume(resend: select)
		}
		
		return preceeding.transformActivation(
			context: context,
			activation: { result in
				switch result {
				case .success(let v):
					do {
						if let u = try activation(v) {
							return .value(u)
						}
						return .none
					} catch {
						return .end(.other(error))
					}
				case .failure(let e): return .end(e)
				}
			}
		) { result in
			switch result {
			case .success(let v):
				do {
					if let u = try remainder(v) {
						return .value(u)
					}
					return .none
				} catch {
					return .end(.other(error))
				}
			case .failure(let e): return .end(e)
			}
		}
	}

	/// A specialized implementation of `compactMapActivation` that processes only activation values (remaining values are simply passed through). A consequence is that input and output values must have the same type (unlike the unspecialized version which can map onto a different type).
	///
	/// - Parameters:
	///   - select: chooses which parts of the activation sequence (first value, last value or all values) should be passed through the `activation` function (NOTE: if `.last` is used, all but the most recent value is discarded). Default: `.all`.
	///   - context: the `Exec` where `activation` will be evaluated (default: .direct).
	///   - activation: processing closure for activation values
	/// - Returns: a `Signal` where all the activation values have been transformed by `activation` and all other values have been transformed by `remained`. Any error is emitted in the output without change.
	func compactMapActivation(select: SignalActivationSelection = .all, context: Exec = .direct, activation: @escaping (OutputValue) throws -&gt; OutputValue?) -&gt; Signal&lt;OutputValue&gt; {
		return compactMapActivation(select: select, context: context, activation: activation, remainder: { value in value })		
	}
	
	/// Implementation of [Reactive X operator "FlatMap"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatten&lt;Interface: SignalInterface&gt;() -&gt; Signal&lt;Interface.OutputValue&gt; where OutputValue == Interface {
		return transformFlatten(closePropagation: .errors) { (v: OutputValue, mergedInput: SignalMergedInput&lt;Interface.OutputValue&gt;) in
			mergedInput.add(v, closePropagation: .errors, removeOnDeactivate: true)
		}
	}
	
	/// Implementation of [Reactive X operator "FlatMap"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatMap&lt;Interface: SignalInterface&gt;(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -&gt; Interface) -&gt; Signal&lt;Interface.OutputValue&gt; {
		return transformFlatten(closePropagation: .errors, context: context) { (v: OutputValue, mergedInput: SignalMergedInput&lt;Interface.OutputValue&gt;) in
			mergedInput.add(try processor(v), closePropagation: .errors, removeOnDeactivate: true)
		}
	}
	
	/// Implementation of [Reactive X operator "FlatMapFirst"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatMapFirst&lt;Interface: SignalInterface&gt;(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -&gt; Interface) -&gt; Signal&lt;Interface.OutputValue&gt; {
		return transformFlatten(initialState: false, closePropagation: .errors, context: context) { (s: inout Bool, v: OutputValue, mergedInput: SignalMergedInput&lt;Interface.OutputValue&gt;) in
			if !s {
				mergedInput.add(try processor(v), closePropagation: .errors, removeOnDeactivate: true)
				s = true
			}
		}
	}
	
	/// Implementation of [Reactive X operator "FlatMapLatest"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// See also `switchLatest`
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatMapLatest&lt;Interface: SignalInterface&gt;(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -&gt; Interface) -&gt; Signal&lt;Interface.OutputValue&gt; {
		return transformFlatten(initialState: nil, closePropagation: .errors, context: context) { (s: inout Signal&lt;Interface.OutputValue&gt;?, v: OutputValue, mergedInput: SignalMergedInput&lt;Interface.OutputValue&gt;) in
			if let existing = s {
				mergedInput.remove(existing)
			}
			let next = try processor(v).signal
			mergedInput.add(next, closePropagation: .errors, removeOnDeactivate: true)
			s = next
		}
	}
	
	/// Implementation of [Reactive X operator "FlatMap"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - initialState: an initial value for a state parameter that will be passed to the processor on each iteration.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatMap&lt;Interface: SignalInterface, V&gt;(initialState: V, context: Exec = .direct, _ processor: @escaping (inout V, OutputValue) throws -&gt; Interface) -&gt; Signal&lt;Interface.OutputValue&gt; {
		return transformFlatten(initialState: initialState, closePropagation: .errors, context: context) { (s: inout V, v: OutputValue, mergedInput: SignalMergedInput&lt;Interface.OutputValue&gt;) in
			mergedInput.add(try processor(&amp;s, v), closePropagation: .errors, removeOnDeactivate: true)
		}
	}
	
	/// Implementation of [Reactive X operator "ConcatMap"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is serially concatenated into a single stream
	func concatMap&lt;Interface: SignalInterface&gt;(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -&gt; Interface) -&gt; Signal&lt;Interface.OutputValue&gt; {
		return transformFlatten(initialState: 0, closePropagation: .errors, context: context) { (index: inout Int, v: OutputValue, mergedInput: SignalMergedInput&lt;(Int, Result&lt;Interface.OutputValue, SignalEnd&gt;)&gt;) in
			mergedInput.add(try processor(v).transform { (r: Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; Signal&lt;Result&lt;Interface.OutputValue, SignalEnd&gt;&gt;.Next in
				switch r {
				case .success:
					return .value(r)
				case .failure(let e):
					return .value(r, end: e)
				}
			}.map { [index] (r: Result&lt;Interface.OutputValue, SignalEnd&gt;) -&gt; (Int, Result&lt;Interface.OutputValue, SignalEnd&gt;) in (index, r) }, closePropagation: .errors, removeOnDeactivate: true)
			index += 1
		}.transform(initialState: (0, Array&lt;Array&lt;Result&lt;Interface.OutputValue, SignalEnd&gt;&gt;&gt;())) { (state: inout (completed: Int, buffers: Array&lt;Array&lt;Result&lt;Interface.OutputValue, SignalEnd&gt;&gt;&gt;), result: Result&lt;(Int, Result&lt;Interface.OutputValue, SignalEnd&gt;), SignalEnd&gt;) -&gt; Signal&lt;Interface.OutputValue&gt;.Next in
			switch result {
			case .success(let index, .success(let v)):
				// We can send results for the first incomplete signal without buffering
				if index == state.completed {
					return .value(v)
				} else {
					// Make sure we have enough buffers
					while index &gt;= state.buffers.count {
						state.buffers.append([])
					}
					
					// Buffer the result
					state.buffers[index].append(Result&lt;Interface.OutputValue, SignalEnd&gt;.success(v))
					return .none
				}
			case .success(let index, .failure(let e)):
				// If its an error, try to send some more buffers
				if index == state.completed {
					state.completed += 1
					var results = [Signal&lt;Interface.OutputValue&gt;.Result]()
					for i in state.completed..&lt;state.buffers.count {
						for j in state.buffers[i] where !j.isFailure {
							results.append(j)
						}
						
						let incomplete = state.buffers[i].last?.isFailure != true
						state.buffers[i].removeAll()
						if incomplete {
							break
						}
						state.completed += 1
					}
					return .array(results)
				} else {
					// If we're not up to that buffer, just record the error
					state.buffers[index].append(Result&lt;Interface.OutputValue, SignalEnd&gt;.failure(e))
					return .none
				}
			case .failure(let error): return .end(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "GroupBy"](http://reactivex.io/documentation/operators/groupby.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs the "key" for the output `Signal`
	/// - Returns: a parent `Signal` where values are tuples of a "key" and a child `Signal` that will contain all values from `self` associated with that "key".
	func groupBy&lt;U: Hashable&gt;(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -&gt; U) -&gt; Signal&lt;(U, Signal&lt;OutputValue&gt;)&gt; {
		return self.transform(initialState: Dictionary&lt;U, SignalInput&lt;OutputValue&gt;&gt;(), context: context) { (outputs: inout Dictionary&lt;U, SignalInput&lt;OutputValue&gt;&gt;, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;(U, Signal&lt;OutputValue&gt;)&gt;.Next in
			switch r {
			case .success(let v):
				do {
					let u = try processor(v)
					if let o = outputs[u] {
						o.send(value: v)
						return .none
					} else {
						let (input, preCachedSignal) = Signal&lt;OutputValue&gt;.create()
						let s = preCachedSignal.cacheUntilActive()
						input.send(value: v)
						outputs[u] = input
						return .value((u, s))
					}
				} catch {
					return .error(error)
				}
			case .failure(let e):
				outputs.forEach { tuple in tuple.value.send(end: e) }
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html)
	///
	/// - Parameters:
	///   - keyPath: selects a child value to emit
	/// - Returns: a `Signal` where all the values have been transformed by the key path.
	func keyPath&lt;U&gt;(_ keyPath: KeyPath&lt;OutputValue, U&gt;) -&gt; Signal&lt;U&gt; {
		return transform { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			switch r {
			case .success(let v): return .value(v[keyPath: keyPath])
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a value for the output `Signal`
	/// - Returns: a `Signal` where all the values have been transformed by the `processor`. Any error is emitted in the output without change.
	func map&lt;U&gt;(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -&gt; U) -&gt; Signal&lt;U&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			switch r {
			case .success(let v): return .single(Result&lt;U, Error&gt; { try processor(v) }.mapError(SignalEnd.other))
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html)
	///
	/// - Parameters:
	///   - initialState: an initial value for a state parameter that will be passed to the processor on each iteration.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a value for the output `Signal`
	/// - Returns: a `Signal` where all the values have been transformed by the `processor`. Any error is emitted in the output without change.
	func map&lt;U, V&gt;(initialState: V, context: Exec = .direct, _ processor: @escaping (inout V, OutputValue) throws -&gt; U) -&gt; Signal&lt;U&gt; {
		return transform(initialState: initialState, context: context) { (s: inout V, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			switch r {
			case .success(let v): return .single(Result&lt;U, Error&gt; { try processor(&amp;s, v) }.mapError(SignalEnd.other))
			case .failure(let e): return .end(e)
			}
		}
	}

	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html) that offers a separate transformation for "activation" values.
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - activation: processing closure for activation values
	///   - remainder: processing closure for all normal (non-activation) values
	/// - Returns: a `Signal` where all the activation values have been transformed by `activation` and all other values have been transformed by `remained`. Any error is emitted in the output without change.
	func mapActivation&lt;U&gt;(select: SignalActivationSelection, context: Exec = .direct, activation: @escaping (OutputValue) throws -&gt; U, remainder: @escaping (OutputValue) throws -&gt; U) -&gt; Signal&lt;U&gt; {
		return compactMapActivation(select: select, context: context, activation: activation, remainder: remainder)
	}
	
	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: used to transform the closing error 
	/// - Returns: when an error is emitted from `self`, emits the result returned from passing that error into `processor`. All values emitted normally.
	func mapErrors(context: Exec = .direct, _ processor: @escaping (SignalEnd) -&gt; SignalEnd) -&gt; Signal&lt;OutputValue&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v): return .value(v)
			case .failure(let e): return .end(processor(e))
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Scan"](http://reactivex.io/documentation/operators/scan.html)
	///
	/// See also: `Signal.reduce` which returns a `SignalMulti` and whose processor has the signature `(inout U, OutputValue) -&gt; Void` to make in-place transformations easier.
	/// See also: `aggregate` which performs the equivalent of scan over the entire sequence before emitting a single value.
	///
	/// - Parameters:
	///   - initialState: an initial value for a state parameter that will be passed to the processor on each iteration.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: takes the most recently emitted value and the most recent value from `self` and returns the next emitted value
	/// - Returns: a `Signal` where the result from each invocation of `processor` are emitted
	func scan&lt;U&gt;(initialState: U, context: Exec = .direct, _ processor: @escaping (U, OutputValue) throws -&gt; U) -&gt; Signal&lt;U&gt; {
		return transform(initialState: initialState, context: context) { (accumulated: inout U, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			switch r {
			case .success(let v):
				do {
					accumulated = try processor(accumulated, v)
					return .value(accumulated)
				} catch {
					return .error(error)
				}
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for non-overlapping/no-gap buffers.
	///
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameter boundaries: when this `Signal` sends a value, the buffer is emitted and cleared
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `boundaries`
	func window&lt;Interface: SignalInterface&gt;(boundaries: Interface) -&gt; Signal&lt;Signal&lt;OutputValue&gt;&gt; {
		return combine(boundaries, initialState: nil) { (current: inout SignalInput&lt;OutputValue&gt;?, cr: EitherResult2&lt;OutputValue, Interface.OutputValue&gt;) -&gt; Signal&lt;Signal&lt;OutputValue&gt;&gt;.Next in
			switch cr {
			case .result1(.success(let v)):
				if let c = current {
					c.send(value: v)
					return .none
				} else {
					let (i, s) = Signal&lt;OutputValue&gt;.create()
					current = i
					return .value(s.cacheUntilActive(precached: [v]))
				}
			case .result1(.failure(let e)):
				return .end(e)
			case .result2(.success):
				_ = current?.complete()
				current = nil
				return .none
			case .result2(.failure(let e)):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for buffers with overlap or gaps between.
	///
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameter windows: a "windows" signal (one that describes a series of times and durations). Each value `Signal` in the stream starts a new buffer and when the value `Signal` closes, the buffer is emitted.
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func window&lt;Interface: SignalInterface&gt;(windows: Interface) -&gt; Signal&lt;Signal&lt;OutputValue&gt;&gt; where Interface.OutputValue: SignalInterface {
		return combine(windows.valueDurations { s in s }, initialState: [Int: SignalInput&lt;OutputValue&gt;]()) { (children: inout [Int: SignalInput&lt;OutputValue&gt;], cr: EitherResult2&lt;OutputValue, (Int, Interface.OutputValue?)&gt;) -&gt; Signal&lt;Signal&lt;OutputValue&gt;&gt;.Next in
			switch cr {
			case .result1(.success(let v)):
				for index in children.keys {
					if let c = children[index] {
						c.send(value: v)
					}
				}
				return .none
			case .result1(.failure(let e)):
				return .end(e)
			case .result2(.success(let index, .some)):
				let (i, s) = Signal&lt;OutputValue&gt;.create()
				children[index] = i
				return .value(s)
			case .result2(.success(let index, .none)):
				if let c = children[index] {
					c.complete()
					children.removeValue(forKey: index)
				}
				return .none
			case .result2(.failure(let e)):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for buffers of fixed length and a fixed number of values separating starts.
	///
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameters:
	///   - count: the number of separate values to accumulate before emitting an array of values
	///   - skip: the stride between the start of each new buffer (can be smaller than `count`, resulting in overlapping buffers)
	/// - Returns: a signal where the values are arrays of length `count` of values from `self`, with start values separated by `skip`
	func window(count: UInt, skip: UInt) -&gt; Signal&lt;Signal&lt;OutputValue&gt;&gt; {
		let multi = multicast()
		
		// Create the two listeners to the "multi" signal carefully so that the window signal is *first* (so it reaches the buffer before the value signal)
		let windowSignal = multi.stride(count: Int(skip)).map { v in
			// `count - 1` is the index of the count-th element but since `valuesSignal` will resolve before this, we need to fire 1 element sooner, hence `count - 2`
			multi.elementAt(count - 2).ignoreElements(outputType: OutputValue.self)
		}
		
		return multi.window(windows: windowSignal)
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for non-overlapping, periodic buffer start times and possibly limited buffer sizes.
	///
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameters:
	///   - interval: the number of seconds between the start of each buffer
	///   - count: the number of separate values to accumulate before emitting an array of values
	///   - continuous: if `true` (default), the `timeshift` periodic timer runs continuously (empty buffers may be emitted if a timeshift elapses without any source signals). If `false`, the periodic timer does start until the first value is received from the source and the periodic timer is paused when a buffer is emitted.
	///   - context: context where the timer will run
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func window(interval: DispatchTimeInterval, count: Int = Int.max, continuous: Bool = true, context: Exec = .direct) -&gt; Signal&lt;Signal&lt;OutputValue&gt;&gt; {
		let multi = multicast()
		
		// Create the two listeners to the "multi" signal carefully so that the raw signal is *first* (so it reaches the buffer before the boundary signal)
		let valuesSignal = multi.map { v in v }
		let boundarySignal = multi.timedCountedBoundary(interval: interval, count: count, continuous: continuous, context: context)
		
		return valuesSignal.window(boundaries: boundarySignal)
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for non-overlapping buffers of fixed length.
	///
	/// - Note: this is just a convenience wrapper around `buffer(count:skip:behavior)` where `skip` equals `count`.
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameter count: the number of separate values to accumulate before emitting an array of values
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `count`
	func window(count: UInt) -&gt; Signal&lt;Signal&lt;OutputValue&gt;&gt; {
		return window(count: count, skip: count)
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for periodic buffer start times and fixed duration buffers.
	///
	/// - Note: this is just a convenience wrapper around `buffer(windows:behaviors)` where the `windows` signal contains `timerSignal` signals contained in a `Signal.interval` signal.
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameters:
	///   - interval: the duration of each buffer, in seconds
	///   - timeshift: the number of seconds between the start of each buffer (if smaller than `interval`, buffers will overlap).
	///   - context: context where the timer will run
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func window(interval: DispatchTimeInterval, timeshift: DispatchTimeInterval, context: Exec = .direct) -&gt; Signal&lt;Signal&lt;OutputValue&gt;&gt; {
		return window(windows: Signal.interval(timeshift, initial: .seconds(0), context: context).map { v in Signal&lt;Void&gt;.timer(interval: interval, context: context) })
	}
	
	/// Implementation of [Reactive X operator "Debounce"](http://reactivex.io/documentation/operators/debounce.html)
	///
	/// - Parameters:
	///   - interval: the duration over which to drop values.
	///   - flushOnClose: if true, then any buffered value is sent before closing, if false (default) then the buffered value is discarded when a close occurs
	///   - context: context where the timer will run
	/// - Returns: a signal where values are emitted after a `interval` but only if no another value occurs during that `interval`.
	func debounce(interval: DispatchTimeInterval, flushOnClose: Bool = false, context: Exec = .direct) -&gt; Signal&lt;OutputValue&gt; {
		let serialContext = context.serialized()
		let (mergedInput, signal) = Signal&lt;OutputValue&gt;.createMergedInput()
		let intermediate = transform(initialState: nil, context: serialContext) { (timer: inout Signal&lt;OutputValue&gt;?, result: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch result {
			case .success(let v):
				if let oldTimer = timer {
					mergedInput.remove(oldTimer)
				}
				let newTimer = Signal&lt;OutputValue&gt;.timer(interval: interval, value: v, context: serialContext)
				mergedInput.add(newTimer, closePropagation: .none, removeOnDeactivate: true)
				timer = newTimer
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
		mergedInput.add(intermediate, closePropagation: .all, removeOnDeactivate: false)
		return signal
	}
	
	/// Implementation of [Reactive X operator "throttleFirst"](http://reactivex.io/documentation/operators/sample.html)
	///
	/// - Note: this is largely the reverse of `debounce`.
	///
	/// - Parameters:
	///   - interval: the duration over which to drop values.
	///   - context: context where the timer will run
	/// - Returns: a signal where a timer is started when a value is received and emitted and further values received within that `interval` will be dropped.
	func throttleFirst(interval: DispatchTimeInterval, context: Exec = .direct) -&gt; Signal&lt;OutputValue&gt; {
		let timerQueue = context.serialized()
		var timer: Lifetime? = nil
		return transform(initialState: nil, context: timerQueue) { (cleanup: inout OnDelete?, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			cleanup = cleanup ?? OnDelete {
				timer = nil
			}
			
			switch r {
			case .failure(let e):
				return .end(e)
			case .success(let v) where timer == nil:
				timer = timerQueue.singleTimer(interval: interval) {
					timer = nil
				}
				return .value(v)
			case .success: return .none
			}
		}
	}
}

extension SignalInterface where OutputValue: Hashable {
	/// Implementation of [Reactive X operator "distinct"](http://reactivex.io/documentation/operators/distinct.html)
	///
	/// - Returns: a signal where all values received are remembered and only values not previously received are emitted.
	func distinct() -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: Set&lt;OutputValue&gt;()) { (previous: inout Set&lt;OutputValue&gt;, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v):
				if !previous.contains(v) {
					previous.insert(v)
					return .value(v)
				}
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
}

extension SignalInterface where OutputValue: Equatable {
	/// Implementation of [Reactive X operator "distinct"](http://reactivex.io/documentation/operators/distinct.html)
	///
	/// - Returns: a signal that emits the first value but then emits subsequent values only when they are different to the previous value.
	func distinctUntilChanged() -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: nil) { (previous: inout OutputValue?, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v):
				if previous != v {
					previous = v
					return .value(v)
				}
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "distinct"](http://reactivex.io/documentation/operators/distinct.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `comparator` will be evaluated (default: .direct).
	///   - comparator: a function taking two parameters (the previous and current value in the signal) which should return `false` to indicate the current value should be emitted.
	/// - Returns: a signal that emits the first value but then emits subsequent values only if the function `comparator` returns `false` when passed the previous and current values.
	func distinctUntilChanged(context: Exec = .direct, compare: @escaping (OutputValue, OutputValue) throws -&gt; Bool) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: nil) { (previous: inout OutputValue?, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v):
				do {
					if let p = previous, try compare(p, v) {
						previous = v
						return .none
					} else {
						previous = v
						return .value(v)
					}
				} catch {
					return .error(error)
				}
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "elementAt"](http://reactivex.io/documentation/operators/elementat.html)
	///
	/// - Parameter index: identifies the element to be emitted.
	/// - Returns: a signal that emits the zero-indexed element identified by `index` and then closes.
	func elementAt(_ index: UInt) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: 0, context: .direct) { (curr: inout UInt, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v) where curr == index:
				return .value(v, end: .complete)
			case .success:
				curr += 1
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "filter"](http://reactivex.io/documentation/operators/filter.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `matching` will be evaluated (default: .direct).
	///   - matching: a function which is passed the current value and should return `true` to indicate the value should be emitted.
	/// - Returns: a signal that emits received values only if the function `matching` returns `true` when passed the value.
	func filter(context: Exec = .direct, matching: @escaping (OutputValue) throws -&gt; Bool) -&gt; Signal&lt;OutputValue&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			do {
				switch r {
				case .success(let v) where try matching(v): return .value(v)
				case .success: return .none
				case .failure(let e): return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "ofType"](http://reactivex.io/documentation/operators/filter.html)
	///
	/// - Parameters:
	///   - type: values will be filtered to this type (NOTE: only the *static* type of this parameter is considered â if the runtime type is more specific, that will be ignored).
	/// - Returns: a signal that emits received values only if the value can be dynamically cast to the type `U`, specified statically by `type`.
	func ofType&lt;U&gt;(_ type: U.Type) -&gt; Signal&lt;U&gt; {
		return self.transform(initialState: 0) { (curr: inout Int, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			switch r {
			case .success(let v as U): return .value(v)
			case .success: return .none
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "first"](http://reactivex.io/documentation/operators/first.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `matching` will be evaluated (default: .direct).
	///   - matching: run for each value until it returns `true`
	/// - Returns: a signal that, when an error is received, emits the first value (if any) in the signal where `matching` returns `true` when invoked with the value, followed by the error.
	func first(context: Exec = .direct, matching: @escaping (OutputValue) throws -&gt; Bool = { _ in true }) -&gt; Signal&lt;OutputValue&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			do {
				switch r {
				case .success(let v) where try matching(v): return .value(v, end: .complete)
				case .success: return .none
				case .failure(let e): return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "single"](http://reactivex.io/documentation/operators/first.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `matching` will be evaluated (default: .direct).
	///   - matching: run for each value
	/// - Returns: a signal that, if a single value in the sequence, when passed to `matching` returns `true`, then that value will be returned, followed by a SignalEnd.complete when the input signal closes (otherwise a SignalEnd.complete will be emitted without emitting any prior values).
	func single(context: Exec = .direct, matching: @escaping (OutputValue) throws -&gt; Bool = { _ in true }) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: nil, context: context) { (state: inout (firstMatch: OutputValue, unique: Bool)?, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			do {
				switch r {
				case .success(let v) where try matching(v):
					if let s = state {
						state = (firstMatch: s.firstMatch, unique: false)
					} else {
						state = (firstMatch: v, unique: true)
					}
					return .none
				case .success:
					return .none
				case .failure(let e):
					if let s = state, s.unique == true {
						return .value(s.firstMatch, end: e)
					} else {
						return .end(e)
					}
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "ignoreElements"](http://reactivex.io/documentation/operators/ignoreelements.html)
	///
	/// - Returns: a signal that emits the input error, when received, otherwise ignores all values.
	func ignoreElements&lt;U&gt;(outputType: U.Type = U.self) -&gt; Signal&lt;U&gt; {
		return transform { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			if case .failure(let e) = r {
				return .end(e)
			} else {
				return .none
			}
		}
	}
	
	/// Implementation of [Reactive X operator "last"](http://reactivex.io/documentation/operators/last.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `matching` will be evaluated (default: .direct).
	///   - matching: run for each value
	/// - Returns: a signal that, when an error is received, emits the last value (if any) in the signal where `matching` returns `true` when invoked with the value, followed by the error.
	func last(context: Exec = .direct, matching: @escaping (OutputValue) throws -&gt; Bool = { _ in true }) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: nil, context: context) { (last: inout OutputValue?, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			do {
				switch r {
				case .success(let v) where try matching(v):
					last = v
					return .none
				case .success:
					return .none
				case .failure(let e):
					if let l = last {
						return .value(l, end: e)
					} else {
						return .end(e)
					}
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "sample"](http://reactivex.io/documentation/operators/sample.html)
	///
	/// See also: `debounce` is the equivalent where the sampling interval is time based
	/// See also: `withLatestFrom` always emits, even when the sampled signal hasn't emitted another value during the interval
	///
	/// - Parameter trigger: instructs the result to emit the last value from `self`
	/// - Returns: a signal that, when a value is received from `trigger`, emits the last value (if any) received from `self`.
	func sample&lt;Interface: SignalInterface&gt;(_ trigger: Interface) -&gt; Signal&lt;OutputValue&gt; {
		return combine(trigger, initialState: nil, context: .direct) { (last: inout OutputValue?, c: EitherResult2&lt;OutputValue, Interface.OutputValue&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch (c, last) {
			case (.result1(.success(let v)), _):
				last = v
				return .none
			case (.result1(.failure(let e)), _):
				return .end(e)
			case (.result2(.success), .some(let l)):
				last = nil
				return .value(l)
			case (.result2(.success), _):
				return .none
			case (.result2(.failure(let e)), _):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "sample"](http://reactivex.io/documentation/operators/sample.html)
	///
	/// - Parameter trigger: instructs the result to emit the last value from `self`
	/// - Returns: a signal that, when a value is received from `trigger`, emits the last value (if any) received from `self`.
	func throttleFirst&lt;Interface: SignalInterface&gt;(_ trigger: Interface) -&gt; Signal&lt;OutputValue&gt; {
		return combine(trigger, initialState: nil, context: .direct) { (last: inout OutputValue?, c: EitherResult2&lt;OutputValue, Interface.OutputValue&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch (c, last) {
			case (.result1(.success(let v)), nil):
				last = v
				return .none
			case (.result1(.success), _):
				return .none
			case (.result1(.failure(let e)), _):
				return .end(e)
			case (.result2(.success), .some(let l)):
				last = nil
				return .value(l)
			case (.result2(.success), _):
				return .none
			case (.result2(.failure(let e)), _):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "skip"](http://reactivex.io/documentation/operators/skip.html)
	///
	/// - Parameter count: the number of values from the start of `self` to drop
	/// - Returns: a signal that drops `count` values from `self` then mirrors `self`.
	func skip(_ count: Int) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: 0) { (progressCount: inout Int, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v) where progressCount &gt;= count: return .value(v)
			case .success:
				progressCount = progressCount + 1
				return .none
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "skipLast"](http://reactivex.io/documentation/operators/skiplast.html)
	///
	/// - Parameter count: the number of values from the end of `self` to drop
	/// - Returns: a signal that buffers `count` values from `self` then for each new value received from `self`, emits the oldest value in the buffer. When `self` closes, all remaining values in the buffer are discarded.
	func skipLast(_ count: Int) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: Array&lt;OutputValue&gt;()) { (buffer: inout Array&lt;OutputValue&gt;, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v):
				buffer.append(v)
				if buffer.count &gt; count {
					return .value(buffer.removeFirst())
				} else {
					return .none
				}
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "skip"](http://reactivex.io/documentation/operators/skip.html)
	///
	/// - Parameter count: the number of values from the start of `self` to emit
	/// - Returns: a signal that emits `count` values from `self` then closes.
	func take(_ count: Int) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: 0) { (progressCount: inout Int, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			progressCount = progressCount + 1
			switch r {
			case .success(let v) where progressCount &gt;= count: return .value(v, end: .complete)
			case .success(let v): return .value(v)
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "skipLast"](http://reactivex.io/documentation/operators/skiplast.html)
	///
	/// - Parameter count: the number of values from the end of `self` to emit
	/// - Returns: a signal that buffers `count` values from `self` then for each new value received from `self`, drops the oldest value in the buffer. When `self` closes, all values in the buffer are emitted, followed by the close.
	func takeLast(_ count: Int) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: Array&lt;OutputValue&gt;()) { (buffer: inout Array&lt;OutputValue&gt;, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v):
				buffer.append(v)
				if buffer.count &gt; count {
					buffer.removeFirst()
				}
				return .none
			case .failure(let e):
				return .values(sequence: buffer, end: e)
			}
		}
	}
}

extension SignalInterface {
	/// - Note: the [Reactive X operators "And", "Then" and "When"](http://reactivex.io/documentation/operators/and-then-when.html) are considered unnecessary, given the slightly different implementation of `CwlSignal.Signal.zip` which produces tuples (rather than producing a non-structural type) and is hence equivalent to `and`+`then`.
}

extension SignalInterface {
	/// Implementation similar to [Reactive X operator "sample"](http://reactivex.io/documentation/operators/sample.html) except that the output is sent every time self emits, not just when sample has changed since self last emitted.
	///
	/// See also: `combineLatest`, `sample` and `throttleFirst` which have similar but slightly different emitting scenarios.
	///
	/// - Parameter sample: the latest value from this signal will be emitted whenever `self` emits
	/// - Returns: a signal that emits the latest value from `sample` each time `self` emits
	func withLatestFrom&lt;Interface: SignalInterface&gt;(_ sample: Interface) -&gt; Signal&lt;Interface.OutputValue&gt; {
		return combine(sample, initialState: nil, context: .direct) { (last: inout Interface.OutputValue?, c: EitherResult2&lt;OutputValue, Interface.OutputValue&gt;) -&gt; Signal&lt;Interface.OutputValue&gt;.Next in
			switch (c, last) {
			case (.result1(.success), .some(let l)): return .value(l)
			case (.result1(.success), _): return .none
			case (.result1(.failure(let e)), _): return .end(e)
			case (.result2(.success(let v)), _):
				last = v
				return .none
			case (.result2(.failure(let e)), _): return .end(e)
			}
		}
	}
	
	/// Implementation similar to [Reactive X operator "sample"](http://reactivex.io/documentation/operators/sample.html) except that a function is run to generate the emitted value each time self emits. The function is passed the value emitted from `self` and the last emitted value from the `sample` signal parameter.
	///
	/// See also: `combineLatest`, `sample` and `throttleFirst` which have similar but slightly different emitting scenarios.
	///
	/// - Parameter sample: a signal whose latest value will be used each time `self` emits
	/// - Parameter processor: produces the outputs values
	/// - Returns: a signal that, when a value is received from `trigger`, emits the result or performing `processor`.
	func withLatestFrom&lt;Interface: SignalInterface, R&gt;(_ sample: Interface, context: Exec = .direct, _ processor: @escaping (OutputValue, Interface.OutputValue) throws -&gt; R) -&gt; Signal&lt;R&gt; {
		return combine(sample, initialState: nil, context: context) { (last: inout Interface.OutputValue?, c: EitherResult2&lt;OutputValue, Interface.OutputValue&gt;) -&gt; Signal&lt;R&gt;.Next in
			switch (c, last) {
			case (.result1(.success(let left)), .some(let right)):
				do {
					return .value(try processor(left, right))
				} catch {
					return .error(error)
				}
			case (.result1(.success), _): return .none
			case (.result1(.failure(let e)), _): return .end(e)
			case (.result2(.success(let v)), _):
				last = v
				return .none
			case (.result2(.failure(let e)), _): return .end(e)
			}
		}
	}

	/// Implementation of [Reactive X operator "combineLatest"](http://reactivex.io/documentation/operators/combinelatest.html) for two observed signals.
	///
	/// - Parameters:
	///   - second: an observed signal.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the most recent values of the observed signals (or nil if a signal has not yet emitted a value) when any of the observed signals emits a value
	/// - Returns: a signal that emits the values from the processor and closes when any of the observed signals closes
	func combineLatestWith&lt;U: SignalInterface, V&gt;(_ second: U, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue) throws -&gt; V) -&gt; Signal&lt;V&gt; {
		return combine(second, initialState: (nil, nil), context: context) { (state: inout (OutputValue?, U.OutputValue?), r: EitherResult2&lt;OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;V&gt;.Next in
			switch r {
			case .result1(.success(let v)): state = (v, state.1)
			case .result2(.success(let v)): state = (state.0, v)
			case .result1(.failure(let e)): return .end(e)
			case .result2(.failure(let e)): return .end(e)
			}
			if let v0 = state.0, let v1 = state.1 {
				do {
					return .value(try processor(v0, v1))
				} catch {
					return .error(error)
				}
			} else {
				return .none
			}
		}
	}

	@available(*, deprecated, message:"Renamed to combineLatestWith. Alternately, use static combineLatest function.")
	func combineLatest&lt;U: SignalInterface, V&gt;(_ second: U, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue) throws -&gt; V) -&gt; Signal&lt;V&gt; {
		return combineLatestWith(second, context: context, processor)
	}
	
	static func combineLatest&lt;U: SignalInterface, V&gt;(_ first: Self, _ second: U, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue) throws -&gt; V) -&gt; Signal&lt;V&gt; {
		return first.combineLatestWith(second, context: context, processor)
	}
	
	/// Implementation of [Reactive X operator "combineLatest"](http://reactivex.io/documentation/operators/combinelatest.html) for three observed signals.
	///
	/// - Parameters:
	///   - second: an observed signal.
	///   - third: an observed signal.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the most recent values of the observed signals (or nil if a signal has not yet emitted a value) when any of the observed signals emits a value
	/// - Returns: a signal that emits the values from the processor and closes when any of the observed signals closes
	func combineLatestWith&lt;U: SignalInterface, V: SignalInterface, W&gt;(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue) throws -&gt; W) -&gt; Signal&lt;W&gt; {
		return combine(second, third, initialState: (nil, nil, nil), context: context) { (state: inout (OutputValue?, U.OutputValue?, V.OutputValue?), r: EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;) -&gt; Signal&lt;W&gt;.Next in
			switch r {
			case .result1(.success(let v)): state = (v, state.1, state.2)
			case .result2(.success(let v)): state = (state.0, v, state.2)
			case .result3(.success(let v)): state = (state.0, state.1, v)
			case .result1(.failure(let e)): return .end(e)
			case .result2(.failure(let e)): return .end(e)
			case .result3(.failure(let e)): return .end(e)
			}
			if let v0 = state.0, let v1 = state.1, let v2 = state.2 {
				do {
					return .value(try processor(v0, v1, v2))
				} catch {
					return .error(error)
				}
			} else {
				return .none
			}
		}
	}

	@available(*, deprecated, message:"Renamed to combineLatestWith. Alternately, use static combineLatest function.")
	func combineLatest&lt;U: SignalInterface, V: SignalInterface, W&gt;(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue) throws -&gt; W) -&gt; Signal&lt;W&gt; {
		return combineLatestWith(second, third, context: context, processor)
	}
	
	static func combineLatest&lt;U: SignalInterface, V: SignalInterface, W&gt;(_ first: Self, _ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue) throws -&gt; W) -&gt; Signal&lt;W&gt; {
		return first.combineLatestWith(second, third, context: context, processor)
	}
	
	/// Implementation of [Reactive X operator "combineLatest"](http://reactivex.io/documentation/operators/combinelatest.html) for four observed signals.
	///
	/// - Note: support for multiple listeners and reactivation is determined by the specified `behavior`.
	///
	/// - Parameters:
	///   - second: an observed signal.
	///   - third: an observed signal.
	///   - fourth: an observed signal.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the most recent values of the observed signals (or nil if a signal has not yet emitted a value) when any of the observed signals emits a value
	/// - Returns: a signal that emits the values from the processor and closes when any of the observed signals closes
	func combineLatestWith&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue) throws -&gt; X) -&gt; Signal&lt;X&gt; {
		return combine(second, third, fourth, initialState: (nil, nil, nil, nil), context: context) { (state: inout (OutputValue?, U.OutputValue?, V.OutputValue?, W.OutputValue?), r: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;) -&gt; Signal&lt;X&gt;.Next in
			switch r {
			case .result1(.success(let v)): state = (v, state.1, state.2, state.3)
			case .result2(.success(let v)): state = (state.0, v, state.2, state.3)
			case .result3(.success(let v)): state = (state.0, state.1, v, state.3)
			case .result4(.success(let v)): state = (state.0, state.1, state.2, v)
			case .result1(.failure(let e)): return .end(e)
			case .result2(.failure(let e)): return .end(e)
			case .result3(.failure(let e)): return .end(e)
			case .result4(.failure(let e)): return .end(e)
			}
			if let v0 = state.0, let v1 = state.1, let v2 = state.2, let v3 = state.3 {
				do {
					return .value(try processor(v0, v1, v2, v3))
				} catch {
					return .error(error)
				}
			} else {
				return .none
			}
		}
	}

	@available(*, deprecated, message:"Renamed to combineLatestWith. Alternately, use static combineLatest function.")
	func combineLatest&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue) throws -&gt; X) -&gt; Signal&lt;X&gt; {
		return combineLatestWith(second, third, fourth, context: context, processor)
	}

	static func combineLatest&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(_ first: Self, _ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue) throws -&gt; X) -&gt; Signal&lt;X&gt; {
		return first.combineLatestWith(second, third, fourth, context: context, processor)
	}
	
	/// Implementation of [Reactive X operator "combineLatest"](http://reactivex.io/documentation/operators/combinelatest.html) for five observed signals.
	///
	/// - Note: support for multiple listeners and reactivation is determined by the specified `behavior`.
	///
	/// - Parameters:
	///   - second: an observed signal.
	///   - third: an observed signal.
	///   - fourth: an observed signal.
	///   - fifth: an observed signal.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the most recent values of the observed signals (or nil if a signal has not yet emitted a value) when any of the observed signals emits a value
	/// - Returns: a signal that emits the values from the processor and closes when any of the observed signals closes
	func combineLatestWith&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue) throws -&gt; Y) -&gt; Signal&lt;Y&gt; {
		return combine(second, third, fourth, fifth, initialState: (nil, nil, nil, nil, nil), context: context) { (state: inout (OutputValue?, U.OutputValue?, V.OutputValue?, W.OutputValue?, X.OutputValue?), r: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;) -&gt; Signal&lt;Y&gt;.Next in
			switch r {
			case .result1(.success(let v)): state = (v, state.1, state.2, state.3, state.4)
			case .result2(.success(let v)): state = (state.0, v, state.2, state.3, state.4)
			case .result3(.success(let v)): state = (state.0, state.1, v, state.3, state.4)
			case .result4(.success(let v)): state = (state.0, state.1, state.2, v, state.4)
			case .result5(.success(let v)): state = (state.0, state.1, state.2, state.3, v)
			case .result1(.failure(let e)): return .end(e)
			case .result2(.failure(let e)): return .end(e)
			case .result3(.failure(let e)): return .end(e)
			case .result4(.failure(let e)): return .end(e)
			case .result5(.failure(let e)): return .end(e)
			}
			if let v0 = state.0, let v1 = state.1, let v2 = state.2, let v3 = state.3, let v4 = state.4 {
				do {
					return .value(try processor(v0, v1, v2, v3, v4))
				} catch {
					return .error(error)
				}
			} else {
				return .none
			}
		}
	}

	@available(*, deprecated, message:"Renamed to combineLatestWith. Alternately, use static combineLatest function.")
	func combineLatest&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue) throws -&gt; Y) -&gt; Signal&lt;Y&gt; {
		return combineLatestWith(second, third, fourth, fifth, context: context, processor)
	}

	static func combineLatest&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y&gt;(_ first: Self, _ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue) throws -&gt; Y) -&gt; Signal&lt;Y&gt; {
		return first.combineLatestWith(second, third, fourth, fifth, context: context, processor)
	}
	
	static func combineLatest&lt;S: Sequence&gt;(sequence: S) -&gt; Signal&lt;[OutputValue]&gt; where S.Element: SignalInterface, OutputValue == S.Element.OutputValue {
		let array = Array(sequence)
		let count = array.count
		let indexed = Signal&lt;OutputValue&gt;.indexed(array)
		return indexed.transform(initialState: Array&lt;OutputValue?&gt;(repeating: nil, count: count)) { buffer, result in
			switch result {
			case .success((let offset, let element)):
				buffer[offset] = element
				let compacted = buffer.compactMap { $0 }
				guard compacted.count == count else { return .none }
				return .value(compacted)
			case .failure(let e): return .end(e)
			}
		}
	}

	static func combineLatest&lt;S: SignalInterface&gt;(_ signals: S...) -&gt; Signal&lt;[OutputValue]&gt; where OutputValue == S.OutputValue {
		return combineLatest(sequence: signals)
	}
	
	/// Implementation of [Reactive X operator "join"](http://reactivex.io/documentation/operators/join.html)
	///
	/// - Parameters:
	///   - withRight: an observed signal
	///   - leftEnd: function invoked when a value is received from `self`. The resulting signal is observed and the time until signal close is treated as a duration "window" that started with the received `self` value.
	///   - rightEnd: function invoked when a value is received from `right`. The resulting signal is observed and the time until signal close is treated as a duration "window" that started with the received `right` value.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the corresponding `left` and `right` values when a `left` value is emitted during a `right`-&gt;`rightEnd` window or a `right` value is received during a `left`-&gt;`leftEnd` window
	/// - Returns: a signal that emits the values from the processor and closes when any of the last of the observed windows closes.
	func intersect&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(withRight: U, leftEnd: @escaping (OutputValue) -&gt; V, rightEnd: @escaping (U.OutputValue) -&gt; W, context: Exec = .direct, _ processor: @escaping ((OutputValue, U.OutputValue)) -&gt; X) -&gt; Signal&lt;X&gt; {
		let leftDurations = valueDurations({ t in leftEnd(t).takeWhile { _ in false } })
		let rightDurations = withRight.valueDurations({ u in rightEnd(u).takeWhile { _ in false } })
		let a = leftDurations.combine(rightDurations, initialState: ([Int: OutputValue](), [Int: U.OutputValue]())) { (state: inout (activeLeft: [Int: OutputValue], activeRight: [Int: U.OutputValue]), cr: EitherResult2&lt;(Int, OutputValue?), (Int, U.OutputValue?)&gt;) -&gt; Signal&lt;(OutputValue, U.OutputValue)&gt;.Next in
			switch cr {
			case .result1(.success(let leftIndex, .some(let leftValue))):
				state.activeLeft[leftIndex] = leftValue
				return .array(state.activeRight.sorted { $0.0 &lt; $1.0 }.map { tuple in .success((leftValue, tuple.value)) })
			case .result2(.success(let rightIndex, .some(let rightValue))):
				state.activeRight[rightIndex] = rightValue
				return .array(state.activeLeft.sorted { $0.0 &lt; $1.0 }.map { tuple in .success((tuple.value, rightValue)) })
			case .result1(.success(let leftIndex, .none)):
				state.activeLeft.removeValue(forKey: leftIndex)
				return .none
			case .result2(.success(let rightIndex, .none)):
				state.activeRight.removeValue(forKey: rightIndex)
				return .none
			default:
				return .complete()
			}
		}
		return a.map(context: context, processor)
	}
	
	/// Implementation of [Reactive X operator "groupJoin"](http://reactivex.io/documentation/operators/join.html)
	///
	/// - Parameters:
	///   - withRight: an observed signal.
	///   - leftEnd: function invoked when a value is received from `self`. The resulting signal is observed and the time until signal close is treated as a duration "window" that started with the received `self` value.
	///   - rightEnd: function invoked when a value is received from `right`. The resulting signal is observed and the time until signal close is treated as a duration "window" that started with the received `right` value.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: when a `left` value is received, this function is invoked with the `left` value and a `Signal` that will emit all the `right` values encountered until the `left`-&gt;`leftEnd` window closes. The value returned by this function will be emitted as part of the `Signal` returned from `groupIntersect`.
	/// - Returns: a signal that emits the values from the processor and closes when any of the last of the observed windows closes.
	func groupIntersect&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X&gt;(withRight: U, leftEnd: @escaping (OutputValue) -&gt; V, rightEnd: @escaping (U.OutputValue) -&gt; W, context: Exec = .direct, _ processor: @escaping ((OutputValue, Signal&lt;U.OutputValue&gt;)) -&gt; X) -&gt; Signal&lt;X&gt; {
		let leftDurations = valueDurations({ u in leftEnd(u).takeWhile { _ in false } })
		let rightDurations = withRight.valueDurations({ u in rightEnd(u).takeWhile { _ in false } })
		return leftDurations.combine(rightDurations, initialState: ([Int: SignalInput&lt;U.OutputValue&gt;](), [Int: U.OutputValue]())) { (state: inout (activeLeft: [Int: SignalInput&lt;U.OutputValue&gt;], activeRight: [Int: U.OutputValue]), cr: EitherResult2&lt;(Int, OutputValue?), (Int, U.OutputValue?)&gt;) -&gt; Signal&lt;(OutputValue, Signal&lt;U.OutputValue&gt;)&gt;.Next in
			switch cr {
			case .result1(.success(let leftIndex, .some(let leftValue))):
				let (li, ls) = Signal&lt;U.OutputValue&gt;.create()
				state.activeLeft[leftIndex] = li
				return .value((leftValue, ls.cacheUntilActive(precached: state.activeRight.sorted { $0.0 &lt; $1.0 }.map { $0.value })))
			case .result2(.success(let rightIndex, .some(let rightValue))):
				state.activeRight[rightIndex] = rightValue
				state.activeLeft.sorted { $0.0 &lt; $1.0 }.forEach { tuple in tuple.value.send(value: rightValue) }
				return .none
			case .result1(.success(let leftIndex, .none)):
				_ = state.activeLeft[leftIndex]?.complete()
				state.activeLeft.removeValue(forKey: leftIndex)
				return .none
			case .result2(.success(let rightIndex, .none)):
				state.activeRight.removeValue(forKey: rightIndex)
				return .none
			default:
				return .complete()
			}
		}.map(context: context, processor)
	}
}

extension Signal {	
	/// Implementation of [Reactive X operator "merge"](http://reactivex.io/documentation/operators/merge.html) where the output closes only when the last source closes.
	///
	/// - Parameter sources: a variable parameter list of `Signal&lt;OutputValue&gt;` instances that are merged with `self` to form the result.
	/// - Returns: a signal that emits every value from every `sources` input `signal`.
	func merge&lt;S: Sequence&gt;(sequence: S) -&gt; Signal&lt;OutputValue&gt; where S.Iterator.Element == Signal&lt;OutputValue&gt; {
		let (mergedInput, sig) = Signal&lt;OutputValue&gt;.createMergedInput(onLastInputClosed: .complete)
		mergedInput.add(signal, closePropagation: .errors)
		for s in sequence {
			mergedInput.add(s, closePropagation: .errors)
		}
		return sig
	}
	
	/// Implementation of [Reactive X operator "merge"](http://reactivex.io/documentation/operators/merge.html) where the output closes only when the last source closes.
	///
	/// NOTE: the signal closes as `SignalComplete.cancelled` when the last output closes. For other closing semantics, use `Signal.mergSetAndSignal` instead.
	///
	/// - Parameter sources: an `Array` where `signal` is merged into the result.
	/// - Returns: a signal that emits every value from every `sources` input `signal`.
	static func merge&lt;S: Sequence&gt;(sequence: S) -&gt; Signal&lt;OutputValue&gt; where S.Iterator.Element == Signal&lt;OutputValue&gt; {
		let (mergedInput, sig) = Signal&lt;OutputValue&gt;.createMergedInput(onLastInputClosed: .complete)
		var sequenceEmpty = true
		for s in sequence {
			mergedInput.add(s, closePropagation: .errors)
			sequenceEmpty = false
		}
		if sequenceEmpty {
			return Signal&lt;OutputValue&gt;.preclosed()
		}
		return sig
	}
	
	/// Implementation of [Reactive X operator "merge"](http://reactivex.io/documentation/operators/merge.html) where the output closes only when the last source closes.
	///
	/// - Parameter sources: an `Array` where `signal` is merged into the result.
	/// - Returns: a signal that emits every value from every `sources` input `signal`.
	static func merge(_ sources: Signal&lt;OutputValue&gt;...) -&gt; Signal&lt;OutputValue&gt; {
		return merge(sequence: sources)
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "merge"](http://reactivex.io/documentation/operators/merge.html) where the output closes only when the last source closes.
	///
	/// - Parameter sources: a variable parameter list of `Signal&lt;OutputValue&gt;` instances that are merged with `self` to form the result.
	/// - Returns: a signal that emits every value from every `sources` input `signal`.
	func merge(_ sources: Signal&lt;OutputValue&gt;...) -&gt; Signal&lt;OutputValue&gt; {
		let (mergedInput, sig) = Signal&lt;OutputValue&gt;.createMergedInput(onLastInputClosed: .complete)
		mergedInput.add(signal, closePropagation: .errors)
		for s in sources {
			mergedInput.add(s, closePropagation: .errors)
		}
		return sig
	}
	
	/// Implementation of [Reactive X operator "startWith"](http://reactivex.io/documentation/operators/startwith.html)
	///
	/// - Parameter sequence: a sequence of values.
	/// - Returns: a signal that emits every value from `sequence` immediately before it starts mirroring `self`.
	func startWith&lt;S: Sequence&gt;(sequence: S) -&gt; Signal&lt;OutputValue&gt; where S.Iterator.Element == OutputValue {
		return Signal.from(sequence).combine(signal, initialState: false) { (alreadySent: inout Bool, r: EitherResult2&lt;OutputValue, OutputValue&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .result1(.success(let v)):
				if !alreadySent {
					return .value(v)
				} else {
					return .none
				}
			case .result1(.failure):
				alreadySent = true
				return .none
			case .result2(.success(let v)):
				if !alreadySent {
					alreadySent = true
					return .values(sequence: Array(sequence).appending(v))
				} else {
					return .value(v)
				}
			case .result2(.failure(let e)):
				if !alreadySent {
					alreadySent = true
					return .values(sequence: sequence, end: e)
				} else {
					return .end(e)
				}
			}
		}
	}
	
	/// Implementation of [Reactive X operator "startWith"](http://reactivex.io/documentation/operators/startwith.html)
	///
	/// - Parameter value: a value.
	/// - Returns: a signal that emits the value immediately before it starts mirroring `self`.
	func startWith(_ values: OutputValue...) -&gt; Signal&lt;OutputValue&gt; {
		return startWith(sequence: values)
	}
	
	/// Implementation of [Reactive X operator "endWith"](http://reactivex.io/documentation/operators/endwith.html)
	///
	/// - Returns: a signal that emits every value from `sequence` on activation and then mirrors `self`.
	func endWith&lt;U: Sequence&gt;(sequence: U, conditional: @escaping (SignalEnd) -&gt; SignalEnd? = { e in e }) -&gt; Signal&lt;OutputValue&gt; where U.Iterator.Element == OutputValue {
		return transform() { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v): return .value(v)
			case .failure(let e):
				if let newEnd = conditional(e) {
					return .values(sequence: sequence, end: newEnd)
				} else {
					return .end(e)
				}
			}
		}
	}
	
	/// Implementation of [Reactive X operator "endWith"](http://reactivex.io/documentation/operators/endwith.html)
	///
	/// - Returns: a signal that emits every value from `sequence` on activation and then mirrors `self`.
	func endWith(_ values: OutputValue..., conditional: @escaping (Error) -&gt; Error? = { e in e }) -&gt; Signal&lt;OutputValue&gt; {
		return endWith(sequence: values)
	}

	/// Implementation of [Reactive X operator "switch"](http://reactivex.io/documentation/operators/switch.html)
	///
	/// See also: `flatMapLatest` (emits values from the latest `Signal` to start emitting)
	///
	/// - Parameter signal: each of the inner signals emitted by this outer signal is observed, with the most recent signal emitted from the result
	/// - Returns: a signal that emits the values from the latest `Signal` emitted by `signal`
	func switchLatest&lt;U&gt;() -&gt; Signal&lt;U&gt; where OutputValue: SignalInterface, OutputValue.OutputValue == U {
		return transformFlatten(initialState: nil, closePropagation: .errors) { (latest: inout Signal&lt;U&gt;?, next: OutputValue, mergedInput: SignalMergedInput&lt;U&gt;) in
			if let l = latest {
				mergedInput.remove(l)
			}
			let s = next.signal
			mergedInput.add(s, closePropagation: .errors, removeOnDeactivate: true)
			latest = s
		}
	}

	@available(*, deprecated, message:"Renamed to zipWith. Alternately, use static zip function.")
	func zip&lt;U: SignalInterface&gt;(_ second: U) -&gt; Signal&lt;(OutputValue, U.OutputValue)&gt; {
		return zipWith(second)
	}

	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameter second: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `with`.
	static func zip&lt;U: SignalInterface&gt;(_ first: Self, _ second: U) -&gt; Signal&lt;(Self.OutputValue, U.OutputValue)&gt; {
		return first.zipWith(second)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameter second: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `with`.
	func zipWith&lt;U: SignalInterface&gt;(_ second: U) -&gt; Signal&lt;(OutputValue, U.OutputValue)&gt; {
		return combine(second, initialState: (Array&lt;OutputValue&gt;(), Array&lt;U.OutputValue&gt;(), false, false)) { (queues: inout (first: Array&lt;OutputValue&gt;, second: Array&lt;U.OutputValue&gt;, firstClosed: Bool, secondClosed: Bool), r: EitherResult2&lt;OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;(OutputValue, U.OutputValue)&gt;.Next in
			switch (r, queues.first.first, queues.second.first) {
			case (.result1(.success(let first)), _, .some(let second)):
				queues.second.removeFirst()
				if (queues.second.isEmpty &amp;&amp; queues.secondClosed) {
					return .value((first, second), end: .complete)
				} else {
					return .value((first, second))
				}
			case (.result1(.success(let first)), _, _):
				queues.first.append(first)
				return .none
			case (.result1(.failure(let e)), _, _):
				if queues.first.isEmpty || (queues.second.isEmpty &amp;&amp; queues.secondClosed) {
					return .end(e)
				} else {
					queues.firstClosed = true
				}
				return .none
			case (.result2(.success(let second)), .some(let first), _):
				queues.first.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) {
					return .value((first, second), end: .complete)
				} else {
					return .value((first, second))
				}
			case (.result2(.success(let second)), _, _):
				queues.second.append(second)
				return .none
			case (.result2(.failure(let e)), _, _):
				if queues.second.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) {
					return .end(e)
				} else {
					queues.secondClosed = true
					return .none
				}
			}
		}
	}
	
	@available(*, deprecated, message:"Renamed to zipWith. Alternately, use static zip function.")
	func zip&lt;U: SignalInterface, V: SignalInterface&gt;(_ second: U, _ third: V) -&gt; Signal&lt;(OutputValue, U.OutputValue, V.OutputValue)&gt; {
		return zipWith(second, third)
	}
	
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second` and `third`.
	static func zip&lt;U: SignalInterface, V: SignalInterface&gt;(_ first: Self, _ second: U, _ third: V) -&gt; Signal&lt;(Self.OutputValue, U.OutputValue, V.OutputValue)&gt; {
		return first.zipWith(second, third)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second` and `third`.
	func zipWith&lt;U: SignalInterface, V: SignalInterface&gt;(_ second: U, _ third: V) -&gt; Signal&lt;(OutputValue, U.OutputValue, V.OutputValue)&gt; {
		return combine(second, third, initialState: (Array&lt;OutputValue&gt;(), Array&lt;U.OutputValue&gt;(), Array&lt;V.OutputValue&gt;(), false, false, false)) { (queues: inout (first: Array&lt;OutputValue&gt;, second: Array&lt;U.OutputValue&gt;, third: Array&lt;V.OutputValue&gt;, firstClosed: Bool, secondClosed: Bool, thirdClosed: Bool), r: EitherResult3&lt;OutputValue, U.OutputValue, V.OutputValue&gt;) -&gt; Signal&lt;(OutputValue, U.OutputValue, V.OutputValue)&gt;.Next in
			switch (r, queues.first.first, queues.second.first, queues.third.first) {
			case (.result1(.success(let first)), _, .some(let second), .some(let third)):
				queues.second.removeFirst()
				queues.third.removeFirst()
				if (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) {
					return .value((first, second, third), end: .complete)
				} else {
					return .value((first, second, third))
				}
			case (.result1(.success(let first)), _, _, _):
				queues.first.append(first)
				return .none
			case (.result1(.failure(let e)), _, _, _):
				if queues.first.isEmpty || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) {
					return .end(e)
				} else {
					queues.firstClosed = true
					return .none
				}
			case (.result2(.success(let second)), .some(let first), _, .some(let third)):
				queues.first.removeFirst()
				queues.third.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) {
					return .value((first, second, third), end: .complete)
				} else {
					return .value((first, second, third))
				}
			case (.result2(.success(let second)), _, _, _):
				queues.second.append(second)
				return .none
			case (.result2(.failure(let e)), _, _, _):
				if queues.second.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) {
					return .end(e)
				} else {
					queues.secondClosed = true
					return .none
				}
			case (.result3(.success(let third)), .some(let first), .some(let second), _):
				queues.first.removeFirst()
				queues.second.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) {
					return .value((first, second, third), end: .complete)
				} else {
					return .value((first, second, third))
				}
			case (.result3(.success(let third)), _, _, _):
				queues.third.append(third)
				return .none
			case (.result3(.failure(let e)), _, _, _):
				if queues.third.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) {
					return .end(e)
				} else {
					queues.thirdClosed = true
					return .none
				}
			}
		}
	}
	
	@available(*, deprecated, message:"Renamed to zipWith. Alternately, use static zip function.")
	func zip&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface&gt;(_ second: U, _ third: V, _ fourth: W) -&gt; Signal&lt;(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)&gt; {
		return zipWith(second, third, fourth)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	///   - fourth: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second`,`third` and `fourth`.
	static func zip&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface&gt;(_ first: Self, _ second: U, _ third: V, _ fourth: W) -&gt; Signal&lt;(Self.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)&gt; {
		return first.zipWith(second, third, fourth)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	///   - fourth: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second`,`third` and `fourth`.
	func zipWith&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface&gt;(_ second: U, _ third: V, _ fourth: W) -&gt; Signal&lt;(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)&gt; {
		return combine(second, third, fourth, initialState: (Array&lt;OutputValue&gt;(), Array&lt;U.OutputValue&gt;(), Array&lt;V.OutputValue&gt;(), Array&lt;W.OutputValue&gt;(), false, false, false, false)) { (queues: inout (first: Array&lt;OutputValue&gt;, second: Array&lt;U.OutputValue&gt;, third: Array&lt;V.OutputValue&gt;, fourth: Array&lt;W.OutputValue&gt;, firstClosed: Bool, secondClosed: Bool, thirdClosed: Bool, fourthClosed: Bool), r: EitherResult4&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue&gt;) -&gt; Signal&lt;(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)&gt;.Next in
			switch (r, queues.first.first, queues.second.first, queues.third.first, queues.fourth.first) {
			case (.result1(.success(let first)), _, .some(let second), .some(let third), .some(let fourth)):
				queues.second.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				if (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) {
					return .value((first, second, third, fourth), end: .complete)
				} else {
					return .value((first, second, third, fourth))
				}
			case (.result1(.success(let first)), _, _, _, _):
				queues.first.append(first)
				return .none
			case (.result1(.failure(let e)), _, _, _, _):
				if queues.first.isEmpty || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) {
					return .end(e)
				} else {
					queues.firstClosed = true
					return .none
				}
			case (.result2(.success(let second)), .some(let first), _, .some(let third), .some(let fourth)):
				queues.first.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) {
					return .value((first, second, third, fourth), end: .complete)
				} else {
					return .value((first, second, third, fourth))
				}
			case (.result2(.success(let second)), _, _, _, _):
				queues.second.append(second)
				return .none
			case (.result2(.failure(let e)), _, _, _, _):
				if queues.second.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) {
					return .end(e)
				} else {
					queues.secondClosed = true
					return .none
				}
				
			case (.result3(.success(let third)), .some(let first), .some(let second), _, .some(let fourth)):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.fourth.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) {
					return .value((first, second, third, fourth), end: .complete)
				} else {
					return .value((first, second, third, fourth))
				}
			case (.result3(.success(let third)), _, _, _, _):
				queues.third.append(third)
				return .none
			case (.result3(.failure(let e)), _, _, _, _):
				if queues.third.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) {
					return .end(e)
				} else {
					queues.thirdClosed = true
					return .none
				}
			case (.result4(.success(let fourth)), .some(let first), .some(let second), .some(let third), _):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.third.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) {
					return .value((first, second, third, fourth), end: .complete)
				} else {
					return .value((first, second, third, fourth))
				}
			case (.result4(.success(let fourth)), _, _, _, _):
				queues.fourth.append(fourth)
				return .none
			case (.result4(.failure(let e)), _, _, _, _):
				if queues.fourth.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) {
					return .end(e)
				} else {
					queues.fourthClosed = true
					return .none
				}
			}
		}
	}
	
	@available(*, deprecated, message:"Renamed to zipWith. Alternately, use static zip function.")
	func zip&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X) -&gt; Signal&lt;(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)&gt; {
		return zipWith(second, third, fourth, fifth)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	///   - fourth: another `Signal`
	///   - fifth: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second`,`third`, `fourth` and `fifth`.
	static func zip&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface&gt;(_ first: Self, _ second: U, _ third: V, _ fourth: W, _ fifth: X) -&gt; Signal&lt;(Self.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)&gt; {
		return first.zipWith(second, third, fourth, fifth)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	///   - fourth: another `Signal`
	///   - fifth: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second`,`third`, `fourth` and `fifth`.
	func zipWith&lt;U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface&gt;(_ second: U, _ third: V, _ fourth: W, _ fifth: X) -&gt; Signal&lt;(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)&gt; {
		return combine(second, third, fourth, fifth, initialState: (Array&lt;OutputValue&gt;(), Array&lt;U.OutputValue&gt;(), Array&lt;V.OutputValue&gt;(), Array&lt;W.OutputValue&gt;(), Array&lt;X.OutputValue&gt;(), false, false, false, false, false)) { (queues: inout (first: Array&lt;OutputValue&gt;, second: Array&lt;U.OutputValue&gt;, third: Array&lt;V.OutputValue&gt;, fourth: Array&lt;W.OutputValue&gt;, fifth: Array&lt;X.OutputValue&gt;, firstClosed: Bool, secondClosed: Bool, thirdClosed: Bool, fourthClosed: Bool, fifthClosed: Bool), r: EitherResult5&lt;OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue&gt;) -&gt; Signal&lt;(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)&gt;.Next in
			switch (r, queues.first.first, queues.second.first, queues.third.first, queues.fourth.first, queues.fifth.first) {
			case (.result1(.success(let first)), _, .some(let second), .some(let third), .some(let fourth), .some(let fifth)):
				queues.second.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				queues.fifth.removeFirst()
				if (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) || (queues.fifth.isEmpty &amp;&amp; queues.fifthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result1(.success(let first)), _, _, _, _, _):
				queues.first.append(first)
				return .none
			case (.result1(.failure(let e)), _, _, _, _, _):
				if queues.first.isEmpty || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) || (queues.fifth.isEmpty &amp;&amp; queues.fifthClosed) {
					return .end(e)
				} else {
					queues.firstClosed = true
					return .none
				}
			case (.result2(.success(let second)), .some(let first), _, .some(let third), .some(let fourth), .some(let fifth)):
				queues.first.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				queues.fifth.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) || (queues.fifth.isEmpty &amp;&amp; queues.fifthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result2(.success(let second)), _, _, _, _, _):
				queues.second.append(second)
				return .none
			case (.result2(.failure(let e)), _, _, _, _, _):
				if queues.second.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) || (queues.fifth.isEmpty &amp;&amp; queues.fifthClosed) {
					return .end(e)
				} else {
					queues.secondClosed = true
					return .none
				}
			case (.result3(.success(let third)), .some(let first), .some(let second), _, .some(let fourth), .some(let fifth)):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.fourth.removeFirst()
				queues.fifth.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) || (queues.fifth.isEmpty &amp;&amp; queues.fifthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result3(.success(let third)), _, _, _, _, _):
				queues.third.append(third)
				return .none
			case (.result3(.failure(let e)), _, _, _, _, _):
				if queues.third.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) || (queues.fifth.isEmpty &amp;&amp; queues.fifthClosed) {
					return .end(e)
				} else {
					queues.thirdClosed = true
					return .none
				}
			case (.result4(.success(let fourth)), .some(let first), .some(let second), .some(let third), _, .some(let fifth)):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.third.removeFirst()
				queues.fifth.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fifth.isEmpty &amp;&amp; queues.fifthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result4(.success(let fourth)), _, _, _, _, _):
				queues.fourth.append(fourth)
				return .none
			case (.result4(.failure(let e)), _, _, _, _, _):
				if queues.fourth.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fifth.isEmpty &amp;&amp; queues.fifthClosed) {
					return .end(e)
				} else {
					queues.fourthClosed = true
					return .none
				}
			case (.result5(.success(let fifth)), .some(let first), .some(let second), .some(let third), .some(let fourth), _):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				if (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result5(.success(let fifth)), _, _, _, _, _):
				queues.fifth.append(fifth)
				return .none
			case (.result5(.failure(let e)), _, _, _, _, _):
				if queues.fifth.isEmpty || (queues.first.isEmpty &amp;&amp; queues.firstClosed) || (queues.second.isEmpty &amp;&amp; queues.secondClosed) || (queues.third.isEmpty &amp;&amp; queues.thirdClosed) || (queues.fourth.isEmpty &amp;&amp; queues.fourthClosed) {
					return .end(e)
				} else {
					queues.fifthClosed = true
					return .none
				}
			}
		}
	}
}

// Essentially a closure type used by `catchError`, defined as a separate class so the function can reference itself
fileprivate class CatchErrorRecovery&lt;OutputValue&gt; {
	let recover: (SignalEnd) -&gt; Signal&lt;OutputValue&gt;
	let catchTypes: SignalEndPropagation
	init(recover: @escaping (SignalEnd) -&gt; Signal&lt;OutputValue&gt;, catchTypes: SignalEndPropagation) {
		self.recover = recover
		self.catchTypes = catchTypes
	}
	func catchErrorRejoin(j: SignalJunction&lt;OutputValue&gt;, e: SignalEnd, i: SignalInput&lt;OutputValue&gt;) {
		if catchTypes.shouldPropagateEnd(e) {
			do {
				let f: SignalJunction&lt;OutputValue&gt;.Handler = self.catchErrorRejoin
				try recover(e).junction().bind(to: i, onEnd: f)
			} catch {
				i.send(end: .other(error))
			}
		} else {
			i.send(end: e)
		}
	}
}

// Essentially a closure type used by `retry`, defined as a separate class so the function can reference itself
fileprivate class RetryRecovery&lt;U&gt; {
	let shouldRetry: (inout U, SignalEnd) -&gt; DispatchTimeInterval?
	let catchTypes: SignalEndPropagation
	var state: U
	let context: Exec
	var timer: Lifetime? = nil
	init(shouldRetry: @escaping (inout U, SignalEnd) -&gt; DispatchTimeInterval?, catchTypes: SignalEndPropagation, state: U, context: Exec) {
		self.shouldRetry = shouldRetry
		self.catchTypes = catchTypes
		self.state = state
		self.context = context
	}
	func retryRejoin&lt;OutputValue&gt;(j: SignalJunction&lt;OutputValue&gt;, e: SignalEnd, i: SignalInput&lt;OutputValue&gt;) {
		if catchTypes.shouldPropagateEnd(e), let t = shouldRetry(&amp;state, e) {
			timer = context.singleTimer(interval: t) {
				do {
					try j.bind(to: i, onEnd: self.retryRejoin)
				} catch {
					i.send(end: .other(error))
				}
			}
		} else {
			i.send(end: e)
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "catch"](http://reactivex.io/documentation/operators/catch.html), returning a `Signal` on error in `self`.
	///
	/// - Parameters:
	///   - context: context where `recover` will run
	///   - catchSignalComplete: by default, the `recover` closure will be invoked only for unexpected errors, i.e. when `Error` is *not* a `SignalComplete`. Set this parameter to `true` to invoke the `recover` closure for *all* errors, including `SignalEnd.complete` and `SignalComplete.cancelled`. 
	///   - recover: a function that, when passed the `Error` that closed `self`, optionally returns a new signal.
	/// - Returns: a signal that emits the values from `self` until an error is received and then, if `recover` returns non-`nil` emits the values from `recover` and then emits the error from `recover`, otherwise if `recover` returns `nil`, emits the `Error` from `self`.
	func catchError(context: Exec = .direct, catchSignalComplete: Bool = false, recover: @escaping (SignalEnd) -&gt; Signal&lt;OutputValue&gt;) -&gt; Signal&lt;OutputValue&gt; {
		let (input, sig) = Signal&lt;OutputValue&gt;.create()
		// Both `junction` and `input` are newly created so this can't be an error
		try! junction().bind(to: input, onEnd: CatchErrorRecovery(recover: recover, catchTypes: catchSignalComplete ? .all : .errors).catchErrorRejoin)
		return sig
	}
	
	/// Implementation of [Reactive X operator "retry"](http://reactivex.io/documentation/operators/retry.html) where the choice to retry and the delay between retries is controlled by a function.
	///
	/// - Note: a ReactiveX "resubscribe" is interpreted as a disconnect and reconnect, which will trigger reactivation iff (if and only if) the preceding nodes have behavior that supports that.
	///
	/// - Parameters:
	///   - initialState:  a mutable state value that will be passed into `shouldRetry`.
	///   - context: the `Exec` where timed reconnection will occcur (default: .global).
	///   - catchSignalComplete: by default, the `shouldRetry` closure will be invoked only for unexpected errors, i.e. when `Error` is *not* a `SignalComplete`. Set this parameter to `true` to invoke the `recover` closure for *all* errors, including `SignalEnd.complete` and `SignalComplete.cancelled`. 
	///   - shouldRetry: a function that, when passed the current state value and the `Error` that closed `self`, returns an `Optional&lt;Double&gt;`.
	/// - Returns: a signal that emits the values from `self` until an error is received and then, if `shouldRetry` returns non-`nil`, disconnects from `self`, delays by the number of seconds returned from `shouldRetry`, and reconnects to `self` (triggering re-activation), otherwise if `shouldRetry` returns `nil`, emits the `Error` from `self`. If the number of seconds is `0`, the reconnect is synchronous, otherwise it will occur in `context` using `invokeAsync`.
	func retry&lt;U&gt;(_ initialState: U, context: Exec = .direct, catchSignalComplete: Bool = false, shouldRetry: @escaping (inout U, SignalEnd) -&gt; DispatchTimeInterval?) -&gt; Signal&lt;OutputValue&gt; {
		let (input, sig) = Signal&lt;OutputValue&gt;.create()
		// Both `junction` and `input` are newly created so this can't be an error
		try! junction().bind(to: input, onEnd: RetryRecovery(shouldRetry: shouldRetry, catchTypes: catchSignalComplete ? .all : .errors, state: initialState, context: context).retryRejoin)
		return sig
	}
	
	/// Implementation of [Reactive X operator "retry"](http://reactivex.io/documentation/operators/retry.html) where retries occur until the error is not `isSignalComplete` or `count` number of retries has occurred.
	///
	/// - Note: a ReactiveX "resubscribe" is interpreted as a disconnect and reconnect, which will trigger reactivation iff the preceding nodes have behavior that supports that.
	///
	/// - Parameters:
	///   - count: the maximum number of retries
	///   - delayInterval: the number of seconds between retries
	///   - context: the `Exec` where timed reconnection will occcur (default: .global).
	///   - catchSignalComplete: by default, retry attempts will occur only for unexpected errors, i.e. when `Error` is *not* a `SignalComplete`. Set this parameter to `true` to invoke the `recover` closure for *all* errors, including `SignalEnd.complete` and `SignalComplete.cancelled`. 
	/// - Returns: a signal that emits the values from `self` until an error is received and then, if fewer than `count` retries have occurred, disconnects from `self`, delays by `delaySeconds` and reconnects to `self` (triggering re-activation), otherwise if `count` retries have occurred, emits the `Error` from `self`. If the number of seconds is `0`, the reconnect is synchronous, otherwise it will occur in `context` using `invokeAsync`.
	func retry(count: Int, delayInterval: DispatchTimeInterval, context: Exec = .direct, catchSignalComplete: Bool = false) -&gt; Signal&lt;OutputValue&gt; {
		return retry(0, context: context) { (retryCount: inout Int, e: SignalEnd) -&gt; DispatchTimeInterval? in
			if !catchSignalComplete &amp;&amp; e.isComplete {
				return nil
			} else if retryCount &lt; count {
				retryCount += 1
				return delayInterval
			} else {
				return nil
			}
		}
	}
	
	/// Implementation of [Reactive X operator "delay"](http://reactivex.io/documentation/operators/delay.html) where delay for each value is determined by running an `offset` function.
	///
	/// - Parameters:
	///   - initialState: a user state value passed into the `offset` function
	///   - closePropagation: determines how errors and closure in `offset` affects the resulting signal
	///   - context: the `Exec` where `offset` will run (default: .global).
	///   - offset: a function that, when passed the current state value and the latest value from `self`, returns the number of seconds that the value should be delayed (values less or equal to 0 are sent immediately).
	/// - Returns: a mirror of `self` where values are offset according to `offset` â closing occurs when `self` closes or when the last delayed value is sent (whichever occurs last).
	func delay&lt;U&gt;(initialState: U, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (inout U, OutputValue) -&gt; DispatchTimeInterval) -&gt; Signal&lt;OutputValue&gt; {
		return delay(initialState: initialState, closePropagation: closePropagation, context: context) { (state: inout U, value: OutputValue) -&gt; Signal&lt;Void&gt; in
			return Signal&lt;Void&gt;.timer(interval: offset(&amp;state, value), context: context)
		}
	}
	
	/// Implementation of [Reactive X operator "delay"](http://reactivex.io/documentation/operators/delay.html) where delay for each value is constant.
	///
	/// - Parameters:
	///   - interval: the delay for each value
	///   - context: the `Exec` where timed reconnection will occcur (default: .global).
	/// - Returns: a mirror of `self` where values are delayed by `seconds` â closing occurs when `self` closes or when the last delayed value is sent (whichever occurs last).
	func delay(interval: DispatchTimeInterval, context: Exec = .direct) -&gt; Signal&lt;OutputValue&gt; {
		return delay(initialState: interval, context: context) { (s: inout DispatchTimeInterval, v: OutputValue) -&gt; DispatchTimeInterval in s }
	}
	
	/// Implementation of [Reactive X operator "delay"](http://reactivex.io/documentation/operators/delay.html) where delay for each value is determined by the duration of a signal returned from `offset`.
	///
	/// - Parameters:
	///   - closePropagation: determines how errors and closure in `offset` affects the resulting signal
	///   - context: the `Exec` where `offset` will run (default: .global).
	///   - offset: a function that, when passed the current state value emits a signal, the first value of which will trigger the end of the delay
	/// - Returns: a mirror of `self` where values are offset according to `offset` â closing occurs when `self` closes or when the last delayed value is sent (whichever occurs last).
	func delay&lt;U&gt;(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (OutputValue) -&gt; Signal&lt;U&gt;) -&gt; Signal&lt;OutputValue&gt; {
		return delay(initialState: (), closePropagation: closePropagation, context: context) { (state: inout (), value: OutputValue) -&gt; Signal&lt;U&gt; in return offset(value) }
	}
	
	/// Implementation of [Reactive X operator "delay"](http://reactivex.io/documentation/operators/delay.html) where delay for each value is determined by the duration of a signal returned from `offset`.
	///
	/// - Parameters:
	///   - initialState: a user state value passed into the `offset` function
	///   - closePropagation: determines how errors and closure in `offset` affects the resulting signal
	///   - context: the `Exec` where `offset` will run (default: .global).
	///   - offset: a function that, when passed the current state value emits a signal, the first value of which will trigger the end of the delay
	/// - Returns: a mirror of `self` where values are offset according to `offset` â closing occurs when `self` closes or when the last delayed value is sent (whichever occurs last).
	func delay&lt;U, V&gt;(initialState: V, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (inout V, OutputValue) -&gt; Signal&lt;U&gt;) -&gt; Signal&lt;OutputValue&gt; {
		return valueDurations(initialState: initialState, closePropagation: closePropagation, context: context, offset).transform(initialState: [Int: OutputValue]()) { (values: inout [Int: OutputValue], r: Result&lt;(Int, OutputValue?), SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let index, .some(let t)):
				values[index] = t
				return .none
			case .success(let index, .none):
				return values[index].map { .value($0) } ?? .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "activation" (not a concept that directly exists in ReactiveX but similar to doOnSubscribe).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked when self is activated
	/// - Returns: a signal that emits the same outputs as self
	func onActivate(context: Exec = .direct, _ handler: @escaping () -&gt; ()) -&gt; Signal&lt;OutputValue&gt; {
		let j = junction()
		let s = Signal&lt;OutputValue&gt;.generate { input in
			if let i = input {
				handler()
				_ = try? j.bind(to: i)
			} else {
				_ = j.disconnect()
			}
		}
		return s
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "deactivation" (not a concept that directly exists in ReactiveX but similar to doOnUnsubscribe).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked when self is deactivated
	/// - Returns: a signal that emits the same outputs as self
	func onDeactivate(context: Exec = .direct, _ handler: @escaping () -&gt; ()) -&gt; Signal&lt;OutputValue&gt; {
		let j = junction()
		let s = Signal&lt;OutputValue&gt;.generate { input in
			if let i = input {
				_ = try? j.bind(to: i)
			} else {
				handler()
				_ = j.disconnect()
			}
		}
		return s
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "result" (equivalent to doOnEach).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked for each `Result` in the signal
	/// - Returns: a signal that emits the same outputs as self
	func onResult(context: Exec = .direct, _ handler: @escaping (Result&lt;OutputValue, SignalEnd&gt;) -&gt; ()) -&gt; Signal&lt;OutputValue&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			handler(r)
			return .single(r)
		}
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "values" (equivalent to doOnNext).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked for each value (Result.success) in the signal
	/// - Returns: a signal that emits the same outputs as self
	func onValue(context: Exec = .direct, _ handler: @escaping (OutputValue) -&gt; ()) -&gt; Signal&lt;OutputValue&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v):
				handler(v)
				return .value(v)
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "errors" (equivalent to doOnTerminate).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked for each error (Result.failure) in the signal
	/// - Returns: a signal that emits the same outputs as self
	func onError(context: Exec = .direct, catchSignalComplete: Bool = false, _ handler: @escaping (SignalEnd) -&gt; ()) -&gt; Signal&lt;OutputValue&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v):
				return .value(v)
			case .failure(let e):
				if catchSignalComplete || !e.isComplete {
					handler(e)
				}
				return .end(e)
			}
		}
	}
	
	/// Appends an onActivate, onValue, onError and onDeactivate operator to monitor behavior and inspect lifecycle events.
	///
	/// - Parameters:
	///   - logPrefix: Prepended to the front of log statements. If non-empty, ": " is *also* prepended.
	///   - file: suffixed to the log statement (defaults to #file)
	///   - line: suffixed to the log statement (defaults to #line)
	/// - Returns: the otherwise untransformed signal
	func debug(logPrefix: String = "", file: String = #file, line: Int = #line) -&gt; Signal&lt;OutputValue&gt; {
		let prefix = logPrefix + (logPrefix.isEmpty ? "" : ": ")
		return onActivate { print("\(prefix)Activated at   \(file):\(line)") }
			.onValue { print("\(prefix)Value at       \(file):\(line) - \($0)") }
			.onError { print("\(prefix)Error at       \(file):\(line) - \($0)") }
			.onDeactivate { print("\(prefix)Deactivated at \(file):\(line)") }
	}
	
	/// Implementation of [Reactive X operator "materialize"](http://reactivex.io/documentation/operators/materialize-dematerialize.html)
	///
	/// WARNING: in CwlSignal, this operator will emit a `SignalEnd.complete` into the output signal immediately after emitting the first wrapped error. Within the "first error closes signal" behavior of CwlSignal, this is the only behavior that makes sense (since no further upstream values will be received), however, it does limit the usefulness of `materialize` to constructions where the `materialize` signal immediately outputs into a `SignalMultiInput` (including abstractions built on top, like `switchLatest` or child signals of a `flatMap`) that ignore non-error close conditions from the source signal.
	///
	/// - Returns: a signal where each `Result` emitted from self is further wrapped in a Result.success.
	func materialize() -&gt; Signal&lt;Result&lt;OutputValue, SignalEnd&gt;&gt; {
		return transform { r in
			if r.isFailure {
				return .value(r, end: .complete)
			} else {
				return .value(r)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "dematerialize"](http://reactivex.io/documentation/operators/materialize-dematerialize.html)
	///
	/// NOTE: ideally, this would not be a static function but a "same type" conditional extension. In a future Swift release this will probably change.
	///
	/// - Parameter signal: a signal whose OutputValue is a `Result` wrapped version of an underlying type
	/// - Returns: a signal whose OutputValue is the unwrapped value from the input, with unwrapped errors sent as errors.
	static func dematerialize&lt;OutputValue&gt;(_ signal: Signal&lt;Result&lt;OutputValue, SignalEnd&gt;&gt;) -&gt; Signal&lt;OutputValue&gt; {
		return signal.transform { (r: Result&lt;Result&lt;OutputValue, SignalEnd&gt;, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(.success(let v)): return .value(v)
			case .success(.failure(let e)): return .end(e)
			case .failure(let e): return .end(e)
			}
		}
	}
}

extension SignalInterface {
	/// - Note: the [Reactive X operator "ObserveOn"](http://reactivex.io/documentation/operators/observeon.html) doesn't apply to CwlSignal.Signal since any CwlSignal.Signal that runs work can specify their own execution context and control scheduling in that way.
	
	/// - Note: the [Reactive X operator "Serialize"](http://reactivex.io/documentation/operators/serialize.html) doesn't apply to CwlSignal.Signal since all CwlSignal.Signal instances are always serialized and well-behaved under multi-threaded access.
	
	/// - Note: the [Reactive X operator "Subscribe" and "SubscribeOn"](http://reactivex.io/documentation/operators/subscribe.html) are implemented as `subscribe`.
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "TimeInterval"](http://reactivex.io/documentation/operators/timeinterval.html)
	///
	/// - Parameter context: time between emissions will be calculated based on the timestamps from this context
	/// - Returns: a signal where the values are seconds between emissions from self
	func timeInterval(context: Exec = .direct) -&gt; Signal&lt;Double&gt; {
		let junction = self.map { v in () }.junction()
		
		// This `generate` transform is used to capture the start of the stream
		let s = Signal&lt;Void&gt;.generate { input in
			if let i = input {
				i.send(value: ())
				
				// Then after sending the initial value, connect to upstream
				try! junction.bind(to: i)
			} else {
				_ = junction.disconnect()
			}
		}.transform(initialState: nil, context: context) { (lastTime: inout DispatchTime?, r: Result&lt;Void, SignalEnd&gt;) -&gt; Signal&lt;Double&gt;.Next in
			switch r {
			case .success:
				let currentTime = context.timestamp()
				if let l = lastTime {
					lastTime = currentTime
					return .value(currentTime.since(l).seconds)
				} else {
					lastTime = currentTime
					return .none
				}
			case .failure(let e):
				return .end(e)
			}
		}
		return s
	}
	
	/// Implementation of [Reactive X operator "Timeout"](http://reactivex.io/documentation/operators/timeout.html)
	///
	/// - Parameters:
	///   - interval: the duration before a SignalReactiveError.timeout will be emitted
	///   - resetOnValue: if `true`, each value sent through the signal will reset the timer (making the timeout an "idle" timeout). If `false`, the timeout duration is measured from the start of the signal and is unaffected by whether values are received.
	///   - context: timestamps will be added based on the time in this context
	/// - Returns: a mirror of self unless a timeout occurs, in which case it will closed by a SignalReactiveError.timeout
	func timeout(interval: DispatchTimeInterval, resetOnValue: Bool = true, context: Exec = .direct) -&gt; Signal&lt;OutputValue&gt; {
		let (input, s) = Signal&lt;Void&gt;.create()
		let junction = Signal&lt;Void&gt;.timer(interval: interval, context: context).junction()
		// Both `junction` and `input` are newly created so this can't be an error
		try! junction.bind(to: input)
		return combine(s, context: context) { (cr: EitherResult2&lt;OutputValue, ()&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch cr {
			case .result1(let r):
				if resetOnValue {
					junction.rebind()
				}
				return .single(r)
			case .result2:
				return .end(.other(SignalReactiveError.timeout))
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Timestamp"](http://reactivex.io/documentation/operators/timestamp.html)
	///
	/// - Parameter context: used as the source of time
	/// - Returns: a signal where the values are a two element tuple, first element is self.OutputValue, second element is the `DispatchTime` timestamp that this element was emitted from self.
	func timestamp(context: Exec = .direct) -&gt; Signal&lt;(OutputValue, DispatchTime)&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;(OutputValue, DispatchTime)&gt;.Next in
			switch r {
			case .success(let v): return .value((v, context.timestamp()))
			case .failure(let e): return .end(e)
			}
		}
	}
}

extension SignalInterface {
	/// - Note: the [Reactive X operator "Using"](http://reactivex.io/documentation/operators/using.html) doesn't apply to CwlSignal.Signal which uses standard Swift reference counted lifetimes. Resources should be captured by closures or `transform(initialState:...)`.
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "All"](http://reactivex.io/documentation/operators/all.html)
	///
	/// - Parameters:
	///   - context: the `test` function will be run in this context
	///   - test: will be invoked for every value
	/// - Returns: a signal that emits true and then closes if every value emitted by self returned true from the `test` function and self closed normally, otherwise emits false and then closes
	func all(context: Exec = .direct, test: @escaping (OutputValue) -&gt; Bool) -&gt; Signal&lt;Bool&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;Bool&gt;.Next in
			switch r {
			case .success(let v) where !test(v): return .value(false, end: .complete)
			case .failure(.complete): return .value(true, end: .complete)
			case .failure(let e): return .end(e)
			case .success: return .none
			}
		}
	}
}

extension Signal {
	/// Implementation of [Reactive X operator "Amb"](http://reactivex.io/documentation/operators/amb.html) using the alternate name `race`, since it better conveys the purpose.
	///
	/// - Parameter inputs: a set of inputs
	/// - Returns: connects to all inputs then emits the full set of values from the first of these to emit a value
	static func race&lt;S: Sequence&gt;(sequence: S) -&gt; Signal&lt;OutputValue&gt; where S.Iterator.Element == Signal&lt;OutputValue&gt; {
		let (mergedInput, sig) = Signal&lt;(Int, Result)&gt;.createMergedInput()
		sequence.enumerated().forEach { s in
			mergedInput.add(s.element.transform { r in
				return .value((s.offset, r))
			}, closePropagation: .errors)
		}
		return sig.transform(initialState: -1) { (first: inout Int, r: Signal&lt;(Int, Result)&gt;.Result) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let index, let underlying) where first &lt; 0:
				first = index
				return .single(underlying)
			case .success(let index, let underlying) where first &lt; 0 || first == index:
				return .single(underlying)
			case .failure(let e):
				return .end(e)
			case .success:
				return .none
			}
		}
	}

	static func race(_ signals: Signal&lt;OutputValue&gt;...) -&gt; Signal&lt;OutputValue&gt; {
		return race(sequence: signals)
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "Some"](http://reactivex.io/documentation/operators/some.html)
	///
	/// - Parameters:
	///   - context: the `test` function will be run in this context
	///   - test: will be invoked for every value
	/// - Returns: a signal that emits true and then closes when a value emitted by self returns true from the `test` function, otherwise if no values from self return true, emits false and then closes
	func find(context: Exec = .direct, test: @escaping (OutputValue) -&gt; Bool) -&gt; Signal&lt;Bool&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;Bool&gt;.Next in
			switch r {
			case .success(let v) where test(v):
				return .value(true, end: .complete)
			case .success:
				return .none
			case .failure(let e):
				return .value(false, end: e)
			}
		}
	}

	/// Implementation of [Reactive X operator "Some"](http://reactivex.io/documentation/operators/some.html)
	///
	/// - Parameters:
	///   - context: the `test` function will be run in this context
	///   - test: will be invoked for every value
	/// - Returns: a signal that emits true and then closes when a value emitted by self returns true from the `test` function, otherwise if no values from self return true, emits false and then closes
	func findIndex(context: Exec = .direct, test: @escaping (OutputValue) -&gt; Bool) -&gt; Signal&lt;Int?&gt; {
		return transform(initialState: 0, context: context) { (index: inout Int, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;Int?&gt;.Next in
			switch r {
			case .success(let v) where test(v):
				return .value(index, end: .complete)
			case .success:
				index += 1
				return .none
			case .failure(let e):
				return .value(nil, end: e)
			}
		}
	}
}

extension SignalInterface where OutputValue: Equatable {
	/// Implementation of [Reactive X operator "Some"](http://reactivex.io/documentation/operators/some.html)
	///
	/// - Parameter value: every value emitted by self is tested for equality with this value
	/// - Returns: a signal that emits true and then closes when a value emitted by self tests as `==` to `value`, otherwise if no values from self test as equal, emits false and then closes
	func find(value: OutputValue) -&gt; Signal&lt;Bool&gt; {
		return find { value == $0 }
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "DefaultIfEmpty"](http://reactivex.io/documentation/operators/defaultifempty.html)
	///
	/// - Parameter value: value to emit if self closes without a value
	/// - Returns: a signal that emits the same values as self or `value` if self closes without emitting a value
	func defaultIfEmpty(value: OutputValue) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: false) { (started: inout Bool, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch r {
			case .success(let v):
				started = true
				return .value(v)
			case .failure(let e) where !started:
				return .value(value, end: e)
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "SwitchIfEmpty"](http://reactivex.io/documentation/operators/switchifempty.html)
	///
	/// - Parameter alternate: content will be used if self closes without emitting a value
	/// - Returns: a signal that emits the same values as self or mirrors `alternate` if self closes without emitting a value
	func switchIfEmpty(alternate: Signal&lt;OutputValue&gt;) -&gt; Signal&lt;OutputValue&gt; {
		var fallback: Signal&lt;OutputValue&gt;? = alternate
		let (input, preMappedSignal) = Signal&lt;OutputValue&gt;.create()
		let s = preMappedSignal.map { (t: OutputValue) -&gt; OutputValue in
			fallback = nil
			return t
		}
		
		// Both `junction` and `input` are newly created so this can't be an error
		try! junction().bind(to: input) { (j: SignalJunction&lt;OutputValue&gt;, e: SignalEnd, i: SignalInput&lt;OutputValue&gt;) in
			if let f = fallback {
				f.bind(to: i)
			} else {
				i.send(end: e)
			}
		}
		return s
	}
}

extension SignalInterface where OutputValue: Equatable {
	/// Implementation of [Reactive X operator "SequenceEqual"](http://reactivex.io/documentation/operators/sequenceequal.html)
	///
	/// - Parameter to: another signal whose contents will be compared to this signal
	/// - Returns: a signal that emits `true` if `self` and `to` are equal, `false` otherwise
	func sequenceEqual(to: Signal&lt;OutputValue&gt;) -&gt; Signal&lt;Bool&gt; {
		return combine(to, initialState: (Array&lt;OutputValue&gt;(), Array&lt;OutputValue&gt;(), false, false)) { (state: inout (lq: Array&lt;OutputValue&gt;, rq: Array&lt;OutputValue&gt;, lc: Bool, rc: Bool), r: EitherResult2&lt;OutputValue, OutputValue&gt;) -&gt; Signal&lt;Bool&gt;.Next in
			// state consists of lq (left queue), rq (right queue), lc (left closed), rc (right closed)
			switch (r, state.lq.first, state.rq.first) {
			case (.result1(.success(let left)), _, .some(let right)):
				if left != right {
					return .value(false, end: .complete)
				}
				state.rq.removeFirst()
				return .none
			case (.result1(.success(let left)), _, _):
				state.lq.append(left)
				return .none
			case (.result2(.success(let right)), .some(let left), _):
				if left != right {
					return .value(false, end: .complete)
				}
				state.lq.removeFirst()
				return .none
			case (.result2(.success(let right)), _, _):
				state.rq.append(right)
				return .none
			case (.result1(.failure(let e)), _, _):
				state.lc = true
				if state.rc {
					if state.lq.count == state.rq.count {
						return .value(true, end: e)
					} else {
						return .value(false, end: e)
					}
				}
				return .none
			case (.result2(.failure(let e)), _, _):
				state.rc = true
				if state.lc {
					if state.lq.count == state.rq.count {
						return .value(true, end: e)
					} else {
						return .value(false, end: e)
					}
				}
				return .none
			}
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "SkipUntil"](http://reactivex.io/documentation/operators/skipuntil.html)
	///
	/// - Parameter other: until this signal emits a value, all values from self will be dropped
	/// - Returns: a signal that mirrors `self` after `other` emits a value (but won't emit anything prior)
	func skipUntil&lt;U: SignalInterface&gt;(_ other: U) -&gt; Signal&lt;OutputValue&gt; {
		return combine(other, initialState: false) { (started: inout Bool, cr: EitherResult2&lt;OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch cr {
			case .result1(.success(let v)) where started:
				return .value(v)
			case .result1(.success):
				return .none
			case .result1(.failure(let e)):
				return .end(e)
			case .result2(.success):
				started = true
				return .none
			case .result2(.failure):
				return .none
			}
		}
	}
	
	/// Implementation of [Reactive X operator "SkipWhile"](http://reactivex.io/documentation/operators/skipwhile.html)
	///
	/// - Parameters:
	///   - context: execution context where `condition` will be run
	///   - condition: will be run for every value emitted from `self` until `condition` returns `true`
	/// - Returns: a signal that mirrors `self` dropping values until `condition` returns `true` for one of the values
	func skipWhile(context: Exec = .direct, condition: @escaping (OutputValue) throws -&gt; Bool) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: false, context: context) { (started: inout Bool, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			do {
				switch r {
				case .success(let v) where try !started &amp;&amp; condition(v):
					return .none
				case .success(let v):
					started = true
					return .value(v)
				case .failure(let e):
					return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "SkipWhile"](http://reactivex.io/documentation/operators/skipwhile.html)
	///
	/// - Parameters:
	///   - initialState: intial value for a state parameter that will be passed to `condition` on each invocation
	///   - context: execution context where `condition` will be run
	///   - condition: will be run for every value emitted from `self` until `condition` returns `true`
	/// - Returns: a signal that mirrors `self` dropping values until `condition` returns `true` for one of the values
	func skipWhile&lt;U&gt;(initialState initial: U, context: Exec = .direct, condition: @escaping (inout U, OutputValue) throws -&gt; Bool) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: (initial, false), context: context) { (started: inout (U, Bool), r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			do {
				switch r {
				case .success(let v) where try !started.1 &amp;&amp; condition(&amp;started.0, v):
					return .none
				case .success(let v):
					started.1 = true
					return .value(v)
				case .failure(let e):
					return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "TakeUntil"](http://reactivex.io/documentation/operators/takeuntil.html)
	///
	/// - Parameter other: after this signal emits a value, all values from self will be dropped
	/// - Returns: a signal that mirrors `self` until `other` emits a value (but won't emit anything after)
	func takeUntil&lt;U: SignalInterface&gt;(_ other: U) -&gt; Signal&lt;OutputValue&gt; {
		return combine(other, initialState: false) { (started: inout Bool, cr: EitherResult2&lt;OutputValue, U.OutputValue&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch cr {
			case .result1(.success(let v)) where !started: return .value(v)
			case .result1(.success): return .none
			case .result1(.failure(let e)): return .end(e)
			case .result2(.success):
				started = true
				return .none
			case .result2(.failure): return .none
			}
		}
	}
	
	/// Implementation of [Reactive X operator "TakeWhile"](http://reactivex.io/documentation/operators/takewhile.html)
	///
	/// - Parameters:
	///   - context: execution context where `condition` will be run
	///   - condition: will be run for every value emitted from `self` until `condition` returns `true`
	/// - Returns: a signal that mirrors `self` dropping values after `condition` returns `true` for one of the values
	func takeWhile(context: Exec = .direct, condition: @escaping (OutputValue) throws -&gt; Bool) -&gt; Signal&lt;OutputValue&gt; {
		return transform(context: context) { (r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			do {
				switch r {
				case .success(let v) where try condition(v): return .value(v)
				case .success: return .complete()
				case .failure(let e): return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "TakeWhile"](http://reactivex.io/documentation/operators/takewhile.html)
	///
	/// - Parameters:
	///   - initialState: intial value for a state parameter that will be passed to `condition` on each invocation
	///   - context: execution context where `condition` will be run
	///   - condition: will be run for every value emitted from `self` until `condition` returns `true`
	/// - Returns: a signal that mirrors `self` dropping values after `condition` returns `true` for one of the values
	func takeWhile&lt;U&gt;(initialState initial: U, context: Exec = .direct, condition: @escaping (inout U, OutputValue) throws -&gt; Bool) -&gt; Signal&lt;OutputValue&gt; {
		return transform(initialState: initial, context: context) { (i: inout U, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			do {
				switch r {
				case .success(let v) where try condition(&amp;i, v): return .value(v)
				case .success: return .complete()
				case .failure(let e): return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// A helper method used for mathematical operators. Performs a basic `fold` over the values emitted by `self` then passes the final result through another `finalize` function before emitting the result as a value in the returned signal.
	///
	/// - Parameters:
	///   - initial: used to initialize the fold state
	///   - context: all functions will be invoked in this context
	///   - finalize: invoked when `self` closes, with the current fold state value
	///   - fold: invoked for each value emitted by `self` along with the current fold state value
	/// - Returns: a signal which emits the `finalize` result
	func foldAndFinalize&lt;U, V&gt;(_ initial: V, context: Exec = .direct, finalize: @escaping (V) throws -&gt; U?, fold: @escaping (V, OutputValue) throws -&gt; V) -&gt; Signal&lt;U&gt; {
		return transform(initialState: initial, context: context) { (state: inout V, r: Result&lt;OutputValue, SignalEnd&gt;) -&gt; Signal&lt;U&gt;.Next in
			do {
				switch r {
				case .success(let v):
					state = try fold(state, v)
					return .none
				case .failure(let e):
					if let v = try finalize(state) {
						return .value(v, end: e)
					} else {
						return .end(e)
					}
				}
			} catch {
				return .error(error)
			}
		}
	}
}

extension SignalInterface where OutputValue: BinaryInteger {
	/// Implementation of [Reactive X operator "Average"](http://reactivex.io/documentation/operators/average.html)
	///
	/// - Returns: a signal that emits a single value... the sum of all values emitted by `self`
	func average() -&gt; Signal&lt;OutputValue&gt; {
		return foldAndFinalize((0, 0), finalize: { (fold: (OutputValue, OutputValue)) -&gt; OutputValue? in fold.0 &gt; 0 ? fold.1 / fold.0 : nil }) { (fold: (OutputValue, OutputValue), value: OutputValue) -&gt; (OutputValue, OutputValue) in
			return (fold.0 + 1, fold.1 + value)
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "Concat"](http://reactivex.io/documentation/operators/concat.html)
	///
	/// - Parameter other: a second signal
	/// - Returns: a signal that emits all the values from `self` followed by all the values from `other` (including those emitted while `self` was still active)
	func concat(_ other: Signal&lt;OutputValue&gt;) -&gt; Signal&lt;OutputValue&gt; {
		return combine(other, initialState: ([OutputValue](), nil, nil)) { (state: inout (secondValues: [OutputValue], firstError: SignalEnd?, secondError: SignalEnd?), cr: EitherResult2&lt;OutputValue, OutputValue&gt;) -&gt; Signal&lt;OutputValue&gt;.Next in
			switch (cr, state.firstError) {
			case (.result1(.success(let v)), _):
				return .value(v)
			case (.result1(.failure(.complete)), _):
				if let e2 = state.secondError {
					return .values(sequence: state.secondValues, end: e2)
				} else {
					state.firstError = .complete
					return .values(sequence: state.secondValues)
				}
			case (.result1(.failure(let e1)), _):
				// In the event of an "unexpected" error, don't emit the second signal.
				return .end(e1)
			case (.result2(.success(let v)), .none):
				state.secondValues.append(v)
				return .none
			case (.result2(.success(let v)), .some):
				return .value(v)
			case (.result2(.failure(let e2)), .none):
				state.secondError = e2
				return .none
			case (.result2(.failure(let e2)), .some):
				return .end(e2)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Count"](http://reactivex.io/documentation/operators/count.html)
	///
	/// - Returns: a signal that emits the number of values emitted by `self`
	func count() -&gt; Signal&lt;Int&gt; {
		return aggregate(0) { (fold: (Int), value: OutputValue) -&gt; Int in
			return fold + 1
		}
	}
}

extension SignalInterface where OutputValue: Comparable {
	/// Implementation of [Reactive X operator "Min"](http://reactivex.io/documentation/operators/min.html)
	///
	/// - Returns: the smallest value emitted by self
	func min() -&gt; Signal&lt;OutputValue&gt; {
		return foldAndFinalize(nil, finalize: { $0 }) { (fold: OutputValue?, value: OutputValue) -&gt; OutputValue? in
			return fold.map { value &lt; $0 ? value : $0 } ?? value
		}
	}
	
	/// Implementation of [Reactive X operator "Max"](http://reactivex.io/documentation/operators/max.html)
	///
	/// - Returns: the largest value emitted by self
	func max() -&gt; Signal&lt;OutputValue&gt; {
		return foldAndFinalize(nil, finalize: { $0 }) { (fold: OutputValue?, value: OutputValue) -&gt; OutputValue? in
			return fold.map { value &gt; $0 ? value : $0 } ?? value
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "Reduce"](http://reactivex.io/documentation/operators/reduce.html). The .NET/alternate name of `aggregate` is used to avoid conflict with the Signal.reduce function.
	///
	/// See also: `scan` which applies the same logic but emits the `fold` value on *every* invocation.
	///
	/// - Parameters:
	///   - initial: initialize the state value
	///   - context: the `fold` function will be invoked on this context
	///   - fold: invoked for every value emitted from self
	/// - Returns: emits the last emitted `fold` state value
	func aggregate&lt;U&gt;(_ initial: U, context: Exec = .direct, fold: @escaping (U, OutputValue) -&gt; U) -&gt; Signal&lt;U&gt; {
		return foldAndFinalize(initial, context: context, finalize: { $0 }) { (state: U, value: OutputValue) in
			return fold(state, value)
		}
	}
}

extension SignalInterface where OutputValue: Numeric {
	/// Implementation of [Reactive X operator "Sum"](http://reactivex.io/documentation/operators/sum.html)
	///
	/// - Returns: a signal that emits the sum of all values emitted by self
	func sum() -&gt; Signal&lt;OutputValue&gt; {
		return aggregate(0) { (fold: OutputValue, value: OutputValue) -&gt; OutputValue in
			return fold + value
		}
	}
}
</string>
			<key>Group</key>
			<string>Dependencies</string>
		</dict>
		<key>Dependencies/CwlUtils.swift</key>
		<dict>
			<key>Beginning</key>
			<string>//
//  This file is part of a concatenation of the CwlUtils framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlUtils
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-05-11 02:03:24 +0000 from the following files:
//   CwlAddressInfo.swift
//   CwlCaseNameCodable.swift
//   CwlCollection.swift
//   CwlCustomExecutionContext.swift
//   CwlDebugContext.swift
//   CwlDeferredWork.swift
//   CwlDeque.swift
//   CwlDispatch.swift
//   CwlExec.swift
//   CwlExecutionType.swift
//   CwlFew.swift
//   CwlKeyValueObserver.swift
//   CwlLifetime.swift
//   CwlMutex.swift
//   CwlOnDelete.swift
//   CwlRandom.swift
//   CwlResult.swift
//   CwlScalarScanner.swift
//   CwlSerializingContext.swift
//   CwlSysctl.swift
//   CwlWrappers.swift

import Foundation

/// A wrapper around dl_info, used for symbolicating instruction addresses.
struct AddressInfo {
	private let info: dl_info
	
	/// Address for which this struct was constructed
	let address: UInt
	
	/// Construct for an address
	init(address: UInt) {
		self.address = address

		var i = dl_info()
		dladdr(UnsafeRawPointer(bitPattern: address), &amp;i)
		self.info = i
	}
	
	/// -returns: the "image" (shared object pathname) for the instruction
	var image: String {
		if let dli_fname = info.dli_fname, let fname = String(validatingUTF8: dli_fname), let _ = fname.range(of: "/", options: .backwards, range: nil, locale: nil) {
			return (fname as NSString).lastPathComponent
		} else {
			return "???"
		}
	}
	
	/// - returns: the symbol nearest the address
	var symbol: String {
		if let dli_sname = info.dli_sname, let sname = String(validatingUTF8: dli_sname) {
			return sname
		} else if let dli_fname = info.dli_fname, let _ = String(validatingUTF8: dli_fname) {
			return self.image
		} else {
			return String(format: "0x%1x", UInt(bitPattern: info.dli_saddr))
		}
	}
	
	/// - returns: the address' offset relative to the nearest symbol
	var offset: Int {
		if let dli_sname = info.dli_sname, let _ = String(validatingUTF8: dli_sname) {
			return Int(address - UInt(bitPattern: info.dli_saddr))
		} else if let dli_fname = info.dli_fname, let _ = String(validatingUTF8: dli_fname) {
			return Int(address - UInt(bitPattern: info.dli_fbase))
		} else {
			return Int(address - UInt(bitPattern: info.dli_saddr))
		}
	}
	
	/// - parameter index: the stack frame index
	/// - returns: a formatted string matching that used by NSThread.callStackSymbols
	func formattedDescription(index: Int) -&gt; String {
		return self.image.utf8CString.withUnsafeBufferPointer { (imageBuffer: UnsafeBufferPointer&lt;CChar&gt;) -&gt; String in
			#if arch(x86_64) || arch(arm64)
				return String(format: "%-4ld%-35s 0x%016llx %@ + %ld", index, UInt(bitPattern: imageBuffer.baseAddress), self.address, self.symbol, self.offset)
			#else
				return String(format: "%-4d%-35s 0x%08lx %@ + %d", index, UInt(bitPattern: imageBuffer.baseAddress), self.address, self.symbol, self.offset)
			#endif
		}
	}
}

/// When applied to the output of callStackReturnAddresses, produces identical output to the execinfo function "backtrace_symbols" or NSThread.callStackSymbols
/// - parameter addresses: an array of memory addresses, generally as produced by `callStackReturnAddresses`
/// - returns: an array of formatted, symbolicated stack frame descriptions.
func symbolsForCallStack(addresses: [UInt]) -&gt; [String] {
	return Array(addresses.enumerated().map { tuple -&gt; String in
		return AddressInfo(address: tuple.element).formattedDescription(index: tuple.offset)
	})
}

import Foundation

private struct EmptyKeyedDecodingContainer&lt;K: CodingKey&gt;: KeyedDecodingContainerProtocol {
	typealias Key = K
	
	var codingPath: [CodingKey] { return [] }
	var allKeys: [K] { return [] }
	
	func contains(_ key: K) -&gt; Bool {
		return false
	}
	
	private func keyNotFoundError(_ key: K) -&gt; Error {
		return DecodingError.keyNotFound(key, DecodingError.Context.init(codingPath: [], debugDescription: "EmptyKeyedDecodingContainer contains no values"))
	}
	
	func decodeNil(forKey key: K) throws -&gt; Bool { throw keyNotFoundError(key) }
	func decode(_ type: Bool.Type, forKey key: K) throws -&gt; Bool { throw keyNotFoundError(key) }
	func decode(_ type: String.Type, forKey key: K) throws -&gt; String { throw keyNotFoundError(key) }
	func decode(_ type: Double.Type, forKey key: K) throws -&gt; Double { throw keyNotFoundError(key) }
	func decode(_ type: Float.Type, forKey key: K) throws -&gt; Float { throw keyNotFoundError(key) }
	func decode(_ type: Int.Type, forKey key: K) throws -&gt; Int { throw keyNotFoundError(key) }
	func decode(_ type: Int8.Type, forKey key: K) throws -&gt; Int8 { throw keyNotFoundError(key) }
	func decode(_ type: Int16.Type, forKey key: K) throws -&gt; Int16 { throw keyNotFoundError(key) }
	func decode(_ type: Int32.Type, forKey key: K) throws -&gt; Int32 { throw keyNotFoundError(key) }
	func decode(_ type: Int64.Type, forKey key: K) throws -&gt; Int64 { throw keyNotFoundError(key) }
	func decode(_ type: UInt.Type, forKey key: K) throws -&gt; UInt { throw keyNotFoundError(key) }
	func decode(_ type: UInt8.Type, forKey key: K) throws -&gt; UInt8 { throw keyNotFoundError(key) }
	func decode(_ type: UInt16.Type, forKey key: K) throws -&gt; UInt16 { throw keyNotFoundError(key) }
	func decode(_ type: UInt32.Type, forKey key: K) throws -&gt; UInt32 { throw keyNotFoundError(key) }
	func decode(_ type: UInt64.Type, forKey key: K) throws -&gt; UInt64 { throw keyNotFoundError(key) }
	func decode&lt;T&gt;(_ type: T.Type, forKey key: K) throws -&gt; T where T : Decodable { throw keyNotFoundError(key) }
	func nestedContainer&lt;NestedKey&gt;(keyedBy type: NestedKey.Type, forKey key: K) throws -&gt; KeyedDecodingContainer&lt;NestedKey&gt; where NestedKey : CodingKey { throw keyNotFoundError(key)	}
	func nestedUnkeyedContainer(forKey key: K) throws -&gt; UnkeyedDecodingContainer { throw keyNotFoundError(key) }
	func superDecoder() throws -&gt; Decoder { fatalError() }
	func superDecoder(forKey key: K) throws -&gt; Decoder { throw keyNotFoundError(key) }
}

extension KeyedDecodingContainer {
	static func empty() -&gt; KeyedDecodingContainer&lt;K&gt; {
		return KeyedDecodingContainer&lt;K&gt;(EmptyKeyedDecodingContainer())
	}
}

/// A protocol that enums with associated values can adopt to help in implementing Codable conformance.
/// The downside is that there are some runtime enforced requirements:
///  1. the `CaseName` associated type must be raw constructible from each of the case names in `CaseNameCodable`
///  2. the `decode(from:)` method must validly construct each `CaseNameCodable`
/// NOTE: the encoded value will be `nil` if the associated value has no contents or there is no associated value. In these cases, you shouldn't attempt to read the value.
protocol CaseNameCodable: Codable {
	associatedtype CaseName: CaseNameDecoder where CaseName.AssociatedEnum == Self
}

protocol CaseNameDecoder: Codable, CodingKey, RawRepresentable where RawValue == String {
	associatedtype AssociatedEnum
	func decode(from container: KeyedDecodingContainer&lt;Self&gt;) throws -&gt; AssociatedEnum
}

extension CaseNameCodable {
	private func caseName(from mirror: Mirror) -&gt; CaseName {
		let label = mirror.children.first?.label ?? String(describing: self)
		guard let key = CaseName(rawValue: label) else {
			fatalError("Unable to find a CaseName for \(self) matching \(label)")
		}
		return key
	}
	
	var caseName: CaseName {
		return caseName(from: Mirror(reflecting: self))
	}
	
	func encode(to encoder: Encoder) throws {
		let mirror = Mirror(reflecting: self)
		let key = caseName(from: mirror)
		var container = encoder.container(keyedBy: CaseName.self)
		if let value = mirror.children.first?.value as? Encodable {
			try container.encode(EncodableWrapper(value: value), forKey: key)
		} else {
			try container.encodeNil(forKey: key)
		}
	}
	
	init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CaseName.self)
		guard let key = container.allKeys.first else {
			throw DecodingError.dataCorrupted(DecodingError.Context.init(codingPath: decoder.codingPath, debugDescription: "Missing enum key"))
		}
		self = try key.decode(from: container)
	}
}

private struct EncodableWrapper: Encodable {
	let value: Encodable
	
	func encode(to encoder: Encoder) throws {
		try value.encode(to: encoder)
	}
}

import Foundation

extension Optional {
	/// Reurns true if the current optional is nil. Useful for testing for nil at a specific point during chained unwrapping of nested optionals.
	var isNil: Bool {
		return self == nil
	}
}

extension Collection {
	/// Returns the element at the specified index iff it is within bounds, otherwise nil.
	func at(_ i: Index) -&gt; Iterator.Element? {
		return (i &gt;= startIndex &amp;&amp; i &lt; endIndex) ? self[i] : nil
	}
}

extension Collection {
	/// Constrains the range to the indices of self and returns a SubSequence.
	func at(_ range: Range&lt;Index&gt;) -&gt; SubSequence {
		let start = (range.lowerBound &gt;= startIndex) ? (range.lowerBound &lt; endIndex ? range.lowerBound : endIndex) : startIndex
		let end = (range.upperBound &lt; endIndex) ? (range.upperBound &gt; startIndex ? range.upperBound : startIndex) : endIndex
		return self[start..&lt;end]
	}
}

extension Collection where Index: Strideable, Index.Stride: SignedInteger {
	/// Constrains the range to the indices of self and returns a SubSequence.
	func at(_ range: CountableRange&lt;Index&gt;) -&gt; SubSequence {
		let start = (range.lowerBound &gt;= startIndex) ? (range.lowerBound &lt; endIndex ? range.lowerBound : endIndex) : startIndex
		let end = (range.upperBound &lt; endIndex) ? (range.upperBound &gt; startIndex ? range.upperBound : startIndex) : endIndex
		return self[start..&lt;end]
	}
}

extension RangeReplaceableCollection {
	static func +=(s: inout Self, e: Iterator.Element?) {
		guard let e = e else { return }
		s.append(e)
	}
	
	func appending(_ newElement: Iterator.Element) -&gt; Self {
		var result = self
		result.append(newElement)
		return result
	}
}

import Foundation

/// An abstraction of common execution context concepts
protocol CustomExecutionContext {
	/// A description about how functions will be invoked on an execution context.
	var type: ExecutionType { get }
	
	/// Run `execute` normally on the execution context
	func invoke(_ execute: @escaping () -&gt; Void)
	
	/// Run `execute` asynchronously on the execution context
	/// NOTE: a default implementation of this is provided that, if `type.isImmediate` is false, directly calls `invoke`, otherwise it runs an asynchronous block on the global dispatch queue and calls `invoke` from there.
	func invokeAsync(_ execute: @escaping () -&gt; Void)
	
	/// Run `execute` on the execution context but don't return from this function until the provided function is complete.
	/// NOTE: a default implementation of this is provided that, if `type.isImmediate` is true, simply calls `invoke`, otherwise it calls `invoke` and blocks waiting on a semaphore in the calling context until `invoke` completes. Creating a semphore for every call is inefficient so you should implement this a different way, if possible.
	func invokeSync&lt;Return&gt;(_ execute: () throws -&gt; Return) rethrows -&gt; Return
	
	/// A context that can be used to safely escape the current context.
	/// NOTE: a default implementation of this function is provided that calls `DispatchQueue.global().async`. 
	/// - Parameter qos: The desired DispatchQoS.QoSClass for the new context. If `nil`, then inherit from `self` where possible
	func relativeAsync(qos: DispatchQoS.QoSClass?) -&gt; Exec
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`) unless the returned `Lifetime` is cancelled or released before running occurs.
	/// NOTE: a default implementation of this function is provided that runs the timer on the global dispatch queue and calls `invoke` when it fires. This implementation is likely sufficient for most cases but may not be appropriate if your context has strict timing or serialization requirements.
	func singleTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), passing the `parameter` value as an argument, unless the returned `Lifetime` is cancelled or released before running occurs.
	/// NOTE: a default implementation of this function is provided that runs the timer on the global dispatch queue and calls `invoke` when it fires. This implementation is likely sufficient for most cases but may not be appropriate if your context has strict timing or serialization requirements.
	func singleTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), and again every `interval` (within a `leeway` margin of error) unless the returned `Lifetime` is cancelled or released before running occurs.
	/// NOTE: a default implementation of this function is provided that runs the timer on the global dispatch queue and calls `invoke` when it fires. This implementation is likely sufficient for most cases but may not be appropriate if your context has strict timing or serialization requirements.
	func periodicTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), passing the `parameter` value as an argument, and again every `interval` (within a `leeway` margin of error) unless the returned `Lifetime` is cancelled or released before running occurs.
	/// NOTE: a default implementation of this function is provided that runs the timer on the global dispatch queue and calls `invoke` when it fires. This implementation is likely sufficient for most cases but may not be appropriate if your context has strict timing or serialization requirements.
	func periodicTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime
	
	/// Gets a timestamp representing the host uptime the in the current context
	/// NOTE: a default implementation of this function is provided that calls `DispatchTime.now()`. With the exception of debug, test and other host-isolated contexts, this is usually sufficient. 
	func timestamp() -&gt; DispatchTime
}

/// Many of the ExecutionContext functions returns a `Lifetime` and in most cases, that lifetime is just a dispatch timer. Annoyingly, a `DispatchSourceTimer` is an existential, so we can't extend it to conform to `Lifetime` (a limitation of Swift 4).
/// In these cases, you can force cast to DispatchSource and use this extension.
extension DispatchSource: Lifetime {
}

// Since it's not possible to have default parameters in protocols (yet) the "leeway" free functions are all default-implemented to call the "leeway" functions with a 0 second leeway.
extension CustomExecutionContext {
	func singleTimer(interval: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime {
		return singleTimer(interval: interval, leeway: .seconds(0), handler: handler)
	}
	func singleTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		return singleTimer(parameter: parameter, interval: interval, leeway: .seconds(0), handler: handler)
	}
	func periodicTimer(interval: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime {
		return periodicTimer(interval: interval, leeway: .seconds(0), handler: handler)
	}
	func periodicTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		return periodicTimer(parameter: parameter, interval: interval, leeway: .seconds(0), handler: handler)
	}
}

extension CustomExecutionContext {
	var isImmediateInCurrentContext: Bool { return type.isImmediateInCurrentContext }
	var isAsyncInCurrentContext: Bool { return type.isAsyncInCurrentContext }
	var isImmediateAlways: Bool { return type.isImmediateAlways }
	var isPotentiallyAsync: Bool { return type.isPotentiallyAsync }
	var isReentrant: Bool { return type.isReentrant }
	var isNonReentrant: Bool { return type.isNonReentrant }
	var isConcurrent: Bool { return type.isConcurrent }
	var isSerial: Bool { return type.isSerial }


	func timestamp() -&gt; DispatchTime {
		return DispatchTime.now()
	}
	
	func invokeAsync(_ execute: @escaping () -&gt; Void) {
		if type.isImmediateInCurrentContext == false {
			invoke(execute)
		} else {
			DispatchQueue.global().async { self.invoke(execute) }
		}
	}
	
	func invokeSync&lt;Return&gt;(_ execute: () -&gt; Return) -&gt; Return {
		return withoutActuallyEscaping(execute) { ex in
			var r: Return? = nil
			if type.isImmediateInCurrentContext == true {
				invoke {
					r = ex()
				}
			} else {
				let s = DispatchSemaphore(value: 0)
				self.invoke {
					r = ex()
					s.signal()
				}
				s.wait()
			}
			return r!
		}
	}
	
	func relativeAsync(qos: DispatchQoS.QoSClass?) -&gt; Exec {
		return Exec.global(qos: qos ?? .default)
	}
	
	func singleTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime {
		return DispatchSource.singleTimer(interval: interval, leeway: leeway, queue: DispatchQueue.global(), handler: { self.invoke(handler) }) as! DispatchSource
	}
	
	func singleTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		return DispatchSource.singleTimer(parameter: parameter, interval: interval, leeway: leeway, queue: DispatchQueue.global(), handler: { p in self.invoke{ handler(p) } }) as! DispatchSource
	}
	
	func periodicTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime {
		return DispatchSource.repeatingTimer(interval: interval, leeway: leeway, queue: DispatchQueue.global(), handler: { self.invoke(handler) }) as! DispatchSource
	}
	
	func periodicTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		return DispatchSource.repeatingTimer(parameter: parameter, interval: interval, leeway: leeway, queue: DispatchQueue.global(), handler: { p in self.invoke{ handler(p) } }) as! DispatchSource
	}
}

@available(*, deprecated, message: "Use Exec for variables or CustomExecutionContext for conformances used in the `custom` case of Exec")
typealias ExecutionContext = CustomExecutionContext

import Foundation

/// A set of identifiers for the different queues in the DebugContextCoordinator
///
/// - unspecified: used when a initial DebugContextThread is not specified on startup (not used otherwise)
/// - main: used by `main` and `mainAsync` contexts
/// - `global`: used for a concurrent queues and for timers on direct
/// - custom: any custom queue
enum DebugContextThread: Hashable {
	case unspecified
	case main
	case global
	case custom(String)
	
	/// Convenience test to determine if an `Exec` instance wraps a `DebugContext` identifying `self` as its `thread`.
	func matches(_ exec: Exec) -&gt; Bool {
		if case .custom(let debugContext as DebugContext) = exec, debugContext.thread == self {
			return true
		} else {
			return false
		}
	}
}

/// Basic equality tests for `DebugContextThread`
///
/// - Parameters:
///   - left: a `DebugContextThread`
///   - right: another `DebugContextThread`
/// - Returns: true if they are equal value
func ==(left: DebugContextThread, right: DebugContextThread) -&gt; Bool {
	switch (left, right) {
	case (.custom(let l), .custom(let r)) where l == r: return true
	case (.unspecified, .unspecified): return true
	case (.main, .main): return true
	case (.global, .global): return true
	default: return false
	}
}

/// Simulates running a series of blocks across threads over time by instead queuing the blocks and running them serially in time priority order, incrementing the `currentTime` to reflect the time priority of the last run block.
/// The result is a deterministic simulation of time scheduled blocks, which is otherwise subject to thread scheduling non-determinism.
class DebugContextCoordinator {
	// We use DispatchTime for time calculations but time 0 is treated as a special value ("now") so we start at time = 1, internally, and subtract 1 when returning through the `currentTime` accessor.
	var internalTime: UInt64 = 1
	var queues: Dictionary&lt;DebugContextThread, DebugContextQueue&gt; = [:]
	var stopRequested: Bool = false
	
	/// Returns the current simulated time in nanoseconds
	var currentTime: UInt64 { return internalTime - 1 }
	
	/// Returns the last runs simulated thread
	fileprivate (set) var currentThread: DebugContextThread
	
	/// Constructs an empty instance
	init() {
		currentThread = .unspecified
	}
	
	/// Constructs an empty instance
	init(initialThread: DebugContextThread) {
		self.currentThread = initialThread
	}
	
	/// Implementation mimicking Exec.direct but returning an Exec.custom(DebugContext)
	var direct: Exec {
		return .custom(DebugContext(type: .immediate, thread: .global, coordinator: self))
	}
	
	/// Implementation mimicking Exec.main but returning an Exec.custom(DebugContext)
	var main: Exec {
		return .custom(DebugContext(type: .thread { [weak self] in self?.currentThread == .main }, thread: .main, coordinator: self))
	}
	
	/// Implementation mimicking Exec.mainAsync but returning an Exec.custom(DebugContext)
	var mainAsync: Exec {
		return .custom(DebugContext(type: .threadAsync { [weak self] in self?.currentThread == .main }, thread: .main, coordinator: self))
	}
	
	/// Implementation mimicking Exec.default but returning an Exec.custom(DebugContext)
	var global: Exec {
		return .custom(DebugContext(type: .concurrentAsync, thread: .global, coordinator: self))
	}
	
	/// Implementation mimicking Exec.syncQueue but returning an Exec.custom(DebugContext)
	func syncQueue() -&gt; Exec {
		let uuidString = CFUUIDCreateString(nil, CFUUIDCreate(nil)) as String? ?? ""
		return .custom(DebugContext(type: .mutex, thread: .custom(uuidString), coordinator: self))
	}
	
	/// Implementation mimicking Exec.asyncQueue but returning an Exec.custom(DebugContext)
	func asyncQueue() -&gt; Exec {
		let uuidString = CFUUIDCreateString(nil, CFUUIDCreate(nil)) as String? ?? ""
		return .custom(DebugContext(type: .serialAsync, thread: .custom(uuidString), coordinator: self))
	}
	
	/// Performs all scheduled actions in a serial loop.
	///
	/// - parameter stoppingAfter: If nil, loop will continue until `stop` invoked or until no actions remain. If non-nil, loop will abort after an action matching Lifetime is completed.
	func runScheduledTasks(stoppingAfter: (AnyObject &amp; Lifetime)? = nil) {
		stopRequested = false
		currentThread = .unspecified
		while !stopRequested, let nextTimer = runNextTask() {
			if stoppingAfter != nil, stoppingAfter === nextTimer {
				break
			}
		}
		if stopRequested {
			// Since releasing `queues` will likely cause the release of closures and items held by the queue, which might lead to nested calls to remove items from `queues` violating ownership rules...
			// We copy queues to a non-shared stack location, clear `queues` and *then* release the contents.
			withExtendedLifetime(queues) { queues = [:] }
		}
	}
	
	/// Performs all scheduled actions in a serial loop.
	///
	/// - parameter stoppingAfter: If nil, loop will continue until `stop` invoked or until no actions remain. If non-nil, loop will abort after an action matching Lifetime is completed.
	func runScheduledTasks(untilTime: UInt64) {
		stopRequested = false
		currentThread = .unspecified
		while !stopRequested, let (threadIndex, time) = nextTask(), time &lt;= untilTime {
			_ = runTask(threadIndex: threadIndex, time: time)
		}
		if stopRequested {
			// Since releasing `queues` will likely cause the release of closures and items held by the queue, which might lead to nested calls to remove items from `queues` violating ownership rules...
			// We copy queues to a non-shared stack location, clear `queues` and *then* release the contents.
			withExtendedLifetime(queues) { queues = [:] }
		}
	}
	
	/// Causes `runScheduledTasks` to exit as soon as possible, if it is running.
	func stop() {
		stopRequested = true
	}
	
	/// Discards all scheduled actions and resets time to 1. Useful if the `DebugContextCoordinator` is to be reused.
	func reset() {
		internalTime = 1
		
		// Since releasing `queues` will likely cause the release of closures and items held by the queue, which might lead to nested calls to remove items from `queues` violating ownership rules...
		// We copy queues to a non-shared stack location, clear `queues` and *then* release the contents.
		withExtendedLifetime(queues) { queues = [:] }
	}
	
	func getOrCreateQueue(forName: DebugContextThread) -&gt; DebugContextQueue {
		if let t = queues[forName] {
			return t
		}
		let t = DebugContextQueue()
		
		// Since releasing `queues` will likely cause the release of closures and items held by the queue, which might lead to nested calls to remove items from `queues` violating ownership rules...
		// We copy queues to a non-shared stack location, clear `queues` and *then* release the contents.
		withExtendedLifetime(queues[forName]) { queues[forName] = t }
		
		return t
	}
	
	// Fundamental method for scheduling a block on the coordinator for later invocation.
	func schedule(block: @escaping () -&gt; Void, thread: DebugContextThread, timeInterval interval: Int64, repeats: Bool) -&gt; DebugContextTimer {
		let i = interval &gt; 0 ? UInt64(interval) : 0 as UInt64
		let debugContextTimer = DebugContextTimer(thread: thread, rescheduleInterval: repeats ? i : nil, coordinator: self)
		getOrCreateQueue(forName: thread).schedule(pending: PendingBlock(time: internalTime + i, timer: debugContextTimer, block: block))
		return debugContextTimer
	}
	
	// Remove a block from the scheduler
	func cancelTimer(_ toCancel: DebugContextTimer) {
		if let t = queues[toCancel.thread]  {
			t.cancelTimer(toCancel)
		}
	}
	
	func nextTask() -&gt; (DebugContextThread, UInt64)? {
		var lowestTime = UInt64.max
		var selectedIndex = DebugContextThread.unspecified
		
		// We want a deterministic ordering, so we'll iterate over the queues by key sorted by hashValue
		for index in queues.keys.sorted(by: { (left, right) -&gt; Bool in left.hashValue &lt; right.hashValue }) {
			if let t = queues[index], t.nextTime &lt; lowestTime {
				selectedIndex = index
				lowestTime = t.nextTime
			}
		}
		if lowestTime == UInt64.max {
			return nil
		}
		
		return (selectedIndex, lowestTime)
	}
	
	func runTask(threadIndex: DebugContextThread, time: UInt64) -&gt; DebugContextTimer? {
		(currentThread, internalTime) = (threadIndex, time)
		return queues[threadIndex]?.popAndInvokeNext()
	}
	
	// Run the next event. If nil is returned, no further events remain. If
	func runNextTask() -&gt; DebugContextTimer? {
		if let (threadIndex, time) = nextTask() {
			return runTask(threadIndex: threadIndex, time: time)
		}
		return nil
	}
}

// This structure is used to represent scheduled actions in the DebugContextCoordinator.
struct PendingBlock {
	let time: UInt64
	weak var timer: DebugContextTimer?
	let block: () -&gt; Void
	
	init(time: UInt64, timer: DebugContextTimer?, block: @escaping () -&gt; Void) {
		self.time = time
		self.timer = timer
		self.block = block
	}
	
	var nextInterval: PendingBlock? {
		if let t = timer, let i = t.rescheduleInterval, t.coordinator != nil {
			return PendingBlock(time: time + i, timer: t, block: block)
		}
		return nil
	}
}

// A `DebugContextQueue` is just an array of `PendingBlock`, sorted by scheduled time. It represents the blocks queued for execution on a thread in the `DebugContextCoordinator`.
class DebugContextQueue {
	var pendingBlocks: Array&lt;PendingBlock&gt; = []
	
	init() {
	}
	
	// Insert a block in scheduled order
	func schedule(pending: PendingBlock) {
		var insertionIndex = 0
		while pendingBlocks.count &gt; insertionIndex &amp;&amp; pendingBlocks[insertionIndex].time &lt;= pending.time {
			insertionIndex += 1
		}
		
		pendingBlocks.insert(pending, at: insertionIndex)
	}
	
	// Remove a block
	func cancelTimer(_ toCancel: DebugContextTimer) {
		if let index = pendingBlocks.firstIndex(where: { tuple -&gt; Bool in tuple.timer === toCancel }) {
			pendingBlocks.remove(at: index)
		}
	}
	
	// Return the earliest scheduled time in the queue
	var nextTime: UInt64 {
		return pendingBlocks.first?.time ?? UInt64.max
	}
	
	// Runs the next block in the queue
	func popAndInvokeNext() -&gt; DebugContextTimer? {
		if let next = pendingBlocks.first {
			pendingBlocks.remove(at: 0)
			next.block()
			if let nextInterval = next.nextInterval {
				schedule(pending: nextInterval)
			}
			
			// We ran a block, don't return nil (next.timer may return nil if it has self-cancelled)
			return next.timer ?? DebugContextTimer()
		}
		
		return nil
	}
}

/// An implementation of `ExecutionContext` that schedules its non-immediate actions on a `DebugContextCoordinator`. This type is constructed using the `Exec` mimicking properties and functions on `DebugContextCoordinator`.
struct DebugContext: CustomExecutionContext {
	let type: ExecutionType
	let thread: DebugContextThread
	weak var coordinator: DebugContextCoordinator?
	
	init(type: ExecutionType, thread: DebugContextThread, coordinator: DebugContextCoordinator) {
		self.type = type
		self.thread = thread
		self.coordinator = coordinator
	}
	
	/// Run `execute` normally on the execution context
	func invoke(_ execute: @escaping () -&gt; Void) {
		guard let c = coordinator else { return }
		if type.isImmediateInCurrentContext {
			let previousThread = c.currentThread
			if !type.isConcurrent {
				c.currentThread = thread
			}
			execute()
			if !type.isConcurrent {
				c.currentThread = previousThread
			}
		} else {
			invokeAsync(execute)
		}
	}
	
	/// Run `execute` asynchronously on the execution context
	func invokeAsync(_ execute: @escaping () -&gt; Void) {
		_ = coordinator?.schedule(block: execute, thread: thread, timeInterval: 1, repeats: false)
	}
	
	@available(*, deprecated, message: "Use invokeSync instead")
	func invokeAndWait(_ execute: @escaping () -&gt; Void) {
		_ = invokeSync(execute)
	}
	
	/// Run `execute` on the execution context but don't return from this function until the provided function is complete.
	///
	/// If the debug coordinator is nil or has completed before this block is run, the block will be directly invoked instead of running in the debug context.
	/// In general this shouldn't matter since the debug context is generally just a synchronous invocation.
	///
	/// - Parameter execute: the block to run
	/// - Returns: the return value from running the block
	func invokeSync&lt;Return&gt;(_ execute: () throws -&gt; Return) rethrows -&gt; Return {
		guard let c = coordinator else {
			return try execute()
		}
		if type.isImmediateInCurrentContext {
			let previousThread = c.currentThread
			if !type.isConcurrent {
				c.currentThread = thread
			}
			let r = try execute()
			if !type.isConcurrent {
				c.currentThread = previousThread
			}
			return r
		} else {
			let result = try withoutActuallyEscaping(execute) { ex throws -&gt; Return? in
				var rr: Result&lt;Return, Error&gt;? = nil
				c.runScheduledTasks(stoppingAfter: c.schedule(block: {
					rr = Result { try ex() }
				}, thread: thread, timeInterval: 1, repeats: false))
				return try rr?.get()
			}
			guard let r = result else { return try execute() }
			return r
		}
	}
	
	func relativeAsync(qos: DispatchQoS.QoSClass?) -&gt; Exec {
		guard let c = coordinator else {
			return Exec.direct
		}
		return c.global
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`) unless the returned `Lifetime` is cancelled or released before running occurs.
	func singleTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime {
		guard let c = coordinator else { return DebugContextTimer() }
		return c.schedule(block: handler, thread: thread, timeInterval: interval.nanoseconds, repeats: false)
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), passing the `parameter` value as an argument, unless the returned `Lifetime` is cancelled or released before running occurs.
	func singleTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		guard let c = coordinator else { return DebugContextTimer() }
		return c.schedule(block: { handler(parameter) }, thread: thread, timeInterval: interval.nanoseconds, repeats: false)
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), and again every `interval` (within a `leeway` margin of error) unless the returned `Lifetime` is cancelled or released before running occurs.
	func periodicTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime {
		guard let c = coordinator else { return DebugContextTimer() }
		return c.schedule(block: handler, thread: thread, timeInterval: interval.nanoseconds, repeats: true)
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), passing the `parameter` value as an argument, and again every `interval` (within a `leeway` margin of error) unless the returned `Lifetime` is cancelled or released before running occurs.
	func periodicTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		guard let c = coordinator else { return DebugContextTimer() }
		return c.schedule(block: { handler(parameter) }, thread: thread, timeInterval: interval.nanoseconds, repeats: true)
	}
	
	/// Gets a timestamp representing the host uptime the in the current context
	func timestamp() -&gt; DispatchTime {
		guard let c = coordinator else { return DispatchTime.now() }
		return DispatchTime(uptimeNanoseconds: c.currentTime)
	}
}

// All actions scheduled with a `DebugContextCoordinator` are referenced by a DebugContextTimer (even those actions that are simply asynchronous invocations without a delay).
class DebugContextTimer: Lifetime {
	let thread: DebugContextThread
	let rescheduleInterval: UInt64?
	weak var coordinator: DebugContextCoordinator?
	
	init() {
		thread = .unspecified
		coordinator = nil
		rescheduleInterval = nil
	}
	
	init(thread: DebugContextThread, rescheduleInterval: UInt64?, coordinator: DebugContextCoordinator) {
		self.thread = thread
		self.coordinator = coordinator
		self.rescheduleInterval = rescheduleInterval
	}
	
	/// Lifetime implementation
	func cancel() {
		coordinator?.cancelTimer(self)
		coordinator = nil
	}
	
	deinit {
		cancel()
	}
}

import Foundation

// This type is designed for guarding against mutex re-entrancy by following two simple rules:
//
//  1. No user "work" (functions or closures) should be invoked inside a private mutex
//  2. No user supplied data should be released inside a private mutex
//
// To facilitate these requirements, any user "work" or data ownership should be handled inside `DeferredWork` blocks. These blocks allow this user code to be queued in the desired order but since the `runWork` function should only be called outside the mutex, these blocks run safely outside the mutex.
//
// This pattern has two associated risks:
//  1. If the deferred work calls back into the mutex, it must be able to ensure that it is still relevant (hasn't been superceded by an action that may have occurred between the end of the mutex and the performing of the `DeferredWork`. This may involve a token (inside the mutex, only the most recent token is accepted) or the mutex queueing further requests until the most recent `DeferredWork` completes.
//  2. The `runWork` must be manually invoked. Automtic invocation (e.g in the `deinit` of a lifetime managed `class` instance) would add heap allocation overhead and would also be easy to accidentally release at the wrong point (inside the mutex) causing erratic problems. Instead, the `runWork` is guarded with a `DEBUG`-only `OnDelete` check that ensures that the `runWork` has been correctly invoked by the time the `DeferredWork` falls out of scope.
struct DeferredWork {
	typealias PossibleWork = Few&lt;() -&gt; Void&gt;
	
	var work: PossibleWork

	#if DEBUG
		let invokeCheck: OnDelete = { () -&gt; OnDelete in
			var sourceStack = Thread.callStackReturnAddresses
			return OnDelete {
				let symbols = symbolsForCallStack(addresses: sourceStack.map { $0.uintValue })
				preconditionFailure("Failed to perform work deferred at location:\n" + symbols.joined(separator: "\n"))
			}
		}()
	#endif

	init() {
		work = .none
	}
	
	init(initial: @escaping () -&gt; Void) {
		work = .single(initial)
	}
	
	mutating func append(_ other: DeferredWork) {
		#if DEBUG
			precondition(invokeCheck.isValid &amp;&amp; other.invokeCheck.isValid, "Work appended to an already cancelled/invoked DeferredWork")
				other.invokeCheck.invalidate()
		#endif
		
		switch other.work {
		case .none: break
		case .single(let otherWork): self.append(otherWork)
		case .array(let otherWork):
			switch work {
			case .none: work = .array(otherWork)
			case .single(let existing):
				var newWork: Array&lt;() -&gt; Void&gt; = [existing]
				newWork.append(contentsOf: otherWork)
				work = .array(newWork)
			case .array(var existing):
				work = .none
				existing.append(contentsOf: otherWork)
				work = .array(existing)
			}
		}
	}
	
	mutating func append(_ additionalWork: @escaping () -&gt; Void) {
		#if DEBUG
			precondition(invokeCheck.isValid, "Work appended to an already cancelled/invoked DeferredWork")
		#endif
		
		switch work {
		case .none: work = .single(additionalWork)
		case .single(let existing): work = .array([existing, additionalWork])
		case .array(var existing):
			work = .none
			existing.append(additionalWork)
			work = .array(existing)
		}
	}
	
	mutating func runWork() {
		#if DEBUG
			precondition(invokeCheck.isValid, "Work run multiple times")
			invokeCheck.invalidate()
		#endif
		
		switch work {
		case .none: break
		case .single(let w): w()
		case .array(let ws):
			for w in ws {
				w()
			}
		}
		work = .none
	}
}

import Foundation

/// This is a basic "circular-buffer" style Double-Ended Queue.
struct Deque&lt;T&gt;: RandomAccessCollection, MutableCollection, RangeReplaceableCollection, ExpressibleByArrayLiteral, CustomDebugStringConvertible {
	typealias Index = Int
	typealias Indices = CountableRange&lt;Int&gt;
	typealias Element = T
	
	private let overAllocateFactor = 2
	private let downsizeTriggerFactor = 16
	private let defaultMinimumCapacity = 5
	
	private var buffer: DequeBuffer&lt;T&gt;? = nil
	private var minCapacity: Int
	
	/// Implementation of RangeReplaceableCollection function
	init() {
		self.minCapacity = defaultMinimumCapacity
	}
	
	/// Allocate with a minimum capacity
	init(minCapacity: Int) {
		self.minCapacity = minCapacity
	}
	
	/// Implementation of ExpressibleByArrayLiteral function
	init(arrayLiteral: T...) {
		self.minCapacity = defaultMinimumCapacity
		replaceSubrange(0..&lt;0, with: arrayLiteral)
	}
	
	/// Implementation of CustomDebugStringConvertible function
	var debugDescription: String {
		var result = "\(type(of: self))(["
		var iterator = makeIterator()
		if let next = iterator.next() {
			debugPrint(next, terminator: "", to: &amp;result)
			while let n = iterator.next() {
				result += ", "
				debugPrint(n, terminator: "", to: &amp;result)
			}
		}
		result += "])"
		return result
	}
	
	#if swift(&gt;=4.1)
		subscript(bounds: Range&lt;Index&gt;) -&gt; Slice&lt;Deque&lt;T&gt;&gt; {
			return Slice&lt;Deque&lt;T&gt;&gt;(base: self, bounds: bounds)
		}
	#else
		subscript(bounds: Range&lt;Index&gt;) -&gt; RangeReplaceableRandomAccessSlice&lt;Deque&lt;T&gt;&gt; {
			return RangeReplaceableRandomAccessSlice&lt;Deque&lt;T&gt;&gt;(base: self, bounds: bounds)
		}
	#endif
	
	/// Implementation of RandomAccessCollection function
	subscript(_ at: Index) -&gt; T {
		get {
			return buffer!.withUnsafeMutablePointers { headerPtr, bodyPtr -&gt; T in
				precondition(at &gt;= 0 &amp;&amp; at &lt; headerPtr.pointee.count)
				var offset = headerPtr.pointee.offset + at
				if offset &gt;= headerPtr.pointee.capacity {
					offset -= headerPtr.pointee.capacity
				}
				return bodyPtr[offset]
			}
		}
		set {
			buffer!.withUnsafeMutablePointers { headerPtr, bodyPtr in
				precondition(at &gt;= 0 &amp;&amp; at &lt; headerPtr.pointee.count)
				var offset = headerPtr.pointee.offset + at
				if offset &gt;= headerPtr.pointee.capacity {
					offset -= headerPtr.pointee.capacity
				}
				bodyPtr[offset] = newValue
			}
		}
	}
	
	/// Implementation of Collection function
	var startIndex: Index {
		return 0
	}
	
	/// Implementation of Collection function
	var endIndex: Index {
		return buffer?.withUnsafeMutablePointerToHeader { headerPtr in headerPtr.pointee.count } ?? 0
	}
	
	/// Implementation of Collection function
	var isEmpty: Bool {
		return buffer?.withUnsafeMutablePointerToHeader { headerPtr in headerPtr.pointee.count == 0 } ?? true
	}
	
	/// Implementation of Collection function
	var count: Int {
		return endIndex
	}
	
	/// Optimized implementation of RangeReplaceableCollection function
	mutating func append(_ newElement: T) {
		let done = buffer?.withUnsafeMutablePointers { headerPtr, bodyPtr -&gt; Bool in
			guard headerPtr.pointee.capacity &gt;= headerPtr.pointee.count + 1 else { return false }
			var index = headerPtr.pointee.offset + headerPtr.pointee.count
			if index &gt;= headerPtr.pointee.capacity {
				index -= headerPtr.pointee.capacity
			}
			bodyPtr.advanced(by: index).initialize(to: newElement)
			headerPtr.pointee.count += 1
			return true
		} ?? false
		
		if done {
			return
		}
		
		let index = endIndex
		return replaceSubrange(index..&lt;index, with: CollectionOfOne(newElement))
	}
	
	/// Optimized implementation of RangeReplaceableCollection function
	mutating func insert(_ newElement: T, at: Int) {
		let done = buffer?.withUnsafeMutablePointers { headerPtr, bodyPtr -&gt; Bool in
			guard at == 0, headerPtr.pointee.capacity &gt;= headerPtr.pointee.count + 1 else { return false }
			var index = headerPtr.pointee.offset - 1
			if index &lt; 0 {
				index += headerPtr.pointee.capacity
			}
			bodyPtr.advanced(by: index).initialize(to: newElement)
			headerPtr.pointee.count += 1
			headerPtr.pointee.offset = index
			return true
		} ?? false
		
		if done {
			return
		}
		
		return replaceSubrange(at..&lt;at, with: CollectionOfOne(newElement))
	}
	
	/// Optimized implementation of RangeReplaceableCollection function
	mutating func remove(at: Int) {
		let done = buffer?.withUnsafeMutablePointers { headerPtr, bodyPtr -&gt; Bool in
			if at == headerPtr.pointee.count - 1 {
				headerPtr.pointee.count -= 1
				return true
			} else if at == 0, headerPtr.pointee.count &gt; 0 {
				headerPtr.pointee.offset += 1
				if headerPtr.pointee.offset &gt;= headerPtr.pointee.capacity {
					headerPtr.pointee.offset -= headerPtr.pointee.capacity
				}
				headerPtr.pointee.count -= 1
				return true
			}
			return false
		} ?? false
		
		if done {
			return
		}
		
		return replaceSubrange(at...at, with: EmptyCollection())
	}
	
	/// Optimized implementation of RangeReplaceableCollection function
	mutating func removeFirst() -&gt; T {
		return buffer!.withUnsafeMutablePointers { headerPtr, bodyPtr -&gt; T in
			precondition(headerPtr.pointee.count &gt; 0, "Index beyond bounds")
			let result = bodyPtr[headerPtr.pointee.offset]
			#if swift(&gt;=4.1)
				bodyPtr.advanced(by: headerPtr.pointee.offset).deinitialize(count: 1)
			#else
				bodyPtr.advanced(by: headerPtr.pointee.offset).deinitialize()
			#endif
			headerPtr.pointee.offset += 1
			if headerPtr.pointee.offset &gt;= headerPtr.pointee.capacity {
				headerPtr.pointee.offset -= headerPtr.pointee.capacity
			}
			headerPtr.pointee.count -= 1
			return result
		}
	}
	
	// Used when removing a range from the collection or deiniting self.
	private static func deinitialize(range: CountableRange&lt;Int&gt;, header: UnsafeMutablePointer&lt;DequeHeader&gt;, body: UnsafeMutablePointer&lt;T&gt;) {
		let splitRange = header.pointee.splitRangeIndices(inRange: range)
		body.advanced(by: splitRange.low.startIndex).deinitialize(count: splitRange.low.count)
		body.advanced(by: splitRange.high.startIndex).deinitialize(count: splitRange.high.count)
	}
	
	// Move from an initialized to an uninitialized location, deinitializing the source.
	//
	// NOTE: the terms "preMapped" and "postMapped" are used. "preMapped" refer to the indices exposed by this type (zero based, contiguous), and "postMapped" refers to internal offsets within the buffer (not necessarily zero based and may wrap around). This function will only handle a single, contiguous block of "postMapped" indices so the caller must ensure that this function is invoked separately for each contiguous block.
	private static func moveInitialize(preMappedSourceRange: CountableRange&lt;Int&gt;, postMappedDestinationRange: CountableRange&lt;Int&gt;, sourceHeader: UnsafeMutablePointer&lt;DequeHeader&gt;, sourceBody: UnsafeMutablePointer&lt;T&gt;, destinationBody: UnsafeMutablePointer&lt;T&gt;) {
		let sourceSplitRange = sourceHeader.pointee.splitRangeIndices(inRange: preMappedSourceRange)
		
		assert(sourceSplitRange.low.startIndex &gt;= 0 &amp;&amp; (sourceSplitRange.low.startIndex &lt; sourceHeader.pointee.capacity || sourceSplitRange.low.startIndex == sourceSplitRange.low.endIndex))
		assert(sourceSplitRange.low.endIndex &gt;= 0 &amp;&amp; sourceSplitRange.low.endIndex &lt;= sourceHeader.pointee.capacity)
		
		assert(sourceSplitRange.high.startIndex &gt;= 0 &amp;&amp; (sourceSplitRange.high.startIndex &lt; sourceHeader.pointee.capacity || sourceSplitRange.high.startIndex == sourceSplitRange.high.endIndex))
		assert(sourceSplitRange.high.endIndex &gt;= 0 &amp;&amp; sourceSplitRange.high.endIndex &lt;= sourceHeader.pointee.capacity)
		
		destinationBody.advanced(by: postMappedDestinationRange.startIndex).moveInitialize(from: sourceBody.advanced(by: sourceSplitRange.low.startIndex), count: sourceSplitRange.low.count)
		destinationBody.advanced(by: postMappedDestinationRange.startIndex + sourceSplitRange.low.count).moveInitialize(from: sourceBody.advanced(by: sourceSplitRange.high.startIndex), count: sourceSplitRange.high.count)
	}
	
	// Copy from an initialized to an uninitialized location, leaving the source initialized.
	//
	// NOTE: the terms "preMapped" and "postMapped" are used. "preMapped" refer to the indices exposed by this type (zero based, contiguous), and "postMapped" refers to internal offsets within the buffer (not necessarily zero based and may wrap around). This function will only handle a single, contiguous block of "postMapped" indices so the caller must ensure that this function is invoked separately for each contiguous block.
	private static func copyInitialize(preMappedSourceRange: CountableRange&lt;Int&gt;, postMappedDestinationRange: CountableRange&lt;Int&gt;, sourceHeader: UnsafeMutablePointer&lt;DequeHeader&gt;, sourceBody: UnsafeMutablePointer&lt;T&gt;, destinationBody: UnsafeMutablePointer&lt;T&gt;) {
		let sourceSplitRange = sourceHeader.pointee.splitRangeIndices(inRange: preMappedSourceRange)
		
		assert(sourceSplitRange.low.startIndex &gt;= 0 &amp;&amp; (sourceSplitRange.low.startIndex &lt; sourceHeader.pointee.capacity || sourceSplitRange.low.startIndex == sourceSplitRange.low.endIndex))
		assert(sourceSplitRange.low.endIndex &gt;= 0 &amp;&amp; sourceSplitRange.low.endIndex &lt;= sourceHeader.pointee.capacity)
		
		assert(sourceSplitRange.high.startIndex &gt;= 0 &amp;&amp; (sourceSplitRange.high.startIndex &lt; sourceHeader.pointee.capacity || sourceSplitRange.high.startIndex == sourceSplitRange.high.endIndex))
		assert(sourceSplitRange.high.endIndex &gt;= 0 &amp;&amp; sourceSplitRange.high.endIndex &lt;= sourceHeader.pointee.capacity)
		
		destinationBody.advanced(by: postMappedDestinationRange.startIndex).initialize(from: sourceBody.advanced(by: sourceSplitRange.low.startIndex), count: sourceSplitRange.low.count)
		destinationBody.advanced(by: postMappedDestinationRange.startIndex + sourceSplitRange.low.count).initialize(from: sourceBody.advanced(by: sourceSplitRange.high.startIndex), count: sourceSplitRange.high.count)
	}
	
	// Internal implementation of replaceSubrange&lt;C&gt;(_:with:) when no reallocation
	// of the underlying buffer is required
	private static func mutateWithoutReallocate&lt;C&gt;(info: DequeMutationInfo2, elements newElements: C, header: UnsafeMutablePointer&lt;DequeHeader&gt;, body: UnsafeMutablePointer&lt;T&gt;) where C: Collection, C.Iterator.Element == T {
		if info.removed &gt; 0 {
			Deque.deinitialize(range: info.start..&lt;(info.start + info.removed), header: header, body: body)
		}
		
		if info.removed != info.inserted {
			if info.start &lt; header.pointee.count - (info.start + info.removed) {
				let oldOffset = header.pointee.offset
				header.pointee.offset -= info.inserted - info.removed
				if header.pointee.offset &lt; 0 {
					header.pointee.offset += header.pointee.capacity
				} else if header.pointee.offset &gt;= header.pointee.capacity {
					header.pointee.offset -= header.pointee.capacity
				}
				let delta = oldOffset - header.pointee.offset
				if info.start != 0 {
					let destinationSplitIndices = header.pointee.splitRangeIndices(inRange: 0..&lt;info.start)
					let lowCount = destinationSplitIndices.low.count
					Deque.moveInitialize(preMappedSourceRange: delta..&lt;(delta + lowCount), postMappedDestinationRange: destinationSplitIndices.low, sourceHeader: header, sourceBody: body, destinationBody: body)
					if lowCount != info.start {
						Deque.moveInitialize(preMappedSourceRange: (delta + lowCount)..&lt;(info.start + delta), postMappedDestinationRange: destinationSplitIndices.high, sourceHeader: header, sourceBody: body, destinationBody: body)
					}
				}
			} else {
				if (info.start + info.removed) != header.pointee.count {
					let start = info.start + info.removed
					let end = header.pointee.count
					let destinationSplitIndices = header.pointee.splitRangeIndices(inRange: (info.start + info.inserted)..&lt;(end - info.removed + info.inserted))
					let lowCount = destinationSplitIndices.low.count
					
					Deque.moveInitialize(preMappedSourceRange: start..&lt;end, postMappedDestinationRange: destinationSplitIndices.low, sourceHeader: header, sourceBody: body, destinationBody: body)
					if lowCount != end - start {
						Deque.moveInitialize(preMappedSourceRange: (start + lowCount)..&lt;end, postMappedDestinationRange: destinationSplitIndices.high, sourceHeader: header, sourceBody: body, destinationBody: body)
					}
				}
			}
			header.pointee.count = header.pointee.count - info.removed + info.inserted
		}
		
		if info.inserted == 1, let e = newElements.first {
			if info.start &gt;= header.pointee.capacity - header.pointee.offset {
				body.advanced(by: info.start - header.pointee.capacity + header.pointee.offset).initialize(to: e)
			} else {
				body.advanced(by: header.pointee.offset + info.start).initialize(to: e)
			}
		} else if info.inserted &gt; 0 {
			let inserted = header.pointee.splitRangeIndices(inRange: info.start..&lt;(info.start + info.inserted))
			var iterator = newElements.makeIterator()
			for i in inserted.low {
				if let n = iterator.next() {
					body.advanced(by: i).initialize(to: n)
				}
			}
			for i in inserted.high {
				if let n = iterator.next() {
					body.advanced(by: i).initialize(to: n)
				}
			}
		}
	}
	
	// Internal implementation of replaceSubrange&lt;C&gt;(_:with:) when reallocation
	// of the underlying buffer is required. Can handle no previous buffer or
	// previous buffer too small or previous buffer too big or previous buffer
	// non-unique.
	private mutating func reallocateAndMutate&lt;C&gt;(info: DequeMutationInfo2, elements newElements: C, header: UnsafeMutablePointer&lt;DequeHeader&gt;?, body: UnsafeMutablePointer&lt;T&gt;?, deletePrevious: Bool) where C: Collection, C.Iterator.Element == T {
		if info.newCount == 0 {
			// Let the regular deallocation handle the deinitialize
			buffer = nil
		} else {
			let newCapacity: Int
			let oldCapacity = header?.pointee.capacity ?? 0
			if info.newCount &gt; oldCapacity || info.newCount &lt;= oldCapacity / downsizeTriggerFactor {
				newCapacity = Swift.max(minCapacity, info.newCount * overAllocateFactor)
			} else {
				newCapacity = oldCapacity
			}
			
			let newBuffer = DequeBuffer&lt;T&gt;.create(minimumCapacity: newCapacity) { (buffer: ManagedBuffer&lt;DequeHeader, T&gt;) in
				return DequeHeader(offset: 0, count: info.newCount, capacity: newCapacity)
			} as! DequeBuffer&lt;T&gt;
			if let headerPtr = header, let bodyPtr = body {
				if deletePrevious, info.removed &gt; 0 {
					Deque.deinitialize(range: info.start..&lt;(info.start + info.removed), header: headerPtr, body: bodyPtr)
				}
				
				newBuffer.withUnsafeMutablePointerToElements { newBody in
					if info.start != 0 {
						if deletePrevious {
							Deque.moveInitialize(preMappedSourceRange: 0..&lt;info.start, postMappedDestinationRange: 0..&lt;info.start, sourceHeader: headerPtr, sourceBody: bodyPtr, destinationBody: newBody)
						} else {
							Deque.copyInitialize(preMappedSourceRange: 0..&lt;info.start, postMappedDestinationRange: 0..&lt;info.start, sourceHeader: headerPtr, sourceBody: bodyPtr, destinationBody: newBody)
						}
					}
					
					let oldCount = header?.pointee.count ?? 0
					if info.start + info.removed != oldCount {
						if deletePrevious {
							Deque.moveInitialize(preMappedSourceRange: (info.start + info.removed)..&lt;oldCount, postMappedDestinationRange: (info.start + info.inserted)..&lt;info.newCount, sourceHeader: headerPtr, sourceBody: bodyPtr, destinationBody: newBody)
						} else {
							Deque.copyInitialize(preMappedSourceRange: (info.start + info.removed)..&lt;oldCount, postMappedDestinationRange: (info.start + info.inserted)..&lt;info.newCount, sourceHeader: headerPtr, sourceBody: bodyPtr, destinationBody: newBody)
						}
					}
				}
				
				// Make sure the old buffer doesn't deinitialize when it deallocates.
				if deletePrevious {
					headerPtr.pointee.count = 0
				}
			}
			
			if info.inserted &gt; 0 {
				newBuffer.withUnsafeMutablePointerToElements { newBody in
					#if swift(&gt;=3.1)
						let umbp = UnsafeMutableBufferPointer(start: newBody.advanced(by: info.start), count: info.inserted)
						_ = umbp.initialize(from: newElements)
					#else
						// Insert the new subrange
						newBody.advanced(by: info.start).initialize(from: newElements)
					#endif
				}
			}
			
			buffer = newBuffer
		}
	}
	
	/// Implemetation of the RangeReplaceableCollection function. Internally
	/// implemented using either mutateWithoutReallocate or reallocateAndMutate.
	mutating func replaceSubrange&lt;C&gt;(_ subrange: Range&lt;Int&gt;, with newElements: C) where C: Collection, C.Iterator.Element == T {
		precondition(subrange.lowerBound &gt;= 0, "Subrange lowerBound is negative")
		
		if isKnownUniquelyReferenced(&amp;buffer), let b = buffer {
			b.withUnsafeMutablePointers { headerPtr, bodyPtr in
				let info = DequeMutationInfo2(subrange: subrange, previousCount: headerPtr.pointee.count, insertedCount: numericCast(newElements.count))
				if info.newCount &lt;= headerPtr.pointee.capacity &amp;&amp; (info.newCount &lt; minCapacity || info.newCount &gt; headerPtr.pointee.capacity / downsizeTriggerFactor) {
					Deque.mutateWithoutReallocate(info: info, elements: newElements, header: headerPtr, body: bodyPtr)
				} else {
					reallocateAndMutate(info: info, elements: newElements, header: headerPtr, body: bodyPtr, deletePrevious: true)
				}
			}
		} else if let b = buffer {
			b.withUnsafeMutablePointers { headerPtr, bodyPtr in
				let info = DequeMutationInfo2(subrange: subrange, previousCount: headerPtr.pointee.count, insertedCount: numericCast(newElements.count))
				reallocateAndMutate(info: info, elements: newElements, header: headerPtr, body: bodyPtr, deletePrevious: false)
			}
		} else {
			let info = DequeMutationInfo2(subrange: subrange, previousCount: 0, insertedCount: numericCast(newElements.count))
			reallocateAndMutate(info: info, elements: newElements, header: nil, body: nil, deletePrevious: true)
		}
	}
}

// Internal state for the Deque
private struct DequeHeader {
	var offset: Int
	var count: Int
	var capacity: Int
	
	// Translate from preMapped to postMapped indices.
	//
	// "preMapped" refer to the indices exposed by this type (zero based, contiguous), and "postMapped" refers to internal offsets within the buffer (not necessarily zero based and may wrap around).
	//
	// Since "postMapped" indices are not necessarily contiguous, two separate, contiguous ranges are returned. Both `startIndex` and `endIndex` in the `high` range will equal the `endIndex` in the `low` range if the range specified by `inRange` is continuous after mapping.
	func splitRangeIndices(inRange: CountableRange&lt;Int&gt;) -&gt; (low: CountableRange&lt;Int&gt;, high: CountableRange&lt;Int&gt;) {
		let limit = capacity - offset
		if inRange.startIndex &gt;= limit {
			return (low: (inRange.startIndex - limit)..&lt;(inRange.endIndex - limit), high: (inRange.endIndex - limit)..&lt;(inRange.endIndex - limit))
		} else if inRange.endIndex &gt; limit {
			return (low: (inRange.startIndex + offset)..&lt;capacity, high: 0..&lt;(inRange.endIndex - limit))
		}
		return (low: (inRange.startIndex + offset)..&lt;(inRange.endIndex + offset), high: (inRange.endIndex + offset)..&lt;(inRange.endIndex + offset))
	}
	
}

// Private type used to communicate parameters between replaceSubrange&lt;C&gt;(_:with:)
// and reallocateAndMutate or mutateWithoutReallocate
private struct DequeMutationInfo2 {
	let start: Int
	let removed: Int
	let inserted: Int
	let newCount: Int
	
	init(subrange: Range&lt;Int&gt;, previousCount: Int, insertedCount: Int) {
		precondition(subrange.upperBound &lt;= previousCount, "Subrange upperBound is out of range")
		
		self.start = subrange.lowerBound
		self.removed = subrange.count
		self.inserted = insertedCount
		self.newCount = previousCount - self.removed + self.inserted
	}
}

// Private reimplementation of function with same name from stdlib/public/core/BuiltIn.swift
private func roundUp(_ offset: UInt, toAlignment alignment: Int) -&gt; UInt {
	let x = offset + UInt(bitPattern: alignment) &amp;- 1
	return x &amp; ~(UInt(bitPattern: alignment) &amp;- 1)
}

// Private reimplementation of definition from stdlib/public/SwiftShims/HeapObject.h
private struct HeapObject {
	let metadata: Int = 0
	let strongRefCount: UInt32 = 0
	let weakRefCount: UInt32 = 0
}

// An implementation of DequeBuffer using ManagedBufferPointer to allocate the
// storage and then using raw pointer offsets into self to access contents
// (avoiding the ManagedBufferPointer accessors which are a performance problem
// in Swift 3).
private final class DequeBuffer&lt;T&gt;: ManagedBuffer&lt;DequeHeader, T&gt; {
	#if true
		private static var headerOffset: Int {
			return Int(roundUp(UInt(MemoryLayout&lt;HeapObject&gt;.size), toAlignment: MemoryLayout&lt;DequeHeader&gt;.alignment))
		}
		
		private static var elementOffset: Int {
			return Int(roundUp(UInt(headerOffset) + UInt(MemoryLayout&lt;DequeHeader&gt;.size), toAlignment: MemoryLayout&lt;T&gt;.alignment))
		}
		
		private var bodyPtr: UnsafeMutablePointer&lt;T&gt; {
			return Unmanaged&lt;DequeBuffer&lt;T&gt;&gt;.passUnretained(self).toOpaque().advanced(by: DequeBuffer&lt;T&gt;.elementOffset).assumingMemoryBound(to: T.self)
		}
		
		private var headerPtr: UnsafeMutablePointer&lt;DequeHeader&gt; {
			return Unmanaged&lt;DequeBuffer&lt;T&gt;&gt;.passUnretained(self).toOpaque().advanced(by: DequeBuffer&lt;T&gt;.headerOffset).assumingMemoryBound(to: DequeHeader.self)
		}
	#endif
	
	deinit {
		#if true
			// We need to assert this in case some of our dirty assumptions stop being true
			assert(ManagedBufferPointer&lt;DequeHeader, T&gt;(unsafeBufferObject: self).withUnsafeMutablePointers { (header, body) in
				self.headerPtr == header &amp;&amp; self.bodyPtr == body
			})
			
			let splitRange = headerPtr.pointee.splitRangeIndices(inRange: 0..&lt;headerPtr.pointee.count)
			bodyPtr.advanced(by: splitRange.low.startIndex).deinitialize(count: splitRange.low.count)
			bodyPtr.advanced(by: splitRange.high.startIndex).deinitialize(count: splitRange.high.count)
		#else
			withUnsafeMutablePointers { headerPtr, bodyPtr in
				let splitRange = headerPtr.pointee.splitRangeIndices(inRange: 0..&lt;headerPtr.pointee.count)
				bodyPtr.advanced(by: splitRange.low.startIndex).deinitialize(count: splitRange.low.count)
				bodyPtr.advanced(by: splitRange.high.startIndex).deinitialize(count: splitRange.high.count)
			}
		#endif
	}
}

import Foundation

extension DispatchSource {
	// An overload of timer that immediately sets the handler and schedules the timer
	class func singleTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), queue: DispatchQueue, handler: @escaping () -&gt; Void) -&gt; DispatchSourceTimer {
		let result = DispatchSource.makeTimerSource(queue: queue)
		result.setEventHandler(handler: handler)
		#if swift(&gt;=4)
			result.schedule(deadline: DispatchTime.now() + interval, leeway: leeway)
		#else
			result.scheduleOneshot(deadline: DispatchTime.now() + interval, leeway: leeway)
		#endif
		result.resume()
		return result
	}
	
	// An overload of timer that always uses the default global queue (because it is intended to enter the appropriate mutex as a separate step) and passes a user-supplied Int to the handler function to allow ignoring callbacks if cancelled or rescheduled before mutex acquisition.
	class func singleTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), queue: DispatchQueue = DispatchQueue.global(), handler: @escaping (T) -&gt; Void) -&gt; DispatchSourceTimer {
		let result = DispatchSource.makeTimerSource(queue: queue)
		result.scheduleOneshot(parameter: parameter, interval: interval, leeway: leeway, handler: handler)
		result.resume()
		return result
	}
	
	// An overload of timer that immediately sets the handler and schedules the timer
	class func repeatingTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), queue: DispatchQueue = DispatchQueue.global(), handler: @escaping () -&gt; Void) -&gt; DispatchSourceTimer {
		let result = DispatchSource.makeTimerSource(queue: queue)
		result.setEventHandler(handler: handler)
		#if swift(&gt;=4)
			result.schedule(deadline: DispatchTime.now() + interval, repeating: interval, leeway: leeway)
		#else
			result.scheduleRepeating(deadline: DispatchTime.now() + interval, interval: interval, leeway: leeway)
		#endif
		result.resume()
		return result
	}
	
	// An overload of timer that always uses the default global queue (because it is intended to enter the appropriate mutex as a separate step) and passes a user-supplied Int to the handler function to allow ignoring callbacks if cancelled or rescheduled before mutex acquisition.
	class func repeatingTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), queue: DispatchQueue = DispatchQueue.global(), handler: @escaping (T) -&gt; Void) -&gt; DispatchSourceTimer {
		let result = DispatchSource.makeTimerSource(queue: queue)
		result.scheduleRepeating(parameter: parameter, interval: interval, leeway: leeway, handler: handler)
		result.resume()
		return result
	}
}

extension DispatchSourceTimer {
	// An overload of scheduleOneshot that updates the handler function with a new user-supplied parameter when it changes the expiry deadline
	func scheduleOneshot&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), handler: @escaping (T) -&gt; Void) {
		suspend()
		setEventHandler { handler(parameter) }
		#if swift(&gt;=4)
			schedule(deadline: DispatchTime.now() + interval, leeway: leeway)
		#else
			scheduleOneshot(deadline: DispatchTime.now() + interval, leeway: leeway)
		#endif
		resume()
	}
	
	// An overload of scheduleOneshot that updates the handler function with a new user-supplied parameter when it changes the expiry deadline
	func scheduleRepeating&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), handler: @escaping (T) -&gt; Void) {
		suspend()
		setEventHandler { handler(parameter) }
		#if swift(&gt;=4)
			schedule(deadline: DispatchTime.now() + interval, repeating: interval, leeway: leeway)
		#else
			scheduleRepeating(deadline: DispatchTime.now() + interval, interval: interval, leeway: leeway)
		#endif
		resume()
	}
}

extension DispatchTime {
	func since(_ previous: DispatchTime) -&gt; DispatchTimeInterval {
		return .nanoseconds(Int(uptimeNanoseconds - previous.uptimeNanoseconds))
	}
}

extension DispatchTimeInterval {
	static func interval(_ seconds: TimeInterval) -&gt; DispatchTimeInterval {
		if MemoryLayout&lt;Int&gt;.size &lt; 8 {
			return .milliseconds(Int(seconds * Double(NSEC_PER_SEC / NSEC_PER_MSEC)))
		} else {
			return .nanoseconds(Int(seconds * Double(NSEC_PER_SEC)))
		}
	}
	
	var seconds: Double {
		#if swift (&gt;=3.2)
			switch self {
			case .seconds(let t): return Double(t)
			case .milliseconds(let t): return (Double(NSEC_PER_MSEC) / Double(NSEC_PER_SEC)) * Double(t)
			case .microseconds(let t): return (Double(NSEC_PER_USEC) / Double(NSEC_PER_SEC)) * Double(t)
			case .nanoseconds(let t): return (1.0 / Double(NSEC_PER_SEC)) * Double(t)
			case .never: return Double.infinity
			#if swift (&gt;=5)
				default: fatalError("Unknown case")
			#endif
			}
		#else
			switch self {
			case .seconds(let t): return Double(t)
			case .milliseconds(let t): return (Double(NSEC_PER_MSEC) / Double(NSEC_PER_SEC)) * Double(t)
			case .microseconds(let t): return (Double(NSEC_PER_USEC) / Double(NSEC_PER_SEC)) * Double(t)
			case .nanoseconds(let t): return (1.0 / Double(NSEC_PER_SEC)) * Double(t)
			}
		#endif
	}
	
	var nanoseconds: Int64 {
		#if swift (&gt;=3.2)
			switch self {
			case .seconds(let t): return Int64(NSEC_PER_SEC) * Int64(t)
			case .milliseconds(let t): return Int64(NSEC_PER_MSEC) * Int64(t)
			case .microseconds(let t): return Int64(NSEC_PER_USEC) * Int64(t)
			case .nanoseconds(let t): return Int64(t)
			case .never: return Int64.max
			#if swift (&gt;=5)
				default: fatalError("Unknown case")
			#endif
			}
		#else
			switch self {
			case .seconds(let t): return Int64(NSEC_PER_SEC) * Int64(t)
			case .milliseconds(let t): return Int64(NSEC_PER_MSEC) * Int64(t)
			case .microseconds(let t): return Int64(NSEC_PER_USEC) * Int64(t)
			case .nanoseconds(let t): return Int64(t)
			}
		#endif
	}
}

import Foundation

/// `Exec` is a representation of an arbitrary execution context and offers the ability to interrogate properties of the execution context or to invoke blocks within the context in a number of different ways. The base enum implements the three most common types of execution context in Swift. Switching over these pre-defined cases enables the caller to perform appropriate optimizations (e.g. avoiding calling `invoke` on Exec.direct).
///
/// - direct: the context will directly call any supplied block with no other action taken
/// - main: the context will invoke on the main thread, preferring synchronous invocation where possible.
/// - queue: the context will invoke on a DispatchQueue with details descrbied in the `ExecutionType`
/// - custom: a `CustomExecutionContext` handles all interrogation and invoking
enum Exec {
	/// Invoked directly from the caller's context
	case direct
	
	/// Invoked on the main thread, directly if the current thread is the main thread, otherwise asynchronously (unless invokeSync is used)
	case main
	
	/// Invoked using a Dispatch Queue
	case queue(DispatchQueue, ExecutionType)
	
	/// Invoked using the wrapped existential.
	case custom(CustomExecutionContext)
}

extension Exec {
	/// If this context is concurrent, returns a serialization around this context, otherwise returns this context.
	func serialized() -&gt; Exec {
		return self.type.isConcurrent ? Exec.custom(SerializingContext(concurrentContext: self)) : self
	}
	
	/// Invoked on the main thread, always asynchronously (unless invokeSync is used)
	static var mainAsync: Exec {
		return .queue(.main, .threadAsync { Thread.isMainThread })
	}
	
	/// Invoked asynchronously in the global queue with QOS_CLASS_DEFAULT priority
	static var global: Exec {
		return .queue(.global(), .concurrentAsync)
	}
	
	/// Invoked asynchronously in the global queue with QOS_CLASS_DEFAULT priority
	static func global(qos: DispatchQoS.QoSClass) -&gt; Exec {
		return .queue(.global(qos: qos), .concurrentAsync)
	}
	
	/// Invoked asynchronously in the global queue with QOS_CLASS_USER_INTERACTIVE priority
	static var interactive: Exec {
		return .queue(.global(qos: .userInteractive), .concurrentAsync)
	}
	
	/// Invoked asynchronously in the global queue with QOS_CLASS_USER_INITIATED priority
	static var user: Exec {
		return .queue(.global(qos: .userInitiated), .concurrentAsync)
	}
	
	/// Invoked asynchronously in the global queue with QOS_CLASS_UTILITY priority
	static var utility: Exec {
		return .queue(.global(qos: .utility), .concurrentAsync)
	}
	
	/// Invoked asynchronously in the global queue with QOS_CLASS_BACKGROUND priority
	static var background: Exec {
		return .queue(.global(qos: .background), .concurrentAsync)
	}
	
	/// Constructs an Exec.queue configured as an ExecutionType.recursiveMutex
	static func syncQueue(qos: DispatchQoS.QoSClass = .default) -&gt; Exec {
		return Exec.queue(DispatchQueue(label: ""), ExecutionType.mutex)
	}
	
	/// Constructs an Exec.queue configured as an ExecutionType.recursiveAsync
	static func asyncQueue(qos: DispatchQoS.QoSClass = .default) -&gt; Exec {
		return Exec.queue(DispatchQueue(label: ""), ExecutionType.serialAsync)
	}
}

extension Exec: CustomExecutionContext {
	/// A description about how functions will be invoked on an execution context.
	var type: ExecutionType {
		switch self {
		case .direct: return .immediate
		case .main: return .thread { Thread.isMainThread }
		case .custom(let c): return c.type
		case .queue(_, let t): return t
		}
	}
	
	/// Run `execute` normally on the execution context
	func invoke(_ execute: @escaping () -&gt; Void) {
		switch self {
		case .direct: execute()
		case .main where Thread.isMainThread: execute()
		case .main: DispatchQueue.main.async(execute: execute)
		case .queue(_, .thread(let test)) where test(): execute()
		case .queue(_, .recursiveMutex(let test)) where test(): execute()
		case .queue(let q, let t) where t.isImmediateInCurrentContext: q.sync(execute: execute)
		case .queue(let q, _): q.async(execute: execute)
		case .custom(let c): c.invoke(execute)
		}
	}
	
	/// Run `execute` asynchronously on the execution context
	func invokeAsync(_ execute: @escaping () -&gt; Void) {
		switch self {
		case .direct: DispatchQueue.global().async(execute: execute)
		case .custom(let c): c.invokeAsync(execute)
		case .main: DispatchQueue.main.async(execute: execute)
		case .queue(let q, _): q.async(execute: execute)
		}
	}
	
	/// Run `execute` on the execution context but don't return from this function until the provided function is complete.
	func invokeSync&lt;Result&gt;(_ execute: () throws -&gt; Result) rethrows -&gt; Result {
		switch self {
		case .direct: return try execute()
		case .main where Thread.isMainThread: return try execute()
		case .main: return try DispatchQueue.main.sync(execute: execute)
		case .queue(_, .thread(let test)) where test(): return try execute()
		case .queue(_, .threadAsync(let test)) where test(): return try execute()
		case .queue(_, .recursiveMutex(let test)) where test(): return try execute()
		case .queue(let q, _): return try withoutActuallyEscaping(execute) { e in try q.sync(execute: e) }
		case .custom(let c): return try c.invokeSync(execute)
		}
	}
	
	/// Invokes in a global concurrent context. This context can be used to safely "escape" self.
	///
	/// - Parameter qos: the QoSClass for the new async context. If `nil`, the QoSClass will be derived from the properties of `self`
	/// - Returns: a context that is asynchronous and can be used to escape self
	func relativeAsync(qos: DispatchQoS.QoSClass? = nil) -&gt; Exec {
		switch self {
		case .custom(let c): return c.relativeAsync(qos: qos)
		case .main: return Exec.global(qos: .userInteractive)
		case .queue(let q, _): return Exec.global(qos: q.qos.qosClass)
		case .direct: return Exec.global
		}
	}
	
	private var timerQueue: DispatchQueue {
		switch self {
		case .direct: return DispatchQueue.global()
		case .main: return DispatchQueue.main
		case .queue(let q, _): return q
		case .custom: fatalError()
		}
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`) unless the returned `Lifetime` is cancelled or released before running occurs.
	func singleTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), handler: @escaping () -&gt; Void) -&gt; Lifetime {
		if case .custom(let c) = self {
			return c.singleTimer(interval: interval, leeway: leeway, handler: handler)
		}
		return DispatchSource.singleTimer(interval: interval, leeway: leeway, queue: timerQueue, handler: handler) as! DispatchSource
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), passing the `parameter` value as an argument, unless the returned `Lifetime` is cancelled or released before running occurs.
	func singleTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		if case .custom(let c) = self {
			return c.singleTimer(parameter: parameter, interval: interval, leeway: leeway, handler: handler)
		}
		return DispatchSource.singleTimer(parameter: parameter, interval: interval, leeway: leeway, queue: timerQueue, handler: handler) as! DispatchSource
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), and again every `interval` (within a `leeway` margin of error) unless the returned `Lifetime` is cancelled or released before running occurs.
	func periodicTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), handler: @escaping () -&gt; Void) -&gt; Lifetime {
		if case .custom(let c) = self {
			return c.periodicTimer(interval: interval, leeway: leeway, handler: handler)
		}
		return DispatchSource.repeatingTimer(interval: interval, leeway: leeway, queue: timerQueue, handler: handler) as! DispatchSource
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), passing the `parameter` value as an argument, and again every `interval` (within a `leeway` margin of error) unless the returned `Lifetime` is cancelled or released before running occurs.
	func periodicTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval = .nanoseconds(0), handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		if case .custom(let c) = self {
			return c.periodicTimer(parameter: parameter, interval: interval, leeway: leeway, handler: handler)
		}
		return DispatchSource.repeatingTimer(parameter: parameter, interval: interval, leeway: leeway, queue: timerQueue, handler: handler) as! DispatchSource
	}
	
	/// Gets a timestamp representing the host uptime the in the current context
	func timestamp() -&gt; DispatchTime {
		if case .custom(let c) = self {
			return c.timestamp()
		}
		return DispatchTime.now()
	}
}

extension Exec {
	@available(*, deprecated, message: "Use invokeSync instead")
	func invokeAndWait(_ execute: @escaping () -&gt; Void) {
		_ = invokeSync(execute)
	}
	
	@available(*, deprecated, message:"Values returned from this may be misleading. Perform your own switch to precisely get the information you need.")
	var dispatchQueue: DispatchQueue {
		switch self {
		case .direct, .custom: return DispatchQueue.global()
		case .main: return DispatchQueue.main
		case .queue(let q, _): return q
		}
	}
}

/// Describes 7 key execution context types. The six most common exist as a pair between a sychronous and asynchronous version:
///  * immediate and concurrentAsync
///  * mutex and serialAsync
///  * thread and threadAsync
/// With the final context being an additional variation on mutex:
///  * recursiveMutex
///
/// This list of of execution context types should *not* be considered exhaustive so in general, it is better to interrogate the boolean properties in which you're interested.
/// These properties are currently:
///  * isImmediate[InCurrentContext|Always]
///  * isReentrant
///  * isConcurrent
enum ExecutionType {
	/// This execution type models a simple function invocation.
	///	* completes before `invoke` returns (immediate)
	///   * applies no mutex so nested calls to `invoke` will succeed (reentrant)
	///   * will let parallel calls run at the same time (concurrent)
	///   * invocation always inherits the caller's context (nest always)
	/// e.g. directly calling
	case immediate
	
	/// This execution type models a global concurrent work pool.
	///	* runs outside the current context and might not complete before `invoke` returns (asynchronous)
	///   * involves no mutex so nested calls to `invokeSync` are permitted (reentrant)
	///   * will let parallel calls run at the same time (concurrent)
	///   * normally async but `invokeSync` is invoked from the calling context (sync nests)
	/// e.g. DispatchQueue.global().async
	case concurrentAsync
	
	/// This execution type models a scoped non-recursive mutex.
	///	* completes before `invoke` returns (immediate)
	///   * applies a non-reentrant mutex so nested calls to `invoke` will deadlock (non-reentrant)
	///   * will serialize parallel calls to run one at a time (serial)
	///   * invocation always inherits the caller's context (nest always)
	/// e.g. dispatchQueue.sync
	case mutex
	
	/// This execution type models a scoped recursive mutex. The associated test function returns `true` if the `invoke` or `invokeSync` function can be elided (replaced by direct invocation, since the current context is known to be inside the mutex).
	///	* completes before `invoke` returns (immediate)
	///   * applies a mutex but a nested `invoke` will safely re-enter the mutex (reentrant)
	///   * will serialize parallel calls to run one at a time (serial)
	///   * invocation always inherits the caller's context (nest always)
	/// e.g. NSRecursiveLock.lock(before:)
	case recursiveMutex(() -&gt; Bool)
	
	/// This execution type models a thread. The associated test function returns `true` if the `invoke` or `invokeSync` function can be elided (replaced by direct invocation, since the current context is known to be inside the thread).
	///	* if test function returns true, then `invoke` is immediate in the current context, otherwise asychronous (immediate/asynchronous)
	///   * nested calls to `invoke` are permitted since they will simply be run immediately (reentrant)
	///   * will serialize parallel calls to run one at a time (serial)
	///   * invocation only inherits the caller's context if test function returns true in current context (nest thread)
	/// e.g. `if Thread.isMainThread { /* do work */ } else { DispatchQueue.main.async { /* do work */ }`
	case thread(() -&gt; Bool)
	
	/// This execution type models a thread on which work is typically performed asynchronously. The associated test function returns `true` if the `invoke` or `invokeSync` function can be elided (replaced by direct invocation, since the current context is known to be inside the thread).
	///	* `invoke` is always asynchronous (asynchronous)
	///   * detects when it is already on the current thread so nested calls to `invokeSync` will not deadlock (reentrant)
	///   * will serialize parallel calls to run one at a time (serial)
	///   * normally async but `invokeSync` nests if already on its thread (nest syncThread)
	/// e.g. DispatchQueue.main.async
	case threadAsync(() -&gt; Bool)
	
	/// This execution type models an asynchronous resource that lacks any synchronous access.
	///	* runs outside the current context and might not complete before `invoke` returns (asynchronous)
	///   * applies a non-reentrant mutex so nested calls to `invokeSync` will deadlock (non-reentrant)
	///   * will serialize parallel calls to run one at a time (serial)
	///   * invocation never inherits the caller's context (nest no)
	/// e.g. a serial resource that offers a `performAsync(_:() -&gt; Void)` but doesn't offer a `performSync(_:() -&gt; Void)`
	case serialAsync
}

extension ExecutionType {
	/// Returns true if a block executed with `invoke` is guaranteed to complete before `invoke` returns in the current context.
	/// The inverse of this value is "isAsyncInCurrentContext".
	///
	/// NOTE: this property runs a function for case `.thread` to see if the current thread is the target thread. Any change queue/thread may break the guarantee (the name "thread" is representative-only and might not refer to a literal thread).
	var isImmediateInCurrentContext: Bool {
		switch self {
		case .immediate, .mutex, .recursiveMutex: return true
		case .thread(let isCurrent): return isCurrent()
		case .serialAsync, .concurrentAsync, .threadAsync: return false
		}
	}
	
	/// Inverse of `isImmediateInCurrentContext`
	var isAsyncInCurrentContext: Bool { return !isImmediateInCurrentContext }
	
	/// Returns true if a block executed with `invoke` is always guaranteed to complete before `invoke` returns.
	/// The inverse of this value is "isPotentiallyAsync"
	var isImmediateAlways: Bool {
		switch self {
		case .immediate, .mutex, .recursiveMutex: return true
		case .thread, .serialAsync, .concurrentAsync, .threadAsync: return false
		}
	}
	
	/// Inverse of `isImmediateAlways`
	var isPotentiallyAsync: Bool { return !isImmediateInCurrentContext }
	
	/// Returns true if calling `invoke` or `invokeSync` within an executed block will succeed (not deadlock).
	/// The inverse of this value is "non-reentrant"
	var isReentrant: Bool {
		switch self {
		case .immediate, .recursiveMutex, .thread, .threadAsync, .concurrentAsync: return true
		case .mutex, .serialAsync: return false
		}
	}
	
	/// Inverse of `isReentrant`
	var isNonReentrant: Bool { return !isReentrant }
	
	/// Returns true if calling `invoke` simultaneously on separate threads may result in simultaneous execution.
	/// The inverse of this value is "serial"
	var isConcurrent: Bool {
		switch self {
		case .immediate, .concurrentAsync: return true
		case .mutex, .recursiveMutex, .serialAsync, .thread, .threadAsync: return false
		}
	}
	
	/// Inverse of `isConcurrent`
	var isSerial: Bool { return !isConcurrent }
}


import Foundation

enum Few&lt;T&gt; {
	case none
	case single(T)
	case array(Array&lt;T&gt;)
}

extension Few: Collection {
	func index(after i: Int) -&gt; Int {
		return i + 1
	}
	
	var count: Int {
		switch self {
		case .none: return 0
		case .single: return 1
		case .array(let a): return a.count
		}
	}
	
	var startIndex: Int {
		return 0
	}
	
	var endIndex: Int {
		switch self {
		case .none: return 0
		case .single: return 1
		case .array(let a): return a.endIndex
		}
	}
	
	subscript(key: Int) -&gt; T {
		switch self {
		case .none: fatalError()
		case .single(let value): return value
		case .array(let a): return a[key]
		}
	}
}

import Foundation

/// A wrapper around key-value observing so that you:
///	1. don't need to implement `observeValue` yourself, you can instead handle changes in a closure
///	2. you get a `CallbackReason` for each change which includes `valueChanged`, `pathChanged`, `sourceDeleted`.
///	3. observation is automatically cancelled if you release the KeyValueObserver or the source is released
///
/// While Swift 4 offers an `observe(...) -&gt; NSKeyValueObservation` function which avoids the need for (1), this wrapper continues to offer an advantage on points (2) and (3).
///
/// A majority of the complexity in this class comes from the fact that we turn key-value observing on keyPaths into a series of chained KeyValueObservers that we manage ourselves. This gives us more information when things change but we're re-implementing a number of things that Cococa key-value observing normally gives us for free. Generally in this class, anything involving the `tailPath` is managing observations of the path.
///
/// THREAD SAFETY:
/// This class is memory safe even when observations are triggered concurrently from different threads.
/// Do note though that while all changes are registered under the mutex, callbacks are invoked *outside* the mutex, so it is possible for callbacks to be invoked in a different order than the internal synchronized order.
/// In general, this shouldn't be a problem (since key-value observing is not itself synchronized so there *isn't* an authoritative ordering). However, this may cause unexpected behavior if you invoke `cancel` on this class. If you `cancel` the `KeyValueObserver` while it is concurrently processing changes on another thread, this might result in callback invocations occurring *after* the call to `cancel`. This will only happen if the changes associated with those callbacks were received *before* the `cancel` - it's just the callback that's getting invoked later.
@available(*, deprecated, message:"Use Swift's native KeyPath and observe(_:, options:, changeHandler:) instead")
class KeyValueObserver: NSObject, Lifetime {
	typealias Callback = (_ change: [NSKeyValueChangeKey: Any], _ reason: CallbackReason) -&gt; Void

	// This is the user-supplied callback function
	private var callback: Callback?
	
	// When observing a keyPath, we use a separate KeyValueObserver for each component of the path. The `tailObserver` is the `KeyValueObserver` for the *next* element in the path.
	private var tailObserver: KeyValueObserver?
	
	// This is the key that we're observing on `source`
	private let key: String
	
	// This is any path beyond the key.
	private let tailPath: String?
	
	// This is the set of options passed on construction
	private let options: NSKeyValueObservingOptions
	
	// Used to ensure memory safety for the callback and tailObserver.
	private let mutex = DispatchQueue(label: "")
	
	// Our "deletionBlock" is called to notify us that the source is being deallocated (so we can remove the key value observation before a warning is logged) and this happens during the source's "objc_destructinstance" function. At this point, a `weak` var will be `nil` and an `unowned` will trigger a `_swift_abortRetainUnowned` failure.
	// So we're left with `Unmanaged`. Careful cancellation before the source is deallocated is necessary to ensure we don't access an invalid memory location.
	private let source: Unmanaged&lt;NSObject&gt;
	
	/// The `CallbackReason` explains the location in the path where the change occurred.
	///
	/// - valueChanged: the observed value changed
	/// - pathChanged: one of the connected elements in the path changed
	/// - sourceDeleted: the observed source was deallocated
	/// - cancelled: will never be sent
	enum CallbackReason {
		case valueChanged
		case pathChanged
		case sourceDeleted
		case cancelled
	}
	
	/// Establish the key value observing.
	///
	/// - Parameters:
	///   - source: object on which there's a property we wish to observe
	///   - keyPath: a key or keyPath identifying the property we wish to observe
	///   - options: same as for the normal `addObserver` method
	///   - callback: will be invoked on each change with the change dictionary and the change reason
	init(source: NSObject, keyPath: String, options: NSKeyValueObservingOptions = NSKeyValueObservingOptions.new.union(NSKeyValueObservingOptions.initial), callback: @escaping Callback) {
		self.callback = callback
		self.source = Unmanaged.passUnretained(source)
		self.options = options
		
		// Look for "." indicating a key path
		var range = keyPath.range(of: ".")
		
		// If we have a collection operator, consider the next path component as part of this key
		if let r = range, keyPath.hasPrefix("@") {
			range = keyPath.range(of: ".", range: keyPath.index(after: r.lowerBound)..&lt;keyPath.endIndex, locale: nil)
		}
		
		// Set the key and tailPath based on whether we detected multiple path components
		if let r = range {
			#if swift(&gt;=4)
				self.key = String(keyPath[..&lt;r.lowerBound])
				self.tailPath = String(keyPath[keyPath.index(after: r.lowerBound)...])
			#else
				self.key = keyPath.substring(to: r.lowerBound)
				self.tailPath = keyPath.substring(from: keyPath.index(after: r.lowerBound))
			#endif
		} else {
			self.key = keyPath
			
			// If we're observing a weak property, add an observer on self to the source to detect when it may be set to nil without going through the property setter
			var p: String? = nil
			if let propertyName = keyPath.cString(using: String.Encoding.utf8) {
				let property = class_getProperty(type(of: source), propertyName)
				// Look for both the "id" and "weak" attributes.
				if let prop = property, let attributes = property_getAttributes(prop), let attrsString = String(validatingUTF8: attributes)?.components(separatedBy: ","), attrsString.filter({ $0.hasPrefix("T@") || $0 == "W" }).count == 2 {
					p = "self"
				}
			}
			self.tailPath = p
		}
		
		super.init()
		
		// Detect if the source is deleted
		let deletionBlock = OnDelete { [weak self] in self?.cancel(.sourceDeleted) }
		objc_setAssociatedObject(source, Unmanaged.passUnretained(self).toOpaque(), deletionBlock, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
		
		// Start observing the source
		if key != "self" {
			var currentOptions = options
			if !isObservingTail {
				currentOptions = NSKeyValueObservingOptions.new.union(options.intersection(NSKeyValueObservingOptions.prior))
			}
			
			source.addObserver(self, forKeyPath: key, options: currentOptions, context: Unmanaged.passUnretained(self).toOpaque())
		}
		
		// Start observing the value of the source
		if tailPath != nil {
			updateTailObserver(onValue: source.value(forKeyPath: self.key) as? NSObject, isInitial: true)
		}
	}
	
	deinit {
		cancel()
	}
	
	// This method is called when the key path between the source and the observed property changes. This will recursively create KeyValueObservers along the path.
	//
	// Mutex notes: Method must be called from *INSIDE* mutex (although, it must be *OUTSIDE* the tailObserver's mutex).
	private func updateTailObserver(onValue: NSObject?, isInitial: Bool) {
		tailObserver?.cancel()
		tailObserver = nil
		
		if let _ = self.callback, let tp = tailPath, let currentValue = onValue {
			let currentOptions = isInitial ? self.options : self.options.subtracting(NSKeyValueObservingOptions.initial)
			self.tailObserver = KeyValueObserver(source: currentValue, keyPath: tp, options: currentOptions, callback: self.tailCallback)
		}
	}
	
	// This method is called from the `tailObserver` (representing a change in the key path, not the observed property)
	//
	// Mutex notes: Method is called *OUTSIDE* mutex since it is used as a callback function for the `tailObserver`
	private func tailCallback(_ change: [NSKeyValueChangeKey: Any], reason: CallbackReason) {
		switch reason {
		case .cancelled:
			return
		case .sourceDeleted:
			let c = mutex.sync(execute: { () -&gt; Callback? in
				updateTailObserver(onValue: nil, isInitial: false)
				return self.callback
			})
			c?(change, self.isObservingTail ? .valueChanged : .pathChanged)
		default:
			let c = mutex.sync { self.callback }
			c?(change, reason)
		}
	}
	
	// The method returns `false` if there are subsequent `KeyValueObserver`s observing part of the path between us and the observed property and `true` if we are directly observing the property.
	//
	// Mutex notes: Safe for invocation in or out of mutex
	private var isObservingTail: Bool {
		return tailPath == nil || tailPath == "self"
	}
	
	// Weak properties need `self` observed, as well as the property, to correctly detect changes.
	//
	// Mutex notes: Safe for invocation in or out of mutex
	private var needsWeakTailObserver: Bool {
		return tailPath == "self"
	}
	
	// Accessor for the observed property value. This will correctly get the value from the end of the key path if we are using a tailObserver.
	//
	// Mutex notes: Method must be called from *INSIDE* mutex.
	private func sourceValue() -&gt; Any? {
		if let t = tailObserver, !isObservingTail {
			return t.sourceValue()
		} else {
			return source.takeUnretainedValue().value(forKeyPath: key)
		}
	}
	
	// If we're observing a key path, then we need to update our chain of KeyValueObservers when part of the path changes. This starts that process from the change point.
	//
	// Mutex notes: Method must be called from *INSIDE* mutex.
	private func updateTailObserverGivenChangeDictionary(change: [NSKeyValueChangeKey: Any]) {
		if let newValue = change[NSKeyValueChangeKey.newKey] as? NSObject {
			let value: NSObject? = newValue == NSNull() ? nil : newValue
			updateTailObserver(onValue: value, isInitial: false)
		} else {
			updateTailObserver(onValue: sourceValue() as? NSObject, isInitial: false)
		}
	}
	
	// Implementation of standard key-value observing method.
	override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey: Any]?, context: UnsafeMutableRawPointer?) {
		if context != Unmanaged.passUnretained(self).toOpaque() {
			super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
		}
		
		guard let c = change else {
			assertionFailure("Expected change dictionary")
			return
		}
		
		if self.isObservingTail {
			let cb = mutex.sync { () -&gt; Callback? in
				if needsWeakTailObserver {
					updateTailObserverGivenChangeDictionary(change: c)
				}
				return self.callback
			}
			cb?(c, .valueChanged)
			
		} else {
			let tuple = mutex.sync { () -&gt; (Callback, [NSKeyValueChangeKey: Any])? in
				var transmittedChange: [NSKeyValueChangeKey: Any] = [:]
				if !options.intersection(NSKeyValueObservingOptions.old).isEmpty {
					transmittedChange[NSKeyValueChangeKey.oldKey] = tailObserver?.sourceValue()
				}
				if let _ = c[NSKeyValueChangeKey.notificationIsPriorKey] as? Bool {
					transmittedChange[NSKeyValueChangeKey.notificationIsPriorKey] = true
				}
				updateTailObserverGivenChangeDictionary(change: c)
				if !options.intersection(NSKeyValueObservingOptions.new).isEmpty {
					transmittedChange[NSKeyValueChangeKey.newKey] = tailObserver?.sourceValue()
				}
				if let c = callback {
					return (c, transmittedChange)
				}
				return nil
			}
			if let (cb, tc) = tuple {
				cb(tc, .pathChanged)
			}
		}
	}
	
	/// Stop observing.
	func cancel() {
		cancel(.cancelled)
	}
	
	// Mutex notes: Method is called *OUTSIDE* mutex
	private func cancel(_ reason: CallbackReason) {
		let cb = mutex.sync { () -&gt; Callback? in
			guard let c = callback else { return nil }
			
			// Flag as inactive
			callback = nil
			
			// Remove the observations from this object
			if key != "self" {
				source.takeUnretainedValue().removeObserver(self, forKeyPath: key, context: Unmanaged.passUnretained(self).toOpaque())
			}
			
			// Cancel the OnDelete object
			let unknown = objc_getAssociatedObject(source, Unmanaged.passUnretained(self).toOpaque())
			if let deletionObject = unknown as? OnDelete {
				deletionObject.cancel()
			}

			// And clear the associated object
			objc_setAssociatedObject(source, Unmanaged.passUnretained(self).toOpaque(), nil, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN);
			
			// Remove tail observers
			updateTailObserver(onValue: nil, isInitial: false)
			
			// Send notifications
			return reason != .cancelled ? c : nil
		}
		
		cb?([:], reason)
	}
}

import Foundation

/// This protocol exists to keep alive and terminate-at-will asynchronous and ongoing tasks. It is an
/// implementation of the "Disposable" pattern.
///
/// While conformance to this protocol requires just one function, conforming to this protocol also signals three important traits:
///    1. instances manage an underlying resource
///	 2. the resource will last until one the first of the following end-conditions occurs:
///        a. The resource terminates on its own
///        b. All references to the Lifetime instance are released
///        c. The `cancel()` function is invoked
///
/// ideally, as well:
///
///    3. no further effects or actions of any kind will occur after the first end-condition is registered in the
///       resource's context, no further messages or notifications sent or received, no resurrection possible
///    4. any subsequent end conditions after the first are safe and have no effect
///    5. if Self is a reference type, `cancel` should be explicitly invoked on deinit
///    6. `cancel` should invoke `cancel` on any owned child Lifetime instances
///
/// Examples of violations of the last 4 points exist be should be kept rare.
protocol Lifetime {
	/// Immediately set the resource managed by this instance to an "end-of-life" state.
	/// This a mutating method and should be called only in executation contexts where changing `self` is threadsafe.
	mutating func cancel()
}

typealias Cancellable = Lifetime

/// An array of Lifetime that conforms to Lifetime. Note that a conditional conformance on Array can't properly conform
// to Lifetime since it would permit adding new lifetimes after the aggregate was cancelled.
class AggregateLifetime: Lifetime {
	private var lifetimes: [Lifetime]?
	init(lifetimes: [Lifetime] = []) {
		self.lifetimes = lifetimes
	}
	func cancel() {
		if var ls = lifetimes {
			for i in ls.indices {
				ls[i].cancel()
			}
			lifetimes = nil
		}
	}
	static func +=(left: AggregateLifetime, right: Lifetime) {
		left.lifetimes?.append(right)
	}
	deinit {
		cancel()
	}
}

#if os(Linux)
	import Glibc
#else
	import Darwin
#endif

/// A basic mutex protocol that requires nothing more than "performing work inside the mutex".
protocol ScopedMutex {
	/// Perform work inside the mutex
	func sync&lt;R&gt;(execute work: () throws -&gt; R) rethrows -&gt; R

	/// Perform work inside the mutex, returning immediately if the mutex is in-use
	func trySync&lt;R&gt;(execute work: () throws -&gt; R) rethrows -&gt; R?
}

/// A more specific kind of mutex that assume an underlying primitive and unbalanced lock/trylock/unlock operators
protocol RawMutex: ScopedMutex {
	associatedtype MutexPrimitive

	var underlyingMutex: MutexPrimitive { get set }

	func unbalancedLock()
	func unbalancedTryLock() -&gt; Bool
	func unbalancedUnlock()
}

extension RawMutex {
	func sync&lt;R&gt;(execute work: () throws -&gt; R) rethrows -&gt; R {
		unbalancedLock()
		defer { unbalancedUnlock() }
		return try work()
	}
	func trySync&lt;R&gt;(execute work: () throws -&gt; R) rethrows -&gt; R? {
		guard unbalancedTryLock() else { return nil }
		defer { unbalancedUnlock() }
		return try work()
	}
}

/// A basic wrapper around the "NORMAL" and "RECURSIVE" `pthread_mutex_t` (a general purpose mutex). This type is a "class" type to take advantage of the "deinit" method and prevent accidental copying of the `pthread_mutex_t`.
final class PThreadMutex: RawMutex {
	typealias MutexPrimitive = pthread_mutex_t

	// Non-recursive "PTHREAD_MUTEX_NORMAL" and recursive "PTHREAD_MUTEX_RECURSIVE" mutex types.
	enum PThreadMutexType {
		case normal
		case recursive
	}

	var underlyingMutex = pthread_mutex_t()
	
	/// Default constructs as ".Normal" or ".Recursive" on request.
	init(type: PThreadMutexType = .normal) {
		var attr = pthread_mutexattr_t()
		guard pthread_mutexattr_init(&amp;attr) == 0 else {
			preconditionFailure()
		}
		switch type {
		case .normal:
			pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL)
		case .recursive:
			pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE)
		}
		guard pthread_mutex_init(&amp;underlyingMutex, &amp;attr) == 0 else {
			preconditionFailure()
		}
		pthread_mutexattr_destroy(&amp;attr)
	}
	
	deinit {
		pthread_mutex_destroy(&amp;underlyingMutex)
	}
	
	func unbalancedLock() {
		pthread_mutex_lock(&amp;underlyingMutex)
	}
	
	func unbalancedTryLock() -&gt; Bool {
		return pthread_mutex_trylock(&amp;underlyingMutex) == 0
	}
	
	func unbalancedUnlock() {
		pthread_mutex_unlock(&amp;underlyingMutex)
	}
}

/// A basic wrapper around `os_unfair_lock` (a non-FIFO, high performance lock that offers safety against priority inversion). This type is a "class" type to prevent accidental copying of the `os_unfair_lock`.
@available(OSX 10.12, iOS 10, tvOS 10, watchOS 3, *)
final class UnfairLock: RawMutex {
	typealias MutexPrimitive = os_unfair_lock
	
	init() {
	}
	
	/// Exposed as an "unsafe" property so non-scoped patterns can be implemented, if required.
	var underlyingMutex = os_unfair_lock()
	
	func unbalancedLock() {
		os_unfair_lock_lock(&amp;underlyingMutex)
	}
	
	func unbalancedTryLock() -&gt; Bool {
		return os_unfair_lock_trylock(&amp;underlyingMutex)
	}
	
	func unbalancedUnlock() {
		os_unfair_lock_unlock(&amp;underlyingMutex)
	}
}

import Swift

final class OnDelete: Lifetime {
	var block: (() -&gt; Void)?
	
	init(_ b: @escaping () -&gt; Void) {
		block = b
	}
	
	func invalidate() {
		block = nil
	}
	
	func cancel() {
		block?()
		block = nil
	}
	
	var isValid: Bool {
		return block != nil
	}
	
	deinit {
		cancel()
	}
}

import Foundation

#if !swift(&gt;=4.2)
	protocol RandomNumberGenerator {
		mutating func next() -&gt; UInt64
	}
	struct SystemRandomNumberGenerator: RandomNumberGenerator {
		init() {}
		mutating func next() -&gt; UInt64 {
			var value: UInt64 = 0
			arc4random_buf(&amp;value, MemoryLayout&lt;UInt64&gt;.size)
			return value
		}
	}
#endif

protocol RandomGenerator: RandomNumberGenerator {
	mutating func randomize(buffer: UnsafeMutableRawBufferPointer)
}

extension RandomGenerator {
	mutating func randomize&lt;Value&gt;(value: inout Value) {
		withUnsafeMutablePointer(to: &amp;value) { ptr in
			self.randomize(buffer: UnsafeMutableRawBufferPointer(start: ptr, count: MemoryLayout&lt;Value&gt;.size))
		}
	}
}

struct DevRandom: RandomGenerator {
	class FileDescriptor {
		let value: CInt
		init() {
			value = open("/dev/urandom", O_RDONLY)
			precondition(value &gt;= 0)
		}
		deinit {
			close(value)
		}
	}
	
	let fd: FileDescriptor
	init() {
		fd = FileDescriptor()
	}
	
	mutating func randomize(buffer: UnsafeMutableRawBufferPointer) {
		let result = read(fd.value, buffer.baseAddress, buffer.count)
		precondition(result == buffer.count)
	}
	
	mutating func next() -&gt; UInt64 {
		var bits: UInt64 = 0
		withUnsafeMutablePointer(to: &amp;bits) { ptr in
			self.randomize(buffer: UnsafeMutableRawBufferPointer(start: ptr, count: MemoryLayout&lt;UInt64&gt;.size))
		}
		return bits
	}
}

struct Xoshiro: RandomNumberGenerator {
	typealias StateType = (UInt64, UInt64, UInt64, UInt64)

	private var state: StateType = (0, 0, 0, 0)

	init() {
		var dr = DevRandom()
		dr.randomize(value: &amp;state)
	}
	
	init(seed: StateType) {
		self.state = seed
	}
	
	mutating func next() -&gt; UInt64 {
		// Derived from domain implementation of xoshiro256** here:
		// http://xoshiro.di.unimi.it
		// by David Blackman and Sebastiano Vigna
		let x = state.1 &amp;* 5
		let result = ((x &amp;&lt;&lt; 7) | (x &amp;&gt;&gt; 57)) &amp;* 9
		let t = state.1 &amp;&lt;&lt; 17
		state.2 ^= state.0
		state.3 ^= state.1
		state.1 ^= state.2
		state.0 ^= state.3
		state.2 ^= t
		state.3 = (state.3 &amp;&lt;&lt; 45) | (state.3 &amp;&gt;&gt; 19)
		return result
	}
}

struct MersenneTwister: RandomNumberGenerator {
	// 312 words of storage is 13 x 6 x 4
	private typealias StateType = (
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,

		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,

		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,

		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64,
		UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64
	)
	
	private var state_internal: StateType = (
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	)
	private var index: Int
	private static let stateCount: Int = 312
	
	init() {
		var dr = DevRandom()
		dr.randomize(value: &amp;state_internal)
		index = MersenneTwister.stateCount
	}
	
	init(seed: UInt64) {
		index = MersenneTwister.stateCount
		withUnsafeMutablePointer(to: &amp;state_internal) { $0.withMemoryRebound(to: UInt64.self, capacity: MersenneTwister.stateCount) { state in
			state[0] = seed
			for i in 1..&lt;MersenneTwister.stateCount {
				state[i] = 6364136223846793005 &amp;* (state[i &amp;- 1] ^ (state[i &amp;- 1] &gt;&gt; 62)) &amp;+ UInt64(i)
			}
		} }
	}

	mutating func next() -&gt; UInt64 {
		if index == MersenneTwister.stateCount {
			withUnsafeMutablePointer(to: &amp;state_internal) { $0.withMemoryRebound(to: UInt64.self, capacity: MersenneTwister.stateCount) { state in
				let n = MersenneTwister.stateCount
				let m = n / 2
				let a: UInt64 = 0xB5026F5AA96619E9
				let lowerMask: UInt64 = (1 &lt;&lt; 31) - 1
				let upperMask: UInt64 = ~lowerMask
				var (i, j, stateM) = (0, m, state[m])
				repeat {
					let x1 = (state[i] &amp; upperMask) | (state[i &amp;+ 1] &amp; lowerMask)
					state[i] = state[i &amp;+ m] ^ (x1 &gt;&gt; 1) ^ ((state[i &amp;+ 1] &amp; 1) &amp;* a)
					let x2 = (state[j] &amp; upperMask) | (state[j &amp;+ 1] &amp; lowerMask)
					state[j] = state[j &amp;- m] ^ (x2 &gt;&gt; 1) ^ ((state[j &amp;+ 1] &amp; 1) &amp;* a)
					(i, j) = (i &amp;+ 1, j &amp;+ 1)
				} while i != m &amp;- 1
				
				let x3 = (state[m &amp;- 1] &amp; upperMask) | (stateM &amp; lowerMask)
				state[m &amp;- 1] = state[n &amp;- 1] ^ (x3 &gt;&gt; 1) ^ ((stateM &amp; 1) &amp;* a)
				let x4 = (state[n &amp;- 1] &amp; upperMask) | (state[0] &amp; lowerMask)
				state[n &amp;- 1] = state[m &amp;- 1] ^ (x4 &gt;&gt; 1) ^ ((state[0] &amp; 1) &amp;* a)
			} }
			
			index = 0
		}
		
		var result = withUnsafePointer(to: &amp;state_internal) { $0.withMemoryRebound(to: UInt64.self, capacity: MersenneTwister.stateCount) { ptr in
			return ptr[index]
		} }
		index = index &amp;+ 1

		result ^= (result &gt;&gt; 29) &amp; 0x5555555555555555
		result ^= (result &lt;&lt; 17) &amp; 0x71D67FFFEDA60000
		result ^= (result &lt;&lt; 37) &amp; 0xFFF7EEE000000000
		result ^= result &gt;&gt; 43

		return result
	}
}

import Foundation

/// Either a Success value or an Failure error
extension Result {
	/// Convenience tester/getter for the value
	var value: Success? {
		switch self {
		case .success(let s): return s
		case .failure: return nil
		}
	}
	
	/// Convenience tester/getter for the error
	var error: Failure? {
		switch self {
		case .success: return nil
		case .failure(let f): return f
		}
	}

	/// Test whether the result is an error.
	var isSuccess: Bool {
		return !isFailure
	}

	/// Test whether the result is an error.
	var isFailure: Bool {
		switch self {
		case .success: return false
		case .failure: return true
		}
	}
}

extension Result where Failure == Swift.Error {
	/// Chains another Result to this one. In the event that this Result is a .Success, the provided transformer closure is used to transform the value into another value (of a potentially new type) and a new Result is made from that value. In the event that this Result is a .Failure, the next Result will have the same error as this one.
	func mapThrows&lt;U&gt;(_ transform: (Success) throws -&gt; U) -&gt; Result&lt;U, Failure&gt; {
		switch self {
		case .success(let val): return Result&lt;U, Failure&gt; { try transform(val) }
		case .failure(let e): return .failure(e)
		}
	}
}

import Swift

/// A type for representing the different possible failure conditions when using ScalarScanner
enum ScalarScannerError: Error {
	/// The scalar at the specified index doesn't match the expected grammar
	case unexpected(at: Int)
	
	/// Expected `wanted` at offset `at`
	case matchFailed(wanted: String, at: Int)
	
	/// Expected numerals at offset `at`
	case expectedInt(at: Int)
	
	/// Attempted to read `count` scalars from position `at` but hit the end of the sequence
	case endedPrematurely(count: Int, at: Int)
	
	/// Unable to find search patter `wanted` at or after `after` in the sequence
	case searchFailed(wanted: String, after: Int)
}

extension UnicodeScalar {
	/// Tests if the scalar is within a range
	func isInRange(_ range: ClosedRange&lt;UnicodeScalar&gt;) -&gt; Bool {
		return range.contains(self)
	}
	
	/// Tests if the scalar is a plain ASCII digit
	var isDigit: Bool {
		return ("0"..."9").contains(self)
	}
	
	/// Tests if the scalar is a plain ASCII English alphabet lowercase letter
	var isLower: Bool {
		return ("a"..."z").contains(self)
	}

	/// Tests if the scalar is a plain ASCII English alphabet uppercase letter
	var isUpper: Bool {
		return ("A"..."Z").contains(self)
	}

	/// Tests if the scalar is a plain ASCII English alphabet letter
	var isLetter: Bool {
		return isLower || isUpper
	}
}

/// A structure for traversing a `String.UnicodeScalarView`.
///
/// **UNICODE WARNING**: this struct ignores all Unicode combining rules and parses each scalar individually. The rules for parsing must allow combined characters to be parsed separately or better yet, forbid combining characters at critical parse locations. If your data structure does not include these types of rule then you should be iterating over the `Character` elements in a `String` rather than using this struct.
struct ScalarScanner&lt;C: Collection&gt; where C.Iterator.Element == UnicodeScalar {
	/// The underlying storage
	let scalars: C
	
	/// Current scanning index
	var index: C.Index
	
	/// Number of scalars consumed up to `index` (since String.UnicodeScalarView.Index is not a RandomAccessIndex, this makes determining the position *much* easier)
	var consumed: Int
	
	/// Construct from a String.UnicodeScalarView and a context value
	init(scalars: C) {
		self.scalars = scalars
		self.index = self.scalars.startIndex
		self.consumed = 0
	}
	
	/// Sets the index back to the beginning and clears the consumed count
	mutating func reset() {
		index = scalars.startIndex
		consumed = 0
	}
	
	/// Throw if the scalars at the current `index` don't match the scalars in `scalars`. Advance the `index` to the end of the match.
	/// WARNING: `string` is used purely for its `unicodeScalars` property and matching is purely based on direct scalar comparison (no decomposition or normalization is performed).
	mutating func match(string: String) throws {
		let (newIndex, newConsumed) = try string.unicodeScalars.reduce((index: index, count: 0)) { (tuple: (index: C.Index, count: Int), scalar: UnicodeScalar) in
			if tuple.index == self.scalars.endIndex || scalar != self.scalars[tuple.index] {
				throw ScalarScannerError.matchFailed(wanted: string, at: consumed)
			}
			return (index: self.scalars.index(after: tuple.index), count: tuple.count + 1)
		}
		index = newIndex
		consumed += newConsumed
	}
	
	/// Throw if the next scalar at the current `index` fails to match the next scalar in `scalars`. Advance the `index` to the end of the match.
	mutating func match(scalar: UnicodeScalar) throws {
		if index == scalars.endIndex || scalars[index] != scalar {
			throw ScalarScannerError.matchFailed(wanted: String(scalar), at: consumed)
		}
		index = self.scalars.index(after: index)
		consumed += 1
	}
	
	/// Throw if the next scalar at the current `index` fails to match the next scalar in `scalars`. Advance the `index` to the end of the match.
	mutating func match(where test: (UnicodeScalar) -&gt; Bool) throws {
		if index == scalars.endIndex || !test(scalars[index]) {
			try withoutActuallyEscaping(test) { t in
				throw ScalarScannerError.matchFailed(wanted: String(describing: t), at: consumed)
			}
		}
		index = self.scalars.index(after: index)
		consumed += 1
	}
	
	/// Throw if the scalars at the current `index` don't match the scalars in `value`. Advance the `index` to the end of the match.
	mutating func read(where test: (UnicodeScalar) -&gt; Bool) throws -&gt; UnicodeScalar {
		if index == scalars.endIndex || !test(scalars[index]) {
			try withoutActuallyEscaping(test) { t in
				throw ScalarScannerError.matchFailed(wanted: String(describing: t), at: consumed)
			}
		}
		let s = scalars[index]
		index = self.scalars.index(after: index)
		consumed += 1
		return s
	}

	/// Consume scalars from the contained collection, up to but not including the first instance of `scalar` found. `index` is advanced to immediately before `scalar`. Returns all scalars consumed prior to `scalar` as a `String`. Throws if `scalar` is never found.
	mutating func readUntil(scalar: UnicodeScalar) throws -&gt; String {
		var i = index
		let previousConsumed = consumed
		try skipUntil(scalar: scalar)
		
		var result = ""
		result.reserveCapacity(consumed - previousConsumed)
		while i != index {
			result.unicodeScalars.append(scalars[i])
			i = scalars.index(after: i)
		}
		
		return result
	}
	
	/// Consume scalars from the contained collection, up to but not including the first instance of `string` found. `index` is advanced to immediately before `string`. Returns all scalars consumed prior to `string` as a `String`. Throws if `string` is never found.
	/// WARNING: `string` is used purely for its `unicodeScalars` property and matching is purely based on direct scalar comparison (no decomposition or normalization is performed).
	mutating func readUntil(string: String) throws -&gt; String {
		var i = index
		let previousConsumed = consumed
		try skipUntil(string: string)
		
		var result = ""
		result.reserveCapacity(consumed - previousConsumed)
		while i != index {
			result.unicodeScalars.append(scalars[i])
			i = scalars.index(after: i)
		}
		
		return result
	}
	
	/// Consume scalars from the contained collection, up to but not including the first instance of any character in `set` found. `index` is advanced to immediately before `string`. Returns all scalars consumed prior to `string` as a `String`. Throws if no matching characters are ever found.
	mutating func readUntil(set inSet: Set&lt;UnicodeScalar&gt;) throws -&gt; String {
		var i = index
		let previousConsumed = consumed
		try skipUntil(set: inSet)
		
		var result = ""
		result.reserveCapacity(consumed - previousConsumed)
		while i != index {
			result.unicodeScalars.append(scalars[i])
			i = scalars.index(after: i)
		}
		
		return result
	}
	
	/// Peeks at the scalar at the current `index`, testing it with function `f`. If `f` returns `true`, the scalar is appended to a `String` and the `index` increased. The `String` is returned at the end.
	mutating func readWhile(true test: (UnicodeScalar) -&gt; Bool) -&gt; String {
		var string = ""
		while index != scalars.endIndex {
			if !test(scalars[index]) {
				break
			}
			string.unicodeScalars.append(scalars[index])
			index = self.scalars.index(after: index)
			consumed += 1
		}
		return string
	}
	
	/// Repeatedly peeks at the scalar at the current `index`, testing it with function `f`. If `f` returns `true`, the `index` increased. If `false`, the function returns.
	mutating func skipWhile(true test: (UnicodeScalar) -&gt; Bool) {
		while index != scalars.endIndex {
			if !test(scalars[index]) {
				return
			}
			index = self.scalars.index(after: index)
			consumed += 1
		}
	}
	
	/// Consume scalars from the contained collection, up to but not including the first instance of `scalar` found. `index` is advanced to immediately before `scalar`. Throws if `scalar` is never found.
	mutating func skipUntil(scalar: UnicodeScalar) throws {
		var i = index
		var c = 0
		while i != scalars.endIndex &amp;&amp; scalars[i] != scalar {
			i = self.scalars.index(after: i)
			c += 1
		}
		if i == scalars.endIndex {
			throw ScalarScannerError.searchFailed(wanted: String(scalar), after: consumed)
		}
		index = i
		consumed += c
	}
	
	/// Consume scalars from the contained collection, up to but not including the first instance of any scalar from `set` is found. `index` is advanced to immediately before `scalar`. Throws if `scalar` is never found.
	mutating func skipUntil(set inSet: Set&lt;UnicodeScalar&gt;) throws {
		var i = index
		var c = 0
		while i != scalars.endIndex &amp;&amp; !inSet.contains(scalars[i]) {
			i = self.scalars.index(after: i)
			c += 1
		}
		if i == scalars.endIndex {
			throw ScalarScannerError.searchFailed(wanted: "One of: \(inSet.sorted())", after: consumed)
		}
		index = i
		consumed += c
	}
	
	/// Consume scalars from the contained collection, up to but not including the first instance of `string` found. `index` is advanced to immediately before `string`. Throws if `string` is never found.
	/// WARNING: `string` is used purely for its `unicodeScalars` property and matching is purely based on direct scalar comparison (no decomposition or normalization is performed).
	mutating func skipUntil(string: String) throws {
		let match = string.unicodeScalars
		guard let first = match.first else { return }
		if match.count == 1 {
			return try skipUntil(scalar: first)
		}
		var i = index
		var j = index
		var c = 0
		var d = 0
		let remainder = match[match.index(after: match.startIndex)..&lt;match.endIndex]
		outerLoop: repeat {
			while scalars[i] != first {
				if i == scalars.endIndex {
					throw ScalarScannerError.searchFailed(wanted: String(match), after: consumed)
				}
				i = self.scalars.index(after: i)
				c += 1
				
				// Track the last index and consume count before hitting the match
				j = i
				d = c
			}
			i = self.scalars.index(after: i)
			c += 1
			for s in remainder {
				if i == self.scalars.endIndex {
					throw ScalarScannerError.searchFailed(wanted: String(match), after: consumed)
				}
				if scalars[i] != s {
					continue outerLoop
				}
				i = self.scalars.index(after: i)
				c += 1
			}
			break
		} while true
		index = j
		consumed += d
	}
	
	/// Attempt to advance the `index` by count, returning `false` and `index` unchanged if `index` would advance past the end, otherwise returns `true` and `index` is advanced.
	mutating func skip(count: Int = 1) throws {
		if count == 1 &amp;&amp; index != scalars.endIndex {
			index = scalars.index(after: index)
			consumed += 1
		} else {
			var i = index
			var c = count
			while c &gt; 0 {
				if i == scalars.endIndex {
					throw ScalarScannerError.endedPrematurely(count: count, at: consumed)
				}
				i = self.scalars.index(after: i)
				c -= 1
			}
			index = i
			consumed += count
		}
	}
	
	/// Attempt to advance the `index` by count, returning `false` and `index` unchanged if `index` would advance past the end, otherwise returns `true` and `index` is advanced.
	mutating func backtrack(count: Int = 1) throws {
		if count &lt;= consumed {
			if count == 1 {
				index = scalars.index(index, offsetBy: -1)
				consumed -= 1
			} else {
				let limit = consumed - count
				while consumed != limit {
					index = scalars.index(index, offsetBy: -1)
					consumed -= 1
				}
			}
		} else {
			throw ScalarScannerError.endedPrematurely(count: -count, at: consumed)
		}
	}
	
	/// Returns all content after the current `index`. `index` is advanced to the end.
	mutating func remainder() -&gt; String {
		var string: String = ""
		while index != scalars.endIndex {
			string.unicodeScalars.append(scalars[index])
			index = scalars.index(after: index)
			consumed += 1
		}
		return string
	}
	
	/// If the next scalars after the current `index` match `scalars`, advance over them and return `true`, otherwise, leave `index` unchanged and return `false`.
	/// WARNING: `string` is used purely for its `unicodeScalars` property and matching is purely based on direct scalar comparison (no decomposition or normalization is performed).
	mutating func conditional(string: String) -&gt; Bool {
		var i = index
		var c = 0
		for s in string.unicodeScalars {
			if i == scalars.endIndex || s != scalars[i] {
				return false
			}
			i = self.scalars.index(after: i)
			c += 1
		}
		index = i
		consumed += c
		return true
	}
	
	/// If the next scalar after the current `index` match `scalars`, advance over it and return `true`, otherwise, leave `index` unchanged and return `false`.
	mutating func conditional(scalar: UnicodeScalar) -&gt; Bool {
		if index == scalars.endIndex || scalar != scalars[index] {
			return false
		}
		index = self.scalars.index(after: index)
		consumed += 1
		return true
	}
	
	/// If the next scalar after the current `index` match `value`, advance over it and return `true`, otherwise, leave `index` unchanged and return `false`.
	mutating func conditional(where test: (UnicodeScalar) -&gt; Bool) -&gt; UnicodeScalar? {
		if index == scalars.endIndex || !test(scalars[index]) {
			return nil
		}
		let s = scalars[index]
		index = self.scalars.index(after: index)
		consumed += 1
		return s
	}
	
	/// If the `index` is at the end, throw, otherwise, return the next scalar at the current `index` without advancing `index`.
	func requirePeek() throws -&gt; UnicodeScalar {
		if index == scalars.endIndex {
			throw ScalarScannerError.endedPrematurely(count: 1, at: consumed)
		}
		return scalars[index]
	}
	
	/// If `index` + `ahead` is within bounds, return the scalar at that location, otherwise return `nil`. The `index` will not be changed in any case.
	func peek(skipCount: Int = 0) -&gt; UnicodeScalar? {
		var i = index
		var c = skipCount
		while c &gt; 0 &amp;&amp; i != scalars.endIndex {
			i = self.scalars.index(after: i)
			c -= 1
		}
		if i == scalars.endIndex {
			return nil
		}
		return scalars[i]
	}
	
	/// If the `index` is at the end, throw, otherwise, return the next scalar at the current `index`, advancing `index` by one.
	mutating func readScalar() throws -&gt; UnicodeScalar {
		if index == scalars.endIndex {
			throw ScalarScannerError.endedPrematurely(count: 1, at: consumed)
		}
		let result = scalars[index]
		index = self.scalars.index(after: index)
		consumed += 1
		return result
	}
	
	/// Throws if scalar at the current `index` is not in the range `"0"` to `"9"`. Consume scalars `"0"` to `"9"` until a scalar outside that range is encountered. Return the integer representation of the value scanned, interpreted as a base 10 integer. `index` is advanced to the end of the number.
	mutating func readInt() throws -&gt; Int {
		let result = conditionalInt()
		guard let r = result else {
			throw ScalarScannerError.expectedInt(at: consumed)
		}
		return r
	}
	
	/// Throws if scalar at the current `index` is not in the range `"0"` to `"9"`. Consume scalars `"0"` to `"9"` until a scalar outside that range is encountered. Return the integer representation of the value scanned, interpreted as a base 10 integer. `index` is advanced to the end of the number.
	mutating func conditionalInt() -&gt; Int? {
		var result = 0
		var i = index
		var c = 0
		while i != scalars.endIndex &amp;&amp; scalars[i].isDigit {
			let digit = Int(scalars[i].value - UnicodeScalar("0").value)
			// Avoid overflow
			if (Int.max - digit) / 10 &lt; result {
				return nil
			}
			result = result * 10 + digit
			i = self.scalars.index(after: i)
			c += 1
		}
		if i == index {
			return nil
		}
		index = i
		consumed += c
		return result
	}
	
	/// Consume and return `count` scalars. `index` will be advanced by count. Throws if end of `scalars` occurs before consuming `count` scalars.
	mutating func readScalars(count: Int) throws -&gt; String {
		var result = String()
		result.reserveCapacity(count)
		var i = index
		for _ in 0..&lt;count {
			if i == scalars.endIndex {
				throw ScalarScannerError.endedPrematurely(count: count, at: consumed)
			}
			result.unicodeScalars.append(scalars[i])
			i = self.scalars.index(after: i)
		}
		index = i
		consumed += count
		return result
	}
	
	/// Returns a throwable error capturing the current scanner progress point.
	func unexpectedError() -&gt; ScalarScannerError {
		return ScalarScannerError.unexpected(at: consumed)
	}
	
	var isAtEnd: Bool {
		return index == scalars.endIndex
	}
}

import Foundation

/// An `ExecutionContext` wraps a mutex around calls invoked by an underlying execution context. The effect is to serialize concurrent contexts (immediate or concurrent).
struct SerializingContext: CustomExecutionContext {
	let underlying: Exec
	let mutex = PThreadMutex(type: .recursive)
	
	init(concurrentContext: Exec) {
		underlying = concurrentContext
	}
	
	var type: ExecutionType {
		switch underlying.type {
		case .immediate: return .mutex
		case .concurrentAsync: return .serialAsync
		case .mutex, .recursiveMutex, .thread, .threadAsync, .serialAsync: return underlying.type
		}
	}
	
	func invoke(_ execute: @escaping () -&gt; Void) {
		if case .direct = underlying {
			mutex.sync(execute: execute)
		} else {
			underlying.invoke { [mutex] in mutex.sync(execute: execute) }
		}
	}
	
	func invokeAsync(_ execute: @escaping () -&gt; Void) {
		underlying.invokeAsync { [mutex] in mutex.sync(execute: execute) }
	}
	
	@available(*, deprecated, message: "Use invokeSync instead")
	func invokeAndWait(_ execute: @escaping () -&gt; Void) {
		_ = invokeSync(execute)
	}
	
	func invokeSync&lt;Return&gt;(_ execute: () throws -&gt; Return) rethrows -&gt; Return {
		if case .direct = underlying {
			return try mutex.sync(execute: execute)
		} else {
			return try underlying.invokeSync { [mutex] () throws -&gt; Return in try mutex.sync(execute: execute) }
		}
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`) unless the returned `Lifetime` is cancelled or released before running occurs.
	func singleTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime {
		return mutex.sync { () -&gt; Lifetime in
			let wrapper = MutexWrappedLifetime(mutex: mutex)
			let lifetime = underlying.singleTimer(interval: interval, leeway: leeway) { [weak wrapper] in
				if let w = wrapper {
					w.mutex.sync {
						// Need to perform this double check since the timer may have been cancelled/changed before we managed to enter the mutex
						if w.lifetime != nil {
							handler()
						}
					}
				}
			}
			wrapper.lifetime = lifetime
			return wrapper
		}
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), passing the `parameter` value as an argument, unless the returned `Lifetime` is cancelled or released before running occurs.
	func singleTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		return mutex.sync { () -&gt; Lifetime in
			let wrapper = MutexWrappedLifetime(mutex: mutex)
			let lifetime = underlying.singleTimer(parameter: parameter, interval: interval, leeway: leeway) { [weak wrapper] p in
				if let w = wrapper {
					w.mutex.sync {
						// Need to perform this double check since the timer may have been cancelled/changed before we managed to enter the mutex
						if w.lifetime != nil {
							handler(p)
						}
					}
				}
			}
			wrapper.lifetime = lifetime
			return wrapper
		}
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), and again every `interval` (within a `leeway` margin of error) unless the returned `Lifetime` is cancelled or released before running occurs.
	func periodicTimer(interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping () -&gt; Void) -&gt; Lifetime {
		return mutex.sync { () -&gt; Lifetime in
			let wrapper = MutexWrappedLifetime(mutex: mutex)
			let lifetime = underlying.periodicTimer(interval: interval, leeway: leeway) { [weak wrapper] in
				if let w = wrapper {
					w.mutex.sync {
						// Need to perform this double check since the timer may have been cancelled/changed before we managed to enter the mutex
						if w.lifetime != nil {
							handler()
						}
					}
				}
			}
			wrapper.lifetime = lifetime
			return wrapper
		}
	}
	
	/// Run `execute` on the execution context after `interval` (plus `leeway`), passing the `parameter` value as an argument, and again every `interval` (within a `leeway` margin of error) unless the returned `Lifetime` is cancelled or released before running occurs.
	func periodicTimer&lt;T&gt;(parameter: T, interval: DispatchTimeInterval, leeway: DispatchTimeInterval, handler: @escaping (T) -&gt; Void) -&gt; Lifetime {
		return mutex.sync { () -&gt; Lifetime in
			let wrapper = MutexWrappedLifetime(mutex: mutex)
			let lifetime = underlying.periodicTimer(parameter: parameter, interval: interval, leeway: leeway) { [weak wrapper] p in
				if let w = wrapper {
					w.mutex.sync {
						if w.lifetime != nil {
							handler(p)
						}
					}
				}
			}
			wrapper.lifetime = lifetime
			return wrapper
		}
	}
	
	/// Gets a timestamp representing the host uptime the in the current context
	func timestamp() -&gt; DispatchTime {
		return underlying.timestamp()
	}
}

/// A wrapper around Lifetime that applies a mutex on the cancel operation.
/// This is a class so that `SerializingContext` can pass it weakly to the timer closure, avoiding having the timer keep itself alive.
private class MutexWrappedLifetime: Lifetime {
	var lifetime: Lifetime? = nil
	let mutex: PThreadMutex
	
	init(mutex: PThreadMutex) {
		self.mutex = mutex
	}
	
	func cancel() {
		mutex.sync {
			lifetime?.cancel()
			lifetime = nil
		}
	}
	
	deinit {
		cancel()
	}
}

import Foundation

/// A "static"-only namespace around a series of functions that operate on buffers returned from the `Darwin.sysctl` function
struct Sysctl {
	/// Possible errors.
	enum Error: Swift.Error {
		case unknown
		case malformedUTF8
		case invalidSize
		case posixError(POSIXErrorCode)
	}
	
	/// Access the raw data for an array of sysctl identifiers.
	static func data(for keys: [Int32]) throws -&gt; [Int8] {
		return try keys.withUnsafeBufferPointer() { keysPointer throws -&gt; [Int8] in
			// Preflight the request to get the required data size
			var requiredSize = 0
			let preFlightResult = Darwin.sysctl(UnsafeMutablePointer&lt;Int32&gt;(mutating: keysPointer.baseAddress), UInt32(keys.count), nil, &amp;requiredSize, nil, 0)
			if preFlightResult != 0 {
				throw POSIXErrorCode(rawValue: errno).map {
					print($0.rawValue)
					return Error.posixError($0)
				} ?? Error.unknown
			}
			
			// Run the actual request with an appropriately sized array buffer
			let data = Array&lt;Int8&gt;(repeating: 0, count: requiredSize)
			let result = data.withUnsafeBufferPointer() { dataBuffer -&gt; Int32 in
				return Darwin.sysctl(UnsafeMutablePointer&lt;Int32&gt;(mutating: keysPointer.baseAddress), UInt32(keys.count), UnsafeMutableRawPointer(mutating: dataBuffer.baseAddress), &amp;requiredSize, nil, 0)
			}
			if result != 0 {
				throw POSIXErrorCode(rawValue: errno).map { Error.posixError($0) } ?? Error.unknown
			}
			
			return data
		}
	}

	/// Convert a sysctl name string like "hw.memsize" to the array of `sysctl` identifiers (e.g. [CTL_HW, HW_MEMSIZE])
	static func keys(for name: String) throws -&gt; [Int32] {
		var keysBufferSize = Int(CTL_MAXNAME)
		var keysBuffer = Array&lt;Int32&gt;(repeating: 0, count: keysBufferSize)
		try keysBuffer.withUnsafeMutableBufferPointer { (lbp: inout UnsafeMutableBufferPointer&lt;Int32&gt;) throws in
			try name.withCString { (nbp: UnsafePointer&lt;Int8&gt;) throws in
				guard sysctlnametomib(nbp, lbp.baseAddress, &amp;keysBufferSize) == 0 else {
					throw POSIXErrorCode(rawValue: errno).map { Error.posixError($0) } ?? Error.unknown
				}
			}
		}
		if keysBuffer.count &gt; keysBufferSize {
			keysBuffer.removeSubrange(keysBufferSize..&lt;keysBuffer.count)
		}
		return keysBuffer
	}

	/// Invoke `sysctl` with an array of identifers, interpreting the returned buffer as the specified type. This function will throw `Error.invalidSize` if the size of buffer returned from `sysctl` fails to match the size of `T`.
	static func value&lt;T&gt;(ofType: T.Type, forKeys keys: [Int32]) throws -&gt; T {
		let buffer = try data(for: keys)
		if buffer.count != MemoryLayout&lt;T&gt;.size {
			throw Error.invalidSize
		}
		return try buffer.withUnsafeBufferPointer() { bufferPtr throws -&gt; T in
			guard let baseAddress = bufferPtr.baseAddress else { throw Error.unknown }
			return baseAddress.withMemoryRebound(to: T.self, capacity: 1) { $0.pointee }
		}
	}
	
	/// Invoke `sysctl` with an array of identifers, interpreting the returned buffer as the specified type. This function will throw `Error.invalidSize` if the size of buffer returned from `sysctl` fails to match the size of `T`.
	static func value&lt;T&gt;(ofType type: T.Type, forKeys keys: Int32...) throws -&gt; T {
		return try value(ofType: type, forKeys: keys)
	}
	
	/// Invoke `sysctl` with the specified name, interpreting the returned buffer as the specified type. This function will throw `Error.invalidSize` if the size of buffer returned from `sysctl` fails to match the size of `T`.
	static func value&lt;T&gt;(ofType type: T.Type, forName name: String) throws -&gt; T {
		return try value(ofType: type, forKeys: keys(for: name))
	}
	
	/// Invoke `sysctl` with an array of identifers, interpreting the returned buffer as a `String`. This function will throw `Error.malformedUTF8` if the buffer returned from `sysctl` cannot be interpreted as a UTF8 buffer.
	static func string(for keys: [Int32]) throws -&gt; String {
		let optionalString = try data(for: keys).withUnsafeBufferPointer() { dataPointer -&gt; String? in
			dataPointer.baseAddress.flatMap { String(validatingUTF8: $0) }
		}
		guard let s = optionalString else {
			throw Error.malformedUTF8
		}
		return s
	}
	
	/// Invoke `sysctl` with an array of identifers, interpreting the returned buffer as a `String`. This function will throw `Error.malformedUTF8` if the buffer returned from `sysctl` cannot be interpreted as a UTF8 buffer.
	static func string(for keys: Int32...) throws -&gt; String {
		return try string(for: keys)
	}
	
	/// Invoke `sysctl` with the specified name, interpreting the returned buffer as a `String`. This function will throw `Error.malformedUTF8` if the buffer returned from `sysctl` cannot be interpreted as a UTF8 buffer.
	static func string(for name: String) throws -&gt; String {
		return try string(for: keys(for: name))
	}
	
	/// e.g. "MyComputer.local" (from System Preferences -&gt; Sharing -&gt; Computer Name) or
	/// "My-Name-iPhone" (from Settings -&gt; General -&gt; About -&gt; Name)
	static var hostName: String { return try! Sysctl.string(for: [CTL_KERN, KERN_HOSTNAME]) }
	
	/// e.g. "x86_64" or "N71mAP"
	/// NOTE: this is *corrected* on iOS devices to fetch hw.model
	static var machine: String {
		#if os(iOS) &amp;&amp; !arch(x86_64) &amp;&amp; !arch(i386)
			return try! Sysctl.string(for: [CTL_HW, HW_MODEL])
		#else
			return try! Sysctl.string(for: [CTL_HW, HW_MACHINE])
		#endif
	}
	
	/// e.g. "MacPro4,1" or "iPhone8,1"
	/// NOTE: this is *corrected* on iOS devices to fetch hw.machine
	static var model: String {
		#if os(iOS) &amp;&amp; !arch(x86_64) &amp;&amp; !arch(i386)
			return try! Sysctl.string(for: [CTL_HW, HW_MACHINE])
		#else
			return try! Sysctl.string(for: [CTL_HW, HW_MODEL])
		#endif
	}
	
	/// e.g. "8" or "2"
	static var activeCPUs: Int32 { return try! Sysctl.value(ofType: Int32.self, forKeys: [CTL_HW, HW_AVAILCPU]) }
	
	/// e.g. "15.3.0" or "15.0.0"
	static var osRelease: String { return try! Sysctl.string(for: [CTL_KERN, KERN_OSRELEASE]) }
	
	/// e.g. "Darwin" or "Darwin"
	static var osType: String { return try! Sysctl.string(for: [CTL_KERN, KERN_OSTYPE]) }
	
	/// e.g. "15D21" or "13D20"
	static var osVersion: String { return try! Sysctl.string(for: [CTL_KERN, KERN_OSVERSION]) }
	
	/// e.g. "Darwin Kernel Version 15.3.0: Thu Dec 10 18:40:58 PST 2015; root:xnu-3248.30.4~1/RELEASE_X86_64" or
	/// "Darwin Kernel Version 15.0.0: Wed Dec  9 22:19:38 PST 2015; root:xnu-3248.31.3~2/RELEASE_ARM64_S8000"
	static var version: String { return try! Sysctl.string(for: [CTL_KERN, KERN_VERSION]) }
	
	#if os(macOS)
		/// e.g. 199506 (not available on iOS)
		static var osRev: Int32 { return try! Sysctl.value(ofType: Int32.self, forKeys: [CTL_KERN, KERN_OSREV]) }

		/// e.g. 2659000000 (not available on iOS)
		static var cpuFreq: Int64 { return try! Sysctl.value(ofType: Int64.self, forName: "hw.cpufrequency") }

		/// e.g. 25769803776 (not available on iOS)
		static var memSize: UInt64 { return try! Sysctl.value(ofType: UInt64.self, forKeys: [CTL_HW, HW_MEMSIZE]) }
	#endif
}

import Foundation

/// A class wrapper around a type (usually a value type) so it can be moved without copying.
class Box&lt;T&gt; {
	fileprivate(set) var value: T
	init(_ t: T) {
		value = t
	}
}

//// A class wrapper around a type (usually a value type) so changes to it can be shared (usually as an ad hoc communication channel). NOTE: this version is *not* threadsafe, use AtomicBox for that.
final class MutableBox&lt;T&gt;: Box&lt;T&gt; {
	override var value: T { get { return super.value } set { super.value = newValue } }
	override init(_ t: T) {
		super.init(t)
	}
}

// A class wrapper around a type (usually a value type) so changes to it can be shared in a thread-safe manner (usually as an ad hoc communication channel).
/// "Atomic" in this sense refers to the semantics, not the implementation. This uses a pthread mutex, not CAS-style atomic operations.
final class AtomicBox&lt;T&gt; {
	private var mutex = PThreadMutex()
	private var internalValue: T
	
	init(_ t: T) {
		internalValue = t
	}
	
	var value: T {
		get {
			mutex.unbalancedLock()
			defer { mutex.unbalancedUnlock() }
			return internalValue
		}
	}

	@discardableResult
	func mutate(_ f: (inout T) throws -&gt; Void) rethrows -&gt; T {
		mutex.unbalancedLock()
		defer { mutex.unbalancedUnlock() }
		try f(&amp;internalValue)
		return internalValue
	}
}

/// A struct wrapper around an optional and a construction function that presents the optional through the `value()` function as though it's a lazy var. Unlike a true lazy var, you can query if the value has been initialized.
struct Lazy&lt;T&gt; {
	var valueIfInitialized: T?
	let valueConstructor: () -&gt; T
	
	init(valueConstructor: @escaping () -&gt; T) {
		self.valueConstructor = valueConstructor
	}
	var isInitialized: Bool { return valueIfInitialized != nil }
	mutating func value() -&gt; T {
		if let v = valueIfInitialized {
			return v
		}
		let v = valueConstructor()
		valueIfInitialized = v
		return v
	}
}

/// A wrapper around a type (usually a class type) so it can be weakly referenced from an Array or other strong container.
struct Weak&lt;T: AnyObject&gt; {
	weak var value: T?
	
	init(_ value: T?) {
		self.value = value
	}
	
	func contains(_ other: T) -&gt; Bool {
		if let v = value {
			return v === other
		} else {
			return false
		}
	}
}

/// A wrapper around a type (usually a class type) so it can be referenced unowned from an Array or other strong container.
struct Unowned&lt;T: AnyObject&gt; {
	unowned let value: T
	init(_ value: T) {
		self.value = value
	}
}

/// A enum wrapper around a type (usually a class type) so its ownership can be set at runtime.
enum PossiblyWeak&lt;T: AnyObject&gt; {
	case strong(T)
	case weak(Weak&lt;T&gt;)
	
	init(strong value: T) {
		self = PossiblyWeak&lt;T&gt;.strong(value)
	}
	
	init(weak value: T) {
		self = PossiblyWeak&lt;T&gt;.weak(Weak(value))
	}
	
	var value: T? {
		switch self {
		case .strong(let t): return t
		case .weak(let weakT): return weakT.value
		}
	}
	
	func contains(_ other: T) -&gt; Bool {
		switch self {
		case .strong(let t): return t === other
		case .weak(let weakT):
			if let wt = weakT.value {
				return wt === other
			}
			return false
		}
	}
}
</string>
			<key>Group</key>
			<string>Dependencies</string>
		</dict>
		<key>Dependencies/CwlViewsCore.swift</key>
		<dict>
			<key>Beginning</key>
			<string>//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-05-11 02:03:25 +0000 from the following files:
//   CwlAdapter+Signals.swift
//   CwlAdapter.swift
//   CwlAdapterState.swift
//   CwlCodableContainer.swift
//   CwlMasterDetail.swift
//   CwlModelState.swift
//   CwlStackAdapter.swift
//   CwlTempVar.swift
//   CwlToggleVar.swift
//   CwlVar.swift
//   CwlAssociatedBinderStorage.swift
//   CwlBinder.swift
//   CwlBinderApplyable.swift
//   CwlBinderBase.swift
//   CwlBinderDelegate.swift
//   CwlBinderEmbedderConstructor.swift
//   CwlBinderPreparer.swift
//   CwlBinding.swift
//   CwlBindingName.swift
//   CwlConstant.swift
//   CwlDynamic.swift
//   CwlInitialSubsequent.swift
//   CwlScopedValues.swift
//   CwlSignalCallback.swift
//   CwlTargetAction.swift
//   CwlIndexedMutation.swift
//   CwlSetMutation.swift
//   CwlStackMutation.swift
//   CwlSubrangeMutation.swift
//   CwlTreeMutation.swift
//   CwlAnimatable.swift
//   CwlCoder.swift
//   CwlImageDrawn.swift
//   CwlKeyValueObservationLifetime.swift
//   CwlLayout.swift
//   CwlPreferredFonts.swift
//   CwlExtendedView.swift
//   CwlGradientLayer.swift
//   CwlLayer.swift
//   CwlShapeLayer.swift
//   CwlStackView.swift
//   CwlWebView.swift

import Foundation

extension Adapter: Lifetime {
	func cancel() {
		if State.self is CodableContainer.Type, let value = combinedSignal.peek()?.state, var sc = value as? CodableContainer {
			sc.cancel()
		}
		input.cancel()
	}
}

extension Adapter: Codable where State: Codable {
	init(from decoder: Decoder) throws {
		let c = try decoder.singleValueContainer()
		let p = try c.decode(State.self)
		self.init(adapterState: p)
	}
	
	func encode(to encoder: Encoder) throws {
		if let s = combinedSignal.peek()?.state {
			var c = encoder.singleValueContainer()
			try c.encode(s)
		}
	}
}

extension Adapter: CodableContainer where State: PersistentAdapterState {
	var childCodableContainers: [CodableContainer] {
		if let state = combinedSignal.peek()?.state {
			return (state as? CodableContainer)?.childCodableContainers ?? []
		} else {
			return []
		}
	}
	
	var codableValueChanged: Signal&lt;Void&gt; {
		if State.self is CodableContainer.Type {
			return combinedSignal.flatMapLatest { (content: State.Output) -&gt; Signal&lt;Void&gt; in
				let cc = content.state as! CodableContainer
				return cc.codableValueChanged.startWith(())
			}.dropActivation()
		}
		return combinedSignal.map { _ in () }.dropActivation()
	}
}

struct Adapter&lt;State: AdapterState&gt;: SignalInterface, SignalInputInterface {
	typealias OutputValue = State.Notification
	typealias InputValue = State.Message
	private enum Keys: CodingKey { case `var` }
	
	let executionContext: Exec

	let multiInput: SignalMultiInput&lt;State.Message&gt;
	var input: SignalInput&lt;State.Message&gt; { return multiInput }
	
	let combinedSignal: SignalMulti&lt;State.Output&gt;
	var signal: Signal&lt;State.Notification&gt; {
		return combinedSignal.compactMapActivation(select: .last, context: executionContext, activation: { $0.state.resume() }, remainder: { $0.notification })
	}
	
	init(adapterState: State? = nil) {
		let (i, s) = Signal&lt;State.Message&gt;.multiChannel().tuple
		multiInput = i
		
		if let state = adapterState {
			let (ec, async) = state.instanceContext
			executionContext = ec
			let sig = async ? s.scheduleAsync(relativeTo: executionContext) : s
			combinedSignal = sig.reduce(initialState: (state, nil), context: executionContext) { (content: State.Output, message: State.Message) throws -&gt; State.Output in
				try content.state.reduce(message: message, feedback: i)
			}
		} else {
			let initializer = { (message: State.Message) throws -&gt; State.Output? in
				try State.initialize(message: message, feedback: i)
			}
			let (ec, async) = State.defaultContext
			executionContext = ec
			let sig = async ? s.scheduleAsync(relativeTo: executionContext) : s
			combinedSignal = sig.reduce(context: executionContext, initializer: initializer) { (content: State.Output, message: State.Message) throws -&gt; State.Output in
				try content.state.reduce(message: message, feedback: i)
			}
		}
	}
}

protocol AdapterState {
	associatedtype Message
	associatedtype Notification
	
	typealias Output = (state: Self, notification: Notification?)
	
	static var defaultContext: (Exec, Bool) { get }

	static func initialize(message: Message, feedback: SignalMultiInput&lt;Message&gt;) throws -&gt; Output?

	var instanceContext: (Exec, Bool) { get }

	func reduce(message: Message, feedback: SignalMultiInput&lt;Message&gt;) throws -&gt; Output
	func resume() -&gt; Notification?
}

extension AdapterState {
	static var defaultContext: (Exec, Bool) {
		return (.direct, false)
	}
	
	var instanceContext: (Exec, Bool) {
		return Self.defaultContext
	}
	
	static func initialize(message: Message, feedback: SignalMultiInput&lt;Message&gt;) throws -&gt; Output? {
		return nil
	}
}

protocol NonPersistentAdapterState: AdapterState, Codable {
	init()
}

extension NonPersistentAdapterState {
	init(from decoder: Decoder) throws {
		self.init()
	}
	
	func encode(to encoder: Encoder) throws {
	}
}

extension Adapter {
	init&lt;Value&gt;() where TempValue&lt;Value&gt; == State {
		self.init(adapterState: TempValue&lt;Value&gt;())
	}
}

protocol PersistentAdapterState: AdapterState, Codable {
	associatedtype PersistentValue: Codable
	init(value: PersistentValue)
	var value: PersistentValue { get }
}

extension PersistentAdapterState where Notification == PersistentValue {
	func resume() -&gt; Notification? {
		return value
	}
}

extension Adapter where State: PersistentAdapterState {
	var state: Signal&lt;State&gt; {
		return combinedSignal.compactMap { content in content.state }
	}
}

extension PersistentAdapterState {
	init(from decoder: Decoder) throws {
		let c = try decoder.singleValueContainer()
		let p = try c.decode(PersistentValue.self)
		self.init(value: p)
	}
	
	func encode(to encoder: Encoder) throws {
		var c = encoder.singleValueContainer()
		try c.encode(value)
	}
}

extension Adapter where State: PersistentAdapterState {
	func logJson(prefix: String = "", formatting: JSONEncoder.OutputFormatting = .prettyPrinted) -&gt; Lifetime {
		return codableValueChanged
			.startWith(())
			.subscribe { _ in
				let enc = JSONEncoder()
				enc.outputFormatting = formatting
				if let data = try? enc.encode(self), let string = String(data: data, encoding: .utf8) {
					print("\(prefix)\(string)")
				}
		}
	}
}

protocol PersistentContainerAdapterState: PersistentAdapterState, CodableContainer where PersistentValue: CodableContainer {}

extension PersistentContainerAdapterState {
	var childCodableContainers: [CodableContainer] {
		return value.childCodableContainers
	}
	
	var codableValueChanged: Signal&lt;Void&gt; {
		return value.codableValueChanged
	}
}

protocol CodableContainer: Lifetime, Codable {
	var codableValueChanged: Signal&lt;Void&gt; { get }
	var childCodableContainers: [CodableContainer] { get }
}

extension CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return Mirror(reflecting: self).children.compactMap { $0.value as? CodableContainer }
	}
	
	var codableValueChanged: Signal&lt;Void&gt; {
		let sequence = childCodableContainers.map { return $0.codableValueChanged }
		if sequence.isEmpty {
			return Signal&lt;Void&gt;.preclosed()
		} else if sequence.count == 1 {
			return sequence.first!
		} else {
			return Signal&lt;Void&gt;.merge(sequence: sequence)
		}
	}
	
	mutating func cancel() {
		for var v in childCodableContainers {
			v.cancel()
		}
	}
}

extension Array: Lifetime where Element: CodableContainer {
	mutating func cancel() {
		for var v in self {
			v.cancel()
		}
	}
}

extension Optional: Lifetime where Wrapped: CodableContainer {
	mutating func cancel() {
		self?.cancel()
	}
}

extension Array: CodableContainer where Element: CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return flatMap { $0.childCodableContainers }
	}
}

extension Optional: CodableContainer where Wrapped: CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return self?.childCodableContainers ?? []
	}
}

/// An "Either" type for use in scenarios where "Equatable" and "Codable" are required but there's only ever a single "Master" instance so equality is implied. This is common in Navigation Controller stacks and Split Views.
enum MasterDetail&lt;Master: CodableContainer, Detail: CodableContainer&gt;: CodableContainer {
	case master(Master)
	case detail(Detail)
	
	var childCodableContainers: [CodableContainer] {
		switch self {
		case .master(let tvm): return [tvm]
		case .detail(let dvm): return [dvm]
		}
	}
	
	enum Keys: CodingKey { case master, detail }
	
	func encode(to encoder: Encoder) throws {
		var c = encoder.container(keyedBy: Keys.self)
		switch self {
		case .master(let tvm): try c.encode(tvm, forKey: .master)
		case .detail(let dvm): try c.encode(dvm, forKey: .detail)
		}
	}
	
	init(from decoder: Decoder) throws {
		let c = try decoder.container(keyedBy: Keys.self)
		if let tvm = try c.decodeIfPresent(Master.self, forKey: .master) {
			self = .master(tvm)
		} else {
			self = .detail(try c.decode(Detail.self, forKey: .detail))
		}
	}
}

struct ModelState&lt;Wrapped, M, N&gt;: AdapterState {
	typealias Message = M
	typealias Notification = N
	let instanceContext: (Exec, Bool) 
	
	let reducer: (_ model: inout Wrapped, _ message: Message, _ feedback: SignalMultiInput&lt;Message&gt;) throws -&gt; Notification?
	let resumer: (_ model: Wrapped) -&gt; Notification?
	let wrapped: Wrapped
	
	init(previous: ModelState&lt;Wrapped, M, N&gt;, nextWrapped: Wrapped) {
		self.instanceContext = previous.instanceContext
		self.reducer = previous.reducer
		self.resumer = previous.resumer
		self.wrapped = nextWrapped
	}
	
	init(async: Bool = false, initial: Wrapped, resumer: @escaping (_ model: Wrapped) -&gt; Notification? = { _ in nil }, reducer: @escaping (_ model: inout Wrapped, _ message: Message, _ feedback: SignalMultiInput&lt;Message&gt;) throws -&gt; Notification?) {
		self.instanceContext = (Exec.syncQueue(), async)
		self.reducer = reducer
		self.resumer = resumer
		self.wrapped = initial
	}

	func reduce(message: Message, feedback: SignalMultiInput&lt;Message&gt;) throws -&gt; (state: ModelState&lt;Wrapped, Message, Notification&gt;, notification: N?) {
		var nextWrapped = wrapped
		let n = try reducer(&amp;nextWrapped, message, feedback)
		return (ModelState&lt;Wrapped, M, N&gt;(previous: self, nextWrapped: nextWrapped), n)
	}
	
	func resume() -&gt; Notification? {
		return resumer(wrapped)
	}
}


extension Adapter {
	/// Access the internal state outside of the reactive pipeline.
	///
	/// NOTE: this function is `throws` *not* `rethrows`. The function may throw regardless of whether the supplied `processor` may throw.
	///
	/// - Parameter processor: performs work with the underlying state
	/// - Returns: the result from `processor`
	/// - Throws: Other than any error thrown from `processor`, this function can throw if no model value is available (it might not be initialized or the execution context may have delayed the response).
	func sync&lt;Wrapped, R, M, N&gt;(_ processor: (Wrapped) throws -&gt; R) throws -&gt; R where ModelState&lt;Wrapped, M, N&gt; == State {
		// Don't `peek` inside the `invokeSync` since that would require re-entering the `executionContext`.
		let wrapped = try combinedSignal.capture().get().state.wrapped
		return try executionContext.invokeSync { return try processor(wrapped) }
	}
	
	func slice&lt;Wrapped, Processed, M, N&gt;(resume: N? = nil, _ processor: @escaping (Wrapped, N) throws -&gt; Signal&lt;Processed&gt;.Next) -&gt; Signal&lt;Processed&gt; where ModelState&lt;Wrapped, M, N&gt; == State {
		let s: Signal&lt;State.Output&gt;
		if let r = resume {
			s = combinedSignal.compactMapActivation(context: executionContext) { ($0.state, r) }
		} else {
			s = combinedSignal
		}
		return s.transform(context: executionContext) { result in
			switch result {
			case .failure(let e): return .end(e)
			case .success(_, nil): return .none
			case .success(let wrapped, .some(let notification)):
				do {
					return try processor(wrapped.wrapped, notification)
				} catch {
					return .error(error)
				}
			}
		}
	}
	
	func slice&lt;Value, Wrapped, Processed, M, N&gt;(initial: Value, resume: N? = nil, _ processor: @escaping (inout Value, Wrapped, N) throws -&gt; Signal&lt;Processed&gt;.Next) -&gt; Signal&lt;Processed&gt; where ModelState&lt;Wrapped, M, N&gt; == State {
		let s: Signal&lt;State.Output&gt;
		if let r = resume {
			s = combinedSignal.compactMapActivation(context: executionContext) { ($0.state, r) }
		} else {
			s = combinedSignal
		}
		return s.transform(initialState: initial, context: executionContext) { value, result in
			switch result {
			case .failure(let e): return .end(e)
			case .success(_, nil): return .none
			case .success(let wrapped, .some(let notification)):
				do {
					return try processor(&amp;value, wrapped.wrapped, notification)
				} catch {
					return .error(error)
				}
			}
		}
	}

	func logJson&lt;Wrapped, M, N, Value&gt;(keyPath: KeyPath&lt;Wrapped, Value&gt;, prefix: String = "", formatting: JSONEncoder.OutputFormatting = .prettyPrinted) -&gt; Lifetime where State == ModelState&lt;Wrapped, M, N&gt;, Value: Encodable {
		return combinedSignal.subscribeValues(context: executionContext) { (state, _) in
			let enc = JSONEncoder()
			enc.outputFormatting = formatting
			if let data = try? enc.encode(state.wrapped[keyPath: keyPath]), let string = String(data: data, encoding: .utf8) {
				print("\(prefix)\(string)")
			}
		}
	}
}

import Foundation

typealias StackAdapter&lt;PathElement: Codable&gt; = Adapter&lt;StackAdapterState&lt;PathElement&gt;&gt;

/// This "Adapter" is a `ModelSignalValue` that manages a stack of navigation items as might be used by a UINavigationController. The adapter converts `push`, `popToCount` and `reload` messages into updates to the array of `PathElement`. The adapter includes convenient input signals, animated output signals and includes automatic implementation of coding and notification protocols.
struct StackAdapterState&lt;PathElement: Codable&gt;: PersistentAdapterState {
	typealias Message = StackMutation&lt;PathElement&gt;
	typealias Notification = StackMutation&lt;PathElement&gt;
	
	let value: [PathElement]
	init(value: [PathElement]) {
		self.value = value
	}
	
	func reduce(message: Message, feedback: SignalMultiInput&lt;Message&gt;) -&gt; Output {
		switch message {
		case .push(let e):
			let next = StackAdapterState&lt;PathElement&gt;(value: value.appending(e))
			return Output(state: next, notification: message)
		case .pop:
			let next = StackAdapterState&lt;PathElement&gt;(value: Array(value.dropLast()))
			return Output(state: next, notification: message)
		case .popToCount(let i):
			guard i &gt;= 1 else { return Output(state: self, notification: nil) }
			let next = StackAdapterState&lt;PathElement&gt;(value: Array(value.prefix(i)))
			return Output(state: next, notification: message)
		case .reload(let newStack):
			let next = StackAdapterState&lt;PathElement&gt;(value: newStack)
			return Output(state: next, notification: message)
		}
	}
	
	func resume() -&gt; Notification? {
		return Message.reload(value)
	}
	
	static func initialize(message: Message, feedback: SignalMultiInput&lt;Message&gt;) -&gt; Output? {
		return StackAdapterState&lt;PathElement&gt;(value: []).reduce(message: message, feedback: feedback)
	}
}

extension StackAdapterState: Codable where PathElement: Codable {}

extension StackAdapterState: Lifetime where PathElement: Lifetime {
	mutating func cancel() {
		for var l in value {
			l.cancel()
		}
		self = StackAdapterState(value: value.map { element in
			var e = element
			e.cancel()
			return e
		})
	}
}

extension StackAdapterState: CodableContainer where PathElement: CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return value.childCodableContainers
	}
	
	var codableValueChanged: Signal&lt;Void&gt; {
		return value.codableValueChanged
	}
}

extension Adapter {
	init&lt;PathElement: Codable&gt;( _ value: [PathElement]) where StackAdapterState&lt;PathElement&gt; == State {
		self.init(adapterState: StackAdapterState&lt;PathElement&gt;(value: value))
	}
}

extension Adapter {
	func push&lt;PathElement&gt;() -&gt; SignalInput&lt;PathElement&gt; where State.Message == StackMutation&lt;PathElement&gt; {
		return Signal&lt;PathElement&gt;.channel().map { State.Message.push($0) }.bind(to: input)
	}
	
	func popToCount&lt;PathElement&gt;() -&gt; SignalInput&lt;Int&gt; where State.Message == StackMutation&lt;PathElement&gt; {
		return Signal&lt;Int&gt;.channel().map { State.Message.popToCount($0) }.bind(to: input)
	}
}

struct TempValue&lt;Value&gt;: NonPersistentAdapterState {
	typealias Message = Value
	typealias Notification = Value
	
	let temporaryValue: Value?
	init() {
		temporaryValue = nil
	}
	
	fileprivate init(temporaryValue: Value) {
		self.temporaryValue = temporaryValue
	}
	
	func reduce(message: Value, feedback: SignalMultiInput&lt;Message&gt;) -&gt; Output {
		return Output(state: TempValue(temporaryValue: message), notification: message)
	}
	
	func resume() -&gt; Notification? {
		return temporaryValue
	}
	
	static func initialize(message: Message, feedback: SignalMultiInput&lt;Message&gt;) -&gt; Output? {
		return Output(state: TempValue(temporaryValue: message), notification: message)
	}
}

typealias TempVar&lt;Value&gt; = Adapter&lt;TempValue&lt;Value&gt;&gt;

struct ToggleValue: PersistentAdapterState {
	typealias Message = Void
	typealias Notification = Bool
	
	let value: Bool
	init(value: Bool) {
		self.value = value
	}
	
	func reduce(message: Void, feedback: SignalMultiInput&lt;Message&gt;) -&gt; Output {
		return Output(state: ToggleValue(value: !value), notification: !value)
	}
	
	func resume() -&gt; Notification? { return value }
	
	static func initialize(message: Message, feedback: SignalMultiInput&lt;Message&gt;) -&gt; Output? {
		return nil
	}
}

typealias ToggleVar = Adapter&lt;ToggleValue&gt;

extension Adapter where State == ToggleValue {
	init(_ value: Bool) {
		self.init(adapterState: ToggleValue(value: value))
	}
}

typealias Var&lt;Value: Codable&gt; = Adapter&lt;VarState&lt;Value&gt;&gt;

struct VarState&lt;Value: Codable&gt;: PersistentAdapterState {
	enum Message {
		case set(Value)
		case update(Value)
		case notify(Value)
	}
	typealias Notification = Value
	
	let value: Value
	init(value: Value) {
		self.value = value
	}
	
	func reduce(message: Message, feedback: SignalMultiInput&lt;Message&gt;) -&gt; Output {
		switch message {
		case .set(let v): return Output(state: VarState&lt;Value&gt;(value: v), notification: v)
		case .update(let v): return Output(state: VarState&lt;Value&gt;(value: v), notification: nil)
		case .notify(let v): return Output(state: self, notification: v)
		}
	}
	
	func resume() -&gt; Notification? {
		return value
	}
	
	static func initialize(message: Message, feedback: SignalMultiInput&lt;Message&gt;) -&gt; Output? {
		switch message {
		case .set(let v): return Output(state: VarState&lt;Value&gt;(value: v), notification: v)
		case .update(let v): return Output(state: VarState&lt;Value&gt;(value: v), notification: nil)
		case .notify: return nil
		}
	}
}

extension VarState: Codable where Value: Codable {}

extension VarState: Lifetime where Value: Lifetime {
	mutating func cancel() {
		var v = value
		v.cancel()
		self = VarState(value: v)
	}
}

extension VarState: CodableContainer where Value: CodableContainer {
	var childCodableContainers: [CodableContainer] {
		return value.childCodableContainers
	}
	
	var codableValueChanged: Signal&lt;Void&gt; {
		return value.codableValueChanged
	}
}

extension Adapter {
	init&lt;Value&gt;(_ value: Value) where VarState&lt;Value&gt; == State {
		self.init(adapterState: VarState&lt;Value&gt;(value: value))
	}
}

extension Adapter {
	func set&lt;Value&gt;() -&gt; SignalInput&lt;Value&gt; where State.Message == VarState&lt;Value&gt;.Message {
		return Input().map { VarState&lt;Value&gt;.Message.set($0) }.bind(to: self)
	}
	
	func update&lt;Value&gt;() -&gt; SignalInput&lt;Value&gt; where State.Message == VarState&lt;Value&gt;.Message {
		return Input().map { VarState&lt;Value&gt;.Message.update($0) }.bind(to: self)
	}
	
	func notify&lt;Value&gt;() -&gt; SignalInput&lt;Value&gt; where State.Message == VarState&lt;Value&gt;.Message {
		return Input&lt;Value&gt;().map { VarState&lt;Value&gt;.Message.notify($0) }.bind(to: self)
	}
	
	func allChanges&lt;Value&gt;() -&gt; Signal&lt;Value&gt; where State == VarState&lt;Value&gt; {
		return combinedSignal.compactMap { combined in combined.notification ?? combined.state.value }
	}
	
	func stateChanges&lt;Value&gt;() -&gt; Signal&lt;Value&gt; where State == VarState&lt;Value&gt; {
		return combinedSignal.compactMap { combined in combined.state.value }
	}
}

extension SignalInterface {
	func bind&lt;InputInterface&gt;(to interface: InputInterface) where InputInterface: SignalInputInterface, InputInterface.InputValue == VarState&lt;OutputValue&gt;.Message {
		return map { VarState&lt;OutputValue&gt;.Message.set($0) }.bind(to: interface)
	}
}

extension SignalChannel {
	func bind&lt;Target&gt;(to interface: Target) -&gt; InputInterface where Target: SignalInputInterface, Target.InputValue == VarState&lt;Interface.OutputValue&gt;.Message {
		return final { $0.map { VarState&lt;Interface.OutputValue&gt;.Message.set($0) }.bind(to: interface) }.input
	}
}

extension BindingName {
	/// Build an action binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&gt;&lt;A&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: Adapter&lt;VarState&lt;A&gt;&gt;) -&gt; Binding where SignalInput&lt;A&gt; == Value {
		return name.binding(with: value.set())
	}
}

/// Implementation for `BinderStorage` that wraps Cocoa objects.
class AssociatedBinderStorage: NSObject {
	typealias Instance = NSObject
	private var lifetimes: [Lifetime]? = nil
	
	/// The embed function will avoid embedding and let the AssociatedBinderStorage release if this function returns false.
	/// Override and alter logic if a subclass may require the storage to persist when lifetimes is empty and the dynamic delegate is unused.
	var isInUse: Bool {
		guard let ls = lifetimes else { fatalError("Embed must be called before isInUse") }
		return ls.isEmpty == false || dynamicDelegate != nil
	}
	
	/// Implementation of the `BinderStorage` method to embed supplied lifetimes in an instance. This may be performed once-only for a given instance and storage (the storage should have the same lifetime as the instance and should not be disconnected once connected).
	///
	/// - Parameters:
	///   - lifetimes: lifetimes that will be stored in this storage
	///   - instance: an NSObject where this storage will embed itself
	func embed(lifetimes: [Lifetime], in instance: NSObjectProtocol) {
		assert(self.lifetimes == nil, "Bindings should be set once only")
		self.lifetimes = lifetimes
		guard isInUse else { return }
		
		assert(instance.associatedBinderStorage(subclass: AssociatedBinderStorage.self) == nil, "Bindings should be set once only")
		instance.setAssociatedBinderStorage(self)
	}
	
	/// Explicitly invoke `cancel` on each of the bindings.
	///
	/// WARNING: if `cancel` is invoked outside the main thread, it will be *asynchronously* invoked on the main thread.
	/// Normally, a `cancel` effect is expected to have synchronous effect but it since `cancel` on Binder objects is usually used for breaking reference counted loops, it is considered that the synchronous effect of cancel is less important than avoiding deadlocks â and deadlocks would be easy to accidentally trigger if this were synchronously invoked. If you need synchronous effect, ensure that cancel is invoked on the main thread.
	func cancel() {
		guard Thread.isMainThread else { DispatchQueue.main.async(execute: self.cancel); return }
		
		// `cancel` is mutating so we must use a `for var` (we can't use `forEach`)
		for var l in lifetimes ?? [] {
			l.cancel()
		}
		
		dynamicDelegate?.implementedSelectors = [:]
		dynamicDelegate = nil
	}
	
	deinit {
		cancel()
	}
	
	/// The `dynamicDelegate` is a work-around for the fact that some Cocoa objects change their behavior if you have a delegate that implements a given delegate method. Since Binders will likely implement *all* of their delegate methods, the dynamicDelegate can be used to selectively respond to particular selectors at runtime.
	var dynamicDelegate: DynamicDelegate?
	
	/// An override of the NSObject method so that the dynamicDelegate can work. When the dynamicDelegate states that it can respond to a given selector, that selector is directed to the dynamicDelegate instead. This function will only be involved if Objective-C message sends are sent to the BinderStorage â a rare occurrence outside of deliberate delegate invocations.
	///
	/// - Parameter selector: Objective-C selector that may be implemented by the dynamicDelegate
	/// - Returns: the dynamicDelegate, if it implements the selector
	override func forwardingTarget(for selector: Selector) -&gt; Any? {
		if let dd = dynamicDelegate, let value = dd.implementedSelectors[selector] {
			dd.associatedHandler = value
			return dd
		}
		return nil
	}
	
	/// An override of the NSObject method so that the dynamicDelegate can work.
	///
	/// - Parameter selector: Objective-C selector that may be implemented by the dynamicDelegate
	/// - Returns: true if the dynamicDelegate implements the selector, otherwise returns the super implementation
	override func responds(to selector: Selector) -&gt; Bool {
		if let dd = dynamicDelegate, let value = dd.implementedSelectors[selector] {
			dd.associatedHandler = value
			return true
		}
		return super.responds(to: selector)
	}
}

/// Used in conjunction with `AssociatedBinderStorage`, subclasses of `DynamicDelegate` can implement all delegate methods at compile time but have the `AssociatedBinderStorage` report true to `responds(to:)` only in the cases where the delegate method is selected for enabling.
class DynamicDelegate: NSObject, DefaultConstructable {
	var implementedSelectors = Dictionary&lt;Selector, Any&gt;()
	var associatedHandler: Any?
	
	required override init() {
		super.init()
	}
	
	func handlesSelector(_ selector: Selector) -&gt; Bool {
		return implementedSelectors[selector] != nil
	}
	
	func multiHandler&lt;T&gt;(_ t: T) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T) -&gt; Void]).forEach { f in f(t) }
	}
	
	func multiHandler&lt;T, U&gt;(_ t: T, _ u: U) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U) -&gt; Void]).forEach { f in f(t, u) }
	}
	
	func multiHandler&lt;T, U, V&gt;(_ t: T, _ u: U, _ v: V) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U, V) -&gt; Void]).forEach { f in f(t, u, v) }
	}
	
	func multiHandler&lt;T, U, V, W&gt;(_ t: T, _ u: U, _ v: V, _ w: W) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U, V, W) -&gt; Void]).forEach { f in f(t, u, v, w) }
	}
	
	func multiHandler&lt;T, U, V, W, X&gt;(_ t: T, _ u: U, _ v: V, _ w: W, _ x: X) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U, V, W, X) -&gt; Void]).forEach { f in f(t, u, v, w, x) }
	}
	
	func singleHandler&lt;T, R&gt;(_ t: T) -&gt; R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T) -&gt; R))(t)
	}
	
	func singleHandler&lt;T, U, R&gt;(_ t: T, _ u: U) -&gt; R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U) -&gt; R))(t, u)
	}
	
	func singleHandler&lt;T, U, V, R&gt;(_ t: T, _ u: U, _ v: V) -&gt; R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U, V) -&gt; R))(t, u, v)
	}
	
	func singleHandler&lt;T, U, V, W, R&gt;(_ t: T, _ u: U, _ v: V, _ w: W) -&gt; R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U, V, W) -&gt; R))(t, u, v, w)
	}
	
	func singleHandler&lt;T, U, V, W, X, R&gt;(_ t: T, _ u: U, _ v: V, _ w: W, _ x: X) -&gt; R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U, V, W, X) -&gt; R))(t, u, v, w, x)
	}
	
	func addSingleHandler1&lt;T, R&gt;(_ value: @escaping (T) -&gt; R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addSingleHandler2&lt;T, U, R&gt;(_ value: @escaping (T, U) -&gt; R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addSingleHandler3&lt;T, U, V, R&gt;(_ value: @escaping (T, U, V) -&gt; R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addSingleHandler4&lt;T, U, V, W, R&gt;(_ value: @escaping (T, U, V, W) -&gt; R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addSingleHandler5&lt;T, U, V, W, X, R&gt;(_ value: @escaping (T, U, V, W, X) -&gt; R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	func addMultiHandler1&lt;T&gt;(_ value: @escaping (T) -&gt; Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T) -&gt; Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T) -&gt; Void]
		}
	}
	
	func addMultiHandler2&lt;T, U&gt;(_ value: @escaping (T, U) -&gt; Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U) -&gt; Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U) -&gt; Void]
		}
	}
	
	func addMultiHandler3&lt;T, U, V&gt;(_ value: @escaping (T, U, V) -&gt; Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U, V) -&gt; Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U, V) -&gt; Void]
		}
	}
	
	func addMultiHandler4&lt;T, U, V, W&gt;(_ value: @escaping (T, U, V, W) -&gt; Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U, V, W) -&gt; Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U, V, W) -&gt; Void]
		}
	}
	
	func addMultiHandler5&lt;T, U, V, W, X&gt;(_ value: @escaping (T, U, V, W, X) -&gt; Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U, V, W, X) -&gt; Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U, V, W, X) -&gt; Void]
		}
	}
}

private var associatedBinderStorageKey = NSObject()
extension NSObjectProtocol {
	/// Accessor for any embedded AssociatedBinderStorage on an NSObject. This method is provided for debugging purposes; you should never normally need to access the storage obbject.
	///
	/// - Parameter for: an NSObject
	/// - Returns: the embedded AssociatedBinderStorage (if any)
	func associatedBinderStorage&lt;S: AssociatedBinderStorage&gt;(subclass: S.Type) -&gt; S? {
		return objc_getAssociatedObject(self, &amp;associatedBinderStorageKey) as? S
	}

	/// Accessor for any embedded AssociatedBinderStorage on an NSObject. This method is provided for debugging purposes; you should never normally need to access the storage obbject.
	///
	/// - Parameter newValue: an AssociatedBinderStorage or nil (if clearinging storage)
	func setAssociatedBinderStorage(_ newValue: AssociatedBinderStorage?) {
		objc_setAssociatedObject(self, &amp;associatedBinderStorageKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
	}
}

enum BinderState&lt;Preparer: BinderPreparer&gt; {
	case pending(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding])
	case constructed(Preparer.Output)
	case consumed
}

protocol Binder: class {
	associatedtype Preparer: BinderPreparer
	
	var state: BinderState&lt;Preparer&gt; { get set }
	init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) 
}

extension Binder {
 	typealias Instance = Preparer.Instance
	typealias Parameters = Preparer.Parameters
	typealias Output = Preparer.Output
	
	/// Invokes `consume` on the underlying state. If the state is not `pending`, this will trigger a fatal error. State will be set to `consumed`.
	///
	/// - Returns: the array of `Binding` from the state parameters.
	func consume() -&gt; (type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		guard case .pending(let type, let parameters, let bindings) = state else {
			fatalError("Attempted to consume bindings from already constructed or consumed binder.")
		}
		state = .consumed
		return (type: type, parameters: parameters, bindings: bindings)
	}
}

extension Binder where Preparer.Parameters == Void {
	/// A constructor used when dynamically assembling arrays of bindings
	///
	/// - Parameters:
	///   - bindings: array of bindings
	init(type: Preparer.Instance.Type = Preparer.Instance.self, bindings: [Preparer.Binding]) {
		self.init(type: type, parameters: (), bindings: bindings)
	}

	/// A constructor for a binder.
	///
	/// - Parameters:
	///   - bindings: list of bindings
	init(type: Preparer.Instance.Type = Preparer.Instance.self, _ bindings: Preparer.Binding...) {
		self.init(type: type, parameters: (), bindings: bindings)
	}
}

private extension Binder where Preparer: BinderApplyable {
	var constructed: Preparer.Output? {
		guard case .constructed(let output) = state else { return nil }
		return output
	}
}

extension Binder where Preparer: BinderApplyable {
	func apply(to instance: Preparer.Instance) {
		let (_, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { _ in instance }
		_ = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
	}
}

extension Binder where Preparer: BinderConstructor, Preparer.Instance == Preparer.Output {
	func instance() -&gt; Preparer.Instance {
		if let output = constructed { return output }
		let (type, parameters, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(instance)
		return output
	}

	func instance(parameters: Parameters) -&gt; Preparer.Instance {
		if let output = constructed { return output }
		let (type, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(instance)
		return output
	}
}

extension Binder where Preparer: BinderApplyable, Preparer.Storage == Preparer.Output {
	func wrap(instance: Preparer.Instance) -&gt; Preparer.Output {
		if let output = constructed { return output }
		let (_, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { _ in instance }
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .consumed
		return output
	}
}

extension Binder where Preparer: BinderConstructor, Preparer.Storage == Preparer.Output {
	func construct() -&gt; Preparer.Output {
		let (type, parameters, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(output)
		return output
	}
	
	func construct(parameters: Parameters) -&gt; Preparer.Output {
		let (type, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(output)
		return output
	}
}

/// Preparers usually default construct the `Storage` except in specific cases where the storage needs a reference to the instance.
protocol BinderApplyable: BinderPreparer {
	/// Constructs the `Storage`
	///
	/// - Returns: the storage
	func constructStorage(instance: Instance) -&gt; Storage
	
	/// - Returns: the output, after tying the lifetimes of the instance and storage together
	func combine(lifetimes: [Lifetime], instance: Instance, storage: Storage) -&gt; Output
}

extension BinderApplyable {
	static func bind(_ bindings: [Binding], to source: (_ preparer: Self) -&gt; Instance) -&gt; (Self, Instance, Storage, [Lifetime]) {
		var preparer = Self()
		for b in bindings {
			preparer.prepareBinding(b)
		}
		
		var lifetimes = [Lifetime]()
		let instance = source(preparer)
		let storage = preparer.constructStorage(instance: instance)
		
		preparer.prepareInstance(instance, storage: storage)
		
		for b in bindings {
			lifetimes += preparer.applyBinding(b, instance: instance, storage: storage)
		}
		
		lifetimes += preparer.finalizeInstance(instance, storage: storage)
		
		return (preparer, instance, storage, lifetimes)
	}
}


struct BinderBase: BinderPreparer {
	typealias Instance = Any
	typealias Storage = Any

	enum Binding: BinderBaseBinding {
		case lifetimes(Dynamic&lt;[Lifetime]&gt;)
		case adHocPrepare((Any) -&gt; Void)
		case adHocFinalize((Any) -&gt; Lifetime?)
	}

	var inherited: BinderBase { get { return self } set { } }
	var adHocPrepareClosures: [(Any) -&gt; Void]?
	var adHocFinalizeClosures: [(Any) -&gt; Lifetime?]?

	init() {}
	
	func inheritedBinding(from: BinderBase.Binding) -&gt; BinderBase.Binding? { return nil }
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .adHocPrepare(let x): adHocPrepareClosures = adHocPrepareClosures?.appending(x) ?? [x]
		case .adHocFinalize(let x): adHocFinalizeClosures = adHocFinalizeClosures?.appending(x) ?? [x]
		default: break
		}
	}
	func prepareInstance(_ instance: Instance, storage: Storage) {
		adHocPrepareClosures.map { array in array.forEach { c in c(instance) } }
	}
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .lifetimes(let x):
			switch x {
			case .constant(let lifetimes):
				return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
			case .dynamic(let signal):
				var previous: [Lifetime]?
				return signal.subscribe(context: .main) { next in
					if var previous = previous {
						for i in previous.indices {
							previous[i].cancel()
						}
					}
					if case .success(let next) = next {
						previous = next
					}
				}
			}
		case .adHocPrepare: return nil
		case .adHocFinalize: return nil
		}
	}
	func finalizeInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime? {
		return adHocFinalizeClosures.map { array in AggregateLifetime(lifetimes: array.compactMap { c in c(instance) }) }
	}
	func combine(lifetimes: [Lifetime], instance: Any, storage: Any) -&gt; Any { return () }
}

protocol BinderBaseBinding: Binding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self
	func asBinderBaseBinding() -&gt; BinderBase.Binding?
}
extension BinderBaseBinding where Preparer.Inherited.Binding: BinderBaseBinding {
	func asBinderBaseBinding() -&gt; BinderBase.Binding? {
		return asInheritedBinding()?.asBinderBaseBinding()
	}
}
extension BinderBase.Binding {
	typealias Preparer = BinderBase
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { return nil }
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; BinderBase.Binding { return binding }
}

extension BindingName where Binding: BinderBaseBinding {
	typealias BinderBaseName&lt;V&gt; = BindingName&lt;V, BinderBase.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; BinderBase.Binding) -&gt; BinderBaseName&lt;V&gt; {
		return BinderBaseName&lt;V&gt;(source: source, downcast: Binding.binderBaseBinding)
	}
}
extension BindingName where Binding: BinderBaseBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BinderBaseName&lt;$2&gt; { return .name(BinderBase.Binding.$1) }
	static var lifetimes: BinderBaseName&lt;Dynamic&lt;[Lifetime]&gt;&gt; { return .name(BinderBase.Binding.lifetimes) }

	static var adHocPrepare: BinderBaseName&lt;(Binding.Preparer.Instance) -&gt; Void&gt; {
		return Binding.compositeName(
			value: { f in { (any: Any) -&gt; Void in f(any as! Binding.Preparer.Instance) } },
			binding: BinderBase.Binding.adHocPrepare,
			downcast: Binding.binderBaseBinding
		)
	}

	static var adHocFinalize: BinderBaseName&lt;(Binding.Preparer.Instance) -&gt; Lifetime?&gt; {
		return Binding.compositeName(
			value: { f in { (any: Any) -&gt; Lifetime? in return f(any as! Binding.Preparer.Instance) } },
			binding: BinderBase.Binding.adHocFinalize,
			downcast: Binding.binderBaseBinding
		)
	}
}

protocol BinderDelegateEmbedder: BinderEmbedder where Instance: HasDelegate {
	associatedtype Delegate: DynamicDelegate
	init(delegateClass: Delegate.Type)
	var delegateClass: Delegate.Type { get }
	var dynamicDelegate: Delegate? { get set }
	var delegateIsRequired: Bool { get }
	func prepareDelegate(instance: Instance, storage: Storage)
}

typealias BinderDelegateEmbedderConstructor = BinderDelegateEmbedder &amp; BinderConstructor

protocol HasDelegate: class {
	associatedtype DelegateProtocol
	var delegate: DelegateProtocol? { get set }
}

extension BinderDelegateEmbedder {
	init() {
		self.init(delegateClass: Delegate.self)
	}
	
	var delegateIsRequired: Bool { return dynamicDelegate != nil }
	
	mutating func delegate() -&gt; Delegate {
		if let d = dynamicDelegate {
			return d
		} else {
			let d = delegateClass.init()
			dynamicDelegate = d
			return d
		}
	}
}

extension BinderDelegateEmbedder where Delegate: DynamicDelegate {
	func prepareDelegate(instance: Instance, storage: Storage) {
		if delegateIsRequired {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			if dynamicDelegate != nil {
				storage.dynamicDelegate = dynamicDelegate
			}
			instance.delegate = (storage as! Instance.DelegateProtocol)
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
	}
}

protocol BinderDelegateDerived: BinderEmbedderConstructor where Inherited: BinderDelegateEmbedderConstructor {
	init(delegateClass: Inherited.Delegate.Type)
}

extension BinderDelegateDerived {
	typealias Delegate = Inherited.Delegate
	init() {
		self.init(delegateClass: Inherited.Delegate.self)
	}
	var dynamicDelegate: Inherited.Delegate? {
		get { return inherited.dynamicDelegate }
		set { inherited.dynamicDelegate = newValue }
	}
}

/// Preparers usually construct the `Instance` from a subclass type except in specific cases where additional non-binding parameters are required for instance construction.
protocol BinderConstructor: BinderApplyable {
	/// Constructs the `Instance`
	///
	/// - Parameter subclass: subclass of the instance type to use for construction
	/// - Returns: the instance
	func constructInstance(type: Instance.Type, parameters: Parameters) -&gt; Instance
}

extension BinderConstructor where Instance: DefaultConstructable {
	func constructInstance(type: Instance.Type, parameters: Parameters) -&gt; Instance {
		return type.init()
	}
}

/// All NSObject instances can use AssociatedBinderStorage which embeds lifetimes in the Objective-C associated object storage.
protocol BinderEmbedder: BinderApplyable where Instance: NSObjectProtocol, Storage: AssociatedBinderStorage, Output == Instance {}
extension BinderEmbedder {
	func combine(lifetimes: [Lifetime], instance: Instance, storage: Storage) -&gt; Output {
		storage.embed(lifetimes: lifetimes, in: instance)
		return instance
	}
}

/// A `BinderEmbedderConstructor` is the standard configuration for a constructable NSObject.
typealias BinderEmbedderConstructor = BinderEmbedder &amp; BinderConstructor

protocol DefaultConstructable {
	init()
}

/// A preparer interprets a set of bindings and applies them to an instance.
protocol BinderPreparer: DefaultConstructable {
	associatedtype Instance
	associatedtype Output = Instance
	associatedtype Parameters = Void
	associatedtype Binding
	associatedtype Storage
	associatedtype Inherited: BinderPreparer

	var inherited: Inherited { get set }
	
	func inheritedBinding(from: Binding) -&gt; Inherited.Binding?
	
	/// A first scan of the bindings. Information about bindings present may be recorded during this time.
	///
	/// NOTE: you don't need to process all bindings at your own level but you should pass inherited bindings through
	/// to the inherited preparer (unless you're handling it at your own level)
	///
	/// - Parameter binding: the binding to apply
	mutating func prepareBinding(_ binding: Binding)
	
	/// Bindings which need to be applied before others can be applied at this special early stage
	///
	/// NOTE: the first step should be to call `inheritedPrepareInstance`. `BinderDelegate` should call `prepareDelegate`
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	func prepareInstance(_ instance: Instance, storage: Storage)
	
	/// Apply typical bindings.
	///
	/// NOTE: you should process all bindings and pass inherited bindings through to the inherited preparer
	///
	/// - Parameters:
	///   - binding: the binding to apply
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`.
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime?
	
	/// Bindings which need to be applied after others can be applied at this last stage.
	///
	/// NOTE: the last step should be to call `inheritedFinalizedInstance`
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`
	func finalizeInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime?
}

extension BinderPreparer {
	mutating func inheritedPrepareBinding(_ binding: Binding) {
		guard let ls = inheritedBinding(from: binding) else { return }
		inherited.prepareBinding(ls)
	}

	mutating func prepareBinding(_ binding: Binding) {
		inheritedPrepareBinding(binding)
	}
	
	func inheritedPrepareInstance(_ instance: Instance, storage: Storage) {
		guard let i = instance as? Inherited.Instance, let s = storage as? Inherited.Storage else { return }
		inherited.prepareInstance(i, storage: s)
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
	}
	
	func inheritedApplyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		guard let ls = inheritedBinding(from: binding), let i = instance as? Inherited.Instance, let s = storage as? Inherited.Storage else { return nil }
		return inherited.applyBinding(ls, instance: i, storage: s)
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		return inheritedApplyBinding(binding, instance: instance, storage: storage)
	}
	
	func inheritedFinalizedInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime? {
		guard let i = instance as? Inherited.Instance, let s = storage as? Inherited.Storage else { return nil }
		return inherited.finalizeInstance(i, storage: s)
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime? {
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

import Foundation

protocol Binding {
	associatedtype Preparer: BinderPreparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding?
}

extension Binding {
	typealias Name&lt;V&gt; = BindingName&lt;V, Self, Self&gt;
	
	static func compositeName&lt;Value, Param, Intermediate&gt;(value: @escaping (Value) -&gt; Param, binding: @escaping (Param) -&gt; Intermediate, downcast: @escaping (Intermediate) -&gt; Self) -&gt; BindingName&lt;Value, Intermediate, Self&gt; {
		return BindingName&lt;Value, Intermediate, Self&gt;(
			source: { v in binding(value(v)) },
			downcast: downcast
		)
	}
	
	static func keyPathActionName&lt;Instance, Value, Intermediate&gt;(_ keyPath: KeyPath&lt;Instance, Value&gt;, _ binding: @escaping (TargetAction) -&gt; Intermediate, _ downcast: @escaping (Intermediate) -&gt; Self) -&gt; BindingName&lt;SignalInput&lt;Value&gt;, Intermediate, Self&gt; {
		return compositeName(
			value: { input in
				TargetAction.singleTarget(
					Input&lt;Any?&gt;().map { v in (v as! Instance)[keyPath: keyPath] }.bind(to: input)
				)
			},
			binding: binding,
			downcast: downcast
		)
	}
	
	static func mappedInputName&lt;Value, Mapped, Intermediate&gt;(map: @escaping (Value) -&gt; Mapped, binding: @escaping (SignalInput&lt;Value&gt;) -&gt; Intermediate, downcast: @escaping (Intermediate) -&gt; Self) -&gt; BindingName&lt;SignalInput&lt;Mapped&gt;, Intermediate, Self&gt; {
		return compositeName(
			value: { Input&lt;Value&gt;().map(map).bind(to: $0) },
			binding: binding,
			downcast: downcast
		)
	}
	
	static func mappedWrappedInputName&lt;Value, Mapped, Param, Intermediate&gt;(map: @escaping (Value) -&gt; Mapped, wrap: @escaping (SignalInput&lt;Value&gt;) -&gt; Param, binding: @escaping (Param) -&gt; Intermediate, downcast: @escaping (Intermediate) -&gt; Self) -&gt; BindingName&lt;SignalInput&lt;Mapped&gt;, Intermediate, Self&gt; {
		return compositeName(
			value: { wrap(Input&lt;Value&gt;().map(map).bind(to: $0)) },
			binding: binding,
			downcast: downcast
		)
	}
}

infix operator --: AssignmentPrecedence
infix operator &lt;--: AssignmentPrecedence
infix operator --&gt;: AssignmentPrecedence

struct BindingName&lt;Value, Source, Binding&gt; {
	var source: (Value) -&gt; Source
	var downcast: (Source) -&gt; Binding
	init(source: @escaping (Value) -&gt; Source, downcast: @escaping (Source) -&gt; Binding) {
		self.source = source
		self.downcast = downcast
	}
	func binding(with value: Value) -&gt; Binding {
		return downcast(source(value))
	}
}

extension BindingName {
	/// Build a signal binding (invocations on the instance after construction) from a name and a signal
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func &lt;--&lt;Interface: SignalInterface&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: Interface) -&gt; Binding where Signal&lt;Interface.OutputValue&gt; == Value {
		return name.binding(with: value.signal)
	}

	/// Build a value binding (property changes on the instance) from a name and a signal (values over time)
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func &lt;--&lt;Interface: SignalInterface&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: Interface) -&gt; Binding where Dynamic&lt;Interface.OutputValue&gt; == Value {
		return name.binding(with: Dynamic&lt;Interface.OutputValue&gt;.dynamic(value.signal))
	}

	/// Build an action binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&gt;&lt;InputInterface: SignalInputInterface&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: InputInterface) -&gt; Binding where SignalInput&lt;InputInterface.InputValue&gt; == Value {
		return name.binding(with: value.input)
	}

	/// Build a static binding (construction-only property) from a name and a constant value
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&lt;A&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: A) -&gt; Binding where Constant&lt;A&gt; == Value {
		return name.binding(with: Value.constant(value))
	}
	
	/// Build a value binding (property changes on the instance) from a name and a constant value
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&lt;A&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: A) -&gt; Binding where Dynamic&lt;A&gt; == Value {
		return name.binding(with: Dynamic&lt;A&gt;.constant(value))
	}

	/// Build a delegate binding (synchronous callback) from a name and function with no parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&lt;R&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: @escaping () -&gt; R) -&gt; Binding where Value == () -&gt; R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with one parameter
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&lt;A, R&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: @escaping (A) -&gt; R) -&gt; Binding where Value == (A) -&gt; R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with two parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&lt;A, B, R&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: @escaping (A, B) -&gt; R) -&gt; Binding where Value == (A, B) -&gt; R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with three parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&lt;A, B, C, R&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: @escaping (A, B, C) -&gt; R) -&gt; Binding where Value == (A, B, C) -&gt; R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with four parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&lt;A, B, C, D, R&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: @escaping (A, B, C, D) -&gt; R) -&gt; Binding where Value == (A, B, C, D) -&gt; R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with five parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&lt;A, B, C, D, E, R&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: @escaping (A, B, C, D, E) -&gt; R) -&gt; Binding where Value == (A, B, C, D, E) -&gt; R {
		return name.binding(with: value)
	}
}

extension BindingName where Value == TargetAction {
	/// Build an `TargetAction` binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&gt;&lt;InputInterface: SignalInputInterface&gt;(name: BindingName&lt;TargetAction, Source, Binding&gt;, value: InputInterface) -&gt; Binding where InputInterface.InputValue == Any? {
		return name.binding(with: .singleTarget(value.input))
	}
	
	/// Build a first-responder `TargetAction` binding (callbacks triggered by the instance) from a name and a selector.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --&gt;(name: BindingName&lt;TargetAction, Source, Binding&gt;, value: Selector) -&gt; Binding {
		return name.binding(with: TargetAction.firstResponder(value))
	}
}

/// A simple wrapper around a value used to identify "static" bindings (bindings which are applied only at construction time)
struct Constant&lt;Value&gt; {
	typealias ValueType = Value
	let value: Value
	init(_ value: Value) {
		self.value = value
	}
	static func constant(_ value: Value) -&gt; Constant&lt;Value&gt; {
		return Constant&lt;Value&gt;(value)
	}
}


/// An either type for a value or a signal emitting values of that type. Used for "value" bindings (bindings which set a property on the underlying instance)
enum Dynamic&lt;Value&gt; {
	typealias ValueType = Value
	case constant(Value)
	case dynamic(Signal&lt;Value&gt;)
	
	/// Gets the initial (i.e. used in the constructor) value from the `Dynamic`
	func initialSubsequent() -&gt; InitialSubsequent&lt;Value&gt; {
		switch self {
		case .constant(let v):
			return InitialSubsequent&lt;Value&gt;(initial: v)
		case .dynamic(let signal):
			let sc = signal.capture()
			return InitialSubsequent&lt;Value&gt;(initial: sc.values.last, subsequent: sc)
		}
	}
	
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	func apply&lt;I: AnyObject, B: AnyObject&gt;(_ instance: I, _ storage: B, _ onError: Value? = nil, handler: @escaping (I, B, Value) -&gt; Void) -&gt; Lifetime? {
		switch self {
		case .constant(let v):
			handler(instance, storage, v)
			return nil
		case .dynamic(let signal):
			return signal.apply(instance, storage, onError, handler: handler)
		}
	}
	
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	func apply&lt;I: AnyObject&gt;(_ instance: I, handler: @escaping (I, Value) -&gt; Void) -&gt; Lifetime? {
		switch self {
		case .constant(let v):
			handler(instance, v)
			return nil
		case .dynamic(let signal):
			return signal.apply(instance, handler: handler)
		}
	}
}

extension Signal {
	func apply&lt;I: AnyObject, B: AnyObject&gt;(_ instance: I, _ storage: B, _ onError: OutputValue? = nil, handler: @escaping (I, B, OutputValue) -&gt; Void) -&gt; Lifetime? {
		return signal.subscribe(context: .main) { [unowned instance, unowned storage] r in
			switch (r, onError) {
			case (.success(let v), _): handler(instance, storage, v)
			case (.failure, .some(let v)): handler(instance, storage, v)
			case (.failure, .none): break
			}
		}
	}

	func apply&lt;I: AnyObject&gt;(_ instance: I, handler: @escaping (I, OutputValue) -&gt; Void) -&gt; Lifetime? {
		return signal.subscribeValues(context: .main) { [unowned instance] v in handler(instance, v) }
	}
}

struct InitialSubsequent&lt;Value&gt; {
	let initial: Value?
	let subsequent: SignalCapture&lt;Value&gt;?
	
	init&lt;Interface: SignalInterface&gt;(signal: Interface) where Interface.OutputValue == Value {
		let capture = signal.capture()
		let values = capture.values
		self.init(initial: values.last, subsequent: capture)
	}
	
	init(initial: Value? = nil, subsequent: SignalCapture&lt;Value&gt;? = nil) {
		self.initial = initial
		self.subsequent = subsequent
	}
	
	func resume() -&gt; Signal&lt;Value&gt;? {
		return subsequent?.resume()
	}
	
	func apply&lt;I: AnyObject&gt;(_ instance: I, handler: @escaping (I, Value) -&gt; Void) -&gt; Lifetime? {
		return resume().flatMap { $0.apply(instance, handler: handler) }
	}
	
	func apply&lt;I: AnyObject, Storage: AnyObject&gt;(_ instance: I, _ storage: Storage, handler: @escaping (I, Storage, Value) -&gt; Void) -&gt; Lifetime? {
		return resume().flatMap { $0.apply(instance, storage, handler: handler) }
	}
}

import Foundation

struct ScopedValues&lt;Scope, Value&gt;: ExpressibleByArrayLiteral {
	typealias ArrayLiteralElement = ScopedValues&lt;Scope, Value&gt;

	let pairs: [(scope: Scope, value: Value)]
	
	init(arrayLiteral elements: ScopedValues&lt;Scope, Value&gt;...) {
		self.pairs = elements.flatMap { $0.pairs }
	}
	
	init(pairs: [(Scope, Value)]) {
		self.pairs = pairs
	}
	
	init(scope: Scope, value: Value) {
		self.pairs = [(scope, value)]
	}
	
	static func value(_ value: Value, for scope: Scope) -&gt; ScopedValues&lt;Scope, Value&gt; {
		return ScopedValues(scope: scope, value: value)
	}
}

extension Dynamic {
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	func apply&lt;I: AnyObject, Scope, V&gt;(instance: I, removeOld: @escaping (I, Scope, V) -&gt; Void, applyNew: @escaping (I, Scope, V) -&gt; Void) -&gt; Lifetime? where ScopedValues&lt;Scope, V&gt; == Value {
		var previous: ScopedValues&lt;Scope, V&gt;? = nil
		return apply(instance) { i, v in
			for (scope, value) in previous?.pairs ?? [] {
				removeOld(instance, scope, value)
			}
			previous = v
			for (scope, value) in v.pairs {
				applyNew(instance, scope, value)
			}
		}
	}
}

struct Callback&lt;Value, CallbackValue&gt; {
	let value: Value
	let callback: SignalInput&lt;CallbackValue&gt;
	
	init(_ value: Value, _ callback: SignalInput&lt;CallbackValue&gt;) {
		self.value = value
		self.callback = callback
	}
}

extension SignalInterface {
	func callbackBind&lt;CallbackInputInterface: SignalInputInterface&gt;(to callback: CallbackInputInterface) -&gt; Signal&lt;Callback&lt;OutputValue, CallbackInputInterface.InputValue&gt;&gt; {
		return map { value in Callback(value, callback.input) }
	}

	func ignoreCallback&lt;CallbackValue&gt;() -&gt; Signal&lt;Callback&lt;OutputValue, CallbackValue&gt;&gt; {
		let (i, _) = Signal&lt;CallbackValue&gt;.create()
		return map { value in Callback(value, i) }
	}
}

/// This type encapsulates the idea that target-action pairs in Cocoa may target a specific object (by setting the target to non-nil) or may let the responder chain search for a responder that handles a specific selector.
enum TargetAction {
	case firstResponder(Selector)
	case singleTarget(SignalInput&lt;Any?&gt;)
}

protocol TargetActionSender: class {
	var action: Selector? { get set }
	var target: AnyObject? { get set }
}

extension TargetAction {
	func apply&lt;Source: TargetActionSender&gt;(to instance: Source, constructTarget: () -&gt; SignalActionTarget, selector: Selector = SignalActionTarget.selector) -&gt; Lifetime? {
		switch self {
		case .firstResponder(let s):
			instance.target = nil
			instance.action = s
			return nil
		case .singleTarget(let s):
			let target = constructTarget()
			instance.target = target
			instance.action = SignalActionTarget.selector
			return target.signal.cancellableBind(to: s)
		}
	}
}

/// This enum is intended to be embedded in an ArrayMutation&lt;Element&gt;. The ArrayMutation&lt;Element&gt; combines an IndexSet with this enum. This enum specifies what actions should be taken at the locations specified by the IndexSet.
///
/// 
enum IndexedMutationKind {
	/// The values at the locations specified by the IndexSet should be deleted.
	/// NOTE: the IndexSet specifies the indexes *before* deletion (and must therefore be applied in reverse).
	case delete

	/// The associated Array&lt;Element&gt; contains values that should be inserted such that they have the indexes specified in IndexSet. The Array&lt;Element&gt; and IndexSet must have identical counts.
	/// NOTE: the IndexSet specifies the indexes *after* insertion (and must therefore be applied in forward order).
	case insert

	/// Elements are deleted from one end and inserted onto the other. If `Int` is positive, values are deleted from the `startIndex` end and inserted at the `endIndex` end, if `Int` is negative, value are deleted from the `endIndex` end and inserted at the `startIndex`end.
	/// The magnitude of `Int` specifies the number of deleted rows and the sign specified the end.
	/// The Array&lt;Element&gt; contains values that should be inserted at the other end of the collection.
	/// The IndexSet contains the indexes of any revealed (scrolled into view) rows
	case scroll(Int)

	/// The associated Array&lt;Element&gt; contains updated values at locations specified by the IndexSet. Semantically, the item should be modelled as updated but not replaced. The Array&lt;Element&gt; and IndexSet must have identical counts.
	// In many cases, update and replace are the same. The only differences relate to scenarios where the items are considered to have "identity". An update *retains* the previous identity whereas a replace *discards* any previous identity.
	case update
	
	/// The values at the locations specified by the IndexSet should be removed from their locations and spliced back in at the location specified by the associated Int index. For scrolled subranges, items may not be moved from outside or to outside the visible range (items moved from outside the visible range must be inserted and items moved outside the visible range must be deleted)
	/// NOTE: the IndexSet specifies the indexes *before* removal (and must therefore be applied in reverse) and the Int index specifies an index *after* removal.
	case move(Int)

	/// Equivalent to a Deletion of all previous indexes and an Insertion of the new values. The associated Array&lt;Element&gt; contains the new state of the array. All previous values should be discarded and the entire array replaced with this new version. The Array&lt;Element&gt; and IndexSet must have identical counts.
	/// NOTE: the IndexSet specifies the indexes *after* insertion (and must therefore be applied in forward order).
	case reload
}

/// An `ArrayMutation` communicates changes to an array in one context so that another array, mirroring its contents in another context, can mimic the same changes.
/// Subscribing to a stream of `ArrayMutation`s is sufficient to communication the complete state and animatable transitions of an array between to parts of a program.
/// In most cases, the source and destination will need to keep their own complete copy of the array to correctly calculate the effect of the mutation.
struct IndexedMutation&lt;Element, Metadata&gt;: ExpressibleByArrayLiteral {
	/// Determines the meaning of this `ArrayMutation`
	let kind: IndexedMutationKind

	/// The metadats type is typically `Void` for plain array mutations since application of an indexed mutation to an array leaves no storage for metadata.
	/// Subrange and tree mutations use the metadata for subrange details and "leaf" data but require specialized storage structures to receive that data. The semantics of the metadata is specific to the respective `apply` functions.
	/// NOTE: Any non-nil metadata is typically set buy the mutation but a metadata value of `nil` doesn't clear the metadata, it usually just has no effect. The exception is `.reload` operations which function like re-creating the storage and explicitly set the value in all cases.
	let metadata: Metadata?
	
	/// The meaning of the indexSet is dependent on the `kind` â it may contain indexes in the array that will be deleted by this mutation or it may contain indexes that new entries will occupy after application of this mutation.
	let indexSet: IndexSet
	
	/// New values that will be inserted at locations determined by the `kind` and the `indexSet`.
	let values: Array&lt;Element&gt;
	
	/// Construct from components.
	init(kind: IndexedMutationKind, metadata: Metadata?, indexSet: IndexSet, values: Array&lt;Element&gt;) {
		self.kind = kind
		self.metadata = metadata
		self.indexSet = indexSet
		self.values = values
	}
}

extension IndexedMutation {
	/// Construct an empty array mutation that represents a no-op.
	init() {
		self.init(kind: .update, metadata: nil, indexSet: IndexSet(), values: [])
	}
	
	/// A .reload mutation can be constructed from an array literal (since it is equivalent to an array assignment).
	init(arrayLiteral elements: Element...) {
		self.init(kind: .reload, metadata: nil, indexSet: IndexSet(integersIn: elements.indices), values: elements)
	}

	/// Construct a mutation that discards any previous history and simply starts with a completely new array.
	init(metadata: Metadata? = nil, reload values: Array&lt;Element&gt;) {
		self.init(kind: .reload, metadata: metadata, indexSet: IndexSet(integersIn: values.indices), values: values)
	}

	/// Construct a mutation that represents a metadata-only change.
	init(metadata: Metadata) {
		self.init(kind: .update, metadata: metadata, indexSet: IndexSet(), values: [])
	}

	/// Construct a mutation that represents the deletion of the values at a set of indices.
	init(metadata: Metadata? = nil, deletedIndexSet: IndexSet) {
		self.init(kind: .delete, metadata: metadata, indexSet: deletedIndexSet, values: [])
	}
	
	/// Construct a mutation that represents advancing the visible window through a larger array.
	init(metadata: Metadata? = nil, scrollForwardRevealing indexSet: IndexSet, values: Array&lt;Element&gt;) {
		precondition(indexSet.count == values.count)
		self.init(kind: .scroll(indexSet.count), metadata: metadata, indexSet: indexSet, values: values)
	}
	
	/// Construct a mutation that represents retreating the visible window through a larger array.
	init(metadata: Metadata? = nil, scrollBackwardRevealing indexSet: IndexSet, values: Array&lt;Element&gt;) {
		precondition(indexSet.count == values.count)
		self.init(kind: .scroll(-indexSet.count), metadata: metadata, indexSet: indexSet, values: values)
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init(metadata: Metadata? = nil, insertedIndexSet: IndexSet, values: Array&lt;Element&gt;) {
		precondition(insertedIndexSet.count == values.count)
		self.init(kind: .insert, metadata: metadata, indexSet: insertedIndexSet, values: values)
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init(metadata: Metadata? = nil, updatedIndexSet: IndexSet, values: Array&lt;Element&gt;) {
		precondition(updatedIndexSet.count == values.count)
		self.init(kind: .update, metadata: metadata, indexSet: updatedIndexSet, values: values)
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init(metadata: Metadata? = nil, movedIndexSet: IndexSet, targetIndex: Int) {
		self.init(kind: .move(targetIndex), metadata: metadata, indexSet: movedIndexSet, values: [])
	}
	

	/// Convenience constructor for deleting a single element
	static func deleted(at index: Int) -&gt; IndexedMutation&lt;Element, Metadata&gt; {
		return IndexedMutation&lt;Element, Metadata&gt;(deletedIndexSet: IndexSet(integer: index))
	}
	
	/// Convenience constructor for inserting a single element
	static func inserted(_ value: Element, at index: Int) -&gt; IndexedMutation&lt;Element, Metadata&gt; {
		return IndexedMutation&lt;Element, Metadata&gt;(insertedIndexSet: IndexSet(integer: index), values: [value])
	}
	
	/// Convenience constructor for inserting a single element
	static func updated(_ value: Element, at index: Int) -&gt; IndexedMutation&lt;Element, Metadata&gt; {
		return IndexedMutation&lt;Element, Metadata&gt;(updatedIndexSet: IndexSet(integer: index), values: [value])
	}
	
	/// Convenience constructor for inserting a single element
	static func moved(from oldIndex: Int, to newIndex: Int) -&gt; IndexedMutation&lt;Element, Metadata&gt; {
		return IndexedMutation&lt;Element, Metadata&gt;(movedIndexSet: IndexSet(integer: oldIndex), targetIndex: newIndex)
	}
	
	/// Convenience constructor for reloading
	static func reload(metadata: Metadata? = nil, _ values: [Element]) -&gt; IndexedMutation&lt;Element, Metadata&gt; {
		return IndexedMutation&lt;Element, Metadata&gt;(reload: values)
	}
	
	/// Creates a new IndexedMutation by mapping the values array from this transform. NOTE: metdata is passed through unchanged.
	func mapValues&lt;Other&gt;(_ transform: (Element) -&gt; Other) -&gt; IndexedMutation&lt;Other, Metadata&gt; {
		return IndexedMutation&lt;Other, Metadata&gt;(kind: kind, metadata: metadata, indexSet: indexSet, values: values.map(transform))
	}
	
	/// Creates a new IndexedMutation by mapping the values array from this transform. NOTE: metdata is passed through unchanged.
	func mapMetadata&lt;Alternate&gt;(_ transform: (Metadata) -&gt; Alternate) -&gt; IndexedMutation&lt;Element, Alternate&gt; {
		return IndexedMutation&lt;Element, Alternate&gt;(kind: kind, metadata: metadata.map(transform), indexSet: indexSet, values: values)
	}
	
	/// Given a previous row count, returns the new row count after this mutation
	///
	/// - Parameter rowCount: old number of rows
	func delta(_ rowCount: inout Int) {
		switch kind {
		case .reload: rowCount = values.count
		case .delete: rowCount -= indexSet.count
		case .scroll(let offset): rowCount += values.count - (offset &gt; 0 ? offset : -offset)
		case .insert: rowCount += values.count
		case .move: return
		case .update: return
		}
	}
	
	/// A no-op on rows is explicitly defined as an `.update` with an empty `values` array. Note that metadata may still be non-nil.
	var hasNoEffectOnValues: Bool {
		if case .update = kind, values.count == 0 {
			return true
		}
		return false
	}
	
	func insertionsAndRemovals(length: Int, insert: (Int, Element) -&gt; Void, remove: (Int) -&gt; Void) {
		switch kind {
		case .delete:
			indexSet.reversed().forEach { remove($0) }
		case .scroll(let offset):
			if offset &gt; 0 {
				(0..&lt;offset).forEach { remove($0) }
				values.enumerated().forEach { insert(length - offset + $0.offset, $0.element) }
			} else {
				((length + offset)..&lt;length).forEach { remove($0) }
				values.enumerated().forEach { insert($0.offset, $0.element) }
			}
		case .move(let index):
			indexSet.forEach { remove($0) }
			values.enumerated().forEach { insert(index + $0.offset, $0.element) }
		case .insert:
			for (i, v) in zip(indexSet, values) {
				insert(i, v)
			}
		case .update:
			indexSet.forEach { remove($0) }
			for (i, v) in zip(indexSet, values) {
				insert(i, v)
			}
		case .reload:
			(0..&lt;length).reversed().forEach { remove($0) }
			values.enumerated().forEach { insert($0.offset, $0.element) }
		}
	}
}

typealias ArrayMutation&lt;Element&gt; = IndexedMutation&lt;Element, Void&gt;

extension IndexedMutation where Metadata == Void {
	/// Apply the mutation described by this value to the provided array
	func apply&lt;C: RangeReplaceableCollection &amp; MutableCollection&gt;(to a: inout C) where C.Index == Int, C.Iterator.Element == Element {
		switch kind {
		case .delete:
			indexSet.rangeView.reversed().forEach { a.removeSubrange($0) }
		case .scroll(let offset):
			a.removeSubrange(offset &gt; 0 ? a.startIndex..&lt;offset : (a.endIndex + offset)..&lt;a.endIndex)
			a.insert(contentsOf: values, at: offset &gt; 0 ? a.endIndex : a.startIndex)
		case .move(let index):
			let moving = indexSet.map { a[$0] }
			indexSet.rangeView.reversed().forEach { a.removeSubrange($0) }
			a.insert(contentsOf: moving, at: index)
		case .insert:
			for (i, v) in zip(indexSet, values) {
				a.insert(v, at: i)
			}
		case .update:
			var progress = 0
			indexSet.rangeView.forEach { r in
				a.replaceSubrange(r, with: values[progress..&lt;(progress + r.count)])
				progress += r.count
			}
		case .reload:
			a.replaceSubrange(a.startIndex..&lt;a.endIndex, with: values)
		}
	}
}

import Foundation

enum SetMutationKind {
	case delete
	case insert
	case update
	case reload
}

struct SetMutation&lt;Element&gt; {
	let kind: SetMutationKind
	let values: Array&lt;Element&gt;
	
	init(kind: SetMutationKind, values: Array&lt;Element&gt;) {
		self.kind = kind
		self.values = values
	}
	
	static func delete(_ values: Array&lt;Element&gt;) -&gt; SetMutation&lt;Element&gt; {
		return SetMutation(kind: .delete, values: values)
	}
	
	static func insert(_ values: Array&lt;Element&gt;) -&gt; SetMutation&lt;Element&gt; {
		return SetMutation(kind: .insert, values: values)
	}
	
	static func update(_ values: Array&lt;Element&gt;) -&gt; SetMutation&lt;Element&gt; {
		return SetMutation(kind: .update, values: values)
	}
	
	static func reload(_ values: Array&lt;Element&gt;) -&gt; SetMutation&lt;Element&gt; {
		return SetMutation(kind: .reload, values: values)
	}
	
	func apply(to array: inout Array&lt;Element&gt;, equate: @escaping (Element, Element) -&gt; Bool, compare: @escaping (Element, Element) -&gt; Bool) -&gt; [ArrayMutation&lt;Element&gt;] {
		switch kind {
		case .delete:
			var sorted = values.sorted(by: compare)
			var oldIndices = IndexSet()
			var arrayIndex = 0
			var sortedIndex = 0
			while arrayIndex &lt; array.count &amp;&amp; sortedIndex &lt; sorted.count {
				if !equate(array[arrayIndex], sorted[sortedIndex]) {
					arrayIndex += 1
				} else {
					oldIndices.insert(arrayIndex)
					sortedIndex += 1
					arrayIndex += 1
				}
			}
			precondition(sortedIndex == sorted.count, "Unable to find deleted items.")
			oldIndices.reversed().forEach { array.remove(at: $0) }
			return [ArrayMutation&lt;Element&gt;(deletedIndexSet: oldIndices)]
		case .insert:
			var sorted = values.sorted(by: compare)
			var newIndices = IndexSet()
			var arrayIndex = 0
			var sortedIndex = 0
			while arrayIndex &lt; array.count &amp;&amp; sortedIndex &lt; sorted.count {
				if compare(array[arrayIndex], sorted[sortedIndex]) {
					arrayIndex += 1
				} else {
					newIndices.insert(arrayIndex)
					array.insert(sorted[sortedIndex], at: arrayIndex)
					sortedIndex += 1
					arrayIndex += 1
				}
			}
			while sortedIndex &lt; sorted.count {
				newIndices.insert(arrayIndex)
				array.insert(sorted[sortedIndex], at: arrayIndex)
				sortedIndex += 1
				arrayIndex += 1
			}
			return [ArrayMutation&lt;Element&gt;(insertedIndexSet: newIndices, values: sorted)]
		case .update:
			// It would be nice if this was better than n squared complexity and aggregated the updates, rather than issueing updates for individual rows.
			var result = Array&lt;ArrayMutation&lt;Element&gt;&gt;()
			for v in values {
				let oldIndex = array.firstIndex { u in equate(v, u) }!
				array.remove(at: oldIndex)
				let newIndex = array.firstIndex { u in compare(v, u) } ?? array.count
				array.insert(v, at: newIndex)
				if newIndex == oldIndex {
					result.append(.updated(v, at: oldIndex))
				} else {
					// This ordering (moved, then updated) is required to make UITableView animations work correctly.
					result.append(.moved(from: oldIndex, to: newIndex))
					result.append(.updated(v, at: newIndex))
				}
			}
			return result
		case .reload:
			array = values.sorted(by: compare)
			return [ArrayMutation&lt;Element&gt;(reload: array)]
		}
	}
}

extension SignalInterface {
	func sortedArrayMutation&lt;Element&gt;(equate: @escaping (Element, Element) -&gt; Bool, compare: @escaping (Element, Element) -&gt; Bool) -&gt; Signal&lt;ArrayMutation&lt;Element&gt;&gt; where SetMutation&lt;Element&gt; == OutputValue {
		return transform(initialState: Array&lt;Element&gt;()) { (array: inout Array&lt;Element&gt;, result: Signal&lt;SetMutation&lt;Element&gt;&gt;.Result) in
			switch result {
			case .success(let m): return .values(sequence: m.apply(to: &amp;array, equate: equate, compare: compare))
			case .failure(let e): return .end(e)
			}
		}
	}
}

enum StackMutation&lt;Value&gt;: ExpressibleByArrayLiteral {
	init(arrayLiteral elements: Value...) {
		self = .reload(elements)
	}
	
	typealias ArrayLiteralElement = Value
	
	case push(Value)
	case pop
	case popToCount(Int)
	case reload([Value])
	
	func apply(to stack: inout Array&lt;Value&gt;) {
		switch self {
		case .push(let v): stack.append(v)
		case .pop: stack.removeLast()
		case .popToCount(let c): stack.removeLast(stack.count - c)
		case .reload(let newStack): stack = newStack
		}
	}
}

extension SignalInterface {
	func stackMap&lt;A, B&gt;(_ transform: @escaping (A) -&gt; B) -&gt; Signal&lt;StackMutation&lt;B&gt;&gt; where OutputValue == StackMutation&lt;A&gt; {
		return map { m in
			switch m {
				case .push(let a): return StackMutation&lt;B&gt;.push(transform(a))
				case .pop: return StackMutation&lt;B&gt;.pop
				case .popToCount(let i): return StackMutation&lt;B&gt;.popToCount(i)
				case .reload(let array): return StackMutation&lt;B&gt;.reload(array.map { transform($0) })
			}
		}
	}
}

/// When used as the `Metadata` parameter to an `IndexedMutation`, then the indexed mutation can represent a locally visible subrange within a larger global array.
/// NOTE: when `nil` the following behaviors are implied for each IndexedMutation kind:
///	- reload: the localOffset is 0 and the globalCount is the reload count
///   - delete: the globalCount is reduced by the deletion count 
///   - insert: the globalCount is increased by the insertion count 
///   - scroll: the localOffset is changed by the scroll count
///   - update: neither localOffset nor globalCount are changed
///   - move: neither localOffset nor globalCount are changed
struct Subrange&lt;Leaf&gt; {
	/// This is offset for the visible range. When not provided, the `localOffset` is automatically updated by `.scroll` and reset to `0` on `.reload`.
	/// NOTE: `localOffset` doesn't affect the `IndexedMutation` itself (since the mutation operates entirely in local coordinates) but for animation purposes (which typically needs to occur in global coordinates), the `localOffset` is considered to apply *before* the animation (e.g. the scroll position shifts first, then the values in the new locations are updated).
	let localOffset: Int?
	
	/// This is the length of the greater array after the mutation is applied. When not provided, the `globalCount` is automatically updated by `.insert`, `.delete` and reset to the local count on `.reload`.
	let globalCount: Int?
	
	/// Additional metadata for this tier
	let leaf: Leaf?
	
	init(localOffset: Int?, globalCount: Int?, leaf: Leaf?) {
		self.localOffset = localOffset
		self.globalCount = globalCount
		self.leaf = leaf
	}
}

/// A data type that can be used to cache the destination end of a `Subrange&lt;Leaf&gt;` change stream.
struct SubrangeState&lt;Element, Leaf&gt; {
	var values: Deque&lt;Element&gt;?
	var localOffset: Int = 0
	var globalCount: Int = 0
	var leaf: Leaf?

	init(values: Deque&lt;Element&gt;? = nil, localOffset: Int = 0, globalCount: Int? = nil, leaf: Leaf? = nil) {
		self.values = values
		self.localOffset = localOffset
		self.globalCount = globalCount ?? values?.count ?? 0
		self.leaf = leaf
	}
}

typealias SubrangeMutation&lt;Element, Additional&gt; = IndexedMutation&lt;Element, Subrange&lt;Additional&gt;&gt;

extension IndexedMutation {
	func updateMetadata&lt;Value, Leaf&gt;(_ state: inout SubrangeState&lt;Value, Leaf&gt;) where Subrange&lt;Leaf&gt; == Metadata {
		switch kind {
		case .reload:
			state.localOffset = metadata?.localOffset ?? 0
			state.globalCount = metadata?.globalCount ?? values.count
			state.leaf = metadata?.leaf ?? nil
		case .delete:
			if let localOffset = metadata?.localOffset {
				state.localOffset = localOffset
			}
			state.globalCount = metadata?.globalCount ?? (state.globalCount - indexSet.count)
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		case .insert:
			if let localOffset = metadata?.localOffset {
				state.localOffset = localOffset
			}
			state.globalCount = metadata?.globalCount ?? (state.globalCount + indexSet.count)
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		case .scroll(let offset):
			state.localOffset = metadata?.localOffset ?? (state.localOffset + offset)
			if let globalCount = metadata?.globalCount {
				state.globalCount = globalCount
			}
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		case .update: fallthrough
		case .move:
			if let localOffset = metadata?.localOffset {
				state.localOffset = localOffset
			}
			if let globalCount = metadata?.globalCount {
				state.globalCount = globalCount
			}
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		}
	}
	
	func apply&lt;Submetadata&gt;(toSubrange state: inout SubrangeState&lt;Element, Submetadata&gt;) where Subrange&lt;Submetadata&gt; == Metadata {
		if !hasNoEffectOnValues {
			var rows = state.values ?? []
			mapMetadata { _ in () }.apply(to: &amp;rows)
			state.values = rows
		}
		
		updateMetadata(&amp;state)
	}
}

extension IndexSet {
	/// Maintaining an `SubrangeOffset` with a local offset may require offsetting an `IndexSet`
	func offset(by: Int) -&gt; IndexSet {
		if by == 0 {
			return self
		}
		var result = IndexSet()
		for range in self.rangeView {
			result.insert(integersIn: (range.startIndex + by)..&lt;(range.endIndex + by))
		}
		return result
	}
}

struct TreeMutation&lt;Leaf&gt;: ExpressibleByArrayLiteral {
	let mutations: IndexedMutation&lt;TreeMutation&lt;Leaf&gt;, Leaf&gt;
	
	init(mutations: IndexedMutation&lt;TreeMutation&lt;Leaf&gt;, Leaf&gt;) {
		self.mutations = mutations
	}
	
	init(arrayLiteral elements: TreeMutation&lt;Leaf&gt;...) {
		self.mutations = .reload(elements)
	}
	
	static func leaf(_ value: Leaf, children: [TreeMutation&lt;Leaf&gt;]? = nil) -&gt; TreeMutation&lt;Leaf&gt; {
		return TreeMutation&lt;Leaf&gt;(mutations: children.map { IndexedMutation(metadata: value, reload: $0) } ?? IndexedMutation(metadata: value))
	}
	
	static func leaf&lt;Value&gt;(_ value: Value, children: [TreeMutation&lt;Leaf&gt;]? = nil) -&gt; TreeMutation&lt;Leaf&gt; where Subrange&lt;Value&gt; == Leaf {
		let subrange = Subrange(localOffset: children.map { _ in 0 }, globalCount: children.map { $0.count }, leaf: value)
		return TreeMutation&lt;Leaf&gt;(mutations: children.map { IndexedMutation(metadata: subrange, reload: $0) } ?? IndexedMutation(metadata: subrange))
	}
}

class TreeState&lt;Metadata&gt; {
	weak var parent: TreeState&lt;Metadata&gt;?
	var metadata: Metadata? = nil
	var rows: Array&lt;TreeState&lt;Metadata&gt;&gt;? = nil
	
	init(parent: TreeState&lt;Metadata&gt;?) {}
	
	convenience init(parent: TreeState&lt;Metadata&gt;?, treeMutation: TreeMutation&lt;Metadata&gt;) {
		self.init(parent: parent)
		treeMutation.mutations.apply(toTree: self)
	}
}

typealias TreeSubrangeMutation&lt;Leaf&gt; = TreeMutation&lt;Subrange&lt;Leaf&gt;&gt;

extension IndexedMutation where Element == TreeMutation&lt;Metadata&gt; {
	func apply(toTree treeState: TreeState&lt;Metadata&gt;) {
		if let metadata = metadata {
			treeState.metadata = metadata
		}
		
		if !hasNoEffectOnValues {
			var rows: Array&lt;TreeState&lt;Metadata&gt;&gt; = []
			if case .update = kind {
				for (mutationIndex, rowIndex) in indexSet.enumerated() {
					values[mutationIndex].mutations.apply(toTree: rows[rowIndex])
				}
			} else {
				mapValues { mutation in TreeState&lt;Metadata&gt;.init(parent: treeState, treeMutation: mutation) }.mapMetadata { _ in () }.apply(to: &amp;rows)
			}
			treeState.rows = rows
		}
	}
}

typealias TreeRangeMutation&lt;Leaf&gt; = TreeMutation&lt;Subrange&lt;Leaf&gt;&gt;

class TreeSubrangeState&lt;Leaf&gt; {
	weak var parent: TreeSubrangeState&lt;Leaf&gt;?
	var state = SubrangeState&lt;TreeSubrangeState&lt;Leaf&gt;, Leaf&gt;()

	init(parent: TreeSubrangeState&lt;Leaf&gt;?) {}
	
	convenience init(parent: TreeSubrangeState&lt;Leaf&gt;?, treeSubrangeMutation: TreeSubrangeMutation&lt;Leaf&gt;) {
		self.init(parent: parent)
		treeSubrangeMutation.mutations.apply(toTreeSubrange: self)
	}
}

extension IndexedMutation where Element == TreeMutation&lt;Metadata&gt; {
	func apply&lt;Leaf&gt;(toTreeSubrange treeSubrangeState: TreeSubrangeState&lt;Leaf&gt;) where Subrange&lt;Leaf&gt; == Metadata {
		if !hasNoEffectOnValues {
			if case .update = kind {
				for (mutationIndex, rowIndex) in indexSet.enumerated() {
					values[mutationIndex].mutations.apply(toTreeSubrange: treeSubrangeState.state.values![rowIndex])
				}
			} else {
				mapValues { mutation in TreeSubrangeState&lt;Leaf&gt;.init(parent: treeSubrangeState, treeSubrangeMutation: mutation) }.apply(toSubrange: &amp;treeSubrangeState.state)
			}
		}
		updateMetadata(&amp;treeSubrangeState.state)
	}
}

/// A value abstraction of the arguments to some AppKit/UIKit methods with a `setValue(_:,animated:)` structure.
struct Animatable&lt;Value, AnimationType&gt; {
	let value: Value
	let animation: AnimationType?
	
	static func set(_ value: Value) -&gt; Animatable&lt;Value, AnimationType&gt; {
		return Animatable&lt;Value, AnimationType&gt;(value: value, animation: nil)
	}
	static func animate(_ value: Value, animation: AnimationType) -&gt; Animatable&lt;Value, AnimationType&gt; {
		return Animatable&lt;Value, AnimationType&gt;(value: value, animation: animation)
	}
	
	var isAnimated: Bool {
		return animation != nil
	}
}

typealias SetOrAnimate&lt;Value&gt; = Animatable&lt;Value, ()&gt;

extension Animatable where AnimationType == () {
	static func animate(_ value: Value) -&gt; Animatable&lt;Value, AnimationType&gt; {
		return Animatable&lt;Value, AnimationType&gt;(value: value, animation: ())
	}
}

extension BindingName {
	static func --&lt;A, AnimationType&gt;(name: BindingName&lt;Value, Source, Binding&gt;, value: A) -&gt; Binding where Dynamic&lt;Animatable&lt;A, AnimationType&gt;&gt; == Value {
		return name.binding(with: Value.constant(.set(value)))
	}
	
}

enum AnimationChoice {
	case never
	case subsequent
	case always
}

extension SignalInterface {
	func animate(_ choice: AnimationChoice = .subsequent) -&gt; Signal&lt;Animatable&lt;OutputValue, ()&gt;&gt; {
		return map(initialState: false) { (alreadyReceived: inout Bool, value: OutputValue) in
			if alreadyReceived || choice == .always {
				return .animate(value)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(value)
			}
		}
	}

	func animate(_ choice: AnimationChoice = .subsequent) -&gt; Signal&lt;Animatable&lt;OutputValue?, ()&gt;&gt; {
		return map(initialState: false) { (alreadyReceived: inout Bool, value: OutputValue) in
			if alreadyReceived || choice == .always {
				return .animate(value)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(value)
			}
		}
	}
}

import Foundation

extension Adapter {
	#if os(iOS)
		func storeToArchive&lt;Value&gt;() -&gt; (UIApplication, NSKeyedArchiver) -&gt; Void where State == VarState&lt;Value&gt; {
			return { _, archiver in archiver.encodeLatest(from: self) }
		}
	#elseif os(macOS)
		func storeToArchive&lt;Value&gt;() -&gt; (NSApplication, NSCoder) -&gt; Void where State == VarState&lt;Value&gt; {
			return { _, archiver in archiver.encodeLatest(from: self) }
		}
	#endif
}

extension Adapter {
	#if os(iOS)
		func loadFromArchive&lt;Value&gt;() -&gt; (UIApplication, NSKeyedUnarchiver) -&gt; Void where State == VarState&lt;Value&gt; {
			return { _, unarchiver in unarchiver.decodeSend(to: self.set()) }
		}
	#elseif os(macOS)
		func loadFromArchive&lt;Value&gt;() -&gt; (NSApplication, NSCoder) -&gt; Void where State == VarState&lt;Value&gt; {
			return { _, unarchiver in unarchiver.decodeSend(to: self.set()) }
		}
	#endif
}

extension NSCoder {
	/// Gets the latest value from the signal and encodes the value as JSON data into self using the provided key
	///
	/// - Parameters:
	///   - interface: exposes the signal
	///   - forKey: key used for encoding (is `String.viewStateKey` by default)
	func encodeLatest&lt;Interface&gt;(from interface: Interface, forKey: String = .viewStateKey) where Interface: SignalInterface, Interface.OutputValue: Codable {
		if let data = try? JSONEncoder().encode(interface.peek()) {
			_ = self.encode(data, forKey: forKey)
		}
	}
}

extension NSCoder {
	/// Decodes the JSON data in self, associated with the provided key, and sends into the signal input.
	///
	/// NOTE: this function does not send errors.
	///
	/// - Parameters:
	///   - inputInterface: exposes the signal input
	///   - forKey: key used for decoding (is `String.viewStateKey` by default)
	func decodeSend&lt;InputInterface&gt;(to inputInterface: InputInterface, forKey: String = .viewStateKey) where InputInterface: SignalInputInterface, InputInterface.InputValue: Codable {
		if let data = self.decodeObject(forKey: forKey) as? Data, let value = try? JSONDecoder().decode(InputInterface.InputValue.self, from: data) {
			inputInterface.input.send(value: value)
		}
	}
}

extension String {
	static let viewStateKey = "viewStateData"
}

import Foundation

#if os(macOS)
	extension NSImage {
		static func drawn(width: CGFloat, height: CGFloat, flipped: Bool = true, _ function: @escaping (CGContext, CGRect) -&gt; Void) -&gt; NSImage {
			let size = CGSize(width: width, height: height)
			return NSImage(size: size, flipped: flipped) { rect -&gt; Bool in
				guard let context = NSGraphicsContext.current else { return false }
				function(context.cgContext, rect)
				return true
			}
		}
	}
#else
	extension UIImage {
		static func drawn(width: CGFloat, height: CGFloat, _ function: (CGContext, CGRect) -&gt; Void) -&gt; UIImage {
			let size = CGSize(width: width, height: height)
			UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
			if let graphicsContext = UIGraphicsGetCurrentContext() {
				function(graphicsContext, CGRect(origin: .zero, size: size))
			}
			let rectangleImage = UIGraphicsGetImageFromCurrentImageContext()
			UIGraphicsEndImageContext()
			return rectangleImage ?? UIImage()
		}
	}
#endif

import Foundation

extension NSKeyValueObservation: Lifetime {
	func cancel() {
		self.invalidate()
	}
}

#if os(macOS)
	import AppKit
	
	protocol ViewConvertible {
		func nsView() -&gt; Layout.View
	}
	extension Layout.View: ViewConvertible {
		func nsView() -&gt; Layout.View {
			return self
		}
	}
#else
	import UIKit
	
	protocol ViewConvertible {
		func uiView() -&gt; Layout.View
	}
	extension Layout.View: ViewConvertible {
		func uiView() -&gt; Layout.View {
			return self
		}
	}
#endif

#if os(iOS)
	// This type handles a combination of `layoutMargin` and `safeAreaMargin` inset edges. If a `safeArea` edge is specified, it will be used instead of `layout` edge.
	struct MarginEdges: OptionSet {
		static var none: MarginEdges { return MarginEdges(rawValue: 0) }
		static var topLayout: MarginEdges { return MarginEdges(rawValue: 1) }
		static var leadingLayout: MarginEdges { return MarginEdges(rawValue: 2) }
		static var bottomLayout: MarginEdges { return MarginEdges(rawValue: 4) }
		static var trailingLayout: MarginEdges { return MarginEdges(rawValue: 8) }
		static var topSafeArea: MarginEdges { return MarginEdges(rawValue: 16) }
		static var leadingSafeArea: MarginEdges { return MarginEdges(rawValue: 32) }
		static var bottomSafeArea: MarginEdges { return MarginEdges(rawValue: 64) }
		static var trailingSafeArea: MarginEdges { return MarginEdges(rawValue: 128) }
		static var allLayout: MarginEdges { return [.topLayout, .leadingLayout, .bottomLayout, .trailingLayout] }
		static var allSafeArea: MarginEdges { return [.topSafeArea, .leadingSafeArea, .bottomSafeArea, .trailingSafeArea] }
		let rawValue: UInt
		init(rawValue: UInt) {
			self.rawValue = rawValue
		}
	}
#endif

#if os(macOS)
	extension NSView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(view: self)) })
		}
	}
#else
	extension UIView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(view: self, marginEdges: $0.marginEdges)) })
		}
	}
	
	extension UIScrollView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyContentLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(scrollView: self)) })
		}
	}
#endif

/// A data structure for describing a layout as a series of nested columns and rows.
struct Layout {
	/// A rough equivalent to UIStackViewAlignment, minus baseline cases which aren't handled
	enum Alignment { case leading, trailing, center, fill }
	
	#if os(macOS)
		typealias Axis = NSUserInterfaceLayoutOrientation
		typealias View = NSView
		typealias Guide = NSLayoutGuide
		typealias EdgeInsets = NSEdgeInsets
	#else
		typealias Axis = NSLayoutConstraint.Axis
		typealias View = UIView
		typealias Guide = UILayoutGuide
		typealias EdgeInsets = UIEdgeInsets
	#endif

	/// When a layout is applied, it can animate one of three ways:
	///
	/// - none: Do not animate layout transitions
	/// - frames: Animate frame changes for views present both before and after but do not animate added or removed views
	/// - fade: Use a fade transition for all changes
	/// - all: Animate frame changes for views present both before and after and use fade transitions for other viewa
	struct Animation {
		enum Style {
			case frames
			case fade
			case both
		}
		let style: Style
		let duration: CFTimeInterval
		init(style: Style, duration: CFTimeInterval) {
			self.style = style
			self.duration = duration
		}
		
		static func frames(_ duration: CFTimeInterval = 0.2) -&gt; Animation { return Animation(style: .frames, duration: duration) }
		static func fade(_ duration: CFTimeInterval = 0.2) -&gt; Animation { return Animation(style: .fade, duration: duration) }
		static func both(_ duration: CFTimeInterval = 0.2) -&gt; Animation { return Animation(style: .both, duration: duration) }
	}
	
	
	/// Layout is either horizontal or vertical (although any element within the layout may be a layout in the perpendicular direction)
	let axis: Axis
	
	/// Within the horizontal row or vertical column, layout entities may fill, center or align-leading or align-trailing
	let align: Alignment
	
	#if os(iOS)
		/// The layout may extend to the view bounds or may be limited by the safeAreaMargins or layoutMargins. The safeArea insets supercede the layoutMargins (prior to iOS 11, safeArea is interpreted as UIViewController top/bottom layout guides when laying out within a UIViewController, otherwise it is treated as a synonym for the layoutMargins). This value has no effect on macOS.	
		let marginEdges: MarginEdges
	#endif
	
	/// When applied to the top level `Layout` passed to 'applyLayout`, then replacing an existing layout on a view, if this variable is true, after applying the new layout, `layoutIfNeeded` will be called inside a `UIView.beginAnimations`/`UIView.endAnimations` block. Has no effect when set on a child `Layout`.
	let animation: Layout.Animation?
	
	/// This is the list of views, spaces and sublayouts that will be layed out.
	var entities: [Entity]
	
	/// The default constructor assigns all values. In general, it's easier to use the `.horizontal` or `.vertical` constructor where possible.
	#if os(iOS)
		init(axis: Axis, align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), entities: [Entity]) {
			self.axis = axis
			self.align = align
			self.entities = entities
			self.marginEdges = marginEdges
			self.animation = animation
		}
	
		/// A convenience constructor for a horizontal layout
		static func horizontal(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), _ entities: Entity...) -&gt; Layout {
			return .horizontal(align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		static func horizontal(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), entities: [Entity]) -&gt; Layout {
			return Layout(axis: .horizontal, align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a vertical layout
		static func vertical(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), _ entities: Entity...) -&gt; Layout {
			return .vertical(align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		static func vertical(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), entities: [Entity]) -&gt; Layout {
			return Layout(axis: .vertical, align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a nested pair of layouts that combine to form a single centered arrangment
		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, _ entities: Entity...) -&gt; Layout {
			return .center(axis: axis, alignment: alignment, marginEdges: marginEdges, animation: animation, length: length, breadth: breadth, relativity: relativity, entities: entities)
		}
		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, entities: [Entity]) -&gt; Layout {
			switch axis {
			case .vertical:
				let v = Entity.sublayout(axis: .vertical, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: v
				)
				return Layout(axis: .vertical, align: .center, marginEdges: marginEdges, animation: animation, entities: [matched])
			case .horizontal:
				let h = Entity.sublayout(axis: .horizontal, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: h
				)
				return Layout(axis: .horizontal, align: .center, marginEdges: marginEdges, animation: animation, entities: [matched])
			@unknown default: fatalError()
			}
		}
		
		/// A convenience constructor for a vertical layout
		static func fill(axis: Layout.Axis = .vertical, align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ view: ViewConvertible) -&gt; Layout {
			switch axis {
			case .horizontal: return .horizontal(align: align, marginEdges: marginEdges, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			case .vertical: return .vertical(align: align, marginEdges: marginEdges, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			@unknown default: fatalError()
			}
		}
	#else
		init(axis: Axis, align: Alignment = .fill, animation: Layout.Animation? = .frames(), entities: [Entity]) {
			self.axis = axis
			self.align = align
			self.entities = entities
			self.animation = animation
		}
		
		/// A convenience constructor for a horizontal layout
		static func horizontal(align: Alignment = .fill, animation: Layout.Animation? = .frames(), _ entities: Entity...) -&gt; Layout {
			return .horizontal(align: align, animation: animation, entities: entities)
		}
		static func horizontal(align: Alignment = .fill, animation: Layout.Animation? = .frames(), entities: [Entity]) -&gt; Layout {
			return Layout(axis: .horizontal, align: align, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a vertical layout
		static func vertical(align: Alignment = .fill, animation: Layout.Animation? = .frames(), _ entities: Entity...) -&gt; Layout {
			return .vertical(align: align, animation: animation, entities: entities)
		}
		static func vertical(align: Alignment = .fill, animation: Layout.Animation? = .frames(), entities: [Entity]) -&gt; Layout {
			return Layout(axis: .vertical, align: align, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a nested pair of layouts that combine to form a single centered arrangment
		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, _ entities: Entity...) -&gt; Layout {
			return .center(axis: axis, alignment: alignment, animation: animation, length: length, breadth: breadth, relativity: relativity, entities: entities)
		}
		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, entities: [Entity]) -&gt; Layout {
			switch axis {
			case .vertical:
				let v = Entity.sublayout(axis: .vertical, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: v
				)
				return Layout(axis: .vertical, align: .center, animation: animation, entities: [matched])
			case .horizontal:
				let h = Entity.sublayout(axis: .horizontal, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: h
				)
				return Layout(axis: .horizontal, align: .center, animation: animation, entities: [matched])
			@unknown default: fatalError()
			}
		}
		
		/// A convenience constructor for a vertical layout
		static func fill(axis: Layout.Axis = .vertical, align: Alignment = .fill, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ view: ViewConvertible) -&gt; Layout {
			switch axis {
			case .horizontal: return .horizontal(align: align, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			case .vertical: return .vertical(align: align, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			@unknown default: fatalError()
			}
		}
		
		/// A convenience constructor for a vertical layout 
		static func inset(margins: EdgeInsets, animation: Layout.Animation? = .frames(), _ entity: Entity) -&gt; Layout {
			return .horizontal(.space(.equalTo(constant: margins.left)), .vertical(.space(.equalTo(constant: margins.top)), entity, .space(.equalTo(constant: margins.bottom))), .space(.equalTo(constant: margins.right)))
		}
	#endif
	
	// Used for removing all views from their superviews
	func forEachView(_ visit: (View) -&gt; Void) {
		entities.forEach { $0.forEachView(visit) }
	}
	
	// Used for finding the n-th subview, depth-first search order
	func traverse(over remaining: inout Int) -&gt; ViewConvertible? {
		for e in entities {
			if let match = e.traverse(over: &amp;remaining) {
				return match
			}
		}
		return nil
	}

	/// A linear time search for the view at a given index. Current state is intended for testing-only.
	///
	/// - Parameter at: the view returned will be the `at`-th view encountered in a depth-first walk.
	/// - Returns: the `at`-th view encountered or `nil` if never enountered
	func view(at: Int) -&gt; ViewConvertible? {
		if at &lt; 0 {
			return nil
		}
		var remaining = at
		return traverse(over: &amp;remaining)
	}

	/// The `Layout` describes a series of these `Entity`s which may be a space, a view or a sublayout. There is also a special `matched` layout which allows a series of "same length" entities.
	///
	/// - interViewSpace: AppKit and UIKit use an 8 screen unit space as the "standard" space between adjacent views.
	/// - space: an arbitrary space between views
	/// - view: a view with optional width and height (if not specified, the view will use its "intrinsic" size or will fill the available layout space)
	/// - layout: a nested layout which may be parallel or perpedicular to its container and whose size may be specified (like view)
	/// - matched: a sequence of alternating "same size" and independent entities (you can use `.space(0)` if you don't want independent entities).
	struct Entity {
		enum Content {
			case space(Dimension)
			case sizedView(ViewConvertible, Size?)
			indirect case layout(Layout, size: Size?)
			indirect case matched(Matched)
		}
		let content: Content
		init(_ content: Content) {
			self.content = content
		}
		
		func forEachView(_ visit: (Layout.View) -&gt; Void) {
			switch content {
			case .sizedView(let v, _):
				#if os(macOS)
					visit(v.nsView())
				#else
					visit(v.uiView())
				#endif
			case .layout(let l, _): l.forEachView(visit)
			case .matched(let matched):
				matched.first.forEachView(visit)
				matched.subsequent.forEach { element in
					switch element {
					case .free(let entity): entity.forEachView(visit)
					case .dependent(let dependent): dependent.entity.forEachView(visit)
					}
				}
			case .space: break
			}
		}

		func traverse(over remaining: inout Int) -&gt; ViewConvertible? {
			switch content {
			case .sizedView(let v, _):
				if remaining == 0 {
					return v
				} else {
					remaining -= 1
				}
				return nil
			case .layout(let l, _):
				return l.traverse(over: &amp;remaining)
			case .matched(let matched):
				if let v = matched.first.traverse(over: &amp;remaining) {
					return v
				}
				for s in matched.subsequent {
					switch s {
					case .free(let entity):
						if let v = entity.traverse(over: &amp;remaining) {
							return v
						}
					case .dependent(let dependent):
						if let v = dependent.entity.traverse(over: &amp;remaining) {
							return v
						}
					}
				}
				return nil
			case .space:
				return nil
			}
		}
		
		static func space(_ dimension: Dimension = .standardSpace) -&gt; Entity {
			return Entity(.space(dimension))
		}
		
		static func view(length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ view: ViewConvertible) -&gt; Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			return Entity(.sizedView(view, size))
		}

		static func sublayout(axis: Axis, align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: Entity...) -&gt; Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: axis, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: axis, align: align, entities: entities), size: size))
			#endif
		}
		
		static func sublayout(axis: Axis, align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, entities: [Entity]) -&gt; Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: axis, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: axis, align: align, entities: entities), size: size))
			#endif
		}
		
		static func horizontal(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: Entity...) -&gt; Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .horizontal, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .horizontal, align: align, entities: entities), size: size))
			#endif
		}
		
		static func horizontal(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: [Entity]) -&gt; Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .horizontal, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .horizontal, align: align, entities: entities), size: size))
			#endif
		}
		
		static func vertical(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: Entity...) -&gt; Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .vertical, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .vertical, align: align, entities: entities), size: size))
			#endif
		}
		
		static func vertical(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, entities: [Entity]) -&gt; Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .vertical, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .vertical, align: align, entities: entities), size: size))
			#endif
		}

		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, _ entities: Entity...) -&gt; Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#else
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#endif
		}

		static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, entities: [Entity]) -&gt; Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#else
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#endif
		}
		
		static func pair(_ left: Entity, _ right: Entity, separator: Entity = .space(), priority: Dimension.Priority = .required) -&gt; Entity {
			return Entity(.matched(Matched(
				first: left,
				subsequent: [
					.free(separator),
					.dependent(.init(dimension: .equalTo(ratio: 1.0, priority: priority), right))
				]
			)))
		}
		
		static func matched(_ first: Entity, _ subsequent: Matched.Element...) -&gt; Entity {
			return Entity(.matched(.init(first: first, subsequent: subsequent)))
		}
		
		static func matched(_ first: Entity, subsequent: [Matched.Element]) -&gt; Entity {
			return Entity(.matched(.init(first: first, subsequent: subsequent)))
		}
		
		static func same(priority: Dimension.Priority = .required, _ entities: Entity...) -&gt; Entity {
			return same(entities: entities)
		}
		
		static func same(priority: Dimension.Priority = .required, entities: [Entity]) -&gt; Entity {
			guard let first = entities.first else { return .space(0) }
			return Entity(.matched(.init(first: first, subsequent: entities.dropFirst().map { .same(priority: priority, $0) })))
		}
		
		static func inset(margins: EdgeInsets, _ entity: Entity) -&gt; Entity {
			return .horizontal(.space(.equalTo(constant: margins.left)), .vertical(.space(.equalTo(constant: margins.top)), entity, .space(.equalTo(constant: margins.bottom))), .space(.equalTo(constant: margins.right)))
		}
	}
	
	/// A `Matched` element in a layout is a first element, followed by an array of free and dependent elements. The dependent elements all have a dimension  relationship to the first element (e.g. same size).
	struct Matched {
		struct Dependent {
			let dimension: Dimension
			let entity: Entity
			init(dimension: Dimension, _ entity: Entity) {
				self.entity = entity
				self.dimension = dimension
			}
		}
		enum Element {
			case dependent(Dependent)
			case free(Entity)

			static func same(priority: Dimension.Priority = .required, _ entity: Entity) -&gt; Element {
				return .dependent(.init(dimension: Dimension.equalTo(ratio: 1, priority: priority), entity))
			}
		}
		let first: Entity
		let subsequent: [Element]
		init(first: Entity, subsequent: [Element]) {
			self.first = first
			self.subsequent = subsequent
		}
	}

	/// A `Size` is the combination of both length (size of a layout object in the direction of layout) or breadth (size of a layout object perpendicular to the layout direction). If the length includes a ratio, it is relative to the parent container but the breadth can be relative to the length, allowing for specifying an aspect ratio.
	struct Size {
		enum Relativity {
			case independent
			case lengthRelativeToBreadth
			case breadthRelativeToLength
			
			var isLengthRelativeToBreadth: Bool {
				if case .lengthRelativeToBreadth = self { return true } else { return false }
			}
			var isBreadthRelativeToLength: Bool {
				if case .breadthRelativeToLength = self { return true } else { return false }
			}
		}
		let length: Dimension?
		let breadth: Dimension?
		let relativity: Relativity
		
		init(length: Dimension? = nil, breadth: Dimension?, relativity: Relativity = .independent) {
			self.length = length
			self.breadth = breadth
			self.relativity = relativity
		}
	}

	/// When length (size of a layout object in the direction of layout) or breadth (size of a layout object perpendicular to the layout direction) is specified, it can be specified:
	///	* relative to the parent container (ratio)
	///	* in raw screen units (constant)
	/// The greater/less than and priority can also be specified.
	struct Dimension: ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral {
		typealias FloatLiteralType = Double
		typealias IntegerLiteralType = Int
		
		#if os(macOS)
			typealias Relation = NSLayoutConstraint.Relation
			typealias Priority = NSLayoutConstraint.Priority
		#else
			typealias Relation = NSLayoutConstraint.Relation
			typealias Priority = UILayoutPriority
		#endif
		
		let ratio: CGFloat
		let constant: CGFloat
		let relationship: Relation
		let priority: Dimension.Priority
		init(ratio: CGFloat = 0, constant: CGFloat = 0, relationship: Dimension.Relation = .equal, priority: Dimension.Priority = .required) {
			self.ratio = ratio
			self.constant = constant
			self.relationship = relationship
			self.priority = priority
		}
		
		init(floatLiteral value: Double) {
			self.init(constant: CGFloat(value))
		}
		
		init(integerLiteral value: Int) {
			self.init(constant: CGFloat(value))
		}
		
		static func constant(_ value: CGFloat) -&gt; Dimension {
			return Dimension(constant: value)
		}
		
		static func ratio(_ value: CGFloat, constant: CGFloat = 0) -&gt; Dimension {
			return Dimension(ratio: value, constant: constant)
		}
		
		static var standardSpace = Dimension(ratio: 0, constant: 8, relationship: .equal, priority: .layoutHigh) 
		
		static func lessThanOrEqualTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -&gt; Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .lessThanOrEqual, priority: priority)
		}
		
		static func greaterThanOrEqualTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -&gt; Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .greaterThanOrEqual, priority: priority)
		}
		
		static func equalTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -&gt; Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .equal, priority: priority)
		}
		
		static var fillRemaining: Dimension {
			return equalTo(ratio: 1, priority: .layoutMid)
		}
		
		func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension, priorityAdjustment: Int) -&gt; NSLayoutConstraint {
			let constraint: NSLayoutConstraint
			switch relationship {
			case .equal: constraint = first.constraint(equalTo: second, multiplier: ratio, constant: constant)
			case .lessThanOrEqual: constraint = first.constraint(lessThanOrEqualTo: second, multiplier: ratio, constant: constant)
			case .greaterThanOrEqual: constraint = first.constraint(greaterThanOrEqualTo: second, multiplier: ratio, constant: constant)
			@unknown default: fatalError()
			}
			constraint.priority = adjustedPriority(priority, count: priorityAdjustment)
			constraint.isActive = true
			return constraint
		}
		
		func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension) -&gt; NSLayoutConstraint {
			return scaledConstraintBetween(first: first, second: second, priorityAdjustment: 0)
		}
		
		func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension, constraints: inout [NSLayoutConstraint]) {
			constraints.append(scaledConstraintBetween(first: first, second: second, priorityAdjustment: constraints.count))
		}
		
		func unscaledConstraintBetween&lt;AnchorType&gt;(first: NSLayoutAnchor&lt;AnchorType&gt;, second: NSLayoutAnchor&lt;AnchorType&gt;, constraints: inout [NSLayoutConstraint], reverse: Bool = false) {
			let constraint: NSLayoutConstraint
			switch (relationship, reverse) {
			case (.equal, _): constraint = first.constraint(equalTo: second, constant: reverse ? -constant: constant)
			case (.lessThanOrEqual, false), (.greaterThanOrEqual, true): constraint = first.constraint(lessThanOrEqualTo: second, constant: reverse ? -constant: constant)
			case (.greaterThanOrEqual, false), (.lessThanOrEqual, true): constraint = first.constraint(greaterThanOrEqualTo: second, constant: reverse ? -constant: constant)
			@unknown default: fatalError()
			}
			constraint.priority = adjustedPriority(priority, count: constraints.count)
			constraint.isActive = true
			constraints.append(constraint)
		}
	}

	/// Bounds are used internally to capture a set of guides and anchors. On the Mac, these are merely copied from a single NSLayoutGuide or an NSView. On iOS, these may be copied from a blend of UIViewController top/bottomLayoutGuides, safeAreaLayoutGuides, layoutMarginsGuides or a UIView.
	fileprivate struct Bounds {
		var leading: NSLayoutXAxisAnchor
		var top: NSLayoutYAxisAnchor
		var trailing: NSLayoutXAxisAnchor
		var bottom: NSLayoutYAxisAnchor
		var width: NSLayoutDimension
		var height: NSLayoutDimension
		var centerX: NSLayoutXAxisAnchor
		var centerY: NSLayoutYAxisAnchor
		
		init(box: Layout.Box) {
			leading = box.leadingAnchor
			top = box.topAnchor
			trailing = box.trailingAnchor
			bottom = box.bottomAnchor
			width = box.widthAnchor
			height = box.heightAnchor
			centerX = box.centerXAnchor
			centerY = box.centerYAnchor
		}
		
		#if os(iOS)
			init(scrollView: UIScrollView) {
				leading = scrollView.contentLayoutGuide.leadingAnchor
				top = scrollView.contentLayoutGuide.topAnchor
				trailing = scrollView.contentLayoutGuide.trailingAnchor
				bottom = scrollView.contentLayoutGuide.bottomAnchor
				width = scrollView.contentLayoutGuide.widthAnchor
				height = scrollView.contentLayoutGuide.heightAnchor
				centerX = scrollView.contentLayoutGuide.centerXAnchor
				centerY = scrollView.contentLayoutGuide.centerYAnchor
			}
			
			init(view: Layout.View, marginEdges: MarginEdges) {
				leading = marginEdges.contains(.leadingSafeArea) ? view.safeAreaLayoutGuide.leadingAnchor : (marginEdges.contains(.leadingLayout) ? view.layoutMarginsGuide.leadingAnchor : view.leadingAnchor)
				top = marginEdges.contains(.topSafeArea) ? view.safeAreaLayoutGuide.topAnchor : (marginEdges.contains(.topLayout) ? view.layoutMarginsGuide.topAnchor : view.topAnchor)
				trailing = marginEdges.contains(.trailingSafeArea) ? view.safeAreaLayoutGuide.trailingAnchor : (marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.trailingAnchor : view.trailingAnchor)
				bottom = marginEdges.contains(.bottomSafeArea) ? view.safeAreaLayoutGuide.bottomAnchor : (marginEdges.contains(.bottomLayout) ? view.layoutMarginsGuide.bottomAnchor : view.bottomAnchor)
				width = (marginEdges.contains(.leadingSafeArea) &amp;&amp; marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.widthAnchor : (marginEdges.contains(.leadingLayout) &amp;&amp; marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.widthAnchor : view.widthAnchor)
				height = (marginEdges.contains(.leadingSafeArea) &amp;&amp; marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.heightAnchor : (marginEdges.contains(.leadingLayout) &amp;&amp; marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.heightAnchor : view.heightAnchor)
				centerX = (marginEdges.contains(.leadingSafeArea) &amp;&amp; marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.centerXAnchor : (marginEdges.contains(.leadingLayout) &amp;&amp; marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.centerXAnchor : view.centerXAnchor)
				centerY = (marginEdges.contains(.leadingSafeArea) &amp;&amp; marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.centerYAnchor : (marginEdges.contains(.leadingLayout) &amp;&amp; marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.centerYAnchor : view.centerYAnchor)
			}
		#else
			init(view: Layout.View) {
				leading = view.leadingAnchor
				top = view.topAnchor
				trailing = view.trailingAnchor
				bottom = view.bottomAnchor
				width = view.widthAnchor
				height = view.heightAnchor
				centerX = view.centerXAnchor
				centerY = view.centerYAnchor
			}
		#endif
	}

	private struct State {
		let view: View
		let storage: Storage
		
		var dimension: Dimension? = nil
		var previousEntityBounds: Bounds? = nil
		var containerBounds: Bounds
		
		init(containerBounds: Bounds, in view: View, storage: Storage) {
			self.containerBounds = containerBounds
			self.view = view
			self.storage = storage
		}
	}

	fileprivate class Storage: NSObject {
		let layout: Layout
		var constraints: [NSLayoutConstraint] = []
		var boxes: [Layout.Box] = []
		
		init(layout: Layout) {
			self.layout = layout
		}
	}

	private func twoPointConstraint&lt;First, Second&gt;(firstSource: NSLayoutAnchor&lt;First&gt;, firstTarget: NSLayoutAnchor&lt;First&gt;, secondSource: NSLayoutAnchor&lt;Second&gt;, secondTarget: NSLayoutAnchor&lt;Second&gt;, secondRelationLessThan: Bool? = nil, constraints: inout [NSLayoutConstraint]) {
		let first = firstSource.constraint(equalTo: firstTarget)
		first.priority = .required
		first.isActive = true
		constraints.append(first)
		
		let secondLow = secondSource.constraint(equalTo: secondTarget)
		
		var secondHigh: NSLayoutConstraint? = nil
		if secondRelationLessThan == true {
			secondHigh = secondSource.constraint(lessThanOrEqualTo: secondTarget)
		} else if secondRelationLessThan == false {
			secondHigh = secondSource.constraint(greaterThanOrEqualTo: secondTarget)
		}
		if let high = secondHigh {
			secondLow.priority = adjustedPriority(.layoutLow, count: constraints.count)
			high.priority = adjustedPriority(.layoutHigh, count: constraints.count + 1)
			high.isActive = true
			constraints.append(high)
		} else {
			secondLow.priority = adjustedPriority(.layoutHigh, count: constraints.count)
		}
		secondLow.isActive = true
		constraints.append(secondLow)
	}
	
	private func constrain(bounds: Bounds, leading: Dimension, length: Dimension?, breadth: Dimension?, relativity: Size.Relativity, state: inout State) {
		switch axis {
		case .horizontal:
			leading.unscaledConstraintBetween(first: bounds.leading, second: state.containerBounds.leading, constraints: &amp;state.storage.constraints)
			
			if let l = length {
				l.scaledConstraintBetween(first: bounds.width, second: relativity.isLengthRelativeToBreadth ? bounds.height : state.containerBounds.width, constraints: &amp;state.storage.constraints)
			}
			if let b = breadth {
				b.scaledConstraintBetween(first: bounds.height, second: relativity.isBreadthRelativeToLength ? bounds.width : state.containerBounds.height, constraints: &amp;state.storage.constraints)
			}
			
			switch self.align {
			case .leading:
				twoPointConstraint(firstSource: bounds.top, firstTarget: state.containerBounds.top, secondSource: bounds.bottom, secondTarget: state.containerBounds.bottom, secondRelationLessThan: true, constraints: &amp;state.storage.constraints)
			case .trailing:
				twoPointConstraint(firstSource: bounds.bottom, firstTarget: state.containerBounds.bottom, secondSource: bounds.top, secondTarget: state.containerBounds.top, secondRelationLessThan: false, constraints: &amp;state.storage.constraints)
			case .center:
				twoPointConstraint(firstSource: bounds.centerY, firstTarget: state.containerBounds.centerY, secondSource: bounds.height, secondTarget: state.containerBounds.height, secondRelationLessThan: true, constraints: &amp;state.storage.constraints)
			case .fill:
				twoPointConstraint(firstSource: bounds.top, firstTarget: state.containerBounds.top, secondSource: bounds.bottom, secondTarget: state.containerBounds.bottom, secondRelationLessThan: nil, constraints: &amp;state.storage.constraints)
			}
			
			state.containerBounds.leading = bounds.trailing
		case .vertical:
			leading.unscaledConstraintBetween(first: bounds.top, second: state.containerBounds.top, constraints: &amp;state.storage.constraints)
			
			if let l = length {
				l.scaledConstraintBetween(first: bounds.height, second: relativity.isLengthRelativeToBreadth ? bounds.width : state.containerBounds.height, constraints: &amp;state.storage.constraints)
			}
			
			if let b = breadth {
				b.scaledConstraintBetween(first: bounds.width, second: relativity.isBreadthRelativeToLength ? bounds.height : state.containerBounds.width, constraints: &amp;state.storage.constraints)
			}
			
			switch self.align {
			case .leading:
				twoPointConstraint(firstSource: bounds.leading, firstTarget: state.containerBounds.leading, secondSource: bounds.trailing, secondTarget: state.containerBounds.trailing, secondRelationLessThan: true, constraints: &amp;state.storage.constraints)
			case .trailing:
				twoPointConstraint(firstSource: bounds.trailing, firstTarget: state.containerBounds.trailing, secondSource: bounds.leading, secondTarget: state.containerBounds.leading, secondRelationLessThan: false, constraints: &amp;state.storage.constraints)
			case .center:
				twoPointConstraint(firstSource: bounds.centerX, firstTarget: state.containerBounds.centerX, secondSource: bounds.width, secondTarget: state.containerBounds.width, secondRelationLessThan: true, constraints: &amp;state.storage.constraints)
			case .fill:
				twoPointConstraint(firstSource: bounds.leading, firstTarget: state.containerBounds.leading, secondSource: bounds.trailing, secondTarget: state.containerBounds.trailing, secondRelationLessThan: nil, constraints: &amp;state.storage.constraints)
			}
			
			state.containerBounds.top = bounds.bottom
		@unknown default:	fatalError()
		}
	}
	
	@discardableResult
	private func layout(entity: Entity, state: inout State, needDimensionAnchor: Bool = false) -&gt; NSLayoutDimension? {
		switch entity.content {
		case .space(let dimension):
			if let d = state.dimension, (d.ratio != 0 || d.constant != 0) {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				constrain(bounds: Bounds(box: box), leading: Dimension(), length: d, breadth: nil, relativity: .independent, state: &amp;state)
				state.previousEntityBounds = nil
			}
			if dimension.ratio != 0 || needDimensionAnchor {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				constrain(bounds: Bounds(box: box), leading: Dimension(), length: dimension, breadth: nil, relativity: .independent, state: &amp;state)
				state.previousEntityBounds = Bounds(box: box)
				return axis == .horizontal ? box.widthAnchor : box.heightAnchor
			}
			state.dimension = dimension
			return nil
		case .layout(let l, let size):
			let box = Layout.Box()
			state.view.addLayoutBox(box)
			state.storage.boxes.append(box)
			let bounds = Bounds(box: box)
			l.add(to: state.view, containerBounds: bounds, storage: state.storage)
			constrain(bounds: bounds, leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relativity: size?.relativity ?? .independent, state: &amp;state)
			state.dimension = nil
			state.previousEntityBounds = bounds
			return needDimensionAnchor ? (axis == .horizontal ? box.widthAnchor : box.heightAnchor) : nil
		case .matched(let matched):
			if needDimensionAnchor {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				var subState = State(containerBounds: state.containerBounds, in: state.view, storage: state.storage)
				layout(entity: entity, state: &amp;subState)
				state.dimension = nil
				state.previousEntityBounds = Bounds(box: box)
				return axis == .horizontal ? box.widthAnchor : box.heightAnchor
			} else {
				let first = layout(entity: matched.first, state: &amp;state, needDimensionAnchor: true)!
				for element in matched.subsequent {
					switch element {
					case .free(let free):
						layout(entity: free, state: &amp;state)
					case .dependent(let dependent):
						let match = layout(entity: dependent.entity, state: &amp;state, needDimensionAnchor: true)!
						dependent.dimension.scaledConstraintBetween(first: match, second: first, constraints: &amp;state.storage.constraints)
					}
				}
				return nil
			}
		case .sizedView(let v, let size):
			#if os(macOS)
				let view = v.nsView()
				view.translatesAutoresizingMaskIntoConstraints = false
				state.view.addSubview(view)
				constrain(bounds: Bounds(view: view), leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relativity: size?.relativity ?? .independent, state: &amp;state)
				state.dimension = nil
				state.previousEntityBounds = Bounds(view: view)
			#else
				let view = v.uiView()
				view.translatesAutoresizingMaskIntoConstraints = false
				state.view.addSubview(view)
				constrain(bounds: Bounds(view: view, marginEdges: .none), leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relativity: size?.relativity ?? .independent, state: &amp;state)
				state.dimension = nil
				state.previousEntityBounds = Bounds(view: view, marginEdges: .none)
		#endif
			return needDimensionAnchor ? (axis == .horizontal ? view.widthAnchor : view.heightAnchor) : nil
		}
	}
	
	fileprivate func add(to view: Layout.View, containerBounds: Bounds, storage: Storage) {
		var state = State(containerBounds: containerBounds, in: view, storage: storage)
		for entity in entities {
			layout(entity: entity, state: &amp;state)
		}
		if let previous = state.previousEntityBounds {
			switch axis {
			case .horizontal:
				(state.dimension ?? Dimension()).unscaledConstraintBetween(first: previous.trailing, second: state.containerBounds.trailing, constraints: &amp;state.storage.constraints, reverse: true)
			case .vertical:
				(state.dimension ?? Dimension()).unscaledConstraintBetween(first: previous.bottom, second: state.containerBounds.bottom, constraints: &amp;state.storage.constraints, reverse: true)
			@unknown default: fatalError()
			}
		}
	}
}

// DEBUGGING TIP:
// As of Xcode 8, the "Debug View Hierarchy" option does not show layout guides, making debugging of constraints involving layout guides tricky. To aid debugging in these cases, set the following condition to `true &amp;&amp; DEBUG` and CwlLayout will create views instead of layout guides.
// Otherwise, you can set this to `false &amp;&amp; DEBUG`.
#if true &amp;&amp; DEBUG
	private extension Layout {
		typealias Box = Layout.View
	}
	private extension Layout.View {
		func addLayoutBox(_ layoutBox: Layout.Box) {
			layoutBox.translatesAutoresizingMaskIntoConstraints = false
			self.addSubview(layoutBox)
		}
		func removeLayoutBox(_ layoutBox: Layout.Box) {
			layoutBox.removeFromSuperview()
		}
	}
#else
	private extension Layout {
		typealias Box = Layout.Guide
	}
	private extension Layout.View {
		func addLayoutBox(_ layoutBox: Layout.Box) {
			self.addLayoutGuide(layoutBox)
		}
		func removeLayoutBox(_ layoutBox: Layout.Box) {
			self.removeLayoutGuide(layoutBox)
		}
	}
#endif

// NOTE:
//
// Views often have their own intrinsic size, and they maintain this size at
// either the `.defaultLow` or `.defaultHigh` priority. Unfortunately, layout
// doesn't work well if this intrinsic priority is perfectly balanced with the
// user-applied layout priority.
//
// For this reason, CwlLayout defaults to using the following layout priorities
// which are scaled to be slightly different to the default priorities. This
// allows you to easily set layout priorities above, between or below the
// intrinisic priorities without always resorting to `.required`.
//
extension Layout.Dimension.Priority {
	#if os(macOS)
		// .fittingSizeLevel = .fittingSizeCompression = 50
		static let fittingSizeLevel = NSLayoutConstraint.Priority.fittingSizeCompression
		// .layoutLow = 156.25
		static let layoutLow = NSLayoutConstraint.Priority(rawValue: (5 / 32) * NSLayoutConstraint.Priority.required.rawValue)
		// .defaultLow = 250
		// .layoutMid = 437.5
		static let layoutMid = NSLayoutConstraint.Priority(rawValue: (14 / 32) * NSLayoutConstraint.Priority.required.rawValue)
		// .dragThatCannotResizeWindow = 490
		// .windowSizeStayPut = 500
		// .dragThatCanResizeWindow = 510
		// .defaultHigh = 750
		// .layoutHigh = 843.75
		static let layoutHigh = NSLayoutConstraint.Priority(rawValue: (27 / 32) * NSLayoutConstraint.Priority.required.rawValue)
		// .required = 1000
	#else
		// .fittingSizeLevel = 50
		// .layoutLow = 156.25
		static let layoutLow = UILayoutPriority(rawValue: (5 / 32) * UILayoutPriority.required.rawValue)
		// .defaultLow = 250
		// .layoutMid = 437.5
		static let layoutMid = UILayoutPriority(rawValue: (14 / 32) * UILayoutPriority.required.rawValue)
		// .layoutHigh = 843.75
		static let layoutHigh = UILayoutPriority(rawValue: (27 / 32) * UILayoutPriority.required.rawValue)
		// .required = 1000
	#endif
}

private var associatedLayoutKey = NSObject()
private extension Layout.View {
	var associatedLayoutStorage: Layout.Storage? {
		get { return objc_getAssociatedObject(self, &amp;associatedLayoutKey) as? Layout.Storage }
		set { return objc_setAssociatedObject(self, &amp;associatedLayoutKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN) }
	}
}

private extension Layout.View {
	func remove(constraintsAndBoxes previousLayout: Layout.Storage?, subviews: Set&lt;Layout.View&gt;) {
		guard let previous = previousLayout else { return }
		for constraint in previous.constraints {
			constraint.isActive = false
		}
		for box in previous.boxes {
			self.removeLayoutBox(box)
		}
		subviews.forEach { $0.removeFromSuperview() }
	}
}

// Applying a rolloing set of priorities reduces the chance of ambiguity. Later constraints will always take precedence.
// NOTE: this does not eliminate ambiguity due to conflicting `.required` contraints or views with equal hugging or compression resistance.
private func adjustedPriority(_ priority: Layout.Dimension.Priority, count: Int) -&gt; Layout.Dimension.Priority {
	if priority == .required {
		return priority
	}
	
	let fitting = Layout.Dimension.Priority.fittingSizeLevel.rawValue + (1 / 128)
	return Layout.Dimension.Priority(rawValue: max(fitting, priority.rawValue - Float(count) / 128))
}

private func applyLayoutToView(view: Layout.View, params: (layout: Layout, bounds: Layout.Bounds)?) {
	var removedViews = Set&lt;Layout.View&gt;()
	
	// Check for a previous layout and get the old views
	let previous = view.associatedLayoutStorage
	previous?.layout.forEachView { view in removedViews.insert(view) }
	
	guard let (layout, bounds) = params else {
		// If there's no new layout, remove the old layout and we're done
		view.remove(constraintsAndBoxes: previous, subviews: removedViews)
		return
	}
	
	// Check if this will be animated
	let shouldAnimate = layout.animation?.style != .none &amp;&amp; previous != nil
	
	// Exclude views in the new layout from the removed set. If we're animating, we'll need animated and added sets too.
	var animatedViews = Set&lt;Layout.View&gt;()
	var addedViews = Set&lt;Layout.View&gt;()
	layout.forEachView { v in
		if let animated = removedViews.remove(v), shouldAnimate {
			animatedViews.insert(animated)
		} else if shouldAnimate {
			addedViews.insert(v)
		}
	}

	// Now that we know the precise removed set, remove them.
	let removalChange = { view.remove(constraintsAndBoxes: previous, subviews: removedViews) }
	if shouldAnimate &amp;&amp; layout.animation?.style != .frames &amp;&amp; addedViews.count == 0 &amp;&amp; removedViews.count &gt; 0 {
		// If we're animating the removal of views but not the insertion of views, animate this removal
		fadeTransition(view: view, duration: layout.animation?.duration ?? 0, removalChange)
	} else {
		removalChange()
	}
	
	// Apply the new layout
	let storage = Layout.Storage(layout: layout)
	layout.add(to: view, containerBounds: bounds, storage: storage)
	
	// If we're not animating, store the layout and we're done.
	if !shouldAnimate {
		view.associatedLayoutStorage = storage
		return
	}

	// NOTE: the case where `removedViews.count &gt; 0` but `addedViews.count == 0` is handled above
	if addedViews.count &gt; 0 {
		// Apply the layout, so new views have a precise size
		view.relayout()
		
		// Remove the new views and revert to the old layout
		view.remove(constraintsAndBoxes: storage, subviews: addedViews)
		if let p = previous {
			let oldStorage = Layout.Storage(layout: layout)
			p.layout.add(to: view, containerBounds: bounds, storage: oldStorage)

			// Immediately remove the old constraints but keep the old views
			view.remove(constraintsAndBoxes: oldStorage, subviews: [])
		}
		
		removedViews.forEach { $0.removeFromSuperview() }
		addedViews.forEach { view.addSubview($0) }
		
		// Reapply the new layout. Since the new views are already in-place
		let reapplyStorage = Layout.Storage(layout: layout)
		layout.add(to: view, containerBounds: bounds, storage: reapplyStorage)
		view.associatedLayoutStorage = reapplyStorage
	} else {
		view.associatedLayoutStorage = storage
	}
	
	// Animate the frames of the new layout
	let shouldFade: Bool
	switch layout.animation?.style {
	case .both?, .fade?: shouldFade = true
	case .frames?, nil: shouldFade = false
	}
	let frameChanges = {
		if shouldFade {
			fadeTransition(view: view, duration: layout.animation?.duration ?? 0, { view.relayout() })
		} else {
			view.relayout()
		}
	}
	if layout.animation?.style == .fade {
		frameChanges()
	} else {
		frameAnimation(view: view, duration: layout.animation?.duration ?? 0, frameChanges)
	}
}

private extension Layout.View {
	func relayout() {
		#if os(macOS)
			layoutSubtreeIfNeeded()
		#else
			layoutIfNeeded()
		#endif
	}
}

private func fadeTransition(view: Layout.View, duration: CFTimeInterval, _ changes: @escaping () -&gt; ()) {
	#if os(macOS)
		let transition = CATransition()
		transition.duration = duration
		transition.type = .fade
		view.layer?.add(transition, forKey: nil)
		changes()
	#else
		UIView.transition(with: view, duration: duration, options: [.transitionCrossDissolve, .allowUserInteraction], animations: changes)
	#endif
}

private func frameAnimation(view: Layout.View, duration: CFTimeInterval, _ changes: @escaping () -&gt; ()) {
	#if os(macOS)
		NSAnimationContext.beginGrouping()
		NSAnimationContext.current.duration = duration
		NSAnimationContext.current.allowsImplicitAnimation = true
		changes()
		NSAnimationContext.endGrouping()
	#else
		UIView.transition(with: view, duration: duration, options: [.transitionCrossDissolve, .allowUserInteraction], animations: changes)
	#endif
}

#if os(iOS)
	import UIKit
	
	@available(iOSApplicationExtension 8.2, *)
	extension UIFont {
		static func preferredFont(forTextStyle style: UIFont.TextStyle, weight: UIFont.Weight = .regular, slant: Float = 0) -&gt; UIFont {
			let base = UIFontDescriptor.preferredFontDescriptor(withTextStyle: style)
			let traits: [UIFontDescriptor.TraitKey: Any] = [.weight: weight, .slant: slant]
			let modified = base.addingAttributes([.traits: traits])
			return UIFont(descriptor: modified, size: 0)
		}
	}

	func preferredFontSize(forTextStyle style: UIFont.TextStyle) -&gt; CGFloat {
		return UIFontDescriptor.preferredFontDescriptor(withTextStyle: style).pointSize
	}
#endif

#if os(macOS)
	import AppKit

	@available(OSXApplicationExtension 10.11, *)
	extension NSFont {
		enum TextStyle {
			case controlContent
			case label
			case menu
			case menuBar
			case message
			case monospacedDigit
			case palette
			case system
			case titleBar
			case toolTips
		}
		enum TextSize {
			case controlMini
			case controlRegular
			case controlSmall
			case label
			case points(CGFloat)
			case system
			case title1
			case title2
		}

		static func preferredFont(forTextStyle style: TextStyle, size: TextSize = .system, weight: NSFont.Weight = .regular, slant: CGFloat = 0) -&gt; NSFont {
			let pointSize: CGFloat
			switch size {
			case .controlMini: pointSize = NSFont.systemFontSize(for: .mini)
			case .controlRegular: pointSize = NSFont.systemFontSize(for: .regular)
			case .controlSmall: pointSize = NSFont.systemFontSize(for: .small)
			case .label: pointSize = NSFont.labelFontSize
			case .points(let other): pointSize = other
			case .system: pointSize = NSFont.systemFontSize
			case .title1: pointSize = NSFont.systemFontSize + 5
			case .title2: pointSize = NSFont.systemFontSize + 2
			}
			
			let base: NSFont
			switch style {
			case .controlContent: base = NSFont.controlContentFont(ofSize: pointSize)
			case .label: base = NSFont.labelFont(ofSize: pointSize)
			case .menu: base = NSFont.menuFont(ofSize: pointSize)
			case .menuBar:  base = NSFont.menuBarFont(ofSize: pointSize)
			case .message:  base = NSFont.messageFont(ofSize: pointSize)
			case .monospacedDigit:  base = NSFont.monospacedDigitSystemFont(ofSize: pointSize, weight: weight)
			case .palette:  base = NSFont.paletteFont(ofSize: pointSize)
			case .system:  base = NSFont.systemFont(ofSize: pointSize)
			case .titleBar:  base = NSFont.titleBarFont(ofSize: pointSize)
			case .toolTips:  base = NSFont.toolTipsFont(ofSize: pointSize)
			}

			let traits: [NSFontDescriptor.TraitKey: Any] = [.weight: weight, .slant: slant]
			let modified = base.fontDescriptor.addingAttributes([.traits: traits])
			
			return NSFont(descriptor: modified, size: 0) ?? base
		}
	}
#endif

// MARK: - Binder Part 1: Binder
class ExtendedView&lt;Subclass: Layout.View &amp; ViewWithDelegate &amp; HasDelegate&gt;: Binder, ViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

extension ExtendedView where Subclass == CwlExtendedView {
	convenience init(bindings: [Preparer.Binding]) {
		self.init(type: CwlExtendedView.self, parameters: (), bindings: bindings)
	}
	
	convenience init(_ bindings: Preparer.Binding...) {
		self.init(type: CwlExtendedView.self, parameters: (), bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ExtendedView {
	enum Binding: ExtendedViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		@available(macOS 10.10, *) @available(iOS, unavailable) case backgroundColor(Dynamic&lt;NSColor?&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case sizeDidChange(SignalInput&lt;CGSize&gt;)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	#if os(macOS)
		typealias NSColor = AppKit.NSColor
	#else
		typealias NSColor = ()
	#endif
}

// MARK: - Binder Part 3: Preparer
extension ExtendedView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = ExtendedView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = Subclass
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ExtendedView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .sizeDidChange(let x): delegate().addMultiHandler1({ s in x.send(value: s) }, #selector(ViewDelegate.layoutSubviews(view:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .backgroundColor(let x):
			return x.apply(instance) { i, v in
				#if os(macOS)
					i.backgroundColor = v
				#endif
			}
		case .sizeDidChange: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ExtendedView.Preparer {
	class Storage: View.Preparer.Storage, ViewDelegate {}
	
	class Delegate: DynamicDelegate, ViewDelegate {
		func layoutSubviews(view: Layout.View) {
			multiHandler(view.bounds.size)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ExtendedViewBinding {
	typealias ExtendedViewName&lt;V&gt; = BindingName&lt;V, ExtendedView&lt;Binding.SubclassType&gt;.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; ExtendedView&lt;Binding.SubclassType&gt;.Binding) -&gt; ExtendedViewName&lt;V&gt; {
		return ExtendedViewName&lt;V&gt;(source: source, downcast: Binding.extendedViewBinding)
	}
}
extension BindingName where Binding: ExtendedViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ExtendedViewName&lt;$2&gt; { return .name(ExtendedView.Binding.$1) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	#if os(macOS)
		static var backgroundColor: ExtendedViewName&lt;Dynamic&lt;NSColor?&gt;&gt; { return .name(ExtendedView.Binding.backgroundColor) }
	#endif
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var sizeDidChange: ExtendedViewName&lt;SignalInput&lt;CGSize&gt;&gt; { return .name(ExtendedView.Binding.sizeDidChange) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension ExtendedView {
	#if os(iOS)
		func uiView() -&gt; View.Instance { return instance() }
	#elseif os(macOS)
		func nsView() -&gt; View.Instance { return instance() }
	#endif
}

// MARK: - Binder Part 8: Downcast protocols
protocol ExtendedViewBinding: ViewBinding {
	associatedtype SubclassType: Layout.View &amp; ViewWithDelegate &amp; HasDelegate
	static func extendedViewBinding(_ binding: ExtendedView&lt;SubclassType&gt;.Binding) -&gt; Self
	func asExtendedViewBinding() -&gt; ExtendedView&lt;SubclassType&gt;.Binding?
}
extension ExtendedViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return extendedViewBinding(.inheritedBinding(binding))
	}
}
extension ExtendedViewBinding where Preparer.Inherited.Binding: ExtendedViewBinding, Preparer.Inherited.Binding.SubclassType == SubclassType {
	func asExtendedViewBinding() -&gt; ExtendedView&lt;SubclassType&gt;.Binding? {
		return asInheritedBinding()?.asExtendedViewBinding()
	}
}
extension ExtendedView.Binding {
	typealias Preparer = ExtendedView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asExtendedViewBinding() -&gt; ExtendedView.Binding? { return self }
	static func extendedViewBinding(_ binding: ExtendedView.Binding) -&gt; ExtendedView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
@objc protocol ViewDelegate: class {
	@objc optional func layoutSubviews(view: Layout.View)
}

protocol ViewWithDelegate: class {
	var delegate: ViewDelegate? { get set }

	#if os(macOS)
		var backgroundColor: NSColor? { get set }
	#endif
}

#if os(macOS)
	extension ViewWithDelegate {
		// This default implementation is so that you're not required to implement `backgroundColor` to implement an ExtendedView
		var backgroundColor: NSColor? {
			get {
				return ((self as? NSView)?.layer?.backgroundColor).flatMap { NSColor(cgColor: $0) }
			}
			set {
				if let layer = (self as? NSView)?.layer {
					layer.backgroundColor = newValue?.cgColor 
				}
			}
		}
	}
#endif

/// Implementation of ViewWithDelegate on top of the base UIView.
/// You can use this view directly, subclass it or implement `ViewWithDelegate` and `HasDelegate` on top of another `UIView` to use that view with the `ExtendedView` binder.
class CwlExtendedView: Layout.View, ViewWithDelegate, HasDelegate {
	unowned var delegate: ViewDelegate?
	
	#if os(macOS)
		var backgroundColor: NSColor?
	
		override func draw(_ dirtyRect: NSRect) {
			super.draw(dirtyRect)
			
			if let backgroundColor = backgroundColor {
				backgroundColor.setFill()
				dirtyRect.fill()
			}
		}
	#endif
	
	#if os(iOS)
		override func layoutSubviews() {
			delegate?.layoutSubviews?(view: self)
			super.layoutSubviews()
		}
	#elseif os(macOS)
		override func layout() {
			delegate?.layoutSubviews?(view: self)
			super.layout()
		}
	#endif
}

// MARK: - Binder Part 1: Binder
class GradientLayer: Binder, GradientLayerConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension GradientLayer {
	enum Binding: GradientLayerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case colors(Dynamic&lt;[CGColor]&gt;)
		case locations(Dynamic&lt;[CGFloat]&gt;)
		case endPoint(Dynamic&lt;CGPoint&gt;)
		case startPoint(Dynamic&lt;CGPoint&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension GradientLayer {
	struct Preparer: BinderDelegateDerived {
		typealias Binding = GradientLayer.Binding
		typealias Delegate = Inherited.Delegate
		typealias Inherited = Layer.Preparer
		typealias Instance = CAGradientLayer
		
		var inherited: Inherited
		init(delegateClass: Delegate.Type) {
			inherited = Inherited(delegateClass: delegateClass)
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension GradientLayer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .colors(let x): return x.apply(instance) { i, v in i.colors = v }
		case .locations(let x): return x.apply(instance) { i, v in i.locations = v.map { NSNumber(value: Double($0)) } }
		case .endPoint(let x): return x.apply(instance) { i, v in i.endPoint = v }
		case .startPoint(let x): return x.apply(instance) { i, v in i.startPoint = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension GradientLayer.Preparer {
	typealias Storage = Layer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: GradientLayerBinding {
	typealias GradientLayerName&lt;V&gt; = BindingName&lt;V, GradientLayer.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; GradientLayer.Binding) -&gt; GradientLayerName&lt;V&gt; {
		return GradientLayerName&lt;V&gt;(source: source, downcast: Binding.gradientLayerBinding)
	}
}
extension BindingName where Binding: GradientLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: GradientLayerName&lt;$2&gt; { return .name(GradientLayer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var colors: GradientLayerName&lt;Dynamic&lt;[CGColor]&gt;&gt; { return .name(GradientLayer.Binding.colors) }
	static var locations: GradientLayerName&lt;Dynamic&lt;[CGFloat]&gt;&gt; { return .name(GradientLayer.Binding.locations) }
	static var endPoint: GradientLayerName&lt;Dynamic&lt;CGPoint&gt;&gt; { return .name(GradientLayer.Binding.endPoint) }
	static var startPoint: GradientLayerName&lt;Dynamic&lt;CGPoint&gt;&gt; { return .name(GradientLayer.Binding.startPoint) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol GradientLayerConvertible: LayerConvertible {
	func caGradientLayer() -&gt; GradientLayer.Instance
}
extension GradientLayerConvertible {
	func caLayer() -&gt; Layer.Instance { return caGradientLayer() }
}
extension CAGradientLayer: GradientLayerConvertible {
	func caGradientLayer() -&gt; GradientLayer.Instance { return self }
}
extension GradientLayer {
	func caGradientLayer() -&gt; GradientLayer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol GradientLayerBinding: LayerBinding {
	static func gradientLayerBinding(_ binding: GradientLayer.Binding) -&gt; Self
	func asGradientLayerBinding() -&gt; GradientLayer.Binding?
}
extension GradientLayerBinding {
	static func layerBinding(_ binding: Layer.Binding) -&gt; Self {
		return gradientLayerBinding(.inheritedBinding(binding))
	}
}
extension GradientLayerBinding where Preparer.Inherited.Binding: GradientLayerBinding {
	func asGradientLayerBinding() -&gt; GradientLayer.Binding? {
		return asInheritedBinding()?.asGradientLayerBinding()
	}
}
extension GradientLayer.Binding {
	typealias Preparer = GradientLayer.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asGradientLayerBinding() -&gt; GradientLayer.Binding? { return self }
	static func gradientLayerBinding(_ binding: GradientLayer.Binding) -&gt; GradientLayer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

// MARK: - Binder Part 1: Binder
class Layer: Binder, LayerConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Layer {
	enum Binding: LayerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case actions(Dynamic&lt;[String: SignalInput&lt;[AnyHashable: Any]?&gt;?]&gt;)
		case affineTransform(Dynamic&lt;CGAffineTransform&gt;)
		case anchorPoint(Dynamic&lt;CGPoint&gt;)
		case anchorPointZ(Dynamic&lt;CGFloat&gt;)
		case backgroundColor(Dynamic&lt;CGColor&gt;)
		case borderColor(Dynamic&lt;CGColor&gt;)
		case borderWidth(Dynamic&lt;CGFloat&gt;)
		case bounds(Dynamic&lt;CGRect&gt;)
		case contents(Dynamic&lt;Any?&gt;)
		case contentsCenter(Dynamic&lt;CGRect&gt;)
		case contentsGravity(Dynamic&lt;CALayerContentsGravity&gt;)
		case contentsRect(Dynamic&lt;CGRect&gt;)
		case contentsScale(Dynamic&lt;CGFloat&gt;)
		case cornerRadius(Dynamic&lt;CGFloat&gt;)
		case drawsAsynchronously(Dynamic&lt;Bool&gt;)
		case edgeAntialiasingMask(Dynamic&lt;CAEdgeAntialiasingMask&gt;)
		case frame(Dynamic&lt;CGRect&gt;)
		case isDoubleSided(Dynamic&lt;Bool&gt;)
		case isGeometryFlipped(Dynamic&lt;Bool&gt;)
		case isHidden(Dynamic&lt;Bool&gt;)
		case isOpaque(Dynamic&lt;Bool&gt;)
		case magnificationFilter(Dynamic&lt;CALayerContentsFilter&gt;)
		case mask(Dynamic&lt;LayerConvertible?&gt;)
		case masksToBounds(Dynamic&lt;Bool&gt;)
		case minificationFilter(Dynamic&lt;CALayerContentsFilter&gt;)
		case minificationFilterBias(Dynamic&lt;Float&gt;)
		case name(Dynamic&lt;String&gt;)
		case needsDisplayOnBoundsChange(Dynamic&lt;Bool&gt;)
		case opacity(Dynamic&lt;Float&gt;)
		case position(Dynamic&lt;CGPoint&gt;)
		case rasterizationScale(Dynamic&lt;CGFloat&gt;)
		case shadowColor(Dynamic&lt;CGColor?&gt;)
		case shadowOffset(Dynamic&lt;CGSize&gt;)
		case shadowOpacity(Dynamic&lt;Float&gt;)
		case shadowPath(Dynamic&lt;CGPath?&gt;)
		case shadowRadius(Dynamic&lt;CGFloat&gt;)
		case shouldRasterize(Dynamic&lt;Bool&gt;)
		case style(Dynamic&lt;[AnyHashable: Any]&gt;)
		case sublayers(Dynamic&lt;[LayerConvertible]&gt;)
		case sublayerTransform(Dynamic&lt;CATransform3D&gt;)
		case transform(Dynamic&lt;CATransform3D&gt;)
		case zPosition(Dynamic&lt;CGFloat&gt;)

		@available(macOS 10.13, *) @available(iOS, unavailable) case autoresizingMask(Dynamic&lt;CAAutoresizingMask&gt;)
		@available(macOS 10.13, *) @available(iOS, unavailable) case backgroundFilters(Dynamic&lt;[CIFilter]?&gt;)
		@available(macOS 10.13, *) @available(iOS, unavailable) case compositingFilter(Dynamic&lt;CIFilter?&gt;)
		@available(macOS 10.13, *) @available(iOS, unavailable) case constraints(Dynamic&lt;[CAConstraint]&gt;)
		@available(macOS 10.13, *) @available(iOS, unavailable) case filters(Dynamic&lt;[CIFilter]?&gt;)

		//	2. Signal bindings are performed on the object after construction.
		case addAnimation(Signal&lt;AnimationForKey&gt;)
		case needsDisplay(Signal&lt;Void&gt;)
		case needsDisplayInRect(Signal&lt;CGRect&gt;)
		case removeAllAnimations(Signal&lt;Void&gt;)
		case removeAnimationForKey(Signal&lt;String&gt;)
		case scrollRectToVisible(Signal&lt;CGRect&gt;)

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case display((CALayer) -&gt; Void)
		case draw((CALayer, CGContext) -&gt; Void)
		case layoutSublayers((CALayer) -&gt; Void)
		case willDraw((CALayer) -&gt; Void)
	}

	#if os(macOS)
		typealias CAAutoresizingMask = QuartzCore.CAAutoresizingMask
		typealias CIFilter = QuartzCore.CIFilter
		typealias CAConstraint = QuartzCore.CAConstraint
	#else
		typealias CAConstraint = ()
		typealias CAAutoresizingMask = ()
		typealias CIFilter = ()
	#endif
}

// MARK: - Binder Part 3: Preparer
extension Layer {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = Layer.Binding
		typealias Inherited = BinderBase
		typealias Instance = CALayer
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Layer.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .display(let x): delegate().addMultiHandler1(x, #selector(CALayerDelegate.display(_:)))
		case .draw(let x): delegate().addMultiHandler2(x, #selector(CALayerDelegate.draw(_:in:)))
		case .willDraw(let x): delegate().addMultiHandler1(x, #selector(CALayerDelegate.layerWillDraw(_:)))
		case .layoutSublayers(let x): delegate().addMultiHandler1(x, #selector(CALayerDelegate.layoutSublayers(of:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .actions(let x):
			return x.apply(instance, storage) { i, s, v in
				var actions = i.actions ?? [String: CAAction]()
				for (key, input) in v {
					if let i = input {
						actions[key] = s
						storage.layerActions[key] = i
					} else {
						actions[key] = NSNull()
						s.layerActions.removeValue(forKey: key)
					}
				}
				i.actions = actions
			}
		case .affineTransform(let x): return x.apply(instance) { i, v in i.setAffineTransform(v) }
		case .anchorPoint(let x): return x.apply(instance) { i, v in i.anchorPoint = v }
		case .anchorPointZ(let x): return x.apply(instance) { i, v in i.anchorPointZ = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .borderColor(let x): return x.apply(instance) { i, v in i.borderColor = v }
		case .borderWidth(let x): return x.apply(instance) { i, v in i.borderWidth = v }
		case .bounds(let x): return x.apply(instance) { i, v in i.bounds = v }
		case .contents(let x): return x.apply(instance) { i, v in i.contents = v }
		case .contentsCenter(let x): return x.apply(instance) { i, v in i.contentsCenter = v }
		case .contentsGravity(let x): return x.apply(instance) { i, v in i.contentsGravity = v }
		case .contentsRect(let x): return x.apply(instance) { i, v in i.contentsRect = v }
		case .contentsScale(let x): return x.apply(instance) { i, v in i.contentsScale = v }
		case .cornerRadius(let x): return x.apply(instance) { i, v in i.cornerRadius = v }
		case .drawsAsynchronously(let x): return x.apply(instance) { i, v in i.drawsAsynchronously = v }
		case .edgeAntialiasingMask(let x): return x.apply(instance) { i, v in i.edgeAntialiasingMask = v }
		case .frame(let x): return x.apply(instance) { i, v in i.frame = v }
		case .isDoubleSided(let x): return x.apply(instance) { i, v in i.isDoubleSided = v }
		case .isGeometryFlipped(let x): return x.apply(instance) { i, v in i.isGeometryFlipped = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .isOpaque(let x): return x.apply(instance) { i, v in i.isOpaque = v }
		case .magnificationFilter(let x): return x.apply(instance) { i, v in i.magnificationFilter = v }
		case .mask(let x): return x.apply(instance) { i, v in i.mask = v?.caLayer() }
		case .masksToBounds(let x): return x.apply(instance) { i, v in i.masksToBounds = v }
		case .minificationFilter(let x): return x.apply(instance) { i, v in i.minificationFilter = v }
		case .minificationFilterBias(let x): return x.apply(instance) { i, v in i.minificationFilterBias = v }
		case .name(let x): return x.apply(instance) { i,v in i.name = v }
		case .needsDisplayOnBoundsChange(let x): return x.apply(instance) { i, v in i.needsDisplayOnBoundsChange = v }
		case .opacity(let x): return x.apply(instance) { i, v in i.opacity = v }
		case .position(let x): return x.apply(instance) { i, v in i.position = v }
		case .rasterizationScale(let x): return x.apply(instance) { i, v in i.rasterizationScale = v }
		case .shadowColor(let x): return x.apply(instance) { i, v in i.shadowColor = v }
		case .shadowOffset(let x): return x.apply(instance) { i, v in i.shadowOffset = v }
		case .shadowOpacity(let x): return x.apply(instance) { i, v in i.shadowOpacity = v }
		case .shadowPath(let x): return x.apply(instance) { i, v in i.shadowPath = v }
		case .shadowRadius(let x): return x.apply(instance) { i, v in i.shadowRadius = v }
		case .shouldRasterize(let x): return x.apply(instance) { i, v in i.shouldRasterize = v }
		case .style(let x): return x.apply(instance) { i,v in i.style = v }
		case .sublayers(let x): return x.apply(instance) { i, v in i.sublayers = v.map { $0.caLayer() } }
		case .sublayerTransform(let x): return x.apply(instance) { i, v in i.sublayerTransform = v }
		case .transform(let x): return x.apply(instance) { i, v in i.transform = v }
		case .zPosition(let x): return x.apply(instance) { i, v in i.zPosition = v }
		
		case .autoresizingMask(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.autoresizingMask = v }
			#else
				return nil
			#endif
		case .backgroundFilters(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.backgroundFilters = v }
			#else
				return nil
			#endif
		case .compositingFilter(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.compositingFilter = v }
			#else
				return nil
			#endif
		case .constraints(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.constraints = v }
			#else
				return nil
			#endif
		case .filters(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.filters = v }
			#else
				return nil
			#endif

		//	2. Signal bindings are performed on the object after construction.
		case .addAnimation(let x): return x.apply(instance) { i, v in i.addAnimationForKey(v) }
		case .needsDisplay(let x): return x.apply(instance) { i, v in i.setNeedsDisplay() }
		case .needsDisplayInRect(let x): return x.apply(instance) { i, v in i.setNeedsDisplay(v) }
		case .removeAllAnimations(let x): return x.apply(instance) { i, v in i.removeAllAnimations() }
		case .removeAnimationForKey(let x): return x.apply(instance) { i, v in i.removeAnimation(forKey: v) }
		case .scrollRectToVisible(let x): return x.apply(instance) { i, v in i.scrollRectToVisible(v) }

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .display: return nil
		case .draw: return nil
		case .layoutSublayers: return nil
		case .willDraw: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Layer.Preparer {
	class Storage: AssociatedBinderStorage, CAAction, CALayerDelegate {
		// LayerBinderStorage implementation
		var layerActions = [String: SignalInput&lt;[AnyHashable: Any]?&gt;]()
		@objc func run(forKey event: String, object anObject: Any, arguments dict: [AnyHashable: Any]?) {
			_ = layerActions[event]?.send(value: dict)
		}

		func action(for layer: CALayer, forKey event: String) -&gt; CAAction? {
			return layerActions[event] != nil ? self : nil
		}
	}
	
	class Delegate: DynamicDelegate, CALayerDelegate {
		func layerWillDraw(_ layer: CALayer) {
			multiHandler(layer)
		}
		
		func display(_ layer: CALayer) {
			multiHandler(layer)
		}
		
		@objc(drawLayer:inContext:) func draw(_ layer: CALayer, in ctx: CGContext) {
			multiHandler(layer, ctx)
		}
		
		func layoutSublayers(of layer: CALayer) {
			multiHandler(layer)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: LayerBinding {
	typealias LayerName&lt;V&gt; = BindingName&lt;V, Layer.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; Layer.Binding) -&gt; LayerName&lt;V&gt; {
		return LayerName&lt;V&gt;(source: source, downcast: Binding.layerBinding)
	}
}
extension BindingName where Binding: LayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: LayerName&lt;$2&gt; { return .name(Layer.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var actions: LayerName&lt;Dynamic&lt;[String: SignalInput&lt;[AnyHashable: Any]?&gt;?]&gt;&gt; { return .name(Layer.Binding.actions) }
	static var affineTransform: LayerName&lt;Dynamic&lt;CGAffineTransform&gt;&gt; { return .name(Layer.Binding.affineTransform) }
	static var anchorPoint: LayerName&lt;Dynamic&lt;CGPoint&gt;&gt; { return .name(Layer.Binding.anchorPoint) }
	static var anchorPointZ: LayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(Layer.Binding.anchorPointZ) }
	static var backgroundColor: LayerName&lt;Dynamic&lt;CGColor&gt;&gt; { return .name(Layer.Binding.backgroundColor) }
	static var borderColor: LayerName&lt;Dynamic&lt;CGColor&gt;&gt; { return .name(Layer.Binding.borderColor) }
	static var borderWidth: LayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(Layer.Binding.borderWidth) }
	static var bounds: LayerName&lt;Dynamic&lt;CGRect&gt;&gt; { return .name(Layer.Binding.bounds) }
	static var contents: LayerName&lt;Dynamic&lt;Any?&gt;&gt; { return .name(Layer.Binding.contents) }
	static var contentsCenter: LayerName&lt;Dynamic&lt;CGRect&gt;&gt; { return .name(Layer.Binding.contentsCenter) }
	static var contentsGravity: LayerName&lt;Dynamic&lt;CALayerContentsGravity&gt;&gt; { return .name(Layer.Binding.contentsGravity) }
	static var contentsRect: LayerName&lt;Dynamic&lt;CGRect&gt;&gt; { return .name(Layer.Binding.contentsRect) }
	static var contentsScale: LayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(Layer.Binding.contentsScale) }
	static var cornerRadius: LayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(Layer.Binding.cornerRadius) }
	static var drawsAsynchronously: LayerName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Layer.Binding.drawsAsynchronously) }
	static var edgeAntialiasingMask: LayerName&lt;Dynamic&lt;CAEdgeAntialiasingMask&gt;&gt; { return .name(Layer.Binding.edgeAntialiasingMask) }
	static var frame: LayerName&lt;Dynamic&lt;CGRect&gt;&gt; { return .name(Layer.Binding.frame) }
	static var isDoubleSided: LayerName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Layer.Binding.isDoubleSided) }
	static var isGeometryFlipped: LayerName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Layer.Binding.isGeometryFlipped) }
	static var isHidden: LayerName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Layer.Binding.isHidden) }
	static var isOpaque: LayerName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Layer.Binding.isOpaque) }
	static var magnificationFilter: LayerName&lt;Dynamic&lt;CALayerContentsFilter&gt;&gt; { return .name(Layer.Binding.magnificationFilter) }
	static var mask: LayerName&lt;Dynamic&lt;LayerConvertible?&gt;&gt; { return .name(Layer.Binding.mask) }
	static var masksToBounds: LayerName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Layer.Binding.masksToBounds) }
	static var minificationFilter: LayerName&lt;Dynamic&lt;CALayerContentsFilter&gt;&gt; { return .name(Layer.Binding.minificationFilter) }
	static var minificationFilterBias: LayerName&lt;Dynamic&lt;Float&gt;&gt; { return .name(Layer.Binding.minificationFilterBias) }
	static var name: LayerName&lt;Dynamic&lt;String&gt;&gt; { return .name(Layer.Binding.name) }
	static var needsDisplayOnBoundsChange: LayerName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Layer.Binding.needsDisplayOnBoundsChange) }
	static var opacity: LayerName&lt;Dynamic&lt;Float&gt;&gt; { return .name(Layer.Binding.opacity) }
	static var position: LayerName&lt;Dynamic&lt;CGPoint&gt;&gt; { return .name(Layer.Binding.position) }
	static var rasterizationScale: LayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(Layer.Binding.rasterizationScale) }
	static var shadowColor: LayerName&lt;Dynamic&lt;CGColor?&gt;&gt; { return .name(Layer.Binding.shadowColor) }
	static var shadowOffset: LayerName&lt;Dynamic&lt;CGSize&gt;&gt; { return .name(Layer.Binding.shadowOffset) }
	static var shadowOpacity: LayerName&lt;Dynamic&lt;Float&gt;&gt; { return .name(Layer.Binding.shadowOpacity) }
	static var shadowPath: LayerName&lt;Dynamic&lt;CGPath?&gt;&gt; { return .name(Layer.Binding.shadowPath) }
	static var shadowRadius: LayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(Layer.Binding.shadowRadius) }
	static var shouldRasterize: LayerName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Layer.Binding.shouldRasterize) }
	static var style: LayerName&lt;Dynamic&lt;[AnyHashable: Any]&gt;&gt; { return .name(Layer.Binding.style) }
	static var sublayers: LayerName&lt;Dynamic&lt;[LayerConvertible]&gt;&gt; { return .name(Layer.Binding.sublayers) }
	static var sublayerTransform: LayerName&lt;Dynamic&lt;CATransform3D&gt;&gt; { return .name(Layer.Binding.sublayerTransform) }
	static var transform: LayerName&lt;Dynamic&lt;CATransform3D&gt;&gt; { return .name(Layer.Binding.transform) }
	static var zPosition: LayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(Layer.Binding.zPosition) }
	
	@available(macOS 10.13, *) @available(iOS, unavailable) static var autoresizingMask: LayerName&lt;Dynamic&lt;Layer.CAAutoresizingMask&gt;&gt; { return .name(Layer.Binding.autoresizingMask) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var backgroundFilters: LayerName&lt;Dynamic&lt;[Layer.CIFilter]?&gt;&gt; { return .name(Layer.Binding.backgroundFilters) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var compositingFilter: LayerName&lt;Dynamic&lt;Layer.CIFilter?&gt;&gt; { return .name(Layer.Binding.compositingFilter) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var constraints: LayerName&lt;Dynamic&lt;[Layer.CAConstraint]&gt;&gt; { return .name(Layer.Binding.constraints) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var filters: LayerName&lt;Dynamic&lt;[Layer.CIFilter]?&gt;&gt; { return .name(Layer.Binding.filters) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var addAnimation: LayerName&lt;Signal&lt;AnimationForKey&gt;&gt; { return .name(Layer.Binding.addAnimation) }
	static var needsDisplay: LayerName&lt;Signal&lt;Void&gt;&gt; { return .name(Layer.Binding.needsDisplay) }
	static var needsDisplayInRect: LayerName&lt;Signal&lt;CGRect&gt;&gt; { return .name(Layer.Binding.needsDisplayInRect) }
	static var removeAllAnimations: LayerName&lt;Signal&lt;Void&gt;&gt; { return .name(Layer.Binding.removeAllAnimations) }
	static var removeAnimationForKey: LayerName&lt;Signal&lt;String&gt;&gt; { return .name(Layer.Binding.removeAnimationForKey) }
	static var scrollRectToVisible: LayerName&lt;Signal&lt;CGRect&gt;&gt; { return .name(Layer.Binding.scrollRectToVisible) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var display: LayerName&lt;(CALayer) -&gt; Void&gt; { return .name(Layer.Binding.display) }
	static var draw: LayerName&lt;(CALayer, CGContext) -&gt; Void&gt; { return .name(Layer.Binding.draw) }
	static var layoutSublayers: LayerName&lt;(CALayer) -&gt; Void&gt; { return .name(Layer.Binding.layoutSublayers) }
	static var willDraw: LayerName&lt;(CALayer) -&gt; Void&gt; { return .name(Layer.Binding.willDraw) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol LayerConvertible {
	func caLayer() -&gt; Layer.Instance
}
extension CALayer: LayerConvertible, HasDelegate, DefaultConstructable {
	func caLayer() -&gt; Layer.Instance { return self }
}
extension Layer {
	 func caLayer() -&gt; Layer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol LayerBinding: BinderBaseBinding {
	static func layerBinding(_ binding: Layer.Binding) -&gt; Self
	func asLayerBinding() -&gt; Layer.Binding?
}
extension LayerBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return layerBinding(.inheritedBinding(binding))
	}
}
extension LayerBinding where Preparer.Inherited.Binding: LayerBinding {
	func asLayerBinding() -&gt; Layer.Binding? {
		return asInheritedBinding()?.asLayerBinding()
	}
}
extension Layer.Binding {
	typealias Preparer = Layer.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asLayerBinding() -&gt; Layer.Binding? { return self }
	static func layerBinding(_ binding: Layer.Binding) -&gt; Layer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct AnimationForKey {
	let animation: CAAnimation
	let key: String?
	
	init(animation: CAAnimation, forKey: String? = nil) {
		self.animation = animation
		self.key = forKey
	}
	
	static var fade: AnimationForKey {
		let t = CATransition()
		t.type = CATransitionType.fade
		
		// NOTE: fade animations are always applied under key kCATransition so it's pointless trying to set a key
		return AnimationForKey(animation: t, forKey: nil)
	}
	
	enum Direction {
		case left, right, top, bottom
		func transition(ofType: CATransitionType, forKey: String? = nil) -&gt; AnimationForKey {
			let t = CATransition()
			t.type = ofType
			switch self {
			case .left: t.subtype = CATransitionSubtype.fromLeft
			case .right: t.subtype = CATransitionSubtype.fromRight
			case .top: t.subtype = CATransitionSubtype.fromTop
			case .bottom: t.subtype = CATransitionSubtype.fromBottom
			}
			return AnimationForKey(animation: t, forKey: forKey)
		}
	}
	
	static func moveIn(from: Direction, forKey: String? = nil) -&gt; AnimationForKey {
		return from.transition(ofType: CATransitionType.moveIn, forKey: forKey)
	}
	
	static func push(from: Direction, forKey: String? = nil) -&gt; AnimationForKey {
		return from.transition(ofType: CATransitionType.push, forKey: forKey)
	}
	
	static func reveal(from: Direction, forKey: String? = nil) -&gt; AnimationForKey {
		return from.transition(ofType: CATransitionType.reveal, forKey: forKey)
	}
}

extension CALayer {
	func addAnimationForKey(_ animationForKey: AnimationForKey) {
		add(animationForKey.animation, forKey: animationForKey.key)
	}
}

// MARK: - Binder Part 1: Binder
class ShapeLayer: Binder, ShapeLayerConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ShapeLayer {
	enum Binding: ShapeLayerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case fillColor(Dynamic&lt;CGColor?&gt;)
		case fillRule(Dynamic&lt;CAShapeLayerFillRule&gt;)
		case lineCap(Dynamic&lt;CAShapeLayerLineCap&gt;)
		case lineDashPattern(Dynamic&lt;[NSNumber]?&gt;)
		case lineDashPhase(Dynamic&lt;CGFloat&gt;)
		case lineJoin(Dynamic&lt;CAShapeLayerLineJoin&gt;)
		case lineWidth(Dynamic&lt;CGFloat&gt;)
		case miterLimit(Dynamic&lt;CGFloat&gt;)
		case path(Dynamic&lt;CGPath&gt;)
		case strokeColor(Dynamic&lt;CGColor?&gt;)
		case strokeEnd(Dynamic&lt;CGFloat&gt;)
		case strokeStart(Dynamic&lt;CGFloat&gt;)
		
		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension ShapeLayer {
	struct Preparer: BinderDelegateDerived {
		typealias Binding = ShapeLayer.Binding
		typealias Delegate = Inherited.Delegate
		typealias Inherited = Layer.Preparer
		typealias Instance = CAShapeLayer
		
		var inherited = Inherited()
		init(delegateClass: Delegate.Type) {
			inherited = Inherited(delegateClass: delegateClass)
		}
		
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ShapeLayer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .fillColor(let x): return x.apply(instance) { i, v in i.fillColor = v }
		case .fillRule(let x): return x.apply(instance) { i, v in i.fillRule = v }
		case .lineCap(let x): return x.apply(instance) { i, v in i.lineCap = v }
		case .lineDashPattern(let x): return x.apply(instance) { i, v in i.lineDashPattern = v }
		case .lineDashPhase(let x): return x.apply(instance) { i, v in i.lineDashPhase = v }
		case .lineJoin(let x): return x.apply(instance) { i, v in i.lineJoin = v }
		case .lineWidth(let x): return x.apply(instance) { i, v in i.lineWidth = v }
		case .miterLimit(let x): return x.apply(instance) { i, v in i.miterLimit = v }
		case .path(let x): return x.apply(instance) { i, v in i.path = v }
		case .strokeColor(let x): return x.apply(instance) { i, v in i.strokeColor = v }
		case .strokeEnd(let x): return x.apply(instance) { i, v in i.strokeEnd = v }
		case .strokeStart(let x): return x.apply(instance) { i, v in i.strokeStart = v }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ShapeLayer.Preparer {
	typealias Storage = Layer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ShapeLayerBinding {
	typealias ShapeLayerName&lt;V&gt; = BindingName&lt;V, ShapeLayer.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; ShapeLayer.Binding) -&gt; ShapeLayerName&lt;V&gt; {
		return ShapeLayerName&lt;V&gt;(source: source, downcast: Binding.shapeLayerBinding)
	}
}
extension BindingName where Binding: ShapeLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ShapeLayerName&lt;$2&gt; { return .name(ShapeLayer.Binding.$1) }
	static var fillColor: ShapeLayerName&lt;Dynamic&lt;CGColor?&gt;&gt; { return .name(ShapeLayer.Binding.fillColor) }
	static var fillRule: ShapeLayerName&lt;Dynamic&lt;CAShapeLayerFillRule&gt;&gt; { return .name(ShapeLayer.Binding.fillRule) }
	static var lineCap: ShapeLayerName&lt;Dynamic&lt;CAShapeLayerLineCap&gt;&gt; { return .name(ShapeLayer.Binding.lineCap) }
	static var lineDashPattern: ShapeLayerName&lt;Dynamic&lt;[NSNumber]?&gt;&gt; { return .name(ShapeLayer.Binding.lineDashPattern) }
	static var lineDashPhase: ShapeLayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ShapeLayer.Binding.lineDashPhase) }
	static var lineJoin: ShapeLayerName&lt;Dynamic&lt;CAShapeLayerLineJoin&gt;&gt; { return .name(ShapeLayer.Binding.lineJoin) }
	static var lineWidth: ShapeLayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ShapeLayer.Binding.lineWidth) }
	static var miterLimit: ShapeLayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ShapeLayer.Binding.miterLimit) }
	static var path: ShapeLayerName&lt;Dynamic&lt;CGPath&gt;&gt; { return .name(ShapeLayer.Binding.path) }
	static var strokeColor: ShapeLayerName&lt;Dynamic&lt;CGColor?&gt;&gt; { return .name(ShapeLayer.Binding.strokeColor) }
	static var strokeEnd: ShapeLayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ShapeLayer.Binding.strokeEnd) }
	static var strokeStart: ShapeLayerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ShapeLayer.Binding.strokeStart) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ShapeLayerConvertible: LayerConvertible {
	func caShapeLayer() -&gt; ShapeLayer.Instance
}
extension ShapeLayerConvertible {
	func caLayer() -&gt; Layer.Instance { return caShapeLayer() }
}
extension CAShapeLayer: ShapeLayerConvertible {
	func caShapeLayer() -&gt; ShapeLayer.Instance { return self }
}
extension ShapeLayer {
	func caShapeLayer() -&gt; ShapeLayer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ShapeLayerBinding: LayerBinding {
	static func shapeLayerBinding(_ binding: ShapeLayer.Binding) -&gt; Self
	func asShapeLayerBinding() -&gt; ShapeLayer.Binding?
}
extension ShapeLayerBinding {
	static func layerBinding(_ binding: Layer.Binding) -&gt; Self {
		return shapeLayerBinding(.inheritedBinding(binding))
	}
}
extension ShapeLayerBinding where Preparer.Inherited.Binding: ShapeLayerBinding {
	func asShapeLayerBinding() -&gt; ShapeLayer.Binding? {
		return asInheritedBinding()?.asShapeLayerBinding()
	}
}
extension ShapeLayer.Binding {
	typealias Preparer = ShapeLayer.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asShapeLayerBinding() -&gt; ShapeLayer.Binding? { return self }
	static func shapeLayerBinding(_ binding: ShapeLayer.Binding) -&gt; ShapeLayer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

// MARK: - Binder Part 1: Binder
class StackView: Binder, StackViewConvertible {
	#if os(macOS)
		typealias NSUIView = NSView
		typealias NSUIStackView = NSStackView
		typealias NSUIStackViewDistribution = NSStackView.Distribution
		typealias NSUIStackViewAlignment = NSLayoutConstraint.Attribute
		typealias NSUIUserInterfaceLayoutOrientation = NSUserInterfaceLayoutOrientation
		typealias NSUILayoutPriority = NSLayoutConstraint.Priority
	#else
		typealias NSUIView = UIView
		typealias NSUIStackView = UIStackView
		typealias NSUIStackViewDistribution = UIStackView.Distribution
		typealias NSUIStackViewAlignment = UIStackView.Alignment
		typealias NSUIUserInterfaceLayoutOrientation = NSLayoutConstraint.Axis
		typealias NSUILayoutPriority = UILayoutPriority
	#endif

	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension StackView {
	enum Binding: StackViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case alignment(Dynamic&lt;NSUIStackViewAlignment&gt;)
		case arrangedSubviews(Dynamic&lt;[ViewConvertible]&gt;)
		case axis(Dynamic&lt;NSUIUserInterfaceLayoutOrientation&gt;)
		case distribution(Dynamic&lt;NSUIStackViewDistribution&gt;)
		case spacing(Dynamic&lt;CGFloat&gt;)
		
		@available(macOS 10.13, *) @available(iOS, unavailable) case edgeInsets(Dynamic&lt;NSUIEdgeInsets&gt;)
		@available(macOS 10.13, *) @available(iOS, unavailable) case horizontalClippingResistance(Dynamic&lt;NSUILayoutPriority&gt;)
		@available(macOS 10.13, *) @available(iOS, unavailable) case horizontalHuggingPriority(Dynamic&lt;NSUILayoutPriority&gt;)
		@available(macOS, unavailable) @available(iOS 11, *) case isLayoutMarginsRelativeArrangement(Dynamic&lt;Bool&gt;)
		@available(macOS 10.13, *) @available(iOS, unavailable) case verticalClippingResistance(Dynamic&lt;NSUILayoutPriority&gt;)
		@available(macOS 10.13, *) @available(iOS, unavailable) case verticalHuggingPriority(Dynamic&lt;NSUILayoutPriority&gt;)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	#if os(macOS)
		typealias NSUIEdgeInsets = NSEdgeInsets
	#else
		typealias NSUIEdgeInsets = UIEdgeInsets
	#endif
}

// MARK: - Binder Part 3: Preparer
extension StackView {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = StackView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSUIStackView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension StackView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .alignment(let x): return x.apply(instance) { i, v in i.alignment = v }
		case .axis(let x):
			return x.apply(instance) { i, v in
				#if os(macOS)
					i.orientation = v
				#else
					i.axis = v
				#endif
			}
		case .arrangedSubviews(let x):
			return x.apply(instance) { i, v in
				i.arrangedSubviews.forEach { $0.removeFromSuperview() }
				#if os(macOS)
					v.forEach { i.addArrangedSubview($0.nsView()) }
				#else
					v.forEach { i.addArrangedSubview($0.uiView()) }
				#endif
			}
		case .distribution(let x): return x.apply(instance) { i, v in i.distribution = v }
		case .spacing(let x): return x.apply(instance) { i, v in i.spacing = v }

		case .edgeInsets(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.edgeInsets = v }
			#else
				return nil
			#endif
		case .horizontalClippingResistance(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setClippingResistancePriority(v, for: .horizontal) }
			#else
				return nil
			#endif
		case .horizontalHuggingPriority(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setHuggingPriority(v, for: .horizontal) }
			#else
				return nil
			#endif
		case .isLayoutMarginsRelativeArrangement(let x):
			#if os(macOS)
				return nil
			#else
				return x.apply(instance) { i, v in i.isLayoutMarginsRelativeArrangement = v }
			#endif
		case .verticalClippingResistance(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setClippingResistancePriority(v, for: .vertical) }
			#else
				return nil
			#endif
		case .verticalHuggingPriority(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setHuggingPriority(v, for: .vertical) }
			#else
				return nil
			#endif
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension StackView.Preparer {
	#if os(macOS)
		class Storage: View.Preparer.Storage {
			var gravity: NSStackView.Gravity = .center
		}
	#else
		typealias Storage = View.Preparer.Storage
	#endif
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: StackViewBinding {
	typealias StackViewName&lt;V&gt; = BindingName&lt;V, StackView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; StackView.Binding) -&gt; StackViewName&lt;V&gt; {
		return StackViewName&lt;V&gt;(source: source, downcast: Binding.stackViewBinding)
	}
}
extension BindingName where Binding: StackViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: StackViewName&lt;$2&gt; { return .name(StackView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alignment: StackViewName&lt;Dynamic&lt;StackView.NSUIStackViewAlignment&gt;&gt; { return .name(StackView.Binding.alignment) }
	static var arrangedSubviews: StackViewName&lt;Dynamic&lt;[ViewConvertible]&gt;&gt; { return .name(StackView.Binding.arrangedSubviews) }
	static var axis: StackViewName&lt;Dynamic&lt;StackView.NSUIUserInterfaceLayoutOrientation&gt;&gt; { return .name(StackView.Binding.axis) }
	static var distribution: StackViewName&lt;Dynamic&lt;StackView.NSUIStackViewDistribution&gt;&gt; { return .name(StackView.Binding.distribution) }
	static var spacing: StackViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(StackView.Binding.spacing) }
	
	@available(macOS 10.13, *) @available(iOS, unavailable) static var edgeInsets: StackViewName&lt;Dynamic&lt;StackView.NSUIEdgeInsets&gt;&gt; { return .name(StackView.Binding.edgeInsets) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var horizontalClippingResistance: StackViewName&lt;Dynamic&lt;StackView.NSUILayoutPriority&gt;&gt; { return .name(StackView.Binding.horizontalClippingResistance) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var horizontalHuggingPriority: StackViewName&lt;Dynamic&lt;StackView.NSUILayoutPriority&gt;&gt; { return .name(StackView.Binding.horizontalHuggingPriority) }
	@available(macOS, unavailable) @available(iOS 11, *) static var isLayoutMarginsRelativeArrangement: StackViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(StackView.Binding.isLayoutMarginsRelativeArrangement) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var verticalClippingResistance: StackViewName&lt;Dynamic&lt;StackView.NSUILayoutPriority&gt;&gt; { return .name(StackView.Binding.verticalClippingResistance) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var verticalHuggingPriority: StackViewName&lt;Dynamic&lt;StackView.NSUILayoutPriority&gt;&gt; { return .name(StackView.Binding.verticalHuggingPriority) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
#if os(macOS)
	protocol StackViewConvertible: ViewConvertible {
		func nsStackView() -&gt; StackView.Instance
	}
	extension StackViewConvertible {
		func nsView() -&gt; View.Instance { return nsStackView() }
	}
	extension NSStackView: StackViewConvertible {
		func nsStackView() -&gt; StackView.Instance { return self }
	}
	extension StackView {
		func nsStackView() -&gt; StackView.Instance { return instance() }
	}
#else
	protocol StackViewConvertible: ViewConvertible {
		func uiStackView() -&gt; StackView.Instance
	}
	extension StackViewConvertible {
		func uiView() -&gt; View.Instance { return uiStackView() }
	}
	extension UIStackView: StackViewConvertible {
		func uiStackView() -&gt; StackView.Instance { return self }
	}
	extension StackView {
		func uiStackView() -&gt; StackView.Instance { return instance() }
	}
#endif

// MARK: - Binder Part 8: Downcast protocols
protocol StackViewBinding: ViewBinding {
	static func stackViewBinding(_ binding: StackView.Binding) -&gt; Self
	func asStackViewBinding() -&gt; StackView.Binding?
}
extension StackViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return stackViewBinding(.inheritedBinding(binding))
	}
}
extension StackViewBinding where Preparer.Inherited.Binding: StackViewBinding {
	func asStackViewBinding() -&gt; StackView.Binding? {
		return asInheritedBinding()?.asStackViewBinding()
	}
}
extension StackView.Binding {
	typealias Preparer = StackView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asStackViewBinding() -&gt; StackView.Binding? { return self }
	static func stackViewBinding(_ binding: StackView.Binding) -&gt; StackView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

import WebKit

// MARK: - Binder Part 1: Binder
class WebView: Binder, WebViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	#if os(macOS)
		static func scrollEmbedded(type: WKWebView.Type = WKWebView.self, _ bindings: Binding...) -&gt; ScrollView {
			return ScrollView(
				.borderType -- .noBorder,
				.hasVerticalScroller -- true,
				.hasHorizontalScroller -- true,
				.autohidesScrollers -- true,
				.contentView -- ClipView(
					.documentView -- WebView(type: type, bindings: bindings)
				)
			)
		}
	#endif
}

// On macOS, `WebView` refers to WebKit.WebView until 10.14. This typealias can be used on macOS (or cross-platform scenarios) instead of `WebKit` to disambiguate, until the deployment target is 10.14 or higher.
typealias WebKitView = WebView

// MARK: - Binder Part 2: Binding
extension WebView {
	enum Binding: WebViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case allowsAirPlayForMediaPlayback(Constant&lt;Bool&gt;)
		case allowsInlineMediaPlayback(Constant&lt;Bool&gt;)
		case allowsPictureInPictureForMediaPlayback(Constant&lt;Bool&gt;)
		case applicationNameForUserAgent(Constant&lt;String?&gt;)
		case ignoresViewportScaleLimits(Constant&lt;Bool&gt;)
		case javaScriptCanOpenWindowsAutomatically(Constant&lt;Bool&gt;)
		case javaScriptEnabled(Constant&lt;Bool&gt;)
		case mediaTypesRequiringUserActionForPlayback(Constant&lt;WKAudiovisualMediaTypes&gt;)
		case minimumFontSize(Constant&lt;CGFloat&gt;)
		case processPool(Constant&lt;WKProcessPool&gt;)
		case suppressesIncrementalRendering(Constant&lt;Bool&gt;)
		case urlSchemeHandlers(Constant&lt;[String: WKURLSchemeHandler]&gt;)
		case userContentController(Constant&lt;WKUserContentController&gt;)

		@available(macOS 10.10, *) @available(iOS, unavailable) case javaEnabled(Constant&lt;Bool&gt;)
		@available(macOS 10.10, *) @available(iOS, unavailable) case plugInsEnabled(Constant&lt;Bool&gt;)
		@available(macOS 10.10, *) @available(iOS, unavailable) case tabFocusesLinks(Constant&lt;Bool&gt;)
		@available(macOS 10.12, *) @available(iOS, unavailable) case userInterfaceDirectionPolicy(Constant&lt;WKUserInterfaceDirectionPolicy&gt;)
		@available(macOS, unavailable) @available(iOS 9, *) case allowsPictureInPictureMediaPlayback(Constant&lt;Bool&gt;)
		@available(macOS, unavailable) @available(iOS 11, *) case scrollView(Constant&lt;ScrollView&gt;)
		@available(macOS, unavailable) @available(iOS 11, *) case dataDetectorTypes(Constant&lt;WKDataDetectorTypes&gt;)
		@available(macOS, unavailable) @available(iOS 11, *) case selectionGranularity(Constant&lt;WKSelectionGranularity&gt;)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsBackForwardNavigationGestures(Dynamic&lt;Bool&gt;)
		case allowsLinkPreview(Dynamic&lt;Bool&gt;)
		case customUserAgent(Dynamic&lt;String?&gt;)
		
		@available(macOS 10.13, *) @available(iOS, unavailable) case allowsMagnification(Dynamic&lt;Bool&gt;)
		@available(macOS 10.13, *) @available(iOS, unavailable) case magnification(Dynamic&lt;(factor: CGFloat, centeredAt: CGPoint)&gt;)
		
		//	2. Signal bindings are performed on the object after construction.
		case evaluateJavaScript(Signal&lt;Callback&lt;String, (Any?, Error?)&gt;&gt;)
		case goBack(Signal&lt;Callback&lt;Void, WKNavigation?&gt;&gt;)
		case goForward(Signal&lt;Callback&lt;Void, WKNavigation?&gt;&gt;)
		case goTo(Signal&lt;Callback&lt;WKBackForwardListItem, WKNavigation?&gt;&gt;)
		case load(Signal&lt;Callback&lt;URLRequest, WKNavigation?&gt;&gt;)
		case loadData(Signal&lt;Callback&lt;(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?&gt;&gt;)
		case loadFile(Signal&lt;Callback&lt;(url: URL, allowingReadAccessTo: URL), WKNavigation?&gt;&gt;)
		case loadHTMLString(Signal&lt;Callback&lt;(string: String, baseURL: URL?), WKNavigation?&gt;&gt;)
		case reload(Signal&lt;Callback&lt;Void, WKNavigation?&gt;&gt;)
		case reloadFromOrigin(Signal&lt;Callback&lt;Void, WKNavigation?&gt;&gt;)
		case stopLoading(Signal&lt;Void&gt;)
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case createWebView((_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -&gt; WKWebView?)
		case didClose((WKWebView) -&gt; Void)
		case didCommit((WKWebView, WKNavigation) -&gt; Void)
		case didStartProvisionalNavigation((WKWebView, WKNavigation) -&gt; Void)
		case didReceiveServerRedirectForProvisionalNavigation((WKWebView, WKNavigation) -&gt; Void)
		case didFail((WKWebView, WKNavigation, Error) -&gt; Void)
		case didFailProvisionalNavigation((WKWebView, WKNavigation, Error) -&gt; Void)
		case didFinish((WKWebView, WKNavigation) -&gt; Void)
		case contentProcessDidTerminate((WKWebView) -&gt; Void)
		case decideActionPolicy((WKWebView, WKNavigationAction, (WKNavigationActionPolicy) -&gt; Void) -&gt; Void)
		case decideResponsePolicy((WKWebView, WKNavigationResponse, (WKNavigationActionPolicy) -&gt; Void) -&gt; Void)
		case didReceiveAuthenticationChallenge((WKWebView, URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) -&gt; Void)
		case runJavaScriptAlertPanel((WKWebView, String, WKFrameInfo, () -&gt; Void) -&gt; Void)
		case runJavaScriptConfirmPanel((WKWebView, String, WKFrameInfo, (Bool) -&gt; Void) -&gt; Void)
		case runJavaScriptTextInputPanel((WKWebView, String, String?, WKFrameInfo, (String?) -&gt; Void) -&gt; Void)
		
		@available(macOS, unavailable) @available(iOS 10.0, *) case commitPreviewingViewController((_ webView: WKWebView, _ previewingViewController: UIViewController) -&gt; Void)
		@available(macOS, unavailable) @available(iOS 10.0, *) case previewingViewController((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -&gt; UIViewController?)
		@available(macOS 10.12, *) @available(iOS, unavailable) case runOpenPanel((WKWebView, WKOpenPanelParameters, WKFrameInfo, ([URL]?) -&gt; Void) -&gt; Void)
		@available(macOS, unavailable) @available(iOS 10.0, *) case shouldPreviewElement((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -&gt; Bool)
	}

	#if os(macOS)
		typealias UIViewController = ()
		typealias WKDataDetectorTypes = ()
		typealias WKPreviewElementInfo = ()
		typealias WKPreviewActionItem = ()
		typealias WKOpenPanelParameters = WebKit.WKOpenPanelParameters
		typealias WKSelectionGranularity = ()
		typealias WKUserInterfaceDirectionPolicy = WebKit.WKUserInterfaceDirectionPolicy
	#else
		typealias UIViewController = UIKit.UIViewController
		typealias WKDataDetectorTypes = WebKit.WKDataDetectorTypes
		typealias WKOpenPanelParameters = ()
		typealias WKPreviewElementInfo = WebKit.WKPreviewElementInfo
		typealias WKPreviewActionItem = WebKit.WKPreviewActionItem
		typealias WKSelectionGranularity = WebKit.WKSelectionGranularity
		typealias WKUserInterfaceDirectionPolicy = ()
	#endif
}

// MARK: - Binder Part 3: Preparer
extension WebView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = WebView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = WKWebView
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		mutating func webConfiguration() -&gt; WKWebViewConfiguration {
			if let pwc = possibleWebConfiguration {
				return pwc
			}
			let newConfiguration = WKWebViewConfiguration()
			possibleWebConfiguration = newConfiguration
			return newConfiguration
		}
		var possibleWebConfiguration: WKWebViewConfiguration?
		
		mutating func webPreferences() -&gt; WKPreferences {
			return webConfiguration().preferences
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension WebView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .allowsAirPlayForMediaPlayback(let x): webConfiguration().allowsAirPlayForMediaPlayback = x.value
		case .allowsInlineMediaPlayback(let x):
			#if os(iOS)
				webConfiguration().allowsInlineMediaPlayback = x.value
			#endif
		case .allowsPictureInPictureMediaPlayback(let x):
			#if os(iOS)
				webConfiguration().allowsPictureInPictureMediaPlayback = x.value
			#endif
		case .applicationNameForUserAgent(let x): webConfiguration().applicationNameForUserAgent = x.value
		case .dataDetectorTypes(let x): 
			#if os(iOS)
				webConfiguration().dataDetectorTypes = x.value
			#endif
		case .ignoresViewportScaleLimits(let x):
			#if os(iOS)
				webConfiguration().ignoresViewportScaleLimits = x.value
			#endif
		case .javaEnabled(let x):
			#if os(macOS)
				webPreferences().javaEnabled = x.value
			#endif
		case .javaScriptCanOpenWindowsAutomatically(let x): webPreferences().javaScriptCanOpenWindowsAutomatically = x.value
		case .javaScriptEnabled(let x): webPreferences().javaScriptEnabled = x.value
		case .mediaTypesRequiringUserActionForPlayback(let x): webConfiguration().mediaTypesRequiringUserActionForPlayback = x.value
		case .minimumFontSize(let x): webPreferences().minimumFontSize = x.value
		case .plugInsEnabled(let x):
			#if os(macOS)
				webPreferences().plugInsEnabled = x.value
			#endif
		case .processPool(let x): webConfiguration().processPool = x.value
		case .selectionGranularity(let x): 
			#if os(iOS)
				webConfiguration().selectionGranularity = x.value
			#endif
		case .suppressesIncrementalRendering(let x): webConfiguration().suppressesIncrementalRendering = x.value
		case .tabFocusesLinks(let x):
			#if os(macOS)
				webPreferences().tabFocusesLinks = x.value
			#endif
		case .urlSchemeHandlers(let x):
			for (key, value) in x.value {
				webConfiguration().setURLSchemeHandler(value, forURLScheme: key)
			}
		case .userContentController(let x): webConfiguration().userContentController = x.value

		case .didClose(let x): delegate().addMultiHandler1(x, #selector(WKUIDelegate.webViewDidClose(_:)))
		case .didCommit(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didCommit:)))
		case .didStartProvisionalNavigation(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didStartProvisionalNavigation:)))
		case .didReceiveServerRedirectForProvisionalNavigation(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didReceiveServerRedirectForProvisionalNavigation:)))
		case .didFail(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:didFail:withError:)))
		case .didFailProvisionalNavigation(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:didFailProvisionalNavigation:withError:)))
		case .didFinish(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didFinish:)))
		case .contentProcessDidTerminate(let x): delegate().addMultiHandler1(x, #selector(WKNavigationDelegate.webViewWebContentProcessDidTerminate(_:)))
		case .decideActionPolicy(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -&gt; (WKWebView,WKNavigationAction, @escaping (WKNavigationActionPolicy) -&gt; Void) -&gt; Void)?))
		case .decideResponsePolicy(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -&gt; (WKWebView, WKNavigationResponse, @escaping (WKNavigationResponsePolicy) -&gt; Void) -&gt; Void)?))
		case .didReceiveAuthenticationChallenge(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:didReceive:completionHandler:)))
		case .runJavaScriptAlertPanel(let x): delegate().addMultiHandler4(x, #selector(WKUIDelegate.webView(_:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:)))
		case .runJavaScriptConfirmPanel(let x): delegate().addMultiHandler4(x, #selector(WKUIDelegate.webView(_:runJavaScriptConfirmPanelWithMessage:initiatedByFrame:completionHandler:)))
		case .runJavaScriptTextInputPanel(let x): delegate().addMultiHandler5(x, #selector(WKUIDelegate.webView(_:runJavaScriptTextInputPanelWithPrompt:defaultText:initiatedByFrame:completionHandler:)))
		case .createWebView(let x): delegate().addSingleHandler4(x, #selector(WKUIDelegate.webView(_:createWebViewWith:for:windowFeatures:)))
		case .runOpenPanel(let x):
			#if os(macOS)
				delegate().addMultiHandler4(x, #selector(WKUIDelegate.webView(_:runOpenPanelWith:initiatedByFrame:completionHandler:)))
			#endif
		case .shouldPreviewElement(let x):
			#if os(iOS)
				delegate().addSingleHandler2(x, #selector(WKUIDelegate.webView(_:shouldPreviewElement:)))
			#endif
		case .previewingViewController(let x):
			#if os(iOS)
				delegate().addSingleHandler3(x, #selector(WKUIDelegate.webView(_:previewingViewControllerForElement:defaultActions:)))
			#endif
		case .commitPreviewingViewController(let x):
			#if os(iOS)
				delegate().addMultiHandler2(x, #selector(WKUIDelegate.webView(_:commitPreviewingViewController:)))
			#endif
		default: break
		}
	}
	
	func constructInstance(type: WKWebView.Type, parameters: ()) -&gt; WKWebView {
		if let configuration = possibleWebConfiguration {
			return type.init(frame: .zero, configuration: configuration)
		} else {
			return type.init(frame: .zero)
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		if delegateIsRequired {
			precondition(instance.uiDelegate == nil, "Conflicting delegate applied to instance")
			instance.uiDelegate = storage
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .allowsAirPlayForMediaPlayback: return nil
		case .allowsInlineMediaPlayback: return nil
		case .allowsPictureInPictureForMediaPlayback: return nil
		case .applicationNameForUserAgent: return nil
		case .dataDetectorTypes: return nil
		case .ignoresViewportScaleLimits: return nil
		case .javaScriptCanOpenWindowsAutomatically: return nil
		case .javaScriptEnabled: return nil
		case .mediaTypesRequiringUserActionForPlayback: return nil
		case .minimumFontSize: return nil
		case .processPool: return nil
		case .selectionGranularity: return nil
		case .suppressesIncrementalRendering: return nil
		case .urlSchemeHandlers: return nil
		case .userContentController: return nil
		case .javaEnabled: return nil
		case .plugInsEnabled: return nil
		case .tabFocusesLinks: return nil
		case .userInterfaceDirectionPolicy: return nil
		case .allowsPictureInPictureMediaPlayback: return nil
		
		case .scrollView(let x):
			#if os(macOS)
				return nil
			#else
				x.value.apply(to: instance.scrollView)
				return nil
			#endif
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .allowsBackForwardNavigationGestures(let x): return x.apply(instance) { i, v in i.allowsBackForwardNavigationGestures = v }
		
		case .allowsLinkPreview(let x):
			return x.apply(instance) { i, v in
				i.allowsLinkPreview = v
			}
		case .allowsMagnification(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.allowsMagnification = v }
			#else
				return nil
			#endif
		case .customUserAgent(let x):
			return x.apply(instance) { i, v in
				i.customUserAgent = v
			}
		case .magnification(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setMagnification(v.factor, centeredAt: v.centeredAt) }
			#else
				return nil
			#endif
		
		//	2. Signal bindings are performed on the object after construction.
		case .evaluateJavaScript(let x): return x.apply(instance) { i, v in i.evaluateJavaScript(v.value) { (output, error) in v.callback.send(value: (output, error)) } }
		case .goBack(let x): return x.apply(instance) { i, v in v.callback.send(value: i.goBack()) }
		case .goForward(let x):return x.apply(instance) { i, v in v.callback.send(value: i.goForward()) }
		case .goTo(let x): return x.apply(instance) { i, v in v.callback.send(value: i.go(to: v.value)) }
		case .load(let x): return x.apply(instance) { i, v in v.callback.send(value: i.load(v.value)) }
		case .loadHTMLString(let x): return x.apply(instance) { i, v in v.callback.send(value: i.loadHTMLString(v.value.string, baseURL: v.value.baseURL)) }
		case .reload(let x): return x.apply(instance) { i, v in v.callback.send(value: i.reload()) }
		case .reloadFromOrigin(let x): return x.apply(instance) { i, v in v.callback.send(value: i.reloadFromOrigin()) }
		case .stopLoading(let x): return x.apply(instance) { i, v in i.stopLoading() }

		case .loadData(let x): return x.apply(instance) { i, v in v.callback.send(value: i.load(v.value.data, mimeType: v.value.mimeType, characterEncodingName: v.value.characterEncodingName, baseURL: v.value.baseURL)) }
		case .loadFile(let x): return x.apply(instance) { i, v in v.callback.send(value: i.loadFileURL(v.value.url, allowingReadAccessTo: v.value.allowingReadAccessTo)) }
			
		//	3. Action bindings are triggered by the object after construction.
		case .contentProcessDidTerminate: return nil
		case .decideActionPolicy: return nil
		case .decideResponsePolicy: return nil
		case .didCommit: return nil
		case .didFail: return nil
		case .didFailProvisionalNavigation: return nil
		case .didFinish: return nil
		case .didReceiveAuthenticationChallenge: return nil
		case .didReceiveServerRedirectForProvisionalNavigation: return nil
		case .didStartProvisionalNavigation: return nil
		case .runJavaScriptAlertPanel: return nil
		case .runJavaScriptConfirmPanel: return nil
		case .runJavaScriptTextInputPanel: return nil

		case .didClose: return nil
		case .runOpenPanel: return nil

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .createWebView: return nil
		
		case .commitPreviewingViewController: return nil
		case .previewingViewController: return nil
		case .shouldPreviewElement: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension WebView.Preparer {
	class Storage: View.Preparer.Storage, WKUIDelegate, WKNavigationDelegate {}

	class Delegate: DynamicDelegate, WKUIDelegate, WKNavigationDelegate {
		func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
			multiHandler(webView, (navigation, error))
		}
		
		func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
			multiHandler(webView, (navigation, error))
		}
		
		func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
			multiHandler(webView, ())
		}
		
		func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) {
			multiHandler(webView, navigationAction, decisionHandler)
		}
		
		func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -&gt; Void) {
			multiHandler(webView, navigationResponse, decisionHandler)
		}
		
		func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) {
			multiHandler(webView, challenge, completionHandler)
		}
		
		func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -&gt; Void) {
			multiHandler(webView, message, frame, completionHandler)
		}
		
		func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -&gt; Void) {
			multiHandler(webView, message, frame, completionHandler)
		}
		
		func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -&gt; Void) {
			multiHandler(webView, prompt, defaultText, frame)
		}
		
		func webView(_ webView: WKWebView, createWebViewWith configuration: WKWebViewConfiguration, for navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures) -&gt; WKWebView? {
			return singleHandler(webView, configuration, navigationAction, windowFeatures)
		}

		func webViewDidClose(_ webView: WKWebView) {
			multiHandler(webView)
		}

		#if os(iOS)
			func webView(_ webView: WKWebView, shouldPreviewElement elementInfo: WKPreviewElementInfo) -&gt; Bool {
				return singleHandler(webView, elementInfo)
			}
			
			func webView(_ webView: WKWebView, commitPreviewingViewController previewingViewController: UIViewController) {
				multiHandler(webView, previewingViewController)
			}
			
			func webView(_ webView: WKWebView, previewingViewControllerForElement elementInfo: WKPreviewElementInfo, defaultActions previewActions: [WKPreviewActionItem]) -&gt; UIViewController? {
				return singleHandler(webView, elementInfo, previewActions)
			}
		#else
			func webView(_ webView: WKWebView, runOpenPanelWith parameters: WebView.WKOpenPanelParameters, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping ([URL]?) -&gt; Void) {
				multiHandler(webView, parameters, frame, completionHandler)
			}
		#endif
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: WebViewBinding {
	typealias WebViewName&lt;V&gt; = BindingName&lt;V, WebView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; WebView.Binding) -&gt; WebViewName&lt;V&gt; {
		return WebViewName&lt;V&gt;(source: source, downcast: Binding.webViewBinding)
	}
}
extension BindingName where Binding: WebViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: WebViewName&lt;$2&gt; { return .name(WebView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var allowsAirPlayForMediaPlayback: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.allowsAirPlayForMediaPlayback) }
	static var allowsInlineMediaPlayback: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.allowsInlineMediaPlayback) }
	static var allowsPictureInPictureForMediaPlayback: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.allowsPictureInPictureForMediaPlayback) }
	static var applicationNameForUserAgent: WebViewName&lt;Constant&lt;String?&gt;&gt; { return .name(WebView.Binding.applicationNameForUserAgent) }
	static var ignoresViewportScaleLimits: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.ignoresViewportScaleLimits) }
	static var javaScriptCanOpenWindowsAutomatically: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.javaScriptCanOpenWindowsAutomatically) }
	static var javaScriptEnabled: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.javaScriptEnabled) }
	static var mediaTypesRequiringUserActionForPlayback: WebViewName&lt;Constant&lt;WKAudiovisualMediaTypes&gt;&gt; { return .name(WebView.Binding.mediaTypesRequiringUserActionForPlayback) }
	static var minimumFontSize: WebViewName&lt;Constant&lt;CGFloat&gt;&gt; { return .name(WebView.Binding.minimumFontSize) }
	static var processPool: WebViewName&lt;Constant&lt;WKProcessPool&gt;&gt; { return .name(WebView.Binding.processPool) }
	static var suppressesIncrementalRendering: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.suppressesIncrementalRendering) }
	static var urlSchemeHandlers: WebViewName&lt;Constant&lt;[String: WKURLSchemeHandler]&gt;&gt; { return .name(WebView.Binding.urlSchemeHandlers) }
	static var userContentController: WebViewName&lt;Constant&lt;WKUserContentController&gt;&gt; { return .name(WebView.Binding.userContentController) }
	
	@available(macOS 10.10, *) @available(iOS, unavailable) static var javaEnabled: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.javaEnabled) }
	@available(macOS 10.10, *) @available(iOS, unavailable) static var plugInsEnabled: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.plugInsEnabled) }
	@available(macOS 10.10, *) @available(iOS, unavailable) static var tabFocusesLinks: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.tabFocusesLinks) }
	@available(macOS 10.12, *) @available(iOS, unavailable) static var userInterfaceDirectionPolicy: WebViewName&lt;Constant&lt;WebView.WKUserInterfaceDirectionPolicy&gt;&gt; { return .name(WebView.Binding.userInterfaceDirectionPolicy) }
	@available(macOS, unavailable) @available(iOS 9, *) static var allowsPictureInPictureMediaPlayback: WebViewName&lt;Constant&lt;Bool&gt;&gt; { return .name(WebView.Binding.allowsPictureInPictureMediaPlayback) }
	@available(macOS, unavailable) @available(iOS 11, *) static var scrollView: WebViewName&lt;Constant&lt;ScrollView&gt;&gt; { return .name(WebView.Binding.scrollView) }
	@available(macOS, unavailable) @available(iOS 11, *) static var dataDetectorTypes: WebViewName&lt;Constant&lt;WebView.WKDataDetectorTypes&gt;&gt; { return .name(WebView.Binding.dataDetectorTypes) }
	@available(macOS, unavailable) @available(iOS 11, *) static var selectionGranularity: WebViewName&lt;Constant&lt;WebView.WKSelectionGranularity&gt;&gt; { return .name(WebView.Binding.selectionGranularity) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsBackForwardNavigationGestures: WebViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(WebView.Binding.allowsBackForwardNavigationGestures) }
	
	static var allowsLinkPreview: WebViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(WebView.Binding.allowsLinkPreview) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var allowsMagnification: WebViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(WebView.Binding.allowsMagnification) }
	static var customUserAgent: WebViewName&lt;Dynamic&lt;String?&gt;&gt; { return .name(WebView.Binding.customUserAgent) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var magnification: WebViewName&lt;Dynamic&lt;(factor: CGFloat, centeredAt: CGPoint)&gt;&gt; { return .name(WebView.Binding.magnification) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var evaluateJavaScript: WebViewName&lt;Signal&lt;Callback&lt;String, (Any?, Error?)&gt;&gt;&gt; { return .name(WebView.Binding.evaluateJavaScript) }
	static var goBack: WebViewName&lt;Signal&lt;Callback&lt;Void, WKNavigation?&gt;&gt;&gt; { return .name(WebView.Binding.goBack) }
	static var goForward: WebViewName&lt;Signal&lt;Callback&lt;Void, WKNavigation?&gt;&gt;&gt; { return .name(WebView.Binding.goForward) }
	static var goTo: WebViewName&lt;Signal&lt;Callback&lt;WKBackForwardListItem, WKNavigation?&gt;&gt;&gt; { return .name(WebView.Binding.goTo) }
	static var load: WebViewName&lt;Signal&lt;Callback&lt;URLRequest, WKNavigation?&gt;&gt;&gt; { return .name(WebView.Binding.load) }
	static var loadHTMLString: WebViewName&lt;Signal&lt;Callback&lt;(string: String, baseURL: URL?), WKNavigation?&gt;&gt;&gt; { return .name(WebView.Binding.loadHTMLString) }
	static var reload: WebViewName&lt;Signal&lt;Callback&lt;Void, WKNavigation?&gt;&gt;&gt; { return .name(WebView.Binding.reload) }
	static var reloadFromOrigin: WebViewName&lt;Signal&lt;Callback&lt;Void, WKNavigation?&gt;&gt;&gt; { return .name(WebView.Binding.reloadFromOrigin) }
	static var stopLoading: WebViewName&lt;Signal&lt;Void&gt;&gt; { return .name(WebView.Binding.stopLoading) }
	
	static var loadData: WebViewName&lt;Signal&lt;Callback&lt;(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?&gt;&gt;&gt; { return .name(WebView.Binding.loadData) }
	static var loadFile: WebViewName&lt;Signal&lt;Callback&lt;(url: URL, allowingReadAccessTo: URL), WKNavigation?&gt;&gt;&gt; { return .name(WebView.Binding.loadFile) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var createWebView: WebViewName&lt;(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -&gt; WKWebView?&gt; { return .name(WebView.Binding.createWebView) }
	static var didClose: WebViewName&lt;(WKWebView) -&gt; Void&gt; { return .name(WebView.Binding.didClose) }
	static var didCommit: WebViewName&lt;(WKWebView, WKNavigation) -&gt; Void&gt; { return .name(WebView.Binding.didCommit) }
	static var didStartProvisionalNavigation: WebViewName&lt;(WKWebView, WKNavigation) -&gt; Void&gt; { return .name(WebView.Binding.didStartProvisionalNavigation) }
	static var didReceiveServerRedirectForProvisionalNavigation: WebViewName&lt;(WKWebView, WKNavigation) -&gt; Void&gt; { return .name(WebView.Binding.didReceiveServerRedirectForProvisionalNavigation) }
	static var didFail: WebViewName&lt;(WKWebView, WKNavigation, Error) -&gt; Void&gt; { return .name(WebView.Binding.didFail) }
	static var didFailProvisionalNavigation: WebViewName&lt;(WKWebView, WKNavigation, Error) -&gt; Void&gt; { return .name(WebView.Binding.didFailProvisionalNavigation) }
	static var didFinish: WebViewName&lt;(WKWebView, WKNavigation) -&gt; Void&gt; { return .name(WebView.Binding.didFinish) }
	static var contentProcessDidTerminate: WebViewName&lt;(WKWebView) -&gt; Void&gt; { return .name(WebView.Binding.contentProcessDidTerminate) }
	static var decideActionPolicy: WebViewName&lt;(WKWebView, WKNavigationAction, (WKNavigationActionPolicy) -&gt; Void) -&gt; Void&gt; { return .name(WebView.Binding.decideActionPolicy) }
	static var decideResponsePolicy: WebViewName&lt;(WKWebView, WKNavigationResponse, (WKNavigationActionPolicy) -&gt; Void) -&gt; Void&gt; { return .name(WebView.Binding.decideResponsePolicy) }
	static var didReceiveAuthenticationChallenge: WebViewName&lt;(WKWebView, URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) -&gt; Void&gt; { return .name(WebView.Binding.didReceiveAuthenticationChallenge) }
	static var runJavaScriptAlertPanel: WebViewName&lt;(WKWebView, String, WKFrameInfo, () -&gt; Void) -&gt; Void&gt; { return .name(WebView.Binding.runJavaScriptAlertPanel) }
	static var runJavaScriptConfirmPanel: WebViewName&lt;(WKWebView, String, WKFrameInfo, (Bool) -&gt; Void) -&gt; Void&gt; { return .name(WebView.Binding.runJavaScriptConfirmPanel) }
	static var runJavaScriptTextInputPanel: WebViewName&lt;(WKWebView, String, String?, WKFrameInfo, (String?) -&gt; Void) -&gt; Void&gt; { return .name(WebView.Binding.runJavaScriptTextInputPanel) }
	
	@available(macOS, unavailable) @available(iOS 10.0, *) static var commitPreviewingViewController: WebViewName&lt;(_ webView: WKWebView, _ previewingViewController: WebView.UIViewController) -&gt; Void&gt; { return .name(WebView.Binding.commitPreviewingViewController) }
	@available(macOS, unavailable) @available(iOS 10.0, *) static var previewingViewController: WebViewName&lt;(_ webView: WKWebView, _ elementInfo: WebView.WKPreviewElementInfo, _ previewActions: [WebView.WKPreviewActionItem]) -&gt; WebView.UIViewController?&gt; { return .name(WebView.Binding.previewingViewController) }
	@available(macOS 10.12, *) @available(iOS, unavailable) static var runOpenPanel: WebViewName&lt;(WKWebView, WebView.WKOpenPanelParameters, WKFrameInfo, ([URL]?) -&gt; Void) -&gt; Void&gt; { return .name(WebView.Binding.runOpenPanel) }
	@available(macOS, unavailable) @available(iOS 10.0, *) static var shouldPreviewElement: WebViewName&lt;(_ webView: WKWebView, _ elementInfo: WebView.WKPreviewElementInfo) -&gt; Bool&gt; { return .name(WebView.Binding.shouldPreviewElement) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol WebViewConvertible: ViewConvertible {
	func wkWebView() -&gt; WebView.Instance
}
extension WebViewConvertible {
	#if os(macOS)
		func nsView() -&gt; View.Instance { return wkWebView() }
	#else
		func uiView() -&gt; View.Instance { return wkWebView() }
	#endif
}
extension WKWebView: WebViewConvertible, HasDelegate {
	func wkWebView() -&gt; WebView.Instance { return self }
	var delegate: WKNavigationDelegate? {
		get { return navigationDelegate }
		set { navigationDelegate = newValue }
	}
}
extension WebView {
	func wkWebView() -&gt; WebView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol WebViewBinding: ViewBinding {
	static func webViewBinding(_ binding: WebView.Binding) -&gt; Self
	func asWebViewBinding() -&gt; WebView.Binding?
}
extension WebViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return webViewBinding(.inheritedBinding(binding))
	}
}
extension WebViewBinding where Preparer.Inherited.Binding: WebViewBinding {
	func asWebViewBinding() -&gt; WebView.Binding? {
		return asInheritedBinding()?.asWebViewBinding()
	}
}
extension WebView.Binding {
	typealias Preparer = WebView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asWebViewBinding() -&gt; WebView.Binding? { return self }
	static func webViewBinding(_ binding: WebView.Binding) -&gt; WebView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

</string>
			<key>Group</key>
			<string>Dependencies</string>
		</dict>
		<key>Dependencies/CwlViews_macOS.swift</key>
		<dict>
			<key>Beginning</key>
			<string>//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-05-11 02:03:27 +0000 from the following files:
//   CwlApplication_macOS.swift
//   CwlButton_macOS.swift
//   CwlClickGestureRecognizer_macOS.swift
//   CwlClipView_macOS.swift
//   CwlControl_macOS.swift
//   CwlGestureRecognizer_macOS.swift
//   CwlImageView_macOS.swift
//   CwlMagnificationGestureRecognizer_macOS.swift
//   CwlMenuItem_macOS.swift
//   CwlMenu_macOS.swift
//   CwlOutlineView_macOS.swift
//   CwlPanGestureRecognizer_macOS.swift
//   CwlPopUpButton_macOS.swift
//   CwlPressGestureRecognizer_macOS.swift
//   CwlRotationGestureRecognizer_macOS.swift
//   CwlScrollView_macOS.swift
//   CwlSegmentedControl_macOS.swift
//   CwlSlider_macOS.swift
//   CwlSplitView_macOS.swift
//   CwlTabViewItem_macOS.swift
//   CwlTabView_macOS.swift
//   CwlTableCellView_macOS.swift
//   CwlTableColumn_macOS.swift
//   CwlTableHeaderView_macOS.swift
//   CwlTableRowView_macOS.swift
//   CwlTableView_macOS.swift
//   CwlTextField_macOS.swift
//   CwlTextView_macOS.swift
//   CwlToolbarItem_macOS.swift
//   CwlToolbar_macOS.swift
//   CwlView_macOS.swift
//   CwlWindow_macOS.swift

import AppKit

#if os(macOS)

import Foundation
import CloudKit
import simd

func applicationMain(type: NSApplication.Type = NSApplication.self, _ application: @escaping () -&gt; Application) {
	let instance = type.shared
	let bindings = application().consume().bindings
	let (preparer, _, storage, lifetimes) = Application.Preparer.bind(bindings, to: { _ in instance })
	_ = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
	_ = NSApplicationMain(CommandLine.argc, CommandLine.unsafeArgv)
}

// MARK: - Binder Part 1: Binder
class Application: Binder {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		precondition(type == Preparer.Instance.self, "Custom application subclass must be specified as parameter to `applicationMain`")
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Application {
	enum Binding: ApplicationBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static styles are applied at construction and are subsequently immutable.
	
		// 1. Value bindings may be applied at construction and may subsequently change.
		case activationPolicy(Dynamic&lt;NSApplication.ActivationPolicy&gt;)
		case applicationIconImage(Dynamic&lt;NSImage?&gt;)
		case dockMenu(Dynamic&lt;MenuConvertible?&gt;)
		case mainMenu(Dynamic&lt;MenuConvertible?&gt;)
		case menuBarVisible(Dynamic&lt;Bool&gt;)
		case presentationOptions(Dynamic&lt;NSApplication.PresentationOptions&gt;)
		case relauchOnLogin(Dynamic&lt;Bool&gt;)
		case remoteNotifications(Dynamic&lt;NSApplication.RemoteNotificationType&gt;)
		
		@available(macOS 10.14, *) case appearance(Dynamic&lt;NSAppearance?&gt;)
		
		// 2. Signal bindings are performed on the object after construction.
		case activate(Signal&lt;Bool&gt;)
		case arrangeInFront(Signal&lt;Void&gt;)
		case deactivate(Signal&lt;Void&gt;)
		case hide(Signal&lt;Void&gt;)
		case hideOtherApplications(Signal&lt;Void&gt;)
		case miniaturizeAll(Signal&lt;Void&gt;)
		case orderFrontCharacterPalette(Signal&lt;Void&gt;)
		case orderFrontColorPanel(Signal&lt;Void&gt;)
		case orderFrontStandardAboutPanel(Signal&lt;Dictionary&lt;NSApplication.AboutPanelOptionKey, Any&gt;&gt;)
		case presentError(Signal&lt;Callback&lt;Error, Bool&gt;&gt;)
		case requestUserAttention(Signal&lt;(NSApplication.RequestUserAttentionType, Signal&lt;Void&gt;)&gt;)
		case terminate(Signal&lt;Void&gt;)
		case unhide(Signal&lt;Bool&gt;)
		case unhideAllApplications(Signal&lt;Void&gt;)
		
		// 3. Action bindings are triggered by the object after construction.
		case didBecomeActive(SignalInput&lt;Void&gt;)
		case didChangeOcclusionState(SignalInput&lt;Void&gt;)
		case didChangeScreenParameters(SignalInput&lt;Void&gt;)
		case didFinishLaunching(SignalInput&lt;[AnyHashable: Any]&gt;)
		case didFinishRestoringWindows(SignalInput&lt;Void&gt;)
		case didHide(SignalInput&lt;Void&gt;)
		case didResignActive(SignalInput&lt;Void&gt;)
		case didUnhide(SignalInput&lt;Void&gt;)
		case didUpdate(SignalInput&lt;Void&gt;)
		case willBecomeActive(SignalInput&lt;Void&gt;)
		case willFinishLaunching(SignalInput&lt;Void&gt;)
		case willHide(SignalInput&lt;Void&gt;)
		case willResignActive(SignalInput&lt;Void&gt;)
		case willUnhide(SignalInput&lt;Void&gt;)
		case willUpdate(SignalInput&lt;Void&gt;)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case continueUserActivity((_ application: NSApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([NSUserActivityRestoring]) -&gt; Void) -&gt; Bool)
		case didDecodeRestorableState((_ application: NSApplication, NSCoder) -&gt; Void)
		case didFailToContinueUserActivity((_ application: NSApplication, _ userActivityType: String, _ error: Error) -&gt; Void)
		case didFailToRegisterForRemoteNotifications((_ application: NSApplication, _ error: Error) -&gt; Void)
		case didReceiveRemoteNotification((_ application: NSApplication, _ notification: [String: Any]) -&gt; Void)
		case didRegisterForRemoteNotifications((_ application: NSApplication, _ token: Data) -&gt; Void)
		case didUpdateUserActivity((_ application: NSApplication, NSUserActivity) -&gt; Void)
		case openFile((_ application: NSApplication, _ filename: String) -&gt; Bool)
		case openFiles((_ application: NSApplication, _ filenames: [String]) -&gt; Void)
		case openFileWithoutUI((_ application: Any, _ filename: String) -&gt; Bool)
		case openTempFile((_ application: NSApplication, _ filename: String) -&gt; Bool)
		case openUntitledFile((_ application: NSApplication) -&gt; Bool)
		case printFile((_ application: NSApplication, _ filename: String) -&gt; Bool)
		case printFiles((_ application: NSApplication, _ filenames: [String], _ settings: [NSPrintInfo.AttributeKey: Any], _ showPrintPanels: Bool) -&gt; NSApplication.PrintReply)
		case shouldHandleReopen((_ application: NSApplication, _ hasVisibleWindows: Bool) -&gt; Bool)
		case shouldOpenUntitledFile((_ application: NSApplication) -&gt; Bool)
		case shouldTerminate((_ application: NSApplication) -&gt; NSApplication.TerminateReply)
		case shouldTerminateAfterLastWindowClosed((_ application: NSApplication) -&gt; Bool)
		case userDidAcceptCloudKitShare((_ application: NSApplication, CKShare.Metadata) -&gt; Void)
		case willContinueUserActivity((_ application: NSApplication, _ type: String) -&gt; Bool)
		case willEncodeRestorableState((_ application: NSApplication, NSCoder) -&gt; Void)
		case willPresentError((_ application: NSApplication, Error) -&gt; Error)
		case willTerminate((_ notification: Notification) -&gt; Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension Application {
	struct Preparer: BinderDelegateEmbedder {
		typealias Binding = Application.Binding
		typealias Inherited = BinderBase
		typealias Instance = NSApplication
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var dockMenuInUse: Bool = false
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Application.Preparer {
	var delegateIsRequired: Bool { return dynamicDelegate != nil || dockMenuInUse }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .continueUserActivity(let x): delegate().addSingleHandler3(x, #selector(NSApplicationDelegate.application(_:continue:restorationHandler:)))
		case .dockMenu: dockMenuInUse = true
		case .didDecodeRestorableState(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didDecodeRestorableState:)))
		case .didFailToContinueUserActivity(let x): delegate().addMultiHandler3(x, #selector(NSApplicationDelegate.application(_:didFailToContinueUserActivityWithType:error:)))
		case .didFailToRegisterForRemoteNotifications(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didFailToRegisterForRemoteNotificationsWithError:)))
		case .didReceiveRemoteNotification(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didReceiveRemoteNotification:)))
		case .didRegisterForRemoteNotifications(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didRegisterForRemoteNotificationsWithDeviceToken:)))
		case .didUpdateUserActivity(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didUpdate:)))
		case .openFile(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:openFile:)))
		case .openFiles(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:openFiles:)))
		case .openFileWithoutUI(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:openFileWithoutUI:)))
		case .openTempFile(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:openTempFile:)))
		case .openUntitledFile(let x): delegate().addSingleHandler1(x, #selector(NSApplicationDelegate.applicationOpenUntitledFile(_:)))
		case .printFile(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:printFile:)))
		case .printFiles(let x): delegate().addSingleHandler4(x, #selector(NSApplicationDelegate.application(_:printFiles:withSettings:showPrintPanels:)))
		case .shouldHandleReopen(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.applicationShouldHandleReopen(_:hasVisibleWindows:)))
		case .shouldOpenUntitledFile(let x): delegate().addSingleHandler1(x, #selector(NSApplicationDelegate.applicationShouldOpenUntitledFile(_:)))
		case .shouldTerminate(let x): delegate().addSingleHandler1(x, #selector(NSApplicationDelegate.applicationShouldTerminate(_:)))
		case .shouldTerminateAfterLastWindowClosed(let x): delegate().addSingleHandler1(x, #selector(NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed(_:)))
		case .userDidAcceptCloudKitShare(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:userDidAcceptCloudKitShareWith:)))
		case .willContinueUserActivity(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:willContinueUserActivityWithType:)))
		case .willEncodeRestorableState(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:willEncodeRestorableState:)))
		case .willPresentError(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:willPresentError:)))
		case .willTerminate(let x): delegate().addMultiHandler1(x, #selector(NSApplicationDelegate.applicationWillTerminate(_:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static styles are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .activationPolicy(let x): return x.apply(instance) { i, v in i.setActivationPolicy(v) }
		case .appearance(let x):
			return x.apply(instance) { i, v in
				if #available(OSX 10.14, *) {
					i.appearance = v
				}
			}
		case .applicationIconImage(let x): return x.apply(instance) { i, v in i.applicationIconImage = v }
		case .dockMenu(let x): return x.apply(instance, storage) { i, s, v in s.dockMenu = v?.nsMenu() }
		case .mainMenu(let x): return x.apply(instance) { i, v in i.mainMenu = v?.nsMenu() }
		case .menuBarVisible(let x): return x.apply(instance) { i, v in NSMenu.setMenuBarVisible(v) }
		case .presentationOptions(let x): return x.apply(instance) { i, v in i.presentationOptions = v }
		case .relauchOnLogin(let x): return x.apply(instance) { i, v in v ? i.enableRelaunchOnLogin() : i.disableRelaunchOnLogin() }
		case .remoteNotifications(let x): return x.apply(instance) { i, v in v.isEmpty ? i.unregisterForRemoteNotifications() : i.registerForRemoteNotifications(matching: v) }
			
		// 2. Signal bindings are performed on the object after construction.
		case .activate(let x): return x.apply(instance) { i, v in i.activate(ignoringOtherApps: v) }
		case .arrangeInFront(let x): return x.apply(instance) { i, v in i.arrangeInFront(nil) }
		case .deactivate(let x): return x.apply(instance) { i, v in i.deactivate() }
		case .hide(let x): return x.apply(instance) { i, v in i.hide(nil) }
		case .hideOtherApplications(let x): return x.apply(instance) { i, v in i.hideOtherApplications(nil) }
		case .miniaturizeAll(let x): return x.apply(instance) { i, v in i.miniaturizeAll(nil) }
		case .orderFrontCharacterPalette(let x): return x.apply(instance) { i, v in i.orderFrontCharacterPalette(nil) }
		case .orderFrontColorPanel(let x): return x.apply(instance) { i, v in i.orderFrontColorPanel(nil) }
		case .orderFrontStandardAboutPanel(let x): return x.apply(instance) { i, v in i.orderFrontStandardAboutPanel(options: v) }
		case .presentError(let x):
			return x.apply(instance) { i, v in
				let handled = i.presentError(v.value)
				_ = v.callback.send(value: handled)
			}
		case .requestUserAttention(let x):
			var outstandingRequests = [Lifetime]()
			return x.apply(instance) { i, v in
				let requestIndex = i.requestUserAttention(v.0)
				outstandingRequests += v.1.subscribe { [weak i] r in i?.cancelUserAttentionRequest(requestIndex) }
			}
		case .terminate(let x): return x.apply(instance) { i, v in i.terminate(nil) }
		case .unhide(let x): return x.apply(instance) { i, v in v ? i.unhide(nil) : i.unhideWithoutActivation() }
		case .unhideAllApplications(let x): return x.apply(instance) { i, v in i.unhideAllApplications(nil) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didBecomeActive(let x): return Signal.notifications(name: NSApplication.didBecomeActiveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeOcclusionState(let x): return Signal.notifications(name: NSApplication.didChangeOcclusionStateNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeScreenParameters(let x): return Signal.notifications(name: NSApplication.didChangeScreenParametersNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didFinishLaunching(let x): return Signal.notifications(name: NSApplication.didFinishLaunchingNotification, object: instance).compactMap { n -&gt; [AnyHashable: Any] in n.userInfo ?? [:] }.cancellableBind(to: x)
		case .didFinishRestoringWindows(let x): return Signal.notifications(name: NSApplication.didFinishRestoringWindowsNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didHide(let x): return Signal.notifications(name: NSApplication.didHideNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didResignActive(let x): return Signal.notifications(name: NSApplication.didResignActiveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didUnhide(let x): return Signal.notifications(name: NSApplication.didUnhideNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didUpdate(let x): return Signal.notifications(name: NSApplication.didUpdateNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willBecomeActive(let x): return Signal.notifications(name: NSApplication.willBecomeActiveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willFinishLaunching(let x): return Signal.notifications(name: NSApplication.willFinishLaunchingNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willHide(let x): return Signal.notifications(name: NSApplication.willHideNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willResignActive(let x): return Signal.notifications(name: NSApplication.willResignActiveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willUnhide(let x): return Signal.notifications(name: NSApplication.willUnhideNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willUpdate(let x): return Signal.notifications(name: NSApplication.willUpdateNotification, object: instance).map { n in () }.cancellableBind(to: x)

		case .didFailToContinueUserActivity: return nil
		case .didFailToRegisterForRemoteNotifications: return nil
		case .didReceiveRemoteNotification: return nil
		case .didRegisterForRemoteNotifications: return nil
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .continueUserActivity: return nil
		case .didDecodeRestorableState: return nil
		case .didUpdateUserActivity: return nil
		case .openFile: return nil
		case .openFiles: return nil
		case .openFileWithoutUI: return nil
		case .openTempFile: return nil
		case .openUntitledFile: return nil
		case .printFile: return nil
		case .printFiles: return nil
		case .shouldHandleReopen: return nil
		case .shouldOpenUntitledFile: return nil
		case .shouldTerminate: return nil
		case .shouldTerminateAfterLastWindowClosed: return nil
		case .willContinueUserActivity: return nil
		case .willEncodeRestorableState: return nil
		case .willPresentError: return nil
		case .willTerminate: return nil

		case .userDidAcceptCloudKitShare: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Application.Preparer {
	class Storage: AssociatedBinderStorage, NSApplicationDelegate {
		var dockMenu: NSMenu?
		
		override var isInUse: Bool {
			return super.isInUse || dockMenu != nil
		}
		
		func applicationDockMenu(_ sender: NSApplication) -&gt; NSMenu? {
			return dockMenu
		}
	}
	
	class Delegate: DynamicDelegate, NSApplicationDelegate {
		func applicationShouldTerminate(_ application: NSApplication) -&gt; NSApplication.TerminateReply {
			return singleHandler(application)
		}
		
		func applicationShouldTerminateAfterLastWindowClosed(_ application: NSApplication) -&gt; Bool {
			return singleHandler(application)
		}
		
		func applicationShouldHandleReopen(_ application: NSApplication, hasVisibleWindows: Bool) -&gt; Bool {
			return singleHandler(application, hasVisibleWindows)
		}
		
		func application(_ application: NSApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([NSUserActivityRestoring]) -&gt; Void) -&gt; Bool {
			return singleHandler(application, userActivity, restorationHandler)
		}
		
		func application(_ application: NSApplication, willPresentError error: Error) -&gt; Error {
			return singleHandler(application, error)
		}
		
		func application(_ application: NSApplication, willContinueUserActivityWithType userActivityType: String) -&gt; Bool {
			return singleHandler(application, userActivityType)
		}
		
		func application(_ application: Any, openFileWithoutUI filename: String) -&gt; Bool {
			return singleHandler(application, filename)
		}
		
		func application(_ application: NSApplication, openFile filename: String) -&gt; Bool {
			return singleHandler(application, filename)
		}
		
		func application(_ application: NSApplication, openFiles filenames: [String]) {
			multiHandler(application, filenames)
		}
		
		func application(_ application: NSApplication, printFile filename: String) -&gt; Bool {
			return singleHandler(application, filename)
		}
		
		func application(_ application: NSApplication, printFiles filenames: [String], withSettings printSettings: [NSPrintInfo.AttributeKey: Any], showPrintPanels: Bool) -&gt; NSApplication.PrintReply {
			return singleHandler(application, filenames, printSettings, showPrintPanels)
		}
		
		func application(_ application: NSApplication, openTempFile filename: String) -&gt; Bool {
			return singleHandler(application, filename)
		}
		
		func applicationOpenUntitledFile(_ application: NSApplication) -&gt; Bool {
			return singleHandler(application)
		}
		
		func applicationShouldOpenUntitledFile(_ application: NSApplication) -&gt; Bool {
			return singleHandler(application)
		}
		
		func applicationWillTerminate(_ notification: Notification) {
			multiHandler(notification)
		}
		
		func application(_ application: NSApplication, didUpdate userActivity: NSUserActivity) {
			return multiHandler(application, userActivity)
		}
		
		func application(_ application: NSApplication, willEncodeRestorableState coder: NSCoder) {
			return multiHandler(application, coder)
		}
		
		func application(_ application: NSApplication, didDecodeRestorableState coder: NSCoder) {
			return multiHandler(application, coder)
		}
		
		func application(_ application: NSApplication, didFailToContinueUserActivityWithType userActivityType: String, error: Error) {
			multiHandler(application, userActivityType, error)
		}
		
		func application(_ application: NSApplication, didReceiveRemoteNotification userInfo: [String: Any]) {
			multiHandler(application, userInfo)
		}
		
		func application(_ application: NSApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
			multiHandler(application, deviceToken)
		}
		
		func application(_ application: NSApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
			multiHandler(application, error)
		}
		
		func application(_ application: NSApplication, userDidAcceptCloudKitShareWith metadata: CKShare.Metadata) {
			multiHandler(application, metadata)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ApplicationBinding {
	typealias ApplicationName&lt;V&gt; = BindingName&lt;V, Application.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; Application.Binding) -&gt; ApplicationName&lt;V&gt; {
		return ApplicationName&lt;V&gt;(source: source, downcast: Binding.applicationBinding)
	}
}
extension BindingName where Binding: ApplicationBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ApplicationName&lt;$2&gt; { return .name(Application.Binding.$1) }
	
	//	0. Static styles are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var activationPolicy: ApplicationName&lt;Dynamic&lt;NSApplication.ActivationPolicy&gt;&gt; { return .name(Application.Binding.activationPolicy) }
	static var applicationIconImage: ApplicationName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(Application.Binding.applicationIconImage) }
	static var dockMenu: ApplicationName&lt;Dynamic&lt;MenuConvertible?&gt;&gt; { return .name(Application.Binding.dockMenu) }
	static var mainMenu: ApplicationName&lt;Dynamic&lt;MenuConvertible?&gt;&gt; { return .name(Application.Binding.mainMenu) }
	static var menuBarVisible: ApplicationName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Application.Binding.menuBarVisible) }
	static var presentationOptions: ApplicationName&lt;Dynamic&lt;NSApplication.PresentationOptions&gt;&gt; { return .name(Application.Binding.presentationOptions) }
	static var relauchOnLogin: ApplicationName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Application.Binding.relauchOnLogin) }
	static var remoteNotifications: ApplicationName&lt;Dynamic&lt;NSApplication.RemoteNotificationType&gt;&gt; { return .name(Application.Binding.remoteNotifications) }

	@available(macOS 10.14, *) static var appearance: ApplicationName&lt;Dynamic&lt;NSAppearance?&gt;&gt; { return .name(Application.Binding.appearance) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var activate: ApplicationName&lt;Signal&lt;Bool&gt;&gt; { return .name(Application.Binding.activate) }
	static var arrangeInFront: ApplicationName&lt;Signal&lt;Void&gt;&gt; { return .name(Application.Binding.arrangeInFront) }
	static var deactivate: ApplicationName&lt;Signal&lt;Void&gt;&gt; { return .name(Application.Binding.deactivate) }
	static var hide: ApplicationName&lt;Signal&lt;Void&gt;&gt; { return .name(Application.Binding.hide) }
	static var hideOtherApplications: ApplicationName&lt;Signal&lt;Void&gt;&gt; { return .name(Application.Binding.hideOtherApplications) }
	static var miniaturizeAll: ApplicationName&lt;Signal&lt;Void&gt;&gt; { return .name(Application.Binding.miniaturizeAll) }
	static var orderFrontCharacterPalette: ApplicationName&lt;Signal&lt;Void&gt;&gt; { return .name(Application.Binding.orderFrontCharacterPalette) }
	static var orderFrontColorPanel: ApplicationName&lt;Signal&lt;Void&gt;&gt; { return .name(Application.Binding.orderFrontColorPanel) }
	static var orderFrontStandardAboutPanel: ApplicationName&lt;Signal&lt;Dictionary&lt;NSApplication.AboutPanelOptionKey, Any&gt;&gt;&gt; { return .name(Application.Binding.orderFrontStandardAboutPanel) }
	static var presentError: ApplicationName&lt;Signal&lt;Callback&lt;Error, Bool&gt;&gt;&gt; { return .name(Application.Binding.presentError) }
	static var requestUserAttention: ApplicationName&lt;Signal&lt;(NSApplication.RequestUserAttentionType, Signal&lt;Void&gt;)&gt;&gt; { return .name(Application.Binding.requestUserAttention) }
	static var terminate: ApplicationName&lt;Signal&lt;Void&gt;&gt; { return .name(Application.Binding.terminate) }
	static var unhide: ApplicationName&lt;Signal&lt;Bool&gt;&gt; { return .name(Application.Binding.unhide) }
	static var unhideAllApplications: ApplicationName&lt;Signal&lt;Void&gt;&gt; { return .name(Application.Binding.unhideAllApplications) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBecomeActive: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.didBecomeActive) }
	static var didChangeOcclusionState: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.didChangeOcclusionState) }
	static var didChangeScreenParameters: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.didChangeScreenParameters) }
	static var didFinishLaunching: ApplicationName&lt;SignalInput&lt;[AnyHashable: Any]&gt;&gt; { return .name(Application.Binding.didFinishLaunching) }
	static var didFinishRestoringWindows: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.didFinishRestoringWindows) }
	static var didHide: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.didHide) }
	static var didResignActive: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.didResignActive) }
	static var didUnhide: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.didUnhide) }
	static var didUpdate: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.didUpdate) }
	static var willBecomeActive: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.willBecomeActive) }
	static var willFinishLaunching: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.willFinishLaunching) }
	static var willHide: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.willHide) }
	static var willResignActive: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.willResignActive) }
	static var willUnhide: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.willUnhide) }
	static var willUpdate: ApplicationName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Application.Binding.willUpdate) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var continueUserActivity: ApplicationName&lt;(_ application: NSApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([NSUserActivityRestoring]) -&gt; Void) -&gt; Bool&gt; { return .name(Application.Binding.continueUserActivity) }
	static var didDecodeRestorableState: ApplicationName&lt;(_ application: NSApplication, NSCoder) -&gt; Void&gt; { return .name(Application.Binding.didDecodeRestorableState) }
	static var didFailToContinueUserActivity: ApplicationName&lt;(NSApplication, String, Error) -&gt; Void&gt; { return .name(Application.Binding.didFailToContinueUserActivity) }
	static var didFailToRegisterForRemoteNotifications: ApplicationName&lt;(NSApplication, Error) -&gt; Void&gt; { return .name(Application.Binding.didFailToRegisterForRemoteNotifications) }
	static var didReceiveRemoteNotification: ApplicationName&lt;(NSApplication, [String: Any]) -&gt; Void&gt; { return .name(Application.Binding.didReceiveRemoteNotification) }
	static var didRegisterForRemoteNotifications: ApplicationName&lt;(NSApplication, Data) -&gt; Void&gt; { return .name(Application.Binding.didRegisterForRemoteNotifications) }
	static var didUpdateUserActivity: ApplicationName&lt;(_ application: NSApplication, NSUserActivity) -&gt; Void&gt; { return .name(Application.Binding.didUpdateUserActivity) }
	static var openFile: ApplicationName&lt;(_ application: NSApplication, _ filename: String) -&gt; Bool&gt; { return .name(Application.Binding.openFile) }
	static var openFiles: ApplicationName&lt;(_ application: NSApplication, _ filenames: [String]) -&gt; Void&gt; { return .name(Application.Binding.openFiles) }
	static var openFileWithoutUI: ApplicationName&lt;(_ application: Any, _ filename: String) -&gt; Bool&gt; { return .name(Application.Binding.openFileWithoutUI) }
	static var openTempFile: ApplicationName&lt;(_ application: NSApplication, _ filename: String) -&gt; Bool&gt; { return .name(Application.Binding.openTempFile) }
	static var openUntitledFile: ApplicationName&lt;(_ application: NSApplication) -&gt; Bool&gt; { return .name(Application.Binding.openUntitledFile) }
	static var printFile: ApplicationName&lt;(_ application: NSApplication, _ filename: String) -&gt; Bool&gt; { return .name(Application.Binding.printFile) }
	static var printFiles: ApplicationName&lt;(_ application: NSApplication, _ filenames: [String], _ settings: [NSPrintInfo.AttributeKey: Any], _ showPrintPanels: Bool) -&gt; NSApplication.PrintReply&gt; { return .name(Application.Binding.printFiles) }
	static var shouldHandleReopen: ApplicationName&lt;(_ application: NSApplication, _ hasVisibleWindows: Bool) -&gt; Bool&gt; { return .name(Application.Binding.shouldHandleReopen) }
	static var shouldOpenUntitledFile: ApplicationName&lt;(_ application: NSApplication) -&gt; Bool&gt; { return .name(Application.Binding.shouldOpenUntitledFile) }
	static var shouldTerminate: ApplicationName&lt;(_ application: NSApplication) -&gt; NSApplication.TerminateReply&gt; { return .name(Application.Binding.shouldTerminate) }
	static var shouldTerminateAfterLastWindowClosed: ApplicationName&lt;(_ application: NSApplication) -&gt; Bool&gt; { return .name(Application.Binding.shouldTerminateAfterLastWindowClosed) }
	static var userDidAcceptCloudKitShare: ApplicationName&lt;(_ application: NSApplication, CKShare.Metadata) -&gt; Void&gt; { return .name(Application.Binding.userDidAcceptCloudKitShare) }
	static var willContinueUserActivity: ApplicationName&lt;(_ application: NSApplication, _ type: String) -&gt; Bool&gt; { return .name(Application.Binding.willContinueUserActivity) }
	static var willEncodeRestorableState: ApplicationName&lt;(_ application: NSApplication, NSCoder) -&gt; Void&gt; { return .name(Application.Binding.willEncodeRestorableState) }
	static var willPresentError: ApplicationName&lt;(_ application: NSApplication, Error) -&gt; Error&gt; { return .name(Application.Binding.willPresentError) }
	static var willTerminate: ApplicationName&lt;(_ notification: Notification) -&gt; Void&gt; { return .name(Application.Binding.willTerminate) }

	// Composite binding names
	static func shouldTerminateAfterLastWindowClosed(_ void: Void = ()) -&gt; ApplicationName&lt;Constant&lt;Bool&gt;&gt; {
		return Binding.compositeName(
			value: { constant in { (application: NSApplication) -&gt; Bool in return true } },
			binding: Application.Binding.shouldTerminateAfterLastWindowClosed,
			downcast: Binding.applicationBinding
		)
	}
	
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension NSApplication: HasDelegate {}

// MARK: - Binder Part 8: Downcast protocols
protocol ApplicationBinding: BinderBaseBinding {
	static func applicationBinding(_ binding: Application.Binding) -&gt; Self
	func asApplicationBinding() -&gt; Application.Binding?
}
extension ApplicationBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return applicationBinding(.inheritedBinding(binding))
	}
}
extension ApplicationBinding where Preparer.Inherited.Binding: ApplicationBinding {
	func asApplicationBinding() -&gt; Application.Binding? {
		return asInheritedBinding()?.asApplicationBinding()
	}
}
extension Application.Binding {
	typealias Preparer = Application.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asApplicationBinding() -&gt; Application.Binding? { return self }
	static func applicationBinding(_ binding: Application.Binding) -&gt; Application.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class Button: Binder, ButtonConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Button {
	enum Binding: ButtonBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsMixedState(Dynamic&lt;Bool&gt;)
		case alternateImage(Dynamic&lt;NSImage?&gt;)
		case alternateTitle(Dynamic&lt;String&gt;)
		case attributedAlternateTitle(Dynamic&lt;NSAttributedString&gt;)
		case attributedTitle(Dynamic&lt;NSAttributedString&gt;)
		case bezelColor(Dynamic&lt;NSColor?&gt;)
		case bezelStyle(Dynamic&lt;NSButton.BezelStyle&gt;)
		case buttonType(Dynamic&lt;NSButton.ButtonType&gt;)
		case highlight(Dynamic&lt;Bool&gt;)
		case image(Dynamic&lt;NSImage?&gt;)
		case imageHugsTitle(Dynamic&lt;Bool&gt;)
		case imagePosition(Dynamic&lt;NSControl.ImagePosition&gt;)
		case imageScaling(Dynamic&lt;NSImageScaling&gt;)
		case isBordered(Dynamic&lt;Bool&gt;)
		case isSpringLoaded(Dynamic&lt;Bool&gt;)
		case isTransparent(Dynamic&lt;Bool&gt;)
		case keyEquivalent(Dynamic&lt;String&gt;)
		case keyEquivalentModifierMask(Dynamic&lt;NSEvent.ModifierFlags&gt;)
		case maxAcceleratorLevel(Dynamic&lt;Int&gt;)
		case performKeyEquivalent(Dynamic&lt;NSEvent&gt;)
		case periodicDelay(Dynamic&lt;(delay: Float, interval: Float)&gt;)
		case showsBorderOnlyWhileMouseInside(Dynamic&lt;Bool&gt;)
		case sound(Dynamic&lt;NSSound?&gt;)
		case state(Dynamic&lt;NSControl.StateValue&gt;)
		case title(Dynamic&lt;String&gt;)

		@available(macOS 10.14, *) case contentTintColor(Dynamic&lt;NSColor?&gt;)

		//	2. Signal bindings are performed on the object after construction.
		case setNextState(Signal&lt;Void&gt;)

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension Button {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = Button.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = NSButton
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}
		
// MARK: - Binder Part 4: Preparer overrides
extension Button.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .allowsMixedState(let x): return x.apply(instance) { i, v in i.allowsMixedState = v }
		case .alternateImage(let x): return x.apply(instance) { i, v in i.alternateImage = v }
		case .alternateTitle(let x): return x.apply(instance) { i, v in i.alternateTitle = v }
		case .attributedAlternateTitle(let x): return x.apply(instance) { i, v in i.attributedAlternateTitle = v }
		case .attributedTitle(let x): return x.apply(instance) { i, v in i.attributedTitle = v }
		case .bezelColor(let x): return x.apply(instance) { i, v in i.bezelColor = v }
		case .bezelStyle(let x): return x.apply(instance) { i, v in i.bezelStyle = v }
		case .buttonType(let x): return x.apply(instance) { i, v in i.setButtonType(v) }
		case .contentTintColor(let x):
			return x.apply(instance) { i, v in
				if #available(macOS 10.14, *) {
					i.contentTintColor = v
				}
			}
		case .highlight(let x): return x.apply(instance) { i, v in i.highlight(v) }
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .imageHugsTitle(let x): return x.apply(instance) { i, v in i.imageHugsTitle = v }
		case .imagePosition(let x): return x.apply(instance) { i, v in i.imagePosition = v }
		case .imageScaling(let x): return x.apply(instance) { i, v in i.imageScaling = v }
		case .isBordered(let x): return x.apply(instance) { i, v in i.isBordered = v }
		case .isSpringLoaded(let x): return x.apply(instance) { i, v in i.isSpringLoaded = v }
		case .isTransparent(let x): return x.apply(instance) { i, v in i.isTransparent = v }
		case .keyEquivalent(let x): return x.apply(instance) { i, v in i.keyEquivalent = v }
		case .keyEquivalentModifierMask(let x): return x.apply(instance) { i, v in i.keyEquivalentModifierMask = v }
		case .maxAcceleratorLevel(let x): return x.apply(instance) { i, v in i.maxAcceleratorLevel = v }
		case .performKeyEquivalent(let x): return x.apply(instance) { i, v in i.performKeyEquivalent(with: v) }
		case .periodicDelay(let x): return x.apply(instance) { i, v in i.setPeriodicDelay(v.delay, interval: v.interval) }
		case .showsBorderOnlyWhileMouseInside(let x): return x.apply(instance) { i, v in i.showsBorderOnlyWhileMouseInside = v }
		case .sound(let x): return x.apply(instance) { i, v in i.sound = v }
		case .state(let x): return x.apply(instance) { i, v in i.state = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }

		//	2. Signal bindings are performed on the object after construction.
		case .setNextState(let x): return x.apply(instance) { i, v in i.setNextState() }

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Button.Preparer {
	typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ButtonBinding {
	typealias ButtonName&lt;V&gt; = BindingName&lt;V, Button.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; Button.Binding) -&gt; ButtonName&lt;V&gt; {
		return ButtonName&lt;V&gt;(source: source, downcast: Binding.buttonBinding)
	}
}
extension BindingName where Binding: ButtonBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ButtonName&lt;$2&gt; { return .name(Button.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMixedState: ButtonName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Button.Binding.allowsMixedState) }
	static var alternateImage: ButtonName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(Button.Binding.alternateImage) }
	static var alternateTitle: ButtonName&lt;Dynamic&lt;String&gt;&gt; { return .name(Button.Binding.alternateTitle) }
	static var attributedAlternateTitle: ButtonName&lt;Dynamic&lt;NSAttributedString&gt;&gt; { return .name(Button.Binding.attributedAlternateTitle) }
	static var attributedTitle: ButtonName&lt;Dynamic&lt;NSAttributedString&gt;&gt; { return .name(Button.Binding.attributedTitle) }
	static var bezelColor: ButtonName&lt;Dynamic&lt;NSColor?&gt;&gt; { return .name(Button.Binding.bezelColor) }
	static var bezelStyle: ButtonName&lt;Dynamic&lt;NSButton.BezelStyle&gt;&gt; { return .name(Button.Binding.bezelStyle) }
	static var buttonType: ButtonName&lt;Dynamic&lt;NSButton.ButtonType&gt;&gt; { return .name(Button.Binding.buttonType) }
	static var highlight: ButtonName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Button.Binding.highlight) }
	static var image: ButtonName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(Button.Binding.image) }
	static var imageHugsTitle: ButtonName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Button.Binding.imageHugsTitle) }
	static var imagePosition: ButtonName&lt;Dynamic&lt;NSControl.ImagePosition&gt;&gt; { return .name(Button.Binding.imagePosition) }
	static var imageScaling: ButtonName&lt;Dynamic&lt;NSImageScaling&gt;&gt; { return .name(Button.Binding.imageScaling) }
	static var isBordered: ButtonName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Button.Binding.isBordered) }
	static var isSpringLoaded: ButtonName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Button.Binding.isSpringLoaded) }
	static var isTransparent: ButtonName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Button.Binding.isTransparent) }
	static var keyEquivalent: ButtonName&lt;Dynamic&lt;String&gt;&gt; { return .name(Button.Binding.keyEquivalent) }
	static var keyEquivalentModifierMask: ButtonName&lt;Dynamic&lt;NSEvent.ModifierFlags&gt;&gt; { return .name(Button.Binding.keyEquivalentModifierMask) }
	static var maxAcceleratorLevel: ButtonName&lt;Dynamic&lt;Int&gt;&gt; { return .name(Button.Binding.maxAcceleratorLevel) }
	static var performKeyEquivalent: ButtonName&lt;Dynamic&lt;NSEvent&gt;&gt; { return .name(Button.Binding.performKeyEquivalent) }
	static var periodicDelay: ButtonName&lt;Dynamic&lt;(delay: Float, interval: Float)&gt;&gt; { return .name(Button.Binding.periodicDelay) }
	static var showsBorderOnlyWhileMouseInside: ButtonName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Button.Binding.showsBorderOnlyWhileMouseInside) }
	static var sound: ButtonName&lt;Dynamic&lt;NSSound?&gt;&gt; { return .name(Button.Binding.sound) }
	static var state: ButtonName&lt;Dynamic&lt;NSControl.StateValue&gt;&gt; { return .name(Button.Binding.state) }
	static var title: ButtonName&lt;Dynamic&lt;String&gt;&gt; { return .name(Button.Binding.title) }

	@available(macOS 10.14, *) static var contentTintColor: ButtonName&lt;Dynamic&lt;NSColor?&gt;&gt; { return .name(Button.Binding.contentTintColor) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var setNextState: ButtonName&lt;Signal&lt;Void&gt;&gt; { return .name(Button.Binding.setNextState) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ButtonConvertible: ControlConvertible {
	func nsButton() -&gt; Button.Instance
}
extension ButtonConvertible {
	func nsControl() -&gt; Control.Instance { return nsButton() }
}
extension NSButton: ButtonConvertible {
	func nsButton() -&gt; Button.Instance { return self }
}
extension Button {
	func nsButton() -&gt; Button.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ButtonBinding: ControlBinding {
	static func buttonBinding(_ binding: Button.Binding) -&gt; Self
	func asButtonBinding() -&gt; Button.Binding?
}
extension ButtonBinding {
	static func controlBinding(_ binding: Control.Binding) -&gt; Self {
		return buttonBinding(.inheritedBinding(binding))
	}
}
extension ButtonBinding where Preparer.Inherited.Binding: ButtonBinding {
	func asButtonBinding() -&gt; Button.Binding? {
		return asInheritedBinding()?.asButtonBinding()
	}
}
extension Button.Binding {
	typealias Preparer = Button.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asButtonBinding() -&gt; Button.Binding? { return self }
	static func buttonBinding(_ binding: Button.Binding) -&gt; Button.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class ClickGestureRecognizer: Binder, ClickGestureRecognizerConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ClickGestureRecognizer {
	enum Binding: ClickGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case buttonMask(Dynamic&lt;Int&gt;)
		case numberOfClicksRequired(Dynamic&lt;Int&gt;)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension ClickGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = ClickGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = NSClickGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ClickGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .buttonMask(let x): return x.apply(instance) { i, v in i.buttonMask = v }
		case .numberOfClicksRequired(let x): return x.apply(instance) { i, v in i.numberOfClicksRequired = v }
			
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ClickGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ClickGestureRecognizerBinding {
	typealias ClickGestureRecognizerName&lt;V&gt; = BindingName&lt;V, ClickGestureRecognizer.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; ClickGestureRecognizer.Binding) -&gt; ClickGestureRecognizerName&lt;V&gt; {
		return ClickGestureRecognizerName&lt;V&gt;(source: source, downcast: Binding.clickGestureRecognizerBinding)
	}
}
extension BindingName where Binding: ClickGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ClickGestureRecognizerName&lt;$2&gt; { return .name(ClickGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var buttonMask: ClickGestureRecognizerName&lt;Dynamic&lt;Int&gt;&gt; { return .name(ClickGestureRecognizer.Binding.buttonMask) }
	static var numberOfClicksRequired: ClickGestureRecognizerName&lt;Dynamic&lt;Int&gt;&gt; { return .name(ClickGestureRecognizer.Binding.numberOfClicksRequired) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ClickGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsClickGestureRecognizer() -&gt; ClickGestureRecognizer.Instance
}
extension ClickGestureRecognizerConvertible {
	func nsGestureRecognizer() -&gt; GestureRecognizer.Instance { return nsClickGestureRecognizer() }
}
extension NSClickGestureRecognizer: ClickGestureRecognizerConvertible {
	func nsClickGestureRecognizer() -&gt; ClickGestureRecognizer.Instance { return self }
}
extension ClickGestureRecognizer {
	func nsClickGestureRecognizer() -&gt; ClickGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ClickGestureRecognizerBinding: GestureRecognizerBinding {
	static func clickGestureRecognizerBinding(_ binding: ClickGestureRecognizer.Binding) -&gt; Self
	func asClickGestureRecognizerBinding() -&gt; ClickGestureRecognizer.Binding?
}
extension ClickGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -&gt; Self {
		return clickGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension ClickGestureRecognizerBinding where Preparer.Inherited.Binding: ClickGestureRecognizerBinding {
	func asClickGestureRecognizerBinding() -&gt; ClickGestureRecognizer.Binding? {
		return asInheritedBinding()?.asClickGestureRecognizerBinding()
	}
}
extension ClickGestureRecognizer.Binding {
	typealias Preparer = ClickGestureRecognizer.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asClickGestureRecognizerBinding() -&gt; ClickGestureRecognizer.Binding? { return self }
	static func clickGestureRecognizerBinding(_ binding: ClickGestureRecognizer.Binding) -&gt; ClickGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class ClipView: Binder, ClipViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ClipView {
	enum Binding: ClipViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundColor(Dynamic&lt;NSColor&gt;)
		case bottomConstraintPriority(Dynamic&lt;Layout.Dimension.Priority&gt;)
		case copiesOnScroll(Dynamic&lt;Bool&gt;)
		case documentCursor(Dynamic&lt;NSCursor?&gt;)
		case documentView(Dynamic&lt;ViewConvertible?&gt;)
		case drawsBackground(Dynamic&lt;Bool&gt;)
		case trailingConstraintPriority(Dynamic&lt;Layout.Dimension.Priority&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case scrollTo(Signal&lt;CGPoint&gt;)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension ClipView {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = ClipView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSClipView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ClipView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .copiesOnScroll(let x): return x.apply(instance) { i, v in i.copiesOnScroll = v }
		case .documentCursor(let x): return x.apply(instance) { i, v in i.documentCursor = v }
		case .documentView(let x): return x.apply(instance, storage) { i, s, v in
			if let view = v?.nsView() {
				view.translatesAutoresizingMaskIntoConstraints = false
				i.addSubview(view)
				s.updateConstraints(clipView: i, documentView: view)
				i.documentView = view
			} else {
				s.clearConstraints()
				i.documentView = nil
			}
		}
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .bottomConstraintPriority(let x):
			return x.apply(instance, storage) { i, s, v in
				s.bottomPriority = v
				if let documentView = i.documentView {
					s.updateConstraints(clipView: i, documentView: documentView)
				}
			}
		case .trailingConstraintPriority(let x):
			return x.apply(instance, storage) { i, s, v in
				s.trailingPriority = v
				if let documentView = i.documentView {
					s.updateConstraints(clipView: i, documentView: documentView)
				}
			}
		
		// 2. Signal bindings are performed on the object after construction.
		case .scrollTo(let x): return x.apply(instance) { i, v in i.scroll(to: v) }

		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ClipView.Preparer {
	class Storage: View.Preparer.Storage {
		var trailingPriority: Layout.Dimension.Priority = .dragThatCannotResizeWindow
		var bottomPriority: Layout.Dimension.Priority = .dragThatCannotResizeWindow
		var constraints: [NSLayoutConstraint]?
		
		func clearConstraints() {
			guard let existingConstraints = constraints else { return }
			NSLayoutConstraint.deactivate(existingConstraints)
			constraints = nil
		}
		
		func updateConstraints(clipView: NSClipView, documentView: NSView) {
			clearConstraints()
			
			let trailingConstraint = documentView.trailingAnchor.constraint(equalTo: clipView.trailingAnchor)
			trailingConstraint.priority = trailingPriority
			let bottomConstraint = documentView.bottomAnchor.constraint(equalTo: clipView.bottomAnchor)
			bottomConstraint.priority = bottomPriority
			let newConstraints = [
				bottomConstraint,
				trailingConstraint,
				documentView.topAnchor.constraint(equalTo: clipView.topAnchor),
				documentView.leadingAnchor.constraint(equalTo: clipView.leadingAnchor)
			]
			NSLayoutConstraint.activate(newConstraints)
			constraints = newConstraints
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ClipViewBinding {
	typealias ClipViewName&lt;V&gt; = BindingName&lt;V, ClipView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; ClipView.Binding) -&gt; ClipViewName&lt;V&gt; {
		return ClipViewName&lt;V&gt;(source: source, downcast: Binding.clipViewBinding)
	}
}
extension BindingName where Binding: ClipViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ClipViewName&lt;$2&gt; { return .name(ClipView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundColor: ClipViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(ClipView.Binding.backgroundColor) }
	static var copiesOnScroll: ClipViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ClipView.Binding.copiesOnScroll) }
	static var documentCursor: ClipViewName&lt;Dynamic&lt;NSCursor?&gt;&gt; { return .name(ClipView.Binding.documentCursor) }
	static var documentView: ClipViewName&lt;Dynamic&lt;ViewConvertible?&gt;&gt; { return .name(ClipView.Binding.documentView) }
	static var drawsBackground: ClipViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ClipView.Binding.drawsBackground) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var scrollTo: ClipViewName&lt;Signal&lt;CGPoint&gt;&gt; { return .name(ClipView.Binding.scrollTo) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ClipViewConvertible: ViewConvertible {
	func nsClipView() -&gt; ClipView.Instance
}
extension ClipViewConvertible {
	func nsView() -&gt; View.Instance { return nsClipView() }
}
extension NSClipView: ClipViewConvertible {
	func nsClipView() -&gt; ClipView.Instance { return self }
}
extension ClipView {
	func nsClipView() -&gt; ClipView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ClipViewBinding: ViewBinding {
	static func clipViewBinding(_ binding: ClipView.Binding) -&gt; Self
	func asClipViewBinding() -&gt; ClipView.Binding?
}
extension ClipViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return clipViewBinding(.inheritedBinding(binding))
	}
}
extension ClipViewBinding where Preparer.Inherited.Binding: ClipViewBinding {
	func asClipViewBinding() -&gt; ClipView.Binding? {
		return asInheritedBinding()?.asClipViewBinding()
	}
}
extension ClipView.Binding {
	typealias Preparer = ClipView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asClipViewBinding() -&gt; ClipView.Binding? { return self }
	static func clipViewBinding(_ binding: ClipView.Binding) -&gt; ClipView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class Control: Binder, ControlConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Control {
	enum Binding: ControlBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case alignment(Dynamic&lt;NSTextAlignment&gt;)
		case allowsExpansionToolTips(Dynamic&lt;Bool&gt;)
		case attributedStringValue(Dynamic&lt;NSAttributedString&gt;)
		case baseWritingDirection(Dynamic&lt;NSWritingDirection&gt;)
		case doubleValue(Dynamic&lt;Double&gt;)
		case floatValue(Dynamic&lt;Float&gt;)
		case font(Dynamic&lt;NSFont&gt;)
		case formatter(Dynamic&lt;Foundation.Formatter?&gt;)
		case ignoresMultiClick(Dynamic&lt;Bool&gt;)
		case integerValue(Dynamic&lt;Int&gt;)
		case intValue(Dynamic&lt;Int32&gt;)
		case isContinuous(Dynamic&lt;Bool&gt;)
		case isEnabled(Dynamic&lt;Bool&gt;)
		case isHighlighted(Dynamic&lt;Bool&gt;)
		case lineBreakMode(Dynamic&lt;NSLineBreakMode&gt;)
		case objectValue(Dynamic&lt;Any&gt;)
		case refusesFirstResponder(Dynamic&lt;Bool&gt;)
		case sendActionOn(Dynamic&lt;NSEvent.EventTypeMask&gt;)
		case size(Dynamic&lt;NSControl.ControlSize&gt;)
		case stringValue(Dynamic&lt;String&gt;)
		case tag(Dynamic&lt;Int&gt;)
		case usesSingleLineMode(Dynamic&lt;Bool&gt;)
		
		//	2. Signal bindings are performed on the object after construction.
		case abortEditing(Signal&lt;Void&gt;)
		case performClick(Signal&lt;Void&gt;)
		case sizeToFit(Signal&lt;Void&gt;)
		case validateEditing(Signal&lt;Void&gt;)
		
		//	3. Action bindings are triggered by the object after construction.
		case action(TargetAction)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case textDidBeginEditing((NSText) -&gt; Void)
		case textDidChange((NSText) -&gt; Void)
		case textDidEndEditing((NSText) -&gt; Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension Control {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = Control.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSControl
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Control.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .alignment(let x): return x.apply(instance) { i, v in i.alignment = v }
		case .allowsExpansionToolTips(let x): return x.apply(instance) { i, v in i.allowsExpansionToolTips = v }
		case .attributedStringValue(let x): return x.apply(instance) { i, v in i.attributedStringValue = v }
		case .baseWritingDirection(let x): return x.apply(instance) { i, v in i.baseWritingDirection = v }
		case .doubleValue(let x): return x.apply(instance) { i, v in i.doubleValue = v }
		case .floatValue(let x): return x.apply(instance) { i, v in i.floatValue = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .formatter(let x): return x.apply(instance) { i, v in i.formatter = v }
		case .ignoresMultiClick(let x): return x.apply(instance) { i, v in i.ignoresMultiClick = v }
		case .integerValue(let x): return x.apply(instance) { i, v in i.integerValue = v }
		case .intValue(let x): return x.apply(instance) { i, v in i.intValue = v }
		case .isContinuous(let x): return x.apply(instance) { i, v in i.isContinuous = v }
		case .isEnabled(let x): return x.apply(instance, storage, false) { i, s, v in i.isEnabled = v }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.isHighlighted = v }
		case .lineBreakMode(let x): return x.apply(instance) { i, v in i.lineBreakMode = v }
		case .objectValue(let x): return x.apply(instance) { i, v in i.objectValue = v }
		case .refusesFirstResponder(let x): return x.apply(instance) { i, v in i.refusesFirstResponder = v }
		case .sendActionOn(let x): return x.apply(instance) { i, v in _ = i.sendAction(on: v) }
		case .size(let x): return x.apply(instance) { i, v in i.controlSize = v }
		case .stringValue(let x): return x.apply(instance) { i, v in i.stringValue = v }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .usesSingleLineMode(let x): return x.apply(instance) { i, v in i.usesSingleLineMode = v }
			
		//	2. Signal bindings are performed on the object after construction.
		case .abortEditing(let x): return x.apply(instance) { i, v in i.abortEditing() }
		case .performClick(let x): return x.apply(instance) { i, v in i.performClick(nil) }
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }
		case .validateEditing(let x): return x.apply(instance) { i, v in i.validateEditing() }
			
		//	3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: SignalActionTarget.init)
			
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .textDidBeginEditing(let x):
			return Signal.notifications(name: NSControl.textDidBeginEditingNotification, object: instance).compactMap { n in
				return n.userInfo?["NSFieldEditor"] as? NSText
			}.subscribeValues { x($0) }
		case .textDidChange(let x):
			return Signal.notifications(name: NSControl.textDidChangeNotification, object: instance).compactMap { n in
				return n.userInfo?["NSFieldEditor"] as? NSText
			}.subscribeValues { x($0) }
		case .textDidEndEditing(let x):
			return Signal.notifications(name: NSControl.textDidEndEditingNotification, object: instance).compactMap { n in
				return n.userInfo?["NSFieldEditor"] as? NSText
			}.subscribeValues { x($0) }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Control.Preparer {
	typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ControlBinding {
	typealias ControlName&lt;V&gt; = BindingName&lt;V, Control.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; Control.Binding) -&gt; ControlName&lt;V&gt; {
		return ControlName&lt;V&gt;(source: source, downcast: Binding.controlBinding)
	}
}
extension BindingName where Binding: ControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ControlName&lt;$2&gt; { return .name(Control.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var alignment: ControlName&lt;Dynamic&lt;NSTextAlignment&gt;&gt; { return .name(Control.Binding.alignment) }
	static var allowsExpansionToolTips: ControlName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Control.Binding.allowsExpansionToolTips) }
	static var attributedStringValue: ControlName&lt;Dynamic&lt;NSAttributedString&gt;&gt; { return .name(Control.Binding.attributedStringValue) }
	static var baseWritingDirection: ControlName&lt;Dynamic&lt;NSWritingDirection&gt;&gt; { return .name(Control.Binding.baseWritingDirection) }
	static var doubleValue: ControlName&lt;Dynamic&lt;Double&gt;&gt; { return .name(Control.Binding.doubleValue) }
	static var floatValue: ControlName&lt;Dynamic&lt;Float&gt;&gt; { return .name(Control.Binding.floatValue) }
	static var font: ControlName&lt;Dynamic&lt;NSFont&gt;&gt; { return .name(Control.Binding.font) }
	static var formatter: ControlName&lt;Dynamic&lt;Foundation.Formatter?&gt;&gt; { return .name(Control.Binding.formatter) }
	static var ignoresMultiClick: ControlName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Control.Binding.ignoresMultiClick) }
	static var integerValue: ControlName&lt;Dynamic&lt;Int&gt;&gt; { return .name(Control.Binding.integerValue) }
	static var intValue: ControlName&lt;Dynamic&lt;Int32&gt;&gt; { return .name(Control.Binding.intValue) }
	static var isContinuous: ControlName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Control.Binding.isContinuous) }
	static var isEnabled: ControlName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Control.Binding.isEnabled) }
	static var isHighlighted: ControlName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Control.Binding.isHighlighted) }
	static var lineBreakMode: ControlName&lt;Dynamic&lt;NSLineBreakMode&gt;&gt; { return .name(Control.Binding.lineBreakMode) }
	static var objectValue: ControlName&lt;Dynamic&lt;Any&gt;&gt; { return .name(Control.Binding.objectValue) }
	static var refusesFirstResponder: ControlName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Control.Binding.refusesFirstResponder) }
	static var sendActionOn: ControlName&lt;Dynamic&lt;NSEvent.EventTypeMask&gt;&gt; { return .name(Control.Binding.sendActionOn) }
	static var size: ControlName&lt;Dynamic&lt;NSControl.ControlSize&gt;&gt; { return .name(Control.Binding.size) }
	static var stringValue: ControlName&lt;Dynamic&lt;String&gt;&gt; { return .name(Control.Binding.stringValue) }
	static var tag: ControlName&lt;Dynamic&lt;Int&gt;&gt; { return .name(Control.Binding.tag) }
	static var usesSingleLineMode: ControlName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Control.Binding.usesSingleLineMode) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var abortEditing: ControlName&lt;Signal&lt;Void&gt;&gt; { return .name(Control.Binding.abortEditing) }
	static var performClick: ControlName&lt;Signal&lt;Void&gt;&gt; { return .name(Control.Binding.performClick) }
	static var sizeToFit: ControlName&lt;Signal&lt;Void&gt;&gt; { return .name(Control.Binding.sizeToFit) }
	static var validateEditing: ControlName&lt;Signal&lt;Void&gt;&gt; { return .name(Control.Binding.validateEditing) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var action: ControlName&lt;TargetAction&gt; { return .name(Control.Binding.action) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var textDidBeginEditing: ControlName&lt;(NSText) -&gt; Void&gt; { return .name(Control.Binding.textDidBeginEditing) }
	static var textDidChange: ControlName&lt;(NSText) -&gt; Void&gt; { return .name(Control.Binding.textDidChange) }
	static var textDidEndEditing: ControlName&lt;(NSText) -&gt; Void&gt; { return .name(Control.Binding.textDidEndEditing) }

	// Composite binding names
	static func action( _ void: Void = ()) -&gt; ControlName&lt;SignalInput&lt;Void&gt;&gt; {
		return Binding.compositeName(
			value: { input in
				TargetAction.singleTarget(
					Input&lt;Any?&gt;().map { _ in () }.bind(to: input)
				)
			},
			binding: Control.Binding.action,
			downcast: Binding.controlBinding
		)
	}
	static func action&lt;Value&gt;(_ keyPath: KeyPath&lt;Binding.Preparer.Instance, Value&gt;) -&gt; ControlName&lt;SignalInput&lt;Value&gt;&gt; {
		return Binding.keyPathActionName(keyPath, Control.Binding.action, Binding.controlBinding)
	}
	static func stringChanged(_ void: Void = ()) -&gt; ControlName&lt;SignalInput&lt;String&gt;&gt; {
		return Binding.compositeName(
			value: { input in { text in _ = input.send(value: text.string) } },
			binding: Control.Binding.textDidChange,
			downcast: Binding.controlBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ControlConvertible: ViewConvertible {
	func nsControl() -&gt; Control.Instance
}
extension ControlConvertible {
	func nsView() -&gt; View.Instance { return nsControl() }
}
extension NSControl: ControlConvertible, TargetActionSender {
	func nsControl() -&gt; Control.Instance { return self }
}
extension Control {
	func nsControl() -&gt; Control.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ControlBinding: ViewBinding {
	static func controlBinding(_ binding: Control.Binding) -&gt; Self
	func asControlBinding() -&gt; Control.Binding?
}
extension ControlBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return controlBinding(.inheritedBinding(binding))
	}
}
extension ControlBinding where Preparer.Inherited.Binding: ControlBinding {
	func asControlBinding() -&gt; Control.Binding? {
		return asInheritedBinding()?.asControlBinding()
	}
}
extension Control.Binding {
	typealias Preparer = Control.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asControlBinding() -&gt; Control.Binding? { return self }
	static func controlBinding(_ binding: Control.Binding) -&gt; Control.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class GestureRecognizer: Binder, GestureRecognizerConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension GestureRecognizer {
	enum Binding: GestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowedTouchTypes(Dynamic&lt;NSTouch.TouchTypeMask&gt;)
		case pressureConfiguration(Dynamic&lt;NSPressureConfiguration&gt;)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case action(TargetAction)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldAttemptToRecognize((NSGestureRecognizer, NSEvent) -&gt; Bool)
		case shouldBegin((NSGestureRecognizer) -&gt; Bool)
		case shouldRecognizeSimultaneously((NSGestureRecognizer, NSGestureRecognizer) -&gt; Bool)
		case shouldRequireFailure((NSGestureRecognizer, NSGestureRecognizer) -&gt; Bool)
		case shouldRequireToFail((NSGestureRecognizer, NSGestureRecognizer) -&gt; Bool)
		case shouldReceiveTouch((NSGestureRecognizer, NSTouch) -&gt; Bool)
	}
}

// MARK: - Binder Part 3: Preparer
extension GestureRecognizer {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = GestureRecognizer.Binding
		typealias Inherited = BinderBase
		typealias Instance = NSGestureRecognizer
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension GestureRecognizer.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		case .shouldBegin(let x): delegate().addSingleHandler1(x, #selector(NSGestureRecognizerDelegate.gestureRecognizerShouldBegin(_:)))
		case .shouldRecognizeSimultaneously(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:)))
		case .shouldRequireFailure(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldRequireFailureOf:)))
		case .shouldRequireToFail(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldBeRequiredToFailBy:)))
		case .shouldAttemptToRecognize(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldAttemptToRecognizeWith:)))
		case .shouldReceiveTouch(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowedTouchTypes(let x): return x.apply(instance) { i, v in i.allowedTouchTypes = v }
		case .pressureConfiguration(let x): return x.apply(instance) { i, v in i.pressureConfiguration = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: SignalActionTarget.init)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldAttemptToRecognize: return nil
		case .shouldBegin: return nil
		case .shouldRecognizeSimultaneously: return nil
		case .shouldRequireFailure: return nil
		case .shouldRequireToFail: return nil
		
		case .shouldReceiveTouch: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension GestureRecognizer.Preparer {
	class Storage: AssociatedBinderStorage, NSGestureRecognizerDelegate {}
	
	class Delegate: DynamicDelegate, NSGestureRecognizerDelegate {
		func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldAttemptToRecognizeWith event: NSEvent) -&gt; Bool {
			return singleHandler(gestureRecognizer, event)
		}
		
		func gestureRecognizerShouldBegin(_ gestureRecognizer: NSGestureRecognizer) -&gt; Bool {
			return singleHandler(gestureRecognizer)
		}
		
		func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: NSGestureRecognizer) -&gt; Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: NSGestureRecognizer) -&gt; Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		@objc(gestureRecognizer: shouldBeRequiredToFailByGestureRecognizer:) func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: NSGestureRecognizer) -&gt; Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldReceive touch: NSTouch) -&gt; Bool {
			return singleHandler(gestureRecognizer, touch)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: GestureRecognizerBinding {
	typealias GestureRecognizerName&lt;V&gt; = BindingName&lt;V, GestureRecognizer.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; GestureRecognizer.Binding) -&gt; GestureRecognizerName&lt;V&gt; {
		return GestureRecognizerName&lt;V&gt;(source: source, downcast: Binding.gestureRecognizerBinding)
	}
}
extension BindingName where Binding: GestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: GestureRecognizerName&lt;$2&gt; { return .name(GestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowedTouchTypes: GestureRecognizerName&lt;Dynamic&lt;NSTouch.TouchTypeMask&gt;&gt; { return .name(GestureRecognizer.Binding.allowedTouchTypes) }
	static var pressureConfiguration: GestureRecognizerName&lt;Dynamic&lt;NSPressureConfiguration&gt;&gt; { return .name(GestureRecognizer.Binding.pressureConfiguration) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: GestureRecognizerName&lt;TargetAction&gt; { return .name(GestureRecognizer.Binding.action) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldAttemptToRecognize: GestureRecognizerName&lt;(NSGestureRecognizer, NSEvent) -&gt; Bool&gt; { return .name(GestureRecognizer.Binding.shouldAttemptToRecognize) }
	static var shouldBegin: GestureRecognizerName&lt;(NSGestureRecognizer) -&gt; Bool&gt; { return .name(GestureRecognizer.Binding.shouldBegin) }
	static var shouldRecognizeSimultaneously: GestureRecognizerName&lt;(NSGestureRecognizer, NSGestureRecognizer) -&gt; Bool&gt; { return .name(GestureRecognizer.Binding.shouldRecognizeSimultaneously) }
	static var shouldRequireFailure: GestureRecognizerName&lt;(NSGestureRecognizer, NSGestureRecognizer) -&gt; Bool&gt; { return .name(GestureRecognizer.Binding.shouldRequireFailure) }
	static var shouldRequireToFail: GestureRecognizerName&lt;(NSGestureRecognizer, NSGestureRecognizer) -&gt; Bool&gt; { return .name(GestureRecognizer.Binding.shouldRequireToFail) }
	static var shouldReceiveTouch: GestureRecognizerName&lt;(NSGestureRecognizer, NSTouch) -&gt; Bool&gt; { return .name(GestureRecognizer.Binding.shouldReceiveTouch) }

	// Composite binding names
	static func action&lt;Value&gt;(_ keyPath: KeyPath&lt;Binding.Preparer.Instance, Value&gt;) -&gt; GestureRecognizerName&lt;SignalInput&lt;Value&gt;&gt; {
		return Binding.keyPathActionName(keyPath, GestureRecognizer.Binding.action, Binding.gestureRecognizerBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol GestureRecognizerConvertible {
	func nsGestureRecognizer() -&gt; GestureRecognizer.Instance
}
extension NSGestureRecognizer: GestureRecognizerConvertible, TargetActionSender, DefaultConstructable, HasDelegate {
	func nsGestureRecognizer() -&gt; GestureRecognizer.Instance { return self }
}
extension GestureRecognizer {
	func nsGestureRecognizer() -&gt; GestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol GestureRecognizerBinding: BinderBaseBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -&gt; Self
	func asGestureRecognizerBinding() -&gt; GestureRecognizer.Binding?
}
extension GestureRecognizerBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return gestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension GestureRecognizerBinding where Preparer.Inherited.Binding: GestureRecognizerBinding {
	func asGestureRecognizerBinding() -&gt; GestureRecognizer.Binding? {
		return asInheritedBinding()?.asGestureRecognizerBinding()
	}
}
extension GestureRecognizer.Binding {
	typealias Preparer = GestureRecognizer.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asGestureRecognizerBinding() -&gt; GestureRecognizer.Binding? { return self }
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -&gt; GestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class ImageView: Binder, ImageViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ImageView {
	enum Binding: ImageViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsCutCopyPaste(Dynamic&lt;Bool&gt;)
		case animates(Dynamic&lt;Bool&gt;)
		case image(Dynamic&lt;NSImage?&gt;)
		case imageAlignment(Dynamic&lt;NSImageAlignment&gt;)
		case imageFrameStyle(Dynamic&lt;NSImageView.FrameStyle&gt;)
		case imageScaling(Dynamic&lt;NSImageScaling&gt;)
		case isEditable(Dynamic&lt;Bool&gt;)
		@available(macOS 10.14, *) case contentTintColor(Dynamic&lt;NSColor?&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension ImageView {
	struct Preparer: BinderEmbedderConstructor /* or BinderDelegateEmbedderConstructor */ {
		typealias Binding = ImageView.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = NSImageView
		
		var inherited = Inherited()
		init() {}
		
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ImageView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .allowsCutCopyPaste(let x): return x.apply(instance) { i, v in i.allowsCutCopyPaste = v }
		case .animates(let x): return x.apply(instance) { i, v in i.animates = v }
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .imageAlignment(let x): return x.apply(instance) { i, v in i.imageAlignment = v }
		case .imageFrameStyle(let x): return x.apply(instance) { i, v in i.imageFrameStyle = v }
		case .imageScaling(let x): return x.apply(instance) { i, v in i.imageScaling = v }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .contentTintColor(let x):
			return x.apply(instance) { i, v in
				if #available(OSX 10.14, *) {
					i.contentTintColor = v
				}
			}
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ImageView.Preparer {
	typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ImageViewBinding {
	typealias ImageViewName&lt;V&gt; = BindingName&lt;V, ImageView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; ImageView.Binding) -&gt; ImageViewName&lt;V&gt; {
		return ImageViewName&lt;V&gt;(source: source, downcast: Binding.imageViewBinding)
	}
}
extension BindingName where Binding: ImageViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ImageViewName&lt;$2&gt; { return .name(ImageView.Binding.$1) }
	static var allowsCutCopyPaste: ImageViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ImageView.Binding.allowsCutCopyPaste) }
	static var animates: ImageViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ImageView.Binding.animates) }
	static var image: ImageViewName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(ImageView.Binding.image) }
	static var imageAlignment: ImageViewName&lt;Dynamic&lt;NSImageAlignment&gt;&gt; { return .name(ImageView.Binding.imageAlignment) }
	static var imageFrameStyle: ImageViewName&lt;Dynamic&lt;NSImageView.FrameStyle&gt;&gt; { return .name(ImageView.Binding.imageFrameStyle) }
	static var imageScaling: ImageViewName&lt;Dynamic&lt;NSImageScaling&gt;&gt; { return .name(ImageView.Binding.imageScaling) }
	static var isEditable: ImageViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ImageView.Binding.isEditable) }
	@available(macOS 10.14, *) static var contentTintColor: ImageViewName&lt;Dynamic&lt;NSColor?&gt;&gt; { return .name(ImageView.Binding.contentTintColor) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ImageViewConvertible: ControlConvertible {
	func nsImageView() -&gt; ImageView.Instance
}
extension ImageViewConvertible {
	func nsControl() -&gt; Control.Instance { return nsImageView() }
}
extension NSImageView: ImageViewConvertible /* , HasDelegate // if Preparer is BinderDelegateEmbedderConstructor */ {
	func nsImageView() -&gt; ImageView.Instance { return self }
}
extension ImageView {
	func nsImageView() -&gt; ImageView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ImageViewBinding: ControlBinding {
	static func imageViewBinding(_ binding: ImageView.Binding) -&gt; Self
	func asImageViewBinding() -&gt; ImageView.Binding?
}
extension ImageViewBinding {
	static func controlBinding(_ binding: Control.Binding) -&gt; Self {
		return imageViewBinding(.inheritedBinding(binding))
	}
}
extension ImageViewBinding where Preparer.Inherited.Binding: ImageViewBinding {
	func asImageViewBinding() -&gt; ImageView.Binding? {
		return asInheritedBinding()?.asImageViewBinding()
	}
}
extension ImageView.Binding {
	typealias Preparer = ImageView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asImageViewBinding() -&gt; ImageView.Binding? { return self }
	static func imageViewBinding(_ binding: ImageView.Binding) -&gt; ImageView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class MagnificationGestureRecognizer: Binder, MagnificationGestureRecognizerConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension MagnificationGestureRecognizer {
	enum Binding: MagnificationGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case magnification(Dynamic&lt;CGFloat&gt;)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension MagnificationGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = MagnificationGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = NSMagnificationGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension MagnificationGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .magnification(let x): return x.apply(instance) { i, v in i.magnification = v }
			
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension MagnificationGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: MagnificationGestureRecognizerBinding {
	typealias MagnificationGestureRecognizerName&lt;V&gt; = BindingName&lt;V, MagnificationGestureRecognizer.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; MagnificationGestureRecognizer.Binding) -&gt; MagnificationGestureRecognizerName&lt;V&gt; {
		return MagnificationGestureRecognizerName&lt;V&gt;(source: source, downcast: Binding.magnificationGestureRecognizerBinding)
	}
}
extension BindingName where Binding: MagnificationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: MagnificationGestureRecognizerName&lt;$2&gt; { return .name(MagnificationGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var magnification: MagnificationGestureRecognizerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(MagnificationGestureRecognizer.Binding.magnification) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol MagnificationGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsMagnificationGestureRecognizer() -&gt; MagnificationGestureRecognizer.Instance
}
extension MagnificationGestureRecognizerConvertible {
	func nsGestureRecognizer() -&gt; GestureRecognizer.Instance { return nsMagnificationGestureRecognizer() }
}
extension NSMagnificationGestureRecognizer: MagnificationGestureRecognizerConvertible {
	func nsMagnificationGestureRecognizer() -&gt; MagnificationGestureRecognizer.Instance { return self }
}
extension MagnificationGestureRecognizer {
	func nsMagnificationGestureRecognizer() -&gt; MagnificationGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol MagnificationGestureRecognizerBinding: GestureRecognizerBinding {
	static func magnificationGestureRecognizerBinding(_ binding: MagnificationGestureRecognizer.Binding) -&gt; Self
	func asMagnificationGestureRecognizerBinding() -&gt; MagnificationGestureRecognizer.Binding?
}
extension MagnificationGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -&gt; Self {
		return magnificationGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension MagnificationGestureRecognizerBinding where Preparer.Inherited.Binding: MagnificationGestureRecognizerBinding {
	func asMagnificationGestureRecognizerBinding() -&gt; MagnificationGestureRecognizer.Binding? {
		return asInheritedBinding()?.asMagnificationGestureRecognizerBinding()
	}
}
extension MagnificationGestureRecognizer.Binding {
	typealias Preparer = MagnificationGestureRecognizer.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asMagnificationGestureRecognizerBinding() -&gt; MagnificationGestureRecognizer.Binding? { return self }
	static func magnificationGestureRecognizerBinding(_ binding: MagnificationGestureRecognizer.Binding) -&gt; MagnificationGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class MenuItem: Binder, MenuItemConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension MenuItem {
	enum Binding: MenuItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic&lt;Bool&gt;)
		case isHidden(Dynamic&lt;Bool&gt;)
		case isAlternate(Dynamic&lt;Bool&gt;)
		case title(Dynamic&lt;String&gt;)
		case attributedTitle(Dynamic&lt;NSAttributedString?&gt;)
		case tag(Dynamic&lt;Int&gt;)
		case representedObject(Dynamic&lt;AnyObject?&gt;)
		case state(Dynamic&lt;NSControl.StateValue&gt;)
		case indentationLevel(Dynamic&lt;Int&gt;)
		case image(Dynamic&lt;NSImage?&gt;)
		case onStateImage(Dynamic&lt;NSImage?&gt;)
		case offStateImage(Dynamic&lt;NSImage?&gt;)
		case mixedStateImage(Dynamic&lt;NSImage?&gt;)
		case submenu(Dynamic&lt;MenuConvertible?&gt;)
		case keyEquivalent(Dynamic&lt;String&gt;)
		case keyEquivalentModifierMask(Dynamic&lt;NSEvent.ModifierFlags&gt;)
		case toolTip(Dynamic&lt;String?&gt;)
		case view(Dynamic&lt;ViewConvertible?&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case action(TargetAction)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension MenuItem {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = MenuItem.Binding
		typealias Inherited = BinderBase
		typealias Instance = NSMenuItem
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension MenuItem.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .attributedTitle(let x): return x.apply(instance) { i, v in i.attributedTitle = v }
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .indentationLevel(let x): return x.apply(instance) { i, v in i.indentationLevel = v }
		case .isAlternate(let x): return x.apply(instance) { i, v in i.isAlternate = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .keyEquivalent(let x): return x.apply(instance) { i, v in i.keyEquivalent = v }
		case .keyEquivalentModifierMask(let x): return x.apply(instance) { i, v in i.keyEquivalentModifierMask = v }
		case .mixedStateImage(let x): return x.apply(instance) { i, v in i.mixedStateImage = v }
		case .offStateImage(let x): return x.apply(instance) { i, v in i.offStateImage = v }
		case .onStateImage(let x): return x.apply(instance) { i, v in i.onStateImage = v }
		case .representedObject(let x): return x.apply(instance) { i, v in i.representedObject = v }
		case .state(let x): return x.apply(instance) { i, v in i.state = v }
		case .submenu(let x): return x.apply(instance) { i, v in i.submenu = v?.nsMenu() }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .toolTip(let x): return x.apply(instance) { i, v in i.toolTip = v }
		case .view(let x): return x.apply(instance) { i, v in i.view = v?.nsView() }

		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: SignalActionTarget.init)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension MenuItem.Preparer {
	typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: MenuItemBinding {
	typealias MenuItemName&lt;V&gt; = BindingName&lt;V, MenuItem.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; MenuItem.Binding) -&gt; MenuItemName&lt;V&gt; {
		return MenuItemName&lt;V&gt;(source: source, downcast: Binding.menuItemBinding)
	}
}
extension BindingName where Binding: MenuItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: MenuItemName&lt;$2&gt; { return .name(MenuItem.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: MenuItemName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(MenuItem.Binding.isEnabled) }
	static var isHidden: MenuItemName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(MenuItem.Binding.isHidden) }
	static var isAlternate: MenuItemName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(MenuItem.Binding.isAlternate) }
	static var title: MenuItemName&lt;Dynamic&lt;String&gt;&gt; { return .name(MenuItem.Binding.title) }
	static var attributedTitle: MenuItemName&lt;Dynamic&lt;NSAttributedString?&gt;&gt; { return .name(MenuItem.Binding.attributedTitle) }
	static var tag: MenuItemName&lt;Dynamic&lt;Int&gt;&gt; { return .name(MenuItem.Binding.tag) }
	static var representedObject: MenuItemName&lt;Dynamic&lt;AnyObject?&gt;&gt; { return .name(MenuItem.Binding.representedObject) }
	static var state: MenuItemName&lt;Dynamic&lt;NSControl.StateValue&gt;&gt; { return .name(MenuItem.Binding.state) }
	static var indentationLevel: MenuItemName&lt;Dynamic&lt;Int&gt;&gt; { return .name(MenuItem.Binding.indentationLevel) }
	static var image: MenuItemName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(MenuItem.Binding.image) }
	static var onStateImage: MenuItemName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(MenuItem.Binding.onStateImage) }
	static var offStateImage: MenuItemName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(MenuItem.Binding.offStateImage) }
	static var mixedStateImage: MenuItemName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(MenuItem.Binding.mixedStateImage) }
	static var submenu: MenuItemName&lt;Dynamic&lt;MenuConvertible?&gt;&gt; { return .name(MenuItem.Binding.submenu) }
	static var keyEquivalent: MenuItemName&lt;Dynamic&lt;String&gt;&gt; { return .name(MenuItem.Binding.keyEquivalent) }
	static var keyEquivalentModifierMask: MenuItemName&lt;Dynamic&lt;NSEvent.ModifierFlags&gt;&gt; { return .name(MenuItem.Binding.keyEquivalentModifierMask) }
	static var toolTip: MenuItemName&lt;Dynamic&lt;String?&gt;&gt; { return .name(MenuItem.Binding.toolTip) }
	static var view: MenuItemName&lt;Dynamic&lt;ViewConvertible?&gt;&gt; { return .name(MenuItem.Binding.view) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: MenuItemName&lt;TargetAction&gt; { return .name(MenuItem.Binding.action) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.

	// Composite binding names
	static func action&lt;Value&gt;(_ keyPath: KeyPath&lt;Binding.Preparer.Instance, Value&gt;) -&gt; MenuItemName&lt;SignalInput&lt;Value&gt;&gt; {
		return Binding.keyPathActionName(keyPath, MenuItem.Binding.action, Binding.menuItemBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol MenuItemConvertible {
	func nsMenuItem() -&gt; MenuItem.Instance
}
extension NSMenuItem: MenuItemConvertible, DefaultConstructable, TargetActionSender {
	func nsMenuItem() -&gt; MenuItem.Instance { return self }
}
extension MenuItem {
	func nsMenuItem() -&gt; MenuItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol MenuItemBinding: BinderBaseBinding {
	static func menuItemBinding(_ binding: MenuItem.Binding) -&gt; Self
	func asMenuItemBinding() -&gt; MenuItem.Binding?
}
extension MenuItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return menuItemBinding(.inheritedBinding(binding))
	}
}
extension MenuItemBinding where Preparer.Inherited.Binding: MenuItemBinding {
	func asMenuItemBinding() -&gt; MenuItem.Binding? {
		return asInheritedBinding()?.asMenuItemBinding()
	}
}
extension MenuItem.Binding {
	typealias Preparer = MenuItem.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asMenuItemBinding() -&gt; MenuItem.Binding? { return self }
	static func menuItemBinding(_ binding: MenuItem.Binding) -&gt; MenuItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class Menu: Binder, MenuConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Menu {
	enum Binding: MenuBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case systemName(Constant&lt;SystemMenu&gt;)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsContextMenuPlugIns(Dynamic&lt;Bool&gt;)
		case autoenablesItems(Dynamic&lt;Bool&gt;)
		case font(Dynamic&lt;NSFont&gt;)
		case items(Dynamic&lt;[MenuItemConvertible]&gt;)
		case minimumWidth(Dynamic&lt;CGFloat&gt;)
		case showsStateColumn(Dynamic&lt;Bool&gt;)
		case title(Dynamic&lt;String&gt;)
		case userInterfaceLayoutDirection(Dynamic&lt;NSUserInterfaceLayoutDirection&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case cancelTracking(Signal&lt;Void&gt;)
		case cancelTrackingWithoutAnimation(Signal&lt;Void&gt;)
		case performAction(Signal&lt;Int&gt;)
		case popUp(Signal&lt;(item: Int, at: NSPoint, in: NSView?)&gt;)
		case popUpContextMenu(Signal&lt;(with: NSEvent, for: NSView)&gt;)
		
		// 3. Action bindings are triggered by the object after construction.
		case didBeginTracking(SignalInput&lt;Void&gt;)
		case didEndTracking(SignalInput&lt;Void&gt;)
		case didSendAction(SignalInput&lt;Int&gt;)
		case willSendAction(SignalInput&lt;Int&gt;)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case confinementRect((_ menu: NSMenu, _ screen: NSScreen?) -&gt; NSRect)
		case didClose((_ menu: NSMenu) -&gt; Void)
		case willHighlight((_ menu: NSMenu, _ item: NSMenuItem?, _ index: Int?) -&gt; Void)
		case willOpen((_ menu: NSMenu) -&gt; Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension Menu {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = Menu.Binding
		typealias Inherited = BinderBase
		typealias Instance = NSMenu
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var systemName: SystemMenu?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Menu.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -&gt; Instance {
		let x: NSMenu
		if let sn = systemName {
			let name = sn.rawValue
			let codingProxy = MenuCodingProxy(name: name)
			let archiver = NSKeyedArchiver(requiringSecureCoding: false)
			archiver.setClassName(NSStringFromClass(type), for: MenuCodingProxy.self)
			archiver.outputFormat = .binary
			archiver.encode(codingProxy, forKey: NSKeyedArchiveRootObjectKey)
			archiver.finishEncoding()

			x = (try? NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(archiver.encodedData) as? NSMenu) ?? NSMenu()
		} else {
			x = type.init()
		}
		return x
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .confinementRect(let x): delegate().addSingleHandler2(x, #selector(NSMenuDelegate.confinementRect(for:on:)))
		case .didClose(let x): delegate().addMultiHandler1(x, #selector(NSMenuDelegate.menuDidClose(_:)))
		case .systemName(let x): systemName = x.value
		case .willHighlight(let x): delegate().addMultiHandler3(x, #selector(NSMenuDelegate.menu(_:willHighlight:)))
		case .willOpen(let x): delegate().addMultiHandler1(x, #selector(NSMenuDelegate.menuWillOpen(_:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .systemName: return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsContextMenuPlugIns(let x): return x.apply(instance) { i, v in i.allowsContextMenuPlugIns = v }
		case .autoenablesItems(let x): return x.apply(instance) { i, v in i.autoenablesItems = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .items(let x):
			return x.apply(instance) { i, v in
				i.removeAllItems()
				v.forEach { i.addItem($0.nsMenuItem()) }
			}
		case .minimumWidth(let x): return x.apply(instance) { i, v in i.minimumWidth = v }
		case .showsStateColumn(let x): return x.apply(instance) { i, v in i.showsStateColumn = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .userInterfaceLayoutDirection(let x): return x.apply(instance) { i, v in i.userInterfaceLayoutDirection = v }
		
		// 2. Signal bindings are performed on the object after construction.
		case .cancelTracking(let x): return x.apply(instance) { i, v in i.cancelTracking() }
		case .cancelTrackingWithoutAnimation(let x): return x.apply(instance) { i, v in i.cancelTrackingWithoutAnimation() }
		case .performAction(let x): return x.apply(instance) { i, v in i.performActionForItem(at: v) }
		case .popUp(let x):
			return x.apply(instance) { i, v in
				let item = v.item &gt;= 0 ? (i.items.at(v.item) ?? i.items.last) : i.items.first
				i.popUp(positioning: item, at: v.at, in: v.in)
			}
		case .popUpContextMenu(let x): return x.apply(instance) { i, v in NSMenu.popUpContextMenu(i, with: v.with, for: v.for) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didBeginTracking(let x):
			return Signal.notifications(name: NSMenu.didBeginTrackingNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didClose: return nil
		case .didEndTracking(let x):
			return Signal.notifications(name: NSMenu.didEndTrackingNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didSendAction(let x):
			return Signal.notifications(name: NSMenu.didSendActionNotification, object: instance).compactMap { n -&gt; Int? in
				if let menuItem = n.userInfo?["MenuItem"] as? NSMenuItem, let menu = menuItem.menu, let index = menu.items.firstIndex(where: { i in i == menuItem }) {
					return index
				}
				return nil
				}.cancellableBind(to: x)
		case .willHighlight: return nil
		case .willOpen: return nil
		case .willSendAction(let x):
			return Signal.notifications(name: NSMenu.willSendActionNotification, object: instance).compactMap { n -&gt; Int? in
				if let menuItem = n.userInfo?["MenuItem"] as? NSMenuItem, let menu = menuItem.menu, let index = menu.items.firstIndex(of: menuItem) {
					return index
				}
				return nil
			}.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .confinementRect: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Menu.Preparer {
	class Storage: AssociatedBinderStorage, NSMenuDelegate {}

	class Delegate: DynamicDelegate, NSMenuDelegate {
		func menuWillOpen(_ menu: NSMenu) {
			multiHandler(menu)
		}
		
		func menuDidClose(_ menu: NSMenu) {
			multiHandler(menu)
		}
		
		func confinementRect(for menu: NSMenu, on screen: NSScreen?) -&gt; NSRect {
			return singleHandler(menu, screen)
		}
		
		func menu(_ menu: NSMenu, willHighlight menuItem: NSMenuItem?) {
			let match = menuItem.flatMap { item in menu.items.enumerated().first { offset, element in item == element } }
			multiHandler(menu, menuItem, match?.offset)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: MenuBinding {
	typealias MenuName&lt;V&gt; = BindingName&lt;V, Menu.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; Menu.Binding) -&gt; MenuName&lt;V&gt; {
		return MenuName&lt;V&gt;(source: source, downcast: Binding.menuBinding)
	}
}
extension BindingName where Binding: MenuBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: MenuName&lt;$2&gt; { return .name(Menu.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var systemName: MenuName&lt;Constant&lt;SystemMenu&gt;&gt; { return .name(Menu.Binding.systemName) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsContextMenuPlugIns: MenuName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Menu.Binding.allowsContextMenuPlugIns) }
	static var autoenablesItems: MenuName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Menu.Binding.autoenablesItems) }
	static var font: MenuName&lt;Dynamic&lt;NSFont&gt;&gt; { return .name(Menu.Binding.font) }
	static var items: MenuName&lt;Dynamic&lt;[MenuItemConvertible]&gt;&gt; { return .name(Menu.Binding.items) }
	static var minimumWidth: MenuName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(Menu.Binding.minimumWidth) }
	static var showsStateColumn: MenuName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Menu.Binding.showsStateColumn) }
	static var title: MenuName&lt;Dynamic&lt;String&gt;&gt; { return .name(Menu.Binding.title) }
	static var userInterfaceLayoutDirection: MenuName&lt;Dynamic&lt;NSUserInterfaceLayoutDirection&gt;&gt; { return .name(Menu.Binding.userInterfaceLayoutDirection) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var popUpContextMenu: MenuName&lt;Signal&lt;(with: NSEvent, for: NSView)&gt;&gt; { return .name(Menu.Binding.popUpContextMenu) }
	static var popUp: MenuName&lt;Signal&lt;(item: Int, at: NSPoint, in: NSView?)&gt;&gt; { return .name(Menu.Binding.popUp) }
	static var performAction: MenuName&lt;Signal&lt;Int&gt;&gt; { return .name(Menu.Binding.performAction) }
	static var cancelTracking: MenuName&lt;Signal&lt;Void&gt;&gt; { return .name(Menu.Binding.cancelTracking) }
	static var cancelTrackingWithoutAnimation: MenuName&lt;Signal&lt;Void&gt;&gt; { return .name(Menu.Binding.cancelTrackingWithoutAnimation) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var willOpen: MenuName&lt;(NSMenu) -&gt; Void&gt; { return .name(Menu.Binding.willOpen) }
	static var didClose: MenuName&lt;(NSMenu) -&gt; Void&gt; { return .name(Menu.Binding.didClose) }
	static var didBeginTracking: MenuName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Menu.Binding.didBeginTracking) }
	static var didEndTracking: MenuName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Menu.Binding.didEndTracking) }
	static var willHighlight: MenuName&lt;(NSMenu, NSMenuItem?, Int?) -&gt; Void&gt; { return .name(Menu.Binding.willHighlight) }
	static var willSendAction: MenuName&lt;SignalInput&lt;Int&gt;&gt; { return .name(Menu.Binding.willSendAction) }
	static var didSendAction: MenuName&lt;SignalInput&lt;Int&gt;&gt; { return .name(Menu.Binding.didSendAction) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var confinementRect: MenuName&lt;(_ menu: NSMenu, _ screen: NSScreen?) -&gt; NSRect&gt; { return .name(Menu.Binding.confinementRect) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol MenuConvertible {
	func nsMenu() -&gt; Menu.Instance
}
extension NSMenu: MenuConvertible, HasDelegate, DefaultConstructable {
	func nsMenu() -&gt; Menu.Instance { return self }
}
extension Menu {
	func nsMenu() -&gt; Menu.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol MenuBinding: BinderBaseBinding {
	static func menuBinding(_ binding: Menu.Binding) -&gt; Self
	func asMenuBinding() -&gt; Menu.Binding?
}
extension MenuBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return menuBinding(.inheritedBinding(binding))
	}
}
extension MenuBinding where Preparer.Inherited.Binding: MenuBinding {
	func asMenuBinding() -&gt; Menu.Binding? {
		return asInheritedBinding()?.asMenuBinding()
	}
}
extension Menu.Binding {
	typealias Preparer = Menu.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asMenuBinding() -&gt; Menu.Binding? { return self }
	static func menuBinding(_ binding: Menu.Binding) -&gt; Menu.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
enum SystemMenu: String {
	case apple = "NSAppleMenu"
	case font = "NSFontMenu"
	case help = "NSHelpMenu"
	case recentDocuments = "NSRecentDocumentsMenu"
	case services = "NSServicesMenu"
	case windows = "NSWindowsMenu"
}

class MenuCodingProxy: NSObject, NSCoding {
	let name: String
	
	func encode(with aCoder: NSCoder) {
		aCoder.encode("", forKey: "NSTitle")
		aCoder.encode(name, forKey: "NSName")
	 }

	init(name: String) {
		self.name = name
		super.init()
	}

	required init?(coder aDecoder: NSCoder) {
		name = ""
		super.init()
	 }
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class OutlineView&lt;NodeData&gt;: Binder, OutlineViewConvertible {
	static func scrollEmbedded(type: NSOutlineView.Type = NSOutlineView.self, _ bindings: Binding...) -&gt; ScrollView {
		return ScrollView(
			.borderType -- .noBorder,
			.hasVerticalScroller -- true,
			.hasHorizontalScroller -- true,
			.autohidesScrollers -- true,
			.contentView -- ClipView(
				.documentView -- OutlineView&lt;NodeData&gt;(type: type, bindings: bindings)
			)
		)
	}

	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension OutlineView {
	enum Binding: OutlineViewBinding {
		typealias NodeDataType = NodeData
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsColumnReordering(Dynamic&lt;Bool&gt;)
		case allowsColumnResizing(Dynamic&lt;Bool&gt;)
		case allowsColumnSelection(Dynamic&lt;Bool&gt;)
		case allowsEmptySelection(Dynamic&lt;Bool&gt;)
		case allowsMultipleSelection(Dynamic&lt;Bool&gt;)
		case allowsTypeSelect(Dynamic&lt;Bool&gt;)
		case autoresizesOutlineColumn(Dynamic&lt;Bool&gt;)
		case autosaveExpandedItems(Dynamic&lt;Bool&gt;)
		case autosaveName(Dynamic&lt;NSTableView.AutosaveName?&gt;)
		case autosaveTableColumns(Dynamic&lt;Bool&gt;)
		case backgroundColor(Dynamic&lt;NSColor&gt;)
		case columnAutoresizingStyle(Dynamic&lt;NSTableView.ColumnAutoresizingStyle&gt;)
		case columns(Dynamic&lt;[TableColumn&lt;NodeData&gt;]&gt;)
		case cornerView(Dynamic&lt;ViewConvertible?&gt;)
		case draggingDestinationFeedbackStyle(Dynamic&lt;NSTableView.DraggingDestinationFeedbackStyle&gt;)
		case floatsGroupRows(Dynamic&lt;Bool&gt;)
		case gridColor(Dynamic&lt;NSColor&gt;)
		case gridStyleMask(Dynamic&lt;NSTableView.GridLineStyle&gt;)
		case headerView(Dynamic&lt;TableHeaderViewConvertible?&gt;)
		case indentationMarkerFollowsCell(Dynamic&lt;Bool&gt;)
		case indentationPerLevel(Dynamic&lt;CGFloat&gt;)
		case intercellSpacing(Dynamic&lt;NSSize&gt;)
		case outlineTableColumnIdentifier(Dynamic&lt;NSUserInterfaceItemIdentifier&gt;)
		case rowHeight(Dynamic&lt;CGFloat&gt;)
		case rowSizeStyle(Dynamic&lt;NSTableView.RowSizeStyle&gt;)
		case selectionHighlightStyle(Dynamic&lt;NSTableView.SelectionHighlightStyle&gt;)
		case stronglyReferencesItems(Dynamic&lt;Bool&gt;)
		case treeData(Dynamic&lt;TreeAnimation&lt;NodeData&gt;&gt;)
		case userInterfaceLayoutDirection(Dynamic&lt;NSUserInterfaceLayoutDirection&gt;)
		case usesAlternatingRowBackgroundColors(Dynamic&lt;Bool&gt;)
		case verticalMotionCanBeginDrag(Dynamic&lt;Bool&gt;)
		
		// 2. Signal bindings are performed on the object after construction.
		case collapseIndexPath(Signal&lt;(indexPath: IndexPath?, collapseChildren: Bool)&gt;)
		case deselectAll(Signal&lt;Void&gt;)
		case deselectColumn(Signal&lt;NSUserInterfaceItemIdentifier&gt;)
		case deselectIndexPath(Signal&lt;IndexPath&gt;)
		case expandIndexPath(Signal&lt;(indexPath: IndexPath?, expandChildren: Bool)&gt;)
		case hideRowActions(Signal&lt;Void&gt;)
		case hideRows(Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;)
		case highlightColumn(Signal&lt;NSUserInterfaceItemIdentifier?&gt;)
		case moveColumn(Signal&lt;(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)&gt;)
		case scrollColumnToVisible(Signal&lt;NSUserInterfaceItemIdentifier&gt;)
		case scrollIndexPathToVisible(Signal&lt;IndexPath&gt;)
		case selectAll(Signal&lt;Void&gt;)
		case selectColumns(Signal&lt;(identifiers: Set&lt;NSUserInterfaceItemIdentifier&gt;, byExtendingSelection: Bool)&gt;)
		case selectIndexPaths(Signal&lt;(indexPaths: Set&lt;IndexPath&gt;, byExtendingSelection: Bool)&gt;)
		case setDropIndexPath(Signal&lt;(indexPath: IndexPath?, dropChildIndex: Int)&gt;)
		case sizeLastColumnToFit(Signal&lt;Void&gt;)
		case sizeToFit(Signal&lt;Void&gt;)
		case unhideRows(Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;)
		
		// 3. Action bindings are triggered by the object after construction.
		case columnMoved(SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)&gt;)
		case columnResized(SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)&gt;)
		case doubleAction(TargetAction)
		case selectionChanged(SignalInput&lt;(selectedColumns: Set&lt;NSUserInterfaceItemIdentifier&gt;, selectedIndexPaths: Set&lt;IndexPath&gt;)&gt;)
		case selectionIsChanging(SignalInput&lt;Void&gt;)
		case indexPathDidCollapse(SignalInput&lt;IndexPath&gt;)
		case indexPathDidExpand(SignalInput&lt;IndexPath&gt;)
		case indexPathWillCollapse(SignalInput&lt;IndexPath&gt;)
		case indexPathWillExpand(SignalInput&lt;IndexPath&gt;)
		case visibleIndexPathsChanged(SignalInput&lt;Set&lt;IndexPath&gt;&gt;)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case acceptDrop((_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ indexPath: IndexPath?, _ childIndex: Int) -&gt; Bool)
		case didClickTableColumn((NSOutlineView, NSTableColumn) -&gt; Void)
		case didDragTableColumn((NSOutlineView, NSTableColumn) -&gt; Void)
		case draggingSessionEnded((_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -&gt; Void)
		case draggingSessionWillBegin((_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ willBeginAt: NSPoint, _ forItems: [IndexPath]) -&gt; Void)
		case groupRowCellConstructor((Int) -&gt; TableCellViewConvertible)
		case heightOfRow((NSOutlineView, _ indexPath: IndexPath) -&gt; CGFloat)
		case isIndexPathExpandable((_ outlineView: NSOutlineView, IndexPath) -&gt; Bool)
		case mouseDownInHeaderOfTableColumn((NSOutlineView, NSTableColumn) -&gt; Void)
		case nextTypeSelectMatch((_ outlineView: NSOutlineView, _ from: IndexPath, _ to: IndexPath, _ for: String) -&gt; IndexPath?)
		case pasteboardWriter((_ outlineView: NSOutlineView, _ forIndexPath: IndexPath) -&gt; NSPasteboardWriting?)
		case rowView((_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; TableRowViewConvertible?)
		case selectionIndexesForProposedSelection((_ outlineView: NSOutlineView, _ proposedSelectionIndexes: Set&lt;IndexPath&gt;) -&gt; Set&lt;IndexPath&gt;)
		case selectionShouldChange((_ outlineView: NSOutlineView) -&gt; Bool)
		case shouldCollapse((_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; Bool)
		case shouldExpand((_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; Bool)
		case shouldReorderColumn((_ outlineView: NSOutlineView, _ column: NSTableColumn, _ newIndex: Int) -&gt; Bool)
		case shouldSelectIndexPath((_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; Bool)
		case shouldSelectTableColumn((_ outlineView: NSOutlineView, _ column: NSTableColumn?) -&gt; Bool)
		case shouldTypeSelectForEvent((_ outlineView: NSOutlineView, _ event: NSEvent, _ searchString: String?) -&gt; Bool)
		case sizeToFitWidthOfColumn((_ outlineView: NSOutlineView, _ column: NSTableColumn) -&gt; CGFloat)
		case sortDescriptorsDidChange((NSOutlineView, [NSSortDescriptor]) -&gt; Void)
		case typeSelectString((_ outlineView: NSOutlineView, _ column: NSTableColumn?, _ indexPath: IndexPath) -&gt; String?)
		case updateDraggingItems((_ outlineView: NSOutlineView, _ forDrag: NSDraggingInfo) -&gt; Void)
		case validateDrop((_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ proposedIndexPath: IndexPath?, _ proposedChildIndex: Int) -&gt; NSDragOperation)
	}
}

// MARK: - Binder Part 3: Preparer
extension OutlineView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = OutlineView.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = NSOutlineView
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage(visibleIndexPathsChanged: visibleIndexPathsChanged) }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var singleAction: TargetAction?
		var doubleAction: TargetAction?
		var outlineColumn: NSUserInterfaceItemIdentifier? = nil
		var visibleIndexPathsChanged: MultiOutput&lt;Set&lt;IndexPath&gt;&gt;?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension OutlineView.Preparer {
	var delegateIsRequired: Bool { return true }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.action(let x)): singleAction = x
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .acceptDrop(let x): delegate().addSingleHandler4(x, #selector(NSOutlineViewDataSource.outlineView(_:acceptDrop:item:childIndex:)))
		case .didClickTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:didClick:)))
		case .didDragTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:didDrag:)))
		case .doubleAction(let x): doubleAction = x
		case .draggingSessionEnded(let x): delegate().addMultiHandler4(x, #selector(NSOutlineViewDataSource.outlineView(_:draggingSession:endedAt:operation:)))
		case .heightOfRow(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:heightOfRowByItem:)))
		case .isIndexPathExpandable(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDataSource.outlineView(_:isItemExpandable:)))
		case .mouseDownInHeaderOfTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:mouseDownInHeaderOf:)))
		case .nextTypeSelectMatch(let x): delegate().addSingleHandler4(x, #selector(NSOutlineViewDelegate.outlineView(_:nextTypeSelectMatchFromItem:toItem:for:)))
		case .pasteboardWriter(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDataSource.outlineView(_:pasteboardWriterForItem:)))
		case .rowView(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:rowViewForItem:)))
		case .selectionIndexesForProposedSelection(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:selectionIndexesForProposedSelection:)))
		case .selectionShouldChange(let x): delegate().addSingleHandler1(x, #selector(NSOutlineViewDelegate.selectionShouldChange(in:)))
		case .shouldCollapse(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldCollapseItem:)))
		case .shouldExpand(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldExpandItem:)))
		case .shouldReorderColumn(let x): delegate().addSingleHandler3(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldReorderColumn:toColumn:)))
		case .shouldSelectTableColumn(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldSelect:)))
		case .shouldSelectIndexPath(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldSelectItem:)))
		case .shouldTypeSelectForEvent(let x): delegate().addSingleHandler3(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldTypeSelectFor:withCurrentSearch:)))
		case .sizeToFitWidthOfColumn(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:sizeToFitWidthOfColumn:)))
		case .sortDescriptorsDidChange(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDataSource.outlineView(_:sortDescriptorsDidChange:)))
		case .typeSelectString(let x): delegate().addSingleHandler3(x, #selector(NSOutlineViewDelegate.outlineView(_:typeSelectStringFor:item:)))
		case .updateDraggingItems(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDataSource.outlineView(_:updateDraggingItemsForDrag:)))
		case .validateDrop(let x): delegate().addSingleHandler4(x, #selector(NSOutlineViewDataSource.outlineView(_:validateDrop:proposedItem:proposedChildIndex:)))
		case .visibleIndexPathsChanged(let x):
			visibleIndexPathsChanged = visibleIndexPathsChanged ?? Input().multicast()
			visibleIndexPathsChanged?.signal.bind(to: x)
		default: break
		}
	}
	
	// NOTE: due to the fact that `NSOutlineView` is a subclass of `NSTableView` but uses an *unrelated* delegate protocol type, we need to manually re-implement `prepareDelegate` here since the delegate does *not* conform to the `NSTableViewDelegate` protocol specified in the `HasDelegate` conformance.
	func prepareDelegate(instance: Instance, storage: Storage) {
		if delegateIsRequired {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			if dynamicDelegate != nil {
				storage.dynamicDelegate = dynamicDelegate
			}
			instance.delegate = storage
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		instance.dataSource = storage
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(.action): return nil
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsColumnReordering(let x): return x.apply(instance) { i, v in i.allowsColumnReordering = v }
		case .allowsColumnResizing(let x): return x.apply(instance) { i, v in i.allowsColumnResizing = v }
		case .allowsColumnSelection(let x): return x.apply(instance) { i, v in i.allowsColumnSelection = v }
		case .allowsEmptySelection(let x): return x.apply(instance) { i, v in i.allowsEmptySelection = v }
		case .allowsMultipleSelection(let x): return x.apply(instance) { i, v in i.allowsMultipleSelection = v }
		case .allowsTypeSelect(let x): return x.apply(instance) { i, v in i.allowsTypeSelect = v }
		case .autoresizesOutlineColumn(let x): return x.apply(instance) { i, v in i.autoresizesOutlineColumn = v }
		case .autosaveExpandedItems(let x): return x.apply(instance) { i, v in i.autosaveExpandedItems = v }
		case .autosaveName(let x): return x.apply(instance) { i, v in i.autosaveName = v }
		case .autosaveTableColumns(let x): return x.apply(instance) { i, v in i.autosaveTableColumns = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .columnAutoresizingStyle(let x): return x.apply(instance) { i, v in i.columnAutoresizingStyle = v }
		case .columns(let x): return x.apply(instance, storage) { i, s, v in s.applyColumns(v.map { $0.construct() }, to: i) }
		case .cornerView(let x): return x.apply(instance) { i, v in i.cornerView = v?.nsView() }
		case .draggingDestinationFeedbackStyle(let x): return x.apply(instance) { i, v in i.draggingDestinationFeedbackStyle = v }
		case .floatsGroupRows(let x): return x.apply(instance) { i, v in i.floatsGroupRows = v }
		case .gridColor(let x): return x.apply(instance) { i, v in i.gridColor = v }
		case .gridStyleMask(let x): return x.apply(instance) { i, v in i.gridStyleMask = v }
		case .headerView(let x): return x.apply(instance) { i, v in i.headerView = v?.nsTableHeaderView() }
		case .indentationMarkerFollowsCell(let x): return x.apply(instance) { i, v in i.indentationMarkerFollowsCell = v }
		case .indentationPerLevel(let x): return x.apply(instance) { i, v in i.indentationPerLevel = v }
		case .intercellSpacing(let x): return x.apply(instance) { i, v in i.intercellSpacing = v }
		case .outlineTableColumnIdentifier(let x): return x.apply(instance, storage) { i, s, v in s.outlineColumnIdentifier = v }
		case .rowHeight(let x): return x.apply(instance) { i, v in i.rowHeight = v }
		case .rowSizeStyle(let x): return x.apply(instance) { i, v in i.rowSizeStyle = v }
		case .selectionHighlightStyle(let x): return x.apply(instance) { i, v in i.selectionHighlightStyle = v }
		case .treeData(let x): return x.apply(instance, storage) { i, s, v in s.applyTreeAnimation(v, to: i) }
		case .userInterfaceLayoutDirection(let x): return x.apply(instance) { i, v in i.userInterfaceLayoutDirection = v }
		case .usesAlternatingRowBackgroundColors(let x): return x.apply(instance) { i, v in i.usesAlternatingRowBackgroundColors = v }
		case .verticalMotionCanBeginDrag(let x): return x.apply(instance) { i, v in i.verticalMotionCanBeginDrag = v }

		case .stronglyReferencesItems(let x): return x.apply(instance) { i, v in i.stronglyReferencesItems = v }
		
		// 2. Signal bindings are performed on the object after construction.
		case .collapseIndexPath(let x):
			return x.apply(instance, storage) { i, s, v in
				if let indexPath = v.indexPath, let item = s.item(forIndexPath: indexPath, in: i) {
					i.collapseItem(item, collapseChildren: v.collapseChildren)
				} else {
					i.collapseItem(nil, collapseChildren: v.collapseChildren)
				}
			}
		case .deselectAll(let x): return x.apply(instance) { i, v in i.deselectAll(nil) }
		case .deselectColumn(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v })?.offset {
					i.deselectColumn(index)
				}
			}
		case .deselectIndexPath(let x):
			return x.apply(instance, storage) { i, s, v in
				if let row: Int = s.row(forIndexPath: v, in: i) {
					i.deselectRow(row)
				}
			}
		case .expandIndexPath(let x):
			return x.apply(instance, storage) { i, s, v in
				if let indexPath = v.indexPath, let item = s.item(forIndexPath: indexPath, in: i) {
					i.expandItem(item, expandChildren: v.expandChildren)
				} else {
					i.expandItem(nil, expandChildren: v.expandChildren)
				}
			}
		case .hideRowActions(let x): return x.apply(instance) { i, v in i.rowActionsVisible = false }
		case .hideRows(let x): return x.apply(instance) { i, v in i.hideRows(at: v.indexes, withAnimation: v.withAnimation) }
		case .highlightColumn(let x):
			return x.apply(instance) { i, v in
				i.highlightedTableColumn = v.flatMap { (identifier: NSUserInterfaceItemIdentifier) -&gt; NSTableColumn? in
					return i.tableColumns.first(where: { $0.identifier == identifier })
				}
			}
		case .moveColumn(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v.identifier })?.offset {
					i.moveColumn(index, toColumn: v.toIndex)
				}
			}
		case .scrollColumnToVisible(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v })?.offset {
					i.scrollColumnToVisible(index)
				}
			}
		case .scrollIndexPathToVisible(let x):
			return x.apply(instance, storage) { i, s, v in
				if let row: Int = s.row(forIndexPath: v, in: i) {
					i.scrollRowToVisible(row)
				}
			}
		case .selectAll(let x): return x.apply(instance) { i, v in i.selectAll(nil) }
		case .selectColumns(let x):
			return x.apply(instance) { i, v in
				let indexes = v.identifiers.compactMap { identifier in i.tableColumns.enumerated().first(where: { $0.element.identifier == identifier })?.offset }
				let indexSet = IndexSet(indexes)
				i.selectColumnIndexes(indexSet, byExtendingSelection: v.byExtendingSelection)
			}
		case .selectIndexPaths(let x):
			return x.apply(instance, storage) { i, s, v in
				let indexes = v.indexPaths.compactMap { s.row(forIndexPath: $0, in: i) }
				i.selectRowIndexes(IndexSet(indexes), byExtendingSelection: v.byExtendingSelection)
			}
		case .setDropIndexPath(let x):
			return x.apply(instance, storage) { i, s, v in
				if let indexPath = v.indexPath, let item = s.item(forIndexPath: indexPath, in: i) {
					i.setDropItem(item, dropChildIndex: v.dropChildIndex)
				} else {
					i.setDropItem(nil, dropChildIndex: v.dropChildIndex)
				}
			}
		case .sizeLastColumnToFit(let x): return x.apply(instance) { i, v in i.sizeLastColumnToFit() }
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }
		case .unhideRows(let x): return x.apply(instance) { i, v in i.unhideRows(at: v.indexes, withAnimation: v.withAnimation) }

		// 3. Action bindings are triggered by the object after construction.
		case .columnMoved(let x):
			return Signal.notifications(name: NSTableView.columnDidMoveNotification, object: instance).compactMap { [weak instance] notification -&gt; (column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)? in
				guard let index = (notification.userInfo?["NSNewColumn"] as? NSNumber)?.intValue, let column = instance?.tableColumns.at(index) else {
					return nil
				}
				guard let oldIndex = (notification.userInfo?["NSNewColumn"] as? NSNumber)?.intValue else {
					return nil
				}
				return (column: column.identifier, oldIndex: oldIndex, newIndex: index)
				}.cancellableBind(to: x)
		case .columnResized(let x):
			return Signal.notifications(name: NSTableView.columnDidResizeNotification, object: instance).compactMap { notification -&gt; (column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)? in
				guard let column = (notification.userInfo?["NSTableColumn"] as? NSTableColumn) else {
					return nil
				}
				guard let oldWidth = (notification.userInfo?["NSOldWidth"] as? NSNumber)?.doubleValue else {
					return nil
				}
				return (column: column.identifier, oldWidth: CGFloat(oldWidth), newWidth: column.width)
			}.cancellableBind(to: x)
		case .didClickTableColumn: return nil
		case .didDragTableColumn: return nil
		case .doubleAction: return nil
		case .mouseDownInHeaderOfTableColumn: return nil
		case .selectionChanged(let x):
			return Signal.notifications(name: NSTableView.selectionDidChangeNotification, object: instance).compactMap { [weak instance, weak storage] n -&gt; (selectedColumns: Set&lt;NSUserInterfaceItemIdentifier&gt;, selectedIndexPaths: Set&lt;IndexPath&gt;)? in
				guard let i = instance else {
					return nil
				}
				let selectedColumns = Set&lt;NSUserInterfaceItemIdentifier&gt;(i.selectedColumnIndexes.compactMap { i.tableColumns.at($0)?.identifier })
				let selectedIndexPaths = Set(i.selectedRowIndexes.compactMap { storage?.indexPath(forRow: $0, in: i) })
				return (selectedColumns: selectedColumns, selectedIndexPaths: selectedIndexPaths)
				}.cancellableBind(to: x)
		case .selectionIsChanging(let x):
			return Signal.notifications(name: NSTableView.selectionIsChangingNotification, object: instance).map { notification -&gt; Void in () }.cancellableBind(to: x)
		case .sortDescriptorsDidChange: return nil
		case .indexPathDidCollapse(let x):
			return Signal.notifications(name: NSOutlineView.itemDidCollapseNotification, object: instance).compactMap { [weak instance, weak storage] notification -&gt; IndexPath? in
				guard let b = storage, let i = instance else { return nil }
				return notification.userInfo?["NSObject"].flatMap { b.indexPath(forItem: $0, in: i) }
				}.cancellableBind(to: x)
		case .indexPathDidExpand(let x):
			return Signal.notifications(name: NSOutlineView.itemDidExpandNotification, object: instance).compactMap { [weak instance, weak storage] notification -&gt; IndexPath? in
				guard let b = storage, let i = instance else { return nil }
				return notification.userInfo?["NSObject"].flatMap { b.indexPath(forItem: $0, in: i) }
			}.cancellableBind(to: x)
		case .indexPathWillCollapse(let x):
			return Signal.notifications(name: NSOutlineView.itemWillCollapseNotification, object: instance).compactMap { [weak instance, weak storage] notification -&gt; IndexPath? in
				guard let b = storage, let i = instance else { return nil }
				return notification.userInfo?["NSObject"].flatMap { b.indexPath(forItem: $0, in: i) }
			}.cancellableBind(to: x)
		case .indexPathWillExpand(let x):
			return Signal.notifications(name: NSOutlineView.itemWillExpandNotification, object: instance).compactMap { [weak instance, weak storage] notification -&gt; IndexPath? in
				guard let b = storage, let i = instance else { return nil }
				return notification.userInfo?["NSObject"].flatMap { b.indexPath(forItem: $0, in: i) }
				}.cancellableBind(to: x)
		case .visibleIndexPathsChanged: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .acceptDrop: return nil
		case .draggingSessionEnded: return nil
		case .draggingSessionWillBegin: return nil
		case .groupRowCellConstructor(let x):
			storage.groupRowCellConstructor = x
			return nil
		case .heightOfRow: return nil
		case .isIndexPathExpandable: return nil
		case .nextTypeSelectMatch: return nil
		case .pasteboardWriter: return nil
		case .rowView: return nil
		case .selectionIndexesForProposedSelection: return nil
		case .selectionShouldChange: return nil
		case .shouldCollapse: return nil
		case .shouldExpand: return nil
		case .shouldReorderColumn: return nil
		case .shouldSelectTableColumn: return nil
		case .shouldSelectIndexPath: return nil
		case .shouldTypeSelectForEvent: return nil
		case .sizeToFitWidthOfColumn: return nil
		case .typeSelectString: return nil
		case .updateDraggingItems: return nil
		case .validateDrop: return nil
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime? {
		var lifetimes = [Lifetime]()
		
		switch (singleAction, doubleAction) {
		case (nil, nil): break
		case (.firstResponder(let sa)?, .firstResponder(let da)?):
			instance.action = sa
			instance.doubleAction = da
			instance.target = nil
		case (.singleTarget(let st)?, .singleTarget(let dt)?):
			let target = SignalDoubleActionTarget()
			instance.target = target 
			lifetimes += target.signal.cancellableBind(to: st)
			lifetimes += target.signal.cancellableBind(to: dt)
			instance.action = SignalDoubleActionTarget.selector
			instance.doubleAction = SignalDoubleActionTarget.secondSelector
		case (let s?, nil):
			lifetimes += s.apply(to: instance, constructTarget: SignalActionTarget.init)
		case (nil, let d?):
			lifetimes += d.apply(to: instance, constructTarget: SignalActionTarget.init)
			instance.doubleAction = instance.action
			instance.action = nil
		case (.some, .some): fatalError("Action and double action may not use mix of single target and first responder")
		}
		
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension OutlineView.Preparer {
	class Storage: View.Preparer.Storage, NSOutlineViewDelegate, NSOutlineViewDataSource {
		let visibleIndexPathsChanged: MultiOutput&lt;Set&lt;IndexPath&gt;&gt;?
		
		var actionTarget: SignalDoubleActionTarget? = nil
		var treeState = TreeSubrangeState&lt;NodeData&gt;(parent: nil)
		var visibleIndexPaths: Set&lt;IndexPath&gt; = []
		var groupRowCellConstructor: ((Int) -&gt; TableCellViewConvertible)?
		var columns: [TableColumn&lt;NodeData&gt;.Preparer.Storage] = []
		var outlineColumnIdentifier: NSUserInterfaceItemIdentifier? = nil
		
		init(visibleIndexPathsChanged: MultiOutput&lt;Set&lt;IndexPath&gt;&gt;?) {
			self.visibleIndexPathsChanged = visibleIndexPathsChanged
		}

		override var isInUse: Bool { return true }
		
		func columnForIdentifier(_ identifier: NSUserInterfaceItemIdentifier) -&gt; (offset: Int, element: TableColumn&lt;NodeData&gt;.Preparer.Storage)? {
			return columns.enumerated().first { (tuple: (offset: Int, element: TableColumn&lt;NodeData&gt;.Preparer.Storage)) -&gt; Bool in
				tuple.element.tableColumn.identifier == identifier
			}
		}
		
		func outlineView(_ outlineView: NSOutlineView, itemForPersistentObject object: Any) -&gt; Any? {
			guard let indexPath = object as? IndexPath else { return nil }
			return item(forIndexPath: indexPath, in: outlineView)
		}
		
		func outlineView(_ outlineView: NSOutlineView, persistentObjectForItem item: Any?) -&gt; Any? {
			if let i = item, let indexPath = indexPath(forItem: i, in: outlineView) {
				return indexPath
			}
			return nil
		}
		
		func outlineView(_ outlineView: NSOutlineView, didAdd: NSTableRowView, forRow: Int) {
			DispatchQueue.main.async {
				if let vrsi = self.visibleIndexPathsChanged?.input, let path = self.indexPath(forRow: forRow, in: outlineView) {
					if self.visibleIndexPaths.insert(path).inserted {
						vrsi.send(value: self.visibleIndexPaths)
					}
				}
			}
		}
		
		func outlineView(_ outlineView: NSOutlineView, didRemove: NSTableRowView, forRow: Int) {
			DispatchQueue.main.async {
				if let vrsi = self.visibleIndexPathsChanged?.input, let path = self.indexPath(forRow: forRow, in: outlineView) {
					if self.visibleIndexPaths.insert(path).inserted {
						vrsi.send(value: self.visibleIndexPaths)
					}
				}
			}
		}
		
		func outlineView(_ outlineView: NSOutlineView, child: Int, ofItem: Any?) -&gt; Any {
			if ofItem == nil {
				return treeState.state.values?.at(child) ?? TreeSubrangeState&lt;NodeData&gt;(parent: nil)
			}
			return (ofItem as? TreeSubrangeState&lt;NodeData&gt;)?.state.values?.at(child) ?? TreeSubrangeState&lt;NodeData&gt;(parent: nil)
		}
		
		func outlineView(_ outlineView: NSOutlineView, isItemExpandable item: Any) -&gt; Bool {
			return ((item as? TreeSubrangeState&lt;NodeData&gt;)?.state.values ?? nil) != nil
		}
		
		func outlineView(_ outlineView: NSOutlineView, numberOfChildrenOfItem item: Any?) -&gt; Int {
			if item == nil {
				return treeState.state.globalCount
			}
			return (item as? TreeSubrangeState&lt;NodeData&gt;)?.state.globalCount ?? 0
		}
		
		func outlineView(_ outlineView: NSOutlineView, objectValueFor tableColumn: NSTableColumn?, byItem item: Any?) -&gt; Any? {
			return item
		}
		
		func outlineView(_ outlineView: NSOutlineView, viewFor tableColumn: NSTableColumn?, item: Any) -&gt; NSView? {
			if let tc = tableColumn {
				if let col = columnForIdentifier(tc.identifier) {
					let leaf = (item as? TreeSubrangeState&lt;NodeData&gt;)?.state.leaf
					let identifier = col.element.cellIdentifier?(leaf) ?? tc.identifier
					
					let cellView: NSTableCellView
					let cellInput: SignalInput&lt;NodeData&gt;?
					if let reusedView = outlineView.makeView(withIdentifier: identifier, owner: outlineView), let downcast = reusedView as? NSTableCellView {
						cellView = downcast
						cellInput = cellView.associatedRowInput(valueType: NodeData.self)
					} else if let cc = col.element.cellConstructor {
						let dataTuple = Signal&lt;NodeData&gt;.create()
						let constructed = cc(identifier, dataTuple.signal.multicast()).nsTableCellView()
						if constructed.identifier == nil {
							constructed.identifier = identifier
						}
						cellView = constructed
						cellInput = dataTuple.input
						cellView.setAssociatedRowInput(to: dataTuple.input)
					} else {
						return col.element.dataMissingCell?()?.nsTableCellView()
					}
					
					if let l = leaf {
						_ = cellInput?.send(value: l)
					}
					return cellView
				}
			} else {
				return groupRowCellConstructor?(outlineView.row(forItem: item)).nsTableCellView()
			}
			return nil
		}
		
		var outlineTableColumn: TableColumn&lt;NodeData&gt;.Preparer.Storage?
		func applyOutlineTableColumn(_ outlineTableColumn: TableColumn&lt;NodeData&gt;.Preparer.Storage, to outlineView: NSOutlineView) {
			self.outlineTableColumn = outlineTableColumn
			applyColumns(columns, to: outlineView)
		}
		
		func applyColumns(_ v: [TableColumn&lt;NodeData&gt;.Preparer.Storage], to outlineView: NSOutlineView) {
			columns = v
			let columnsArray = v.map { $0.tableColumn }
			var newColumnSet = Set(columnsArray)
			if let otc = outlineTableColumn?.tableColumn ?? outlineView.outlineTableColumn {
				newColumnSet.insert(otc)
			}
			let oldColumnSet = Set(outlineView.tableColumns)
			
			for c in columnsArray {
				if !oldColumnSet.contains(c) {
					outlineView.addTableColumn(c)
				}
				if !newColumnSet.contains(c) {
					outlineView.removeTableColumn(c)
				}
			}
			if let oci = outlineColumnIdentifier, let tc = columnForIdentifier(oci)?.element.tableColumn {
				outlineView.outlineTableColumn = tc
			} else {
				outlineView.outlineTableColumn = outlineView.tableColumns.first
			}
		}
		
		func applyTreeAnimation(_ treeAnimation: TreeAnimation&lt;NodeData&gt;, to outlineView: NSOutlineView) {
			treeAnimation.value.mutations.apply(toTreeSubrange: treeState)
			outlineView.animate(treeAnimation.value, in: treeState, animation: treeAnimation.animation ?? [])
		}
		
		func indexPath(forItem: Any, in outlineView: NSOutlineView) -&gt; IndexPath? {
			var indexes = IndexPath()
			let next = { (item: inout TreeSubrangeState&lt;NodeData&gt;?) -&gt; (parent: TreeSubrangeState&lt;NodeData&gt;, item: TreeSubrangeState&lt;NodeData&gt;)? in
				if let parent = item?.parent, let next = item {
					item = parent
					return (parent, next)
				}
				return nil
			}
			for (parent, item) in sequence(state: forItem as? TreeSubrangeState&lt;NodeData&gt;, next: next) {
				if let i = parent.state.values?.firstIndex(where: { $0 === item }) {
					indexes.append(i)
				} else {
					return nil
				}
			}
			return indexes
		}
		
		func indexPath(forRow row: Int, in outlineView: NSOutlineView) -&gt; IndexPath? {
			if let item = outlineView.item(atRow: row) {
				return indexPath(forItem: item, in: outlineView)
			}
			return nil
		}
		
		func row(forIndexPath indexPath: IndexPath, in outlineView: NSOutlineView) -&gt; Int? {
			if let i = item(forIndexPath: indexPath, in: outlineView) {
				return outlineView.row(forItem: i)
			}
			return nil
		}
		
		func item(forIndexPath indexPath: IndexPath, in: NSOutlineView) -&gt; Any? {
			var node = treeState
			for index in sequence(state: indexPath, next: { $0.popFirst() }) {
				guard let next = node.state.values?.at(index) else { return nil }
				node = next
			}
			return node
		}
	}
	
	class Delegate: DynamicDelegate, NSOutlineViewDelegate, NSOutlineViewDataSource {
		private func storage(for outlineView: NSOutlineView) -&gt; Storage? {
			return outlineView.delegate as? Storage
		}
		
		func outlineView(_ outlineView: NSOutlineView, didDrag tableColumn: NSTableColumn) {
			multiHandler(outlineView, tableColumn)
		}
		
		func outlineView(_ outlineView: NSOutlineView, didClick tableColumn: NSTableColumn) {
			multiHandler(outlineView, tableColumn)
		}
		
		func outlineView(_ outlineView: NSOutlineView, mouseDownInHeaderOf tableColumn: NSTableColumn) {
			multiHandler(outlineView, tableColumn)
		}
		
		func outlineView(_ outlineView: NSOutlineView, rowViewForItem item: Any) -&gt; NSTableRowView? {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return (singleHandler(outlineView, indexPath) as NSTableRowView?)?.nsTableRowView()
			}
			return nil
		}
		
		func outlineView(_ outlineView: NSOutlineView, heightOfRowByItem item: Any) -&gt; CGFloat {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(indexPath)
			}
			return outlineView.rowHeight
		}
		
		func outlineView(_ outlineView: NSOutlineView, shouldReorderColumn columnIndex: Int, toColumn newColumnIndex: Int) -&gt; Bool {
			if let column = outlineView.tableColumns.at(columnIndex) {
				return singleHandler(outlineView, column.identifier, newColumnIndex)
			}
			return false
		}
		
		func outlineView(_ outlineView: NSOutlineView, sizeToFitWidthOfColumn column: Int) -&gt; CGFloat {
			if let column = outlineView.tableColumns.at(column) {
				return singleHandler(outlineView, column.identifier)
			}
			return 0
		}
		
		func outlineView(_ outlineView: NSOutlineView, shouldTypeSelectFor event: NSEvent, withCurrentSearch searchString: String?) -&gt; Bool {
			return singleHandler(outlineView, event, searchString)
		}
		
		func outlineView(_ outlineView: NSOutlineView, typeSelectStringFor tableColumn: NSTableColumn?, item: Any) -&gt; String? {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(outlineView, tableColumn, indexPath)
			}
			return nil
		}
		
		func outlineView(_ outlineView: NSOutlineView, nextTypeSelectMatchFromItem startItem: Any, toItem endItem: Any, for searchString: String) -&gt; Any? {
			if let startIndexPath = storage(for: outlineView)?.indexPath(forItem: startItem, in: outlineView), let endIndexPath = storage(for: outlineView)?.indexPath(forItem: endItem, in: outlineView) {
				if let indexPath = singleHandler(outlineView, startIndexPath, endIndexPath, searchString) as IndexPath? {
					return storage(for: outlineView)?.item(forIndexPath: indexPath, in: outlineView)
				}
			}
			return nil
		}
		
		func outlineView(_ outlineView: NSOutlineView, shouldSelect tableColumn: NSTableColumn?) -&gt; Bool {
			return singleHandler(outlineView, tableColumn)
		}
		
		func outlineView(_ outlineView: NSOutlineView, selectionIndexesForProposedSelection proposedSelectionIndexes: IndexSet) -&gt; IndexSet {
			var indexPaths = Set&lt;IndexPath&gt;()
			for index in proposedSelectionIndexes {
				if let path = storage(for: outlineView)?.indexPath(forRow: index, in: outlineView) {
					indexPaths.insert(path)
				}
			}
			let indexPathResult = singleHandler(indexPaths) as [IndexPath]
			var result = IndexSet()
			for indexPath in indexPathResult {
				if let index = storage(for: outlineView)?.row(forIndexPath: indexPath, in: outlineView) {
					result.insert(index)
				}
			}
			return result
		}
		
		func outlineView(_ outlineView: NSOutlineView, shouldSelectItem item: Any) -&gt; Bool {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(outlineView, indexPath)
			}
			return false
		}
		
		func selectionShouldChange(in outlineView: NSOutlineView) -&gt; Bool {
			return singleHandler(outlineView)
		}
		
		func outlineView(_ outlineView: NSOutlineView, shouldExpandItem item: Any) -&gt; Bool {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(indexPath)
			}
			return false
		}
		
		func outlineView(_ outlineView: NSOutlineView, shouldCollapseItem item: Any) -&gt; Bool {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(indexPath)
			}
			return false
		}
		
		func outlineView(_ outlineView: NSOutlineView, acceptDrop info: NSDraggingInfo, item: Any?, childIndex index: Int) -&gt; Bool {
			if let i = item {
				if let indexPath = storage(for: outlineView)?.indexPath(forItem: i, in: outlineView) {
					return singleHandler(outlineView, info, indexPath, index)
				} else {
					return false
				}
			}
			return singleHandler(outlineView, info, nil as IndexPath?, index)
		}
		
		func outlineView(_ outlineView: NSOutlineView, sortDescriptorsDidChange oldDescriptors: [NSSortDescriptor]) {
			multiHandler(outlineView, oldDescriptors)
		}
		
		func outlineView(_ outlineView: NSOutlineView, draggingSession session: NSDraggingSession, endedAt screenPoint: NSPoint, operation: NSDragOperation) {
			return singleHandler(outlineView, session, screenPoint, operation)
		}
		
		func outlineView(_ outlineView: NSOutlineView, draggingSession session: NSDraggingSession, willBeginAt screenPoint: NSPoint, forItems draggedItems: [Any]) {
			let indexPaths = draggedItems.compactMap { storage(for: outlineView)?.indexPath(forItem: $0, in: outlineView) }
			return singleHandler(outlineView, session, screenPoint, indexPaths)
		}
		
		func outlineView(_ outlineView: NSOutlineView, isItemExpandable: Any) -&gt; Bool {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: isItemExpandable, in: outlineView) {
				return singleHandler(indexPath)
			}
			return false
		}
		
		func outlineView(_ outlineView: NSOutlineView, pasteboardWriterForItem item: Any) -&gt; NSPasteboardWriting? {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(outlineView, indexPath)
			}
			return nil
		}
		
		func outlineView(_ outlineView: NSOutlineView, updateDraggingItemsForDrag draggingInfo: NSDraggingInfo) {
			multiHandler(outlineView, draggingInfo)
		}
		
		func outlineView(_ outlineView: NSOutlineView, validateDrop info: NSDraggingInfo, proposedItem item: Any?, proposedChildIndex index: Int) -&gt; NSDragOperation {
			if let i = item {
				if let indexPath = storage(for: outlineView)?.indexPath(forItem: i, in: outlineView) {
					return singleHandler(outlineView, info, indexPath, index)
				} else {
					return []
				}
			}
			return singleHandler(outlineView, info, nil as IndexPath?, index)
		}
	}
}

private extension NSOutlineView {
	func animate&lt;NodeData&gt;(_ treeMutation: TreeSubrangeMutation&lt;NodeData&gt;, in treeState: TreeSubrangeState&lt;NodeData&gt;, animation: NSTableView.AnimationOptions) {
		let indices = treeMutation.mutations.indexSet.offset(by: treeState.state.localOffset)
		
		switch treeMutation.mutations.kind {
		case .delete:
			removeItems(at: indices, inParent: treeState, withAnimation: animation)
		case .move(let destination):
			beginUpdates()
			for (count, index) in indices.enumerated() {
				moveItem(at: index, inParent: treeState, to: destination + count, inParent: treeState)
			}
			endUpdates()
		case .insert:
			insertItems(at: indices, inParent: treeState, withAnimation: animation)
		case .scroll:
			beginUpdates()
			for i in indices {
				guard let item = treeState.state.values?.at(i) else { continue }
				reloadItem(item, reloadChildren: true)
			}
			endUpdates()
		case .update:
			beginUpdates()
			for (mutationIndex, valueIndex) in indices.enumerated() {
				guard let childAnimation = treeMutation.mutations.values.at(mutationIndex), let childState = treeState.state.values?.at(valueIndex) else { continue }
				animate(childAnimation, in: childState, animation: animation)
			}
			endUpdates()
		case .reload:
			reloadData()
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: OutlineViewBinding {
	typealias OutlineViewName&lt;V&gt; = BindingName&lt;V, OutlineView&lt;Binding.NodeDataType&gt;.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; OutlineView&lt;Binding.NodeDataType&gt;.Binding) -&gt; OutlineViewName&lt;V&gt; {
		return OutlineViewName&lt;V&gt;(source: source, downcast: Binding.outlineViewBinding)
	}
}
extension BindingName where Binding: OutlineViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: OutlineViewName&lt;$2&gt; { return .name(OutlineView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsColumnReordering: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.allowsColumnReordering) }
	static var allowsColumnResizing: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.allowsColumnResizing) }
	static var allowsColumnSelection: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.allowsColumnSelection) }
	static var allowsEmptySelection: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.allowsEmptySelection) }
	static var allowsMultipleSelection: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.allowsMultipleSelection) }
	static var allowsTypeSelect: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.allowsTypeSelect) }
	static var autoresizesOutlineColumn: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.autoresizesOutlineColumn) }
	static var autosaveExpandedItems: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.autosaveExpandedItems) }
	static var autosaveName: OutlineViewName&lt;Dynamic&lt;NSTableView.AutosaveName?&gt;&gt; { return .name(OutlineView.Binding.autosaveName) }
	static var autosaveTableColumns: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.autosaveTableColumns) }
	static var backgroundColor: OutlineViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(OutlineView.Binding.backgroundColor) }
	static var columnAutoresizingStyle: OutlineViewName&lt;Dynamic&lt;NSTableView.ColumnAutoresizingStyle&gt;&gt; { return .name(OutlineView.Binding.columnAutoresizingStyle) }
	static var columns: OutlineViewName&lt;Dynamic&lt;[TableColumn&lt;Binding.NodeDataType&gt;]&gt;&gt; { return .name(OutlineView.Binding.columns) }
	static var cornerView: OutlineViewName&lt;Dynamic&lt;ViewConvertible?&gt;&gt; { return .name(OutlineView.Binding.cornerView) }
	static var draggingDestinationFeedbackStyle: OutlineViewName&lt;Dynamic&lt;NSTableView.DraggingDestinationFeedbackStyle&gt;&gt; { return .name(OutlineView.Binding.draggingDestinationFeedbackStyle) }
	static var floatsGroupRows: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.floatsGroupRows) }
	static var gridColor: OutlineViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(OutlineView.Binding.gridColor) }
	static var gridStyleMask: OutlineViewName&lt;Dynamic&lt;NSTableView.GridLineStyle&gt;&gt; { return .name(OutlineView.Binding.gridStyleMask) }
	static var headerView: OutlineViewName&lt;Dynamic&lt;TableHeaderViewConvertible?&gt;&gt; { return .name(OutlineView.Binding.headerView) }
	static var indentationMarkerFollowsCell: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.indentationMarkerFollowsCell) }
	static var indentationPerLevel: OutlineViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(OutlineView.Binding.indentationPerLevel) }
	static var intercellSpacing: OutlineViewName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(OutlineView.Binding.intercellSpacing) }
	static var outlineTableColumnIdentifier: OutlineViewName&lt;Dynamic&lt;NSUserInterfaceItemIdentifier&gt;&gt; { return .name(OutlineView.Binding.outlineTableColumnIdentifier) }
	static var rowHeight: OutlineViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(OutlineView.Binding.rowHeight) }
	static var rowSizeStyle: OutlineViewName&lt;Dynamic&lt;NSTableView.RowSizeStyle&gt;&gt; { return .name(OutlineView.Binding.rowSizeStyle) }
	static var selectionHighlightStyle: OutlineViewName&lt;Dynamic&lt;NSTableView.SelectionHighlightStyle&gt;&gt; { return .name(OutlineView.Binding.selectionHighlightStyle) }
	static var stronglyReferencesItems: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.stronglyReferencesItems) }
	static var treeData: OutlineViewName&lt;Dynamic&lt;TreeAnimation&lt;Binding.NodeDataType&gt;&gt;&gt; { return .name(OutlineView.Binding.treeData) }
	static var userInterfaceLayoutDirection: OutlineViewName&lt;Dynamic&lt;NSUserInterfaceLayoutDirection&gt;&gt; { return .name(OutlineView.Binding.userInterfaceLayoutDirection) }
	static var usesAlternatingRowBackgroundColors: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.usesAlternatingRowBackgroundColors) }
	static var verticalMotionCanBeginDrag: OutlineViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(OutlineView.Binding.verticalMotionCanBeginDrag) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var collapseIndexPath: OutlineViewName&lt;Signal&lt;(indexPath: IndexPath?, collapseChildren: Bool)&gt;&gt; { return .name(OutlineView.Binding.collapseIndexPath) }
	static var deselectAll: OutlineViewName&lt;Signal&lt;Void&gt;&gt; { return .name(OutlineView.Binding.deselectAll) }
	static var deselectColumn: OutlineViewName&lt;Signal&lt;NSUserInterfaceItemIdentifier&gt;&gt; { return .name(OutlineView.Binding.deselectColumn) }
	static var deselectIndexPath: OutlineViewName&lt;Signal&lt;IndexPath&gt;&gt; { return .name(OutlineView.Binding.deselectIndexPath) }
	static var expandIndexPath: OutlineViewName&lt;Signal&lt;(indexPath: IndexPath?, expandChildren: Bool)&gt;&gt; { return .name(OutlineView.Binding.expandIndexPath) }
	static var hideRowActions: OutlineViewName&lt;Signal&lt;Void&gt;&gt; { return .name(OutlineView.Binding.hideRowActions) }
	static var hideRows: OutlineViewName&lt;Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;&gt; { return .name(OutlineView.Binding.hideRows) }
	static var highlightColumn: OutlineViewName&lt;Signal&lt;NSUserInterfaceItemIdentifier?&gt;&gt; { return .name(OutlineView.Binding.highlightColumn) }
	static var moveColumn: OutlineViewName&lt;Signal&lt;(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)&gt;&gt; { return .name(OutlineView.Binding.moveColumn) }
	static var scrollColumnToVisible: OutlineViewName&lt;Signal&lt;NSUserInterfaceItemIdentifier&gt;&gt; { return .name(OutlineView.Binding.scrollColumnToVisible) }
	static var scrollIndexPathToVisible: OutlineViewName&lt;Signal&lt;IndexPath&gt;&gt; { return .name(OutlineView.Binding.scrollIndexPathToVisible) }
	static var selectAll: OutlineViewName&lt;Signal&lt;Void&gt;&gt; { return .name(OutlineView.Binding.selectAll) }
	static var selectColumns: OutlineViewName&lt;Signal&lt;(identifiers: Set&lt;NSUserInterfaceItemIdentifier&gt;, byExtendingSelection: Bool)&gt;&gt; { return .name(OutlineView.Binding.selectColumns) }
	static var selectIndexPaths: OutlineViewName&lt;Signal&lt;(indexPaths: Set&lt;IndexPath&gt;, byExtendingSelection: Bool)&gt;&gt; { return .name(OutlineView.Binding.selectIndexPaths) }
	static var setDropIndexPath: OutlineViewName&lt;Signal&lt;(indexPath: IndexPath?, dropChildIndex: Int)&gt;&gt; { return .name(OutlineView.Binding.setDropIndexPath) }
	static var sizeLastColumnToFit: OutlineViewName&lt;Signal&lt;Void&gt;&gt; { return .name(OutlineView.Binding.sizeLastColumnToFit) }
	static var sizeToFit: OutlineViewName&lt;Signal&lt;Void&gt;&gt; { return .name(OutlineView.Binding.sizeToFit) }
	static var unhideRows: OutlineViewName&lt;Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;&gt; { return .name(OutlineView.Binding.unhideRows) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var columnMoved: OutlineViewName&lt;SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)&gt;&gt; { return .name(OutlineView.Binding.columnMoved) }
	static var columnResized: OutlineViewName&lt;SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)&gt;&gt; { return .name(OutlineView.Binding.columnResized) }
	static var doubleAction: OutlineViewName&lt;TargetAction&gt; { return .name(OutlineView.Binding.doubleAction) }
	static var selectionChanged: OutlineViewName&lt;SignalInput&lt;(selectedColumns: Set&lt;NSUserInterfaceItemIdentifier&gt;, selectedIndexPaths: Set&lt;IndexPath&gt;)&gt;&gt; { return .name(OutlineView.Binding.selectionChanged) }
	static var selectionIsChanging: OutlineViewName&lt;SignalInput&lt;Void&gt;&gt; { return .name(OutlineView.Binding.selectionIsChanging) }
	static var indexPathDidCollapse: OutlineViewName&lt;SignalInput&lt;IndexPath&gt;&gt; { return .name(OutlineView.Binding.indexPathDidCollapse) }
	static var indexPathDidExpand: OutlineViewName&lt;SignalInput&lt;IndexPath&gt;&gt; { return .name(OutlineView.Binding.indexPathDidExpand) }
	static var indexPathWillCollapse: OutlineViewName&lt;SignalInput&lt;IndexPath&gt;&gt; { return .name(OutlineView.Binding.indexPathWillCollapse) }
	static var indexPathWillExpand: OutlineViewName&lt;SignalInput&lt;IndexPath&gt;&gt; { return .name(OutlineView.Binding.indexPathWillExpand) }
	static var visibleIndexPathsChanged: OutlineViewName&lt;SignalInput&lt;Set&lt;IndexPath&gt;&gt;&gt; { return .name(OutlineView.Binding.visibleIndexPathsChanged) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var acceptDrop: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ indexPath: IndexPath?, _ childIndex: Int) -&gt; Bool&gt; { return .name(OutlineView.Binding.acceptDrop) }
	static var didClickTableColumn: OutlineViewName&lt;(NSOutlineView, NSTableColumn) -&gt; Void&gt; { return .name(OutlineView.Binding.didClickTableColumn) }
	static var didDragTableColumn: OutlineViewName&lt;(NSOutlineView, NSTableColumn) -&gt; Void&gt; { return .name(OutlineView.Binding.didDragTableColumn) }
	static var draggingSessionEnded: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -&gt; Void&gt; { return .name(OutlineView.Binding.draggingSessionEnded) }
	static var draggingSessionWillBegin: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ willBeginAt: NSPoint, _ forItems: [IndexPath]) -&gt; Void&gt; { return .name(OutlineView.Binding.draggingSessionWillBegin) }
	static var groupRowCellConstructor: OutlineViewName&lt;(Int) -&gt; TableCellViewConvertible&gt; { return .name(OutlineView.Binding.groupRowCellConstructor) }
	static var heightOfRow: OutlineViewName&lt;(NSOutlineView, _ indexPath: IndexPath) -&gt; CGFloat&gt; { return .name(OutlineView.Binding.heightOfRow) }
	static var isIndexPathExpandable: OutlineViewName&lt;(_ outlineView: NSOutlineView, IndexPath) -&gt; Bool&gt; { return .name(OutlineView.Binding.isIndexPathExpandable) }
	static var mouseDownInHeaderOfTableColumn: OutlineViewName&lt;(NSOutlineView, NSTableColumn) -&gt; Void&gt; { return .name(OutlineView.Binding.mouseDownInHeaderOfTableColumn) }
	static var nextTypeSelectMatch: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ from: IndexPath, _ to: IndexPath, _ for: String) -&gt; IndexPath?&gt; { return .name(OutlineView.Binding.nextTypeSelectMatch) }
	static var pasteboardWriter: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ forIndexPath: IndexPath) -&gt; NSPasteboardWriting?&gt; { return .name(OutlineView.Binding.pasteboardWriter) }
	static var rowView: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; TableRowViewConvertible?&gt; { return .name(OutlineView.Binding.rowView) }
	static var selectionIndexesForProposedSelection: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ proposedSelectionIndexes: Set&lt;IndexPath&gt;) -&gt; Set&lt;IndexPath&gt;&gt; { return .name(OutlineView.Binding.selectionIndexesForProposedSelection) }
	static var selectionShouldChange: OutlineViewName&lt;(_ outlineView: NSOutlineView) -&gt; Bool&gt; { return .name(OutlineView.Binding.selectionShouldChange) }
	static var shouldCollapse: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; Bool&gt; { return .name(OutlineView.Binding.shouldCollapse) }
	static var shouldExpand: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; Bool&gt; { return .name(OutlineView.Binding.shouldExpand) }
	static var shouldReorderColumn: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ column: NSTableColumn, _ newIndex: Int) -&gt; Bool&gt; { return .name(OutlineView.Binding.shouldReorderColumn) }
	static var shouldSelectIndexPath: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; Bool&gt; { return .name(OutlineView.Binding.shouldSelectIndexPath) }
	static var shouldSelectTableColumn: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ column: NSTableColumn?) -&gt; Bool&gt; { return .name(OutlineView.Binding.shouldSelectTableColumn) }
	static var shouldTypeSelectForEvent: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ event: NSEvent, _ searchString: String?) -&gt; Bool&gt; { return .name(OutlineView.Binding.shouldTypeSelectForEvent) }
	static var sizeToFitWidthOfColumn: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ column: NSTableColumn) -&gt; CGFloat&gt; { return .name(OutlineView.Binding.sizeToFitWidthOfColumn) }
	static var sortDescriptorsDidChange: OutlineViewName&lt;(NSOutlineView, [NSSortDescriptor]) -&gt; Void&gt; { return .name(OutlineView.Binding.sortDescriptorsDidChange) }
	static var typeSelectString: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ column: NSTableColumn?, _ indexPath: IndexPath) -&gt; String?&gt; { return .name(OutlineView.Binding.typeSelectString) }
	static var updateDraggingItems: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ forDrag: NSDraggingInfo) -&gt; Void&gt; { return .name(OutlineView.Binding.updateDraggingItems) }
	static var validateDrop: OutlineViewName&lt;(_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ proposedIndexPath: IndexPath?, _ proposedChildIndex: Int) -&gt; NSDragOperation&gt; { return .name(OutlineView.Binding.validateDrop) }

	// Composite binding names
	static func doubleAction&lt;Value&gt;(_ keyPath: KeyPath&lt;Binding.Preparer.Instance, Value&gt;) -&gt; OutlineViewName&lt;SignalInput&lt;Value&gt;&gt; {
		return Binding.keyPathActionName(keyPath, OutlineView.Binding.doubleAction, Binding.outlineViewBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol OutlineViewConvertible: ControlConvertible {
	func nsOutlineView() -&gt; NSOutlineView
}
extension NSOutlineView: OutlineViewConvertible {
	func nsOutlineView() -&gt; NSOutlineView { return self }
}
extension OutlineViewConvertible {
	func nsControl() -&gt; Control.Instance { return nsOutlineView() }
}
extension OutlineView {
	func nsOutlineView() -&gt; NSOutlineView { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol OutlineViewBinding: ControlBinding {
	associatedtype NodeDataType
	static func outlineViewBinding(_ binding: OutlineView&lt;NodeDataType&gt;.Binding) -&gt; Self
	func asOutlineViewBinding() -&gt; OutlineView&lt;NodeDataType&gt;.Binding?
}
extension OutlineViewBinding {
	static func controlBinding(_ binding: Control.Binding) -&gt; Self {
		return outlineViewBinding(OutlineView&lt;NodeDataType&gt;.Binding.inheritedBinding(binding))
	}
}
extension OutlineViewBinding where Preparer.Inherited.Binding: OutlineViewBinding, Preparer.Inherited.Binding.NodeDataType == NodeDataType {
	func asOutlineViewBinding() -&gt; OutlineView&lt;NodeDataType&gt;.Binding? {
		return asInheritedBinding()?.asOutlineViewBinding()
	}
}
extension OutlineView.Binding {
	typealias Preparer = OutlineView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asOutlineViewBinding() -&gt; OutlineView.Binding? { return self }
	static func outlineViewBinding(_ binding: OutlineView&lt;NodeDataType&gt;.Binding) -&gt; OutlineView&lt;NodeDataType&gt;.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
typealias TreeAnimation&lt;NodeData&gt; = Animatable&lt;TreeSubrangeMutation&lt;NodeData&gt;, NSTableView.AnimationOptions&gt;

struct OutlineCell&lt;NodeData&gt; {
	let row: Int
	let column: Int
	let columnIdentifier: NSUserInterfaceItemIdentifier
	let data: IndexPath?
	
	init(row: Int, column: Int, outlineView: NSOutlineView) {
		self.row = row
		self.data = (outlineView.delegate as? OutlineView&lt;NodeData&gt;.Preparer.Storage)?.indexPath(forRow: row, in: outlineView)
		self.column = column
		self.columnIdentifier = outlineView.tableColumns[column].identifier
	}
	
	init(row: Int, column: NSTableColumn, outlineView: NSOutlineView) {
		self.row = row
		self.column = outlineView.column(withIdentifier: column.identifier)
		self.columnIdentifier = column.identifier
		self.data = (outlineView.delegate as? OutlineView&lt;NodeData&gt;.Preparer.Storage)?.indexPath(forRow: row, in: outlineView)
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class PanGestureRecognizer: Binder, PanGestureRecognizerConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension PanGestureRecognizer {
	enum Binding: PanGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case buttonMask(Dynamic&lt;Int&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension PanGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = PanGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = NSPanGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension PanGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .buttonMask(let x): return x.apply(instance) { i, v in i.buttonMask = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PanGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PanGestureRecognizerBinding {
	typealias PanGestureRecognizerName&lt;V&gt; = BindingName&lt;V, PanGestureRecognizer.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; PanGestureRecognizer.Binding) -&gt; PanGestureRecognizerName&lt;V&gt; {
		return PanGestureRecognizerName&lt;V&gt;(source: source, downcast: Binding.panGestureRecognizerBinding)
	}
}
extension BindingName where Binding: PanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PanGestureRecognizerName&lt;$2&gt; { return .name(PanGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var buttonMask: PanGestureRecognizerName&lt;Dynamic&lt;Int&gt;&gt; { return .name(PanGestureRecognizer.Binding.buttonMask) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol PanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsPanGestureRecognizer() -&gt; PanGestureRecognizer.Instance
}
extension PanGestureRecognizerConvertible {
	func nsGestureRecognizer() -&gt; GestureRecognizer.Instance { return nsPanGestureRecognizer() }
}
extension NSPanGestureRecognizer: PanGestureRecognizerConvertible {
	func nsPanGestureRecognizer() -&gt; PanGestureRecognizer.Instance { return self }
}
extension PanGestureRecognizer {
	func nsPanGestureRecognizer() -&gt; PanGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol PanGestureRecognizerBinding: GestureRecognizerBinding {
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -&gt; Self
	func asPanGestureRecognizerBinding() -&gt; PanGestureRecognizer.Binding?
}
extension PanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -&gt; Self {
		return panGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension PanGestureRecognizerBinding where Preparer.Inherited.Binding: PanGestureRecognizerBinding {
	func asPanGestureRecognizerBinding() -&gt; PanGestureRecognizer.Binding? {
		return asInheritedBinding()?.asPanGestureRecognizerBinding()
	}
}
extension PanGestureRecognizer.Binding {
	typealias Preparer = PanGestureRecognizer.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPanGestureRecognizerBinding() -&gt; PanGestureRecognizer.Binding? { return self }
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -&gt; PanGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class PopUpButton: Binder, PopUpButtonConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension PopUpButton {
	enum Binding: PopUpButtonBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case autoenablesItems(Dynamic&lt;Bool&gt;)
		case menu(Dynamic&lt;MenuConvertible&gt;)
		case preferredEdge(Dynamic&lt;NSRectEdge&gt;)
		case pullsDown(Dynamic&lt;Bool&gt;)
		case selectedIndex(Dynamic&lt;Int&gt;)
		case title(Dynamic&lt;String&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case willPopUp(SignalInput&lt;Void&gt;)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension PopUpButton {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = PopUpButton.Binding
		typealias Inherited = Button.Preparer
		typealias Instance = NSPopUpButton
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var pullsDown = InitialSubsequent&lt;Bool&gt;()
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension PopUpButton.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .pullsDown(let x): pullsDown = x.initialSubsequent()
		default: break
		}
	}
	
	func constructInstance(type: Instance.Type, parameters: Parameters) -&gt; Instance {
		return type.init(frame: NSRect.zero, pullsDown: pullsDown.initial ?? false)
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .autoenablesItems(let x): return x.apply(instance) { i, v in i.autoenablesItems = v }
		case .menu(let x): return x.apply(instance) { i, v in i.menu = v.nsMenu() }
		case .preferredEdge(let x): return x.apply(instance) { i, v in i.preferredEdge = v }
		case .pullsDown: return pullsDown.resume()?.apply(instance) { i, v in i.pullsDown = v }
		case .selectedIndex(let x): return x.apply(instance) { i, v in i.selectItem(at: v) }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case .willPopUp(let x): return Signal.notifications(name: NSPopUpButton.willPopUpNotification, object: instance).map { n in () }.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PopUpButton.Preparer {
	typealias Storage = Button.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PopUpButtonBinding {
	typealias PopUpButtonName&lt;V&gt; = BindingName&lt;V, PopUpButton.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; PopUpButton.Binding) -&gt; PopUpButtonName&lt;V&gt; {
		return PopUpButtonName&lt;V&gt;(source: source, downcast: Binding.popUpButtonBinding)
	}
}
extension BindingName where Binding: PopUpButtonBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PopUpButtonName&lt;$2&gt; { return .name(PopUpButton.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var autoenablesItems: PopUpButtonName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(PopUpButton.Binding.autoenablesItems) }
	static var menu: PopUpButtonName&lt;Dynamic&lt;MenuConvertible&gt;&gt; { return .name(PopUpButton.Binding.menu) }
	static var preferredEdge: PopUpButtonName&lt;Dynamic&lt;NSRectEdge&gt;&gt; { return .name(PopUpButton.Binding.preferredEdge) }
	static var pullsDown: PopUpButtonName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(PopUpButton.Binding.pullsDown) }
	static var selectedIndex: PopUpButtonName&lt;Dynamic&lt;Int&gt;&gt; { return .name(PopUpButton.Binding.selectedIndex) }
	static var title: PopUpButtonName&lt;Dynamic&lt;String&gt;&gt; { return .name(PopUpButton.Binding.title) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var willPopUp: PopUpButtonName&lt;SignalInput&lt;Void&gt;&gt; { return .name(PopUpButton.Binding.willPopUp) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol PopUpButtonConvertible: ButtonConvertible {
	func nsPopUpButton() -&gt; PopUpButton.Instance
}
extension PopUpButtonConvertible {
	func nsButton() -&gt; Button.Instance { return nsPopUpButton() }
}
extension NSPopUpButton: PopUpButtonConvertible {
	func nsPopUpButton() -&gt; PopUpButton.Instance { return self }
}
extension PopUpButton {
	func nsPopUpButton() -&gt; PopUpButton.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol PopUpButtonBinding: ButtonBinding {
	static func popUpButtonBinding(_ binding: PopUpButton.Binding) -&gt; Self
	func asPopUpButtonBinding() -&gt; PopUpButton.Binding?
}
extension PopUpButtonBinding {
	static func buttonBinding(_ binding: Button.Binding) -&gt; Self {
		return popUpButtonBinding(.inheritedBinding(binding))
	}
}
extension PopUpButtonBinding where Preparer.Inherited.Binding: PopUpButtonBinding {
	func asPopUpButtonBinding() -&gt; PopUpButton.Binding? {
		return asInheritedBinding()?.asPopUpButtonBinding()
	}
}
extension PopUpButton.Binding {
	typealias Preparer = PopUpButton.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPopUpButtonBinding() -&gt; PopUpButton.Binding? { return self }
	static func popUpButtonBinding(_ binding: PopUpButton.Binding) -&gt; PopUpButton.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class PressGestureRecognizer: Binder, PressGestureRecognizerConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension PressGestureRecognizer {
	enum Binding: PressGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowableMovement(Dynamic&lt;CGFloat&gt;)
		case buttonMask(Dynamic&lt;Int&gt;)
		case minimumPressDuration(Dynamic&lt;TimeInterval&gt;)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension PressGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = PressGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = NSPressGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension PressGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowableMovement(let x): return x.apply(instance) { i, v in i.allowableMovement = v }
		case .buttonMask(let x): return x.apply(instance) { i, v in i.buttonMask = v }
		case .minimumPressDuration(let x): return x.apply(instance) { i, v in i.minimumPressDuration = v }
			
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PressGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PressGestureRecognizerBinding {
	typealias PressGestureRecognizerName&lt;V&gt; = BindingName&lt;V, PressGestureRecognizer.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; PressGestureRecognizer.Binding) -&gt; PressGestureRecognizerName&lt;V&gt; {
		return PressGestureRecognizerName&lt;V&gt;(source: source, downcast: Binding.pressGestureRecognizerBinding)
	}
}
extension BindingName where Binding: PressGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PressGestureRecognizerName&lt;$2&gt; { return .name(PressGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowableMovement: PressGestureRecognizerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(PressGestureRecognizer.Binding.allowableMovement) }
	static var buttonMask: PressGestureRecognizerName&lt;Dynamic&lt;Int&gt;&gt; { return .name(PressGestureRecognizer.Binding.buttonMask) }
	static var minimumPressDuration: PressGestureRecognizerName&lt;Dynamic&lt;TimeInterval&gt;&gt; { return .name(PressGestureRecognizer.Binding.minimumPressDuration) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol PressGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsPressGestureRecognizer() -&gt; PressGestureRecognizer.Instance
}
extension PressGestureRecognizerConvertible {
	func nsGestureRecognizer() -&gt; GestureRecognizer.Instance { return nsPressGestureRecognizer() }
}
extension NSPressGestureRecognizer: PressGestureRecognizerConvertible {
	func nsPressGestureRecognizer() -&gt; PressGestureRecognizer.Instance { return self }
}
extension PressGestureRecognizer {
	func nsPressGestureRecognizer() -&gt; PressGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol PressGestureRecognizerBinding: GestureRecognizerBinding {
	static func pressGestureRecognizerBinding(_ binding: PressGestureRecognizer.Binding) -&gt; Self
	func asPressGestureRecognizerBinding() -&gt; PressGestureRecognizer.Binding?
}
extension PressGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -&gt; Self {
		return pressGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension PressGestureRecognizerBinding where Preparer.Inherited.Binding: PressGestureRecognizerBinding {
	func asPressGestureRecognizerBinding() -&gt; PressGestureRecognizer.Binding? {
		return asInheritedBinding()?.asPressGestureRecognizerBinding()
	}
}
extension PressGestureRecognizer.Binding {
	typealias Preparer = PressGestureRecognizer.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPressGestureRecognizerBinding() -&gt; PressGestureRecognizer.Binding? { return self }
	static func pressGestureRecognizerBinding(_ binding: PressGestureRecognizer.Binding) -&gt; PressGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class RotationGestureRecognizer: Binder, RotationGestureRecognizerConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension RotationGestureRecognizer {
	enum Binding: RotationGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rotationInRadians(Dynamic&lt;CGFloat&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension RotationGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = RotationGestureRecognizer.Binding
		typealias Inherited = GestureRecognizer.Preparer
		typealias Instance = NSRotationGestureRecognizer
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension RotationGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .rotationInRadians(let x): return x.apply(instance) { i, v in i.rotation = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension RotationGestureRecognizer.Preparer {
	typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: RotationGestureRecognizerBinding {
	typealias RotationGestureRecognizerName&lt;V&gt; = BindingName&lt;V, RotationGestureRecognizer.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; RotationGestureRecognizer.Binding) -&gt; RotationGestureRecognizerName&lt;V&gt; {
		return RotationGestureRecognizerName&lt;V&gt;(source: source, downcast: Binding.rotationGestureRecognizerBinding)
	}
}
extension BindingName where Binding: RotationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: RotationGestureRecognizerName&lt;$2&gt; { return .name(RotationGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var rotationInRadians: RotationGestureRecognizerName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(RotationGestureRecognizer.Binding.rotationInRadians) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol RotationGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsRotationGestureRecognizer() -&gt; RotationGestureRecognizer.Instance
}
extension RotationGestureRecognizerConvertible {
	func nsGestureRecognizer() -&gt; GestureRecognizer.Instance { return nsRotationGestureRecognizer() }
}
extension NSRotationGestureRecognizer: RotationGestureRecognizerConvertible {
	func nsRotationGestureRecognizer() -&gt; RotationGestureRecognizer.Instance { return self }
}
extension RotationGestureRecognizer {
	func nsRotationGestureRecognizer() -&gt; RotationGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol RotationGestureRecognizerBinding: GestureRecognizerBinding {
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -&gt; Self
	func asRotationGestureRecognizerBinding() -&gt; RotationGestureRecognizer.Binding?
}
extension RotationGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -&gt; Self {
		return rotationGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
extension RotationGestureRecognizerBinding where Preparer.Inherited.Binding: RotationGestureRecognizerBinding {
	func asRotationGestureRecognizerBinding() -&gt; RotationGestureRecognizer.Binding? {
		return asInheritedBinding()?.asRotationGestureRecognizerBinding()
	}
}
extension RotationGestureRecognizer.Binding {
	typealias Preparer = RotationGestureRecognizer.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asRotationGestureRecognizerBinding() -&gt; RotationGestureRecognizer.Binding? { return self }
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -&gt; RotationGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class ScrollView: Binder, ScrollViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ScrollView {
	enum Binding: ScrollViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsMagnification(Dynamic&lt;Bool&gt;)
		case autohidesScrollers(Dynamic&lt;Bool&gt;)
		case automaticallyAdjustsContentInsets(Dynamic&lt;Bool&gt;)
		case backgroundColor(Dynamic&lt;NSColor&gt;)
		case borderType(Dynamic&lt;NSBorderType&gt;)
		case contentInsets(Dynamic&lt;NSEdgeInsets&gt;)
		case contentView(Dynamic&lt;ClipViewConvertible&gt;)
		case documentCursor(Dynamic&lt;NSCursor?&gt;)
		case drawsBackground(Dynamic&lt;Bool&gt;)
		case findBarPosition(Dynamic&lt;NSScrollView.FindBarPosition&gt;)
		case floatingSubviews(Dynamic&lt;[(view: ViewConvertible, axis: NSEvent.GestureAxis)]&gt;)
		case hasHorizontalRuler(Dynamic&lt;Bool&gt;)
		case hasHorizontalScroller(Dynamic&lt;Bool&gt;)
		case hasVerticalRuler(Dynamic&lt;Bool&gt;)
		case hasVerticalScroller(Dynamic&lt;Bool&gt;)
		case horizontalLineScroll(Dynamic&lt;CGFloat&gt;)
		case horizontalPageScroll(Dynamic&lt;CGFloat&gt;)
		case horizontalScrollElasticity(Dynamic&lt;NSScrollView.Elasticity&gt;)
		case magnification(Dynamic&lt;CGFloat&gt;)
		case maxMagnification(Dynamic&lt;CGFloat&gt;)
		case minMagnification(Dynamic&lt;CGFloat&gt;)
		case rulersVisible(Dynamic&lt;Bool&gt;)
		case scrollerInsets(Dynamic&lt;NSEdgeInsets&gt;)
		case scrollerKnobStyle(Dynamic&lt;NSScroller.KnobStyle&gt;)
		case scrollerStyle(Dynamic&lt;NSScroller.Style&gt;)
		case scrollsDynamically(Dynamic&lt;Bool&gt;)
		case usesPredominantAxisScrolling(Dynamic&lt;Bool&gt;)
		case verticalLineScroll(Dynamic&lt;CGFloat&gt;)
		case verticalPageScroll(Dynamic&lt;CGFloat&gt;)
		case verticalScrollElasticity(Dynamic&lt;NSScrollView.Elasticity&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case flashScrollers(Signal&lt;Bool&gt;)
		case magnificationCenteredAtPoint(Signal&lt;(CGFloat, NSPoint)&gt;)
		case magnifyToFitRect(Signal&lt;CGRect&gt;)
		case scrollWheel(Signal&lt;NSEvent&gt;)

		// 3. Action bindings are triggered by the object after construction.
		case didEndLiveMagnify(SignalInput&lt;Void&gt;)
		case didEndLiveScroll(SignalInput&lt;Void&gt;)
		case didLiveScroll(SignalInput&lt;Void&gt;)
		case willStartLiveMagnify(SignalInput&lt;Void&gt;)
		case willStartLiveScroll(SignalInput&lt;Void&gt;)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension ScrollView {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = ScrollView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSScrollView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ScrollView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsMagnification(let x): return x.apply(instance) { i, v in i.allowsMagnification = v }
		case .autohidesScrollers(let x): return x.apply(instance) { i, v in i.autohidesScrollers = v }
		case .automaticallyAdjustsContentInsets(let x): return x.apply(instance) { i, v in i.automaticallyAdjustsContentInsets = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .borderType(let x): return x.apply(instance) { i, v in i.borderType = v }
		case .contentInsets(let x): return x.apply(instance) { i, v in i.contentInsets = v }
		case .contentView(let x): return x.apply(instance) { i, v in i.contentView = v.nsClipView() }
		case .documentCursor(let x): return x.apply(instance) { i, v in i.documentCursor = v }
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .findBarPosition(let x): return x.apply(instance) { i, v in i.findBarPosition = v }
		case .floatingSubviews(let x):
			return x.apply(instance, storage) { i, s, v in
				s.floatingSubviews.forEach { $0.removeFromSuperview() }
				s.floatingSubviews = v.map {
					let sub = $0.view.nsView()
					i.addFloatingSubview(sub, for: $0.axis)
					return sub
				}
			}
		case .hasHorizontalRuler(let x): return x.apply(instance) { i, v in i.hasHorizontalRuler = v }
		case .hasHorizontalScroller(let x): return x.apply(instance) { i, v in i.hasHorizontalScroller = v }
		case .hasVerticalRuler(let x): return x.apply(instance) { i, v in i.hasVerticalRuler = v }
		case .hasVerticalScroller(let x): return x.apply(instance) { i, v in i.hasVerticalScroller = v }
		case .horizontalLineScroll(let x): return x.apply(instance) { i, v in i.horizontalLineScroll = v }
		case .horizontalPageScroll(let x): return x.apply(instance) { i, v in i.horizontalPageScroll = v }
		case .horizontalScrollElasticity(let x): return x.apply(instance) { i, v in i.horizontalScrollElasticity = v }
		case .magnification(let x): return x.apply(instance) { i, v in i.magnification = v }
		case .maxMagnification(let x): return x.apply(instance) { i, v in i.maxMagnification = v }
		case .minMagnification(let x): return x.apply(instance) { i, v in i.minMagnification = v }
		case .rulersVisible(let x): return x.apply(instance) { i, v in i.rulersVisible = v }
		case .scrollerInsets(let x): return x.apply(instance) { i, v in i.scrollerInsets = v }
		case .scrollerKnobStyle(let x): return x.apply(instance) { i, v in i.scrollerKnobStyle = v }
		case .scrollerStyle(let x): return x.apply(instance) { i, v in i.scrollerStyle = v }
		case .scrollsDynamically(let x): return x.apply(instance) { i, v in i.scrollsDynamically = v }
		case .usesPredominantAxisScrolling(let x): return x.apply(instance) { i, v in i.usesPredominantAxisScrolling = v }
		case .verticalLineScroll(let x): return x.apply(instance) { i, v in i.verticalLineScroll = v }
		case .verticalPageScroll(let x): return x.apply(instance) { i, v in i.verticalPageScroll = v }
		case .verticalScrollElasticity(let x): return x.apply(instance) { i, v in i.verticalScrollElasticity = v }

		// 2. Signal bindings are performed on the object after construction.
		case .flashScrollers(let x): return x.apply(instance) { i, v in i.flashScrollers() }
		case .magnificationCenteredAtPoint(let x): return x.apply(instance) { i, v in i.setMagnification(v.0, centeredAt: v.1) }
		case .magnifyToFitRect(let x): return x.apply(instance) { i, v in i.magnify(toFit: v) }
		case .scrollWheel(let x): return x.apply(instance) { i, v in i.scrollWheel(with: v) }

		// 3. Action bindings are triggered by the object after construction.
		case .didEndLiveMagnify(let x): return Signal.notifications(name: NSScrollView.didEndLiveMagnifyNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEndLiveScroll(let x): return Signal.notifications(name: NSScrollView.didEndLiveScrollNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didLiveScroll(let x): return Signal.notifications(name: NSScrollView.didLiveScrollNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willStartLiveMagnify(let x): return Signal.notifications(name: NSScrollView.willStartLiveMagnifyNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willStartLiveScroll(let x): return Signal.notifications(name: NSScrollView.willStartLiveScrollNotification, object: instance).map { n in () }.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ScrollView.Preparer {
	class Storage: View.Preparer.Storage {
		override var isInUse: Bool {
			return super.isInUse || !floatingSubviews.isEmpty
		}
		
		var floatingSubviews: [NSView] = []
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ScrollViewBinding {
	typealias ScrollViewName&lt;V&gt; = BindingName&lt;V, ScrollView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; ScrollView.Binding) -&gt; ScrollViewName&lt;V&gt; {
		return ScrollViewName&lt;V&gt;(source: source, downcast: Binding.scrollViewBinding)
	}
}
extension BindingName where Binding: ScrollViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ScrollViewName&lt;$2&gt; { return .name(ScrollView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMagnification: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.allowsMagnification) }
	static var autohidesScrollers: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.autohidesScrollers) }
	static var automaticallyAdjustsContentInsets: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.automaticallyAdjustsContentInsets) }
	static var backgroundColor: ScrollViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(ScrollView.Binding.backgroundColor) }
	static var borderType: ScrollViewName&lt;Dynamic&lt;NSBorderType&gt;&gt; { return .name(ScrollView.Binding.borderType) }
	static var contentInsets: ScrollViewName&lt;Dynamic&lt;NSEdgeInsets&gt;&gt; { return .name(ScrollView.Binding.contentInsets) }
	static var contentView: ScrollViewName&lt;Dynamic&lt;ClipViewConvertible&gt;&gt; { return .name(ScrollView.Binding.contentView) }
	static var documentCursor: ScrollViewName&lt;Dynamic&lt;NSCursor?&gt;&gt; { return .name(ScrollView.Binding.documentCursor) }
	static var drawsBackground: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.drawsBackground) }
	static var findBarPosition: ScrollViewName&lt;Dynamic&lt;NSScrollView.FindBarPosition&gt;&gt; { return .name(ScrollView.Binding.findBarPosition) }
	static var floatingSubviews: ScrollViewName&lt;Dynamic&lt;[(view: ViewConvertible, axis: NSEvent.GestureAxis)]&gt;&gt; { return .name(ScrollView.Binding.floatingSubviews) }
	static var hasHorizontalRuler: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.hasHorizontalRuler) }
	static var hasHorizontalScroller: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.hasHorizontalScroller) }
	static var hasVerticalRuler: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.hasVerticalRuler) }
	static var hasVerticalScroller: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.hasVerticalScroller) }
	static var horizontalLineScroll: ScrollViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ScrollView.Binding.horizontalLineScroll) }
	static var horizontalPageScroll: ScrollViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ScrollView.Binding.horizontalPageScroll) }
	static var horizontalScrollElasticity: ScrollViewName&lt;Dynamic&lt;NSScrollView.Elasticity&gt;&gt; { return .name(ScrollView.Binding.horizontalScrollElasticity) }
	static var magnification: ScrollViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ScrollView.Binding.magnification) }
	static var maxMagnification: ScrollViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ScrollView.Binding.maxMagnification) }
	static var minMagnification: ScrollViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ScrollView.Binding.minMagnification) }
	static var rulersVisible: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.rulersVisible) }
	static var scrollerInsets: ScrollViewName&lt;Dynamic&lt;NSEdgeInsets&gt;&gt; { return .name(ScrollView.Binding.scrollerInsets) }
	static var scrollerKnobStyle: ScrollViewName&lt;Dynamic&lt;NSScroller.KnobStyle&gt;&gt; { return .name(ScrollView.Binding.scrollerKnobStyle) }
	static var scrollerStyle: ScrollViewName&lt;Dynamic&lt;NSScroller.Style&gt;&gt; { return .name(ScrollView.Binding.scrollerStyle) }
	static var scrollsDynamically: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.scrollsDynamically) }
	static var usesPredominantAxisScrolling: ScrollViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.usesPredominantAxisScrolling) }
	static var verticalLineScroll: ScrollViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ScrollView.Binding.verticalLineScroll) }
	static var verticalPageScroll: ScrollViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(ScrollView.Binding.verticalPageScroll) }
	static var verticalScrollElasticity: ScrollViewName&lt;Dynamic&lt;NSScrollView.Elasticity&gt;&gt; { return .name(ScrollView.Binding.verticalScrollElasticity) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var flashScrollers: ScrollViewName&lt;Signal&lt;Bool&gt;&gt; { return .name(ScrollView.Binding.flashScrollers) }
	static var magnificationCenteredAtPoint: ScrollViewName&lt;Signal&lt;(CGFloat, NSPoint)&gt;&gt; { return .name(ScrollView.Binding.magnificationCenteredAtPoint) }
	static var magnifyToFitRect: ScrollViewName&lt;Signal&lt;CGRect&gt;&gt; { return .name(ScrollView.Binding.magnifyToFitRect) }
	static var scrollWheel: ScrollViewName&lt;Signal&lt;NSEvent&gt;&gt; { return .name(ScrollView.Binding.scrollWheel) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didEndLiveMagnify: ScrollViewName&lt;SignalInput&lt;Void&gt;&gt; { return .name(ScrollView.Binding.didEndLiveMagnify) }
	static var didEndLiveScroll: ScrollViewName&lt;SignalInput&lt;Void&gt;&gt; { return .name(ScrollView.Binding.didEndLiveScroll) }
	static var didLiveScroll: ScrollViewName&lt;SignalInput&lt;Void&gt;&gt; { return .name(ScrollView.Binding.didLiveScroll) }
	static var willStartLiveMagnify: ScrollViewName&lt;SignalInput&lt;Void&gt;&gt; { return .name(ScrollView.Binding.willStartLiveMagnify) }
	static var willStartLiveScroll: ScrollViewName&lt;SignalInput&lt;Void&gt;&gt; { return .name(ScrollView.Binding.willStartLiveScroll) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ScrollViewConvertible: ViewConvertible {
	func nsScrollView() -&gt; ScrollView.Instance
}
extension ScrollViewConvertible {
	func nsView() -&gt; View.Instance { return nsScrollView() }
}
extension NSScrollView: ScrollViewConvertible {
	func nsScrollView() -&gt; ScrollView.Instance { return self }
}
extension ScrollView {
	func nsScrollView() -&gt; ScrollView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ScrollViewBinding: ViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -&gt; Self
	func asScrollViewBinding() -&gt; ScrollView.Binding?
}
extension ScrollViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}
extension ScrollViewBinding where Preparer.Inherited.Binding: ScrollViewBinding {
	func asScrollViewBinding() -&gt; ScrollView.Binding? {
		return asInheritedBinding()?.asScrollViewBinding()
	}
}
extension ScrollView.Binding {
	typealias Preparer = ScrollView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asScrollViewBinding() -&gt; ScrollView.Binding? { return self }
	static func scrollViewBinding(_ binding: ScrollView.Binding) -&gt; ScrollView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class SegmentedControl: Binder, SegmentedControlConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension SegmentedControl {
	enum Binding: SegmentedControlBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case isSpringLoaded(Dynamic&lt;Bool&gt;)
		case distribution(Dynamic&lt;NSSegmentedControl.Distribution&gt;)
		case segments(Dynamic&lt;[SegmentDescription]&gt;)
		case segmentStyle(Dynamic&lt;NSSegmentedControl.Style&gt;)
		case selectedSegment(Dynamic&lt;Int&gt;)
		case trackingMode(Dynamic&lt;NSSegmentedControl.SwitchTracking&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension SegmentedControl {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = SegmentedControl.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = NSSegmentedControl
		
		var inherited = Inherited()
		init() {}
		
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension SegmentedControl.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .isSpringLoaded(let x): return x.apply(instance) { i, v in i.isSpringLoaded = v }
		case .distribution(let x): return x.apply(instance) { i, v in i.segmentDistribution = v }
		case .segments(let x):
			return x.apply(instance) { i, v in
				i.segmentCount = v.count
				for (index, segment) in v.enumerated() {
					i.setAlignment(segment.alignment, forSegment: index)
					i.setImage(segment.image, forSegment: index)
					i.setImageScaling(segment.imageScaling, forSegment: index)
					i.setEnabled(segment.isEnabled, forSegment: index)
					i.setLabel(segment.label, forSegment: index)
					i.setMenu(segment.menu?.nsMenu(), forSegment: index)
					i.setShowsMenuIndicator(segment.showsMenuIndicator, forSegment: index)
					i.setTag(segment.tag, forSegment: index)
					i.setToolTip(segment.toolTip, forSegment: index)
					i.setWidth(segment.width, forSegment: index)
				}
			}
		case .selectedSegment(let x): return x.apply(instance) { i, v in i.selectedSegment = v }
		case .segmentStyle(let x): return x.apply(instance) { i, v in i.segmentStyle = v }
		case .trackingMode(let x): return x.apply(instance) { i, v in i.trackingMode = v }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SegmentedControl.Preparer {
	typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SegmentedControlBinding {
	typealias SegmentedControlName&lt;V&gt; = BindingName&lt;V, SegmentedControl.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; SegmentedControl.Binding) -&gt; SegmentedControlName&lt;V&gt; {
		return SegmentedControlName&lt;V&gt;(source: source, downcast: Binding.segmentedControlBinding)
	}
}
extension BindingName where Binding: SegmentedControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SegmentedControlName&lt;$2&gt; { return .name(SegmentedControl.Binding.$1) }

	static var isSpringLoaded: SegmentedControlName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(SegmentedControl.Binding.isSpringLoaded) }
	static var distribution: SegmentedControlName&lt;Dynamic&lt;NSSegmentedControl.Distribution&gt;&gt; { return .name(SegmentedControl.Binding.distribution) }
	static var segments: SegmentedControlName&lt;Dynamic&lt;[SegmentDescription]&gt;&gt; { return .name(SegmentedControl.Binding.segments) }
	static var segmentStyle: SegmentedControlName&lt;Dynamic&lt;NSSegmentedControl.Style&gt;&gt; { return .name(SegmentedControl.Binding.segmentStyle) }
	static var selectedSegment: SegmentedControlName&lt;Dynamic&lt;Int&gt;&gt; { return .name(SegmentedControl.Binding.selectedSegment) }
	static var trackingMode: SegmentedControlName&lt;Dynamic&lt;NSSegmentedControl.SwitchTracking&gt;&gt; { return .name(SegmentedControl.Binding.trackingMode) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol SegmentedControlConvertible: ControlConvertible {
	func nsSegmentedControl() -&gt; SegmentedControl.Instance
}
extension SegmentedControlConvertible {
	func nsControl() -&gt; Control.Instance { return nsSegmentedControl() }
}
extension NSSegmentedControl: SegmentedControlConvertible /* , HasDelegate // if Preparer is BinderDelegateEmbedderConstructor */ {
	func nsSegmentedControl() -&gt; SegmentedControl.Instance { return self }
}
extension SegmentedControl {
	func nsSegmentedControl() -&gt; SegmentedControl.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol SegmentedControlBinding: ControlBinding {
	static func segmentedControlBinding(_ binding: SegmentedControl.Binding) -&gt; Self
	func asSegmentedControlBinding() -&gt; SegmentedControl.Binding?
}
extension SegmentedControlBinding {
	static func controlBinding(_ binding: Control.Binding) -&gt; Self {
		return segmentedControlBinding(.inheritedBinding(binding))
	}
}
extension SegmentedControlBinding where Preparer.Inherited.Binding: SegmentedControlBinding {
	func asSegmentedControlBinding() -&gt; SegmentedControl.Binding? {
		return asInheritedBinding()?.asSegmentedControlBinding()
	}
}
extension SegmentedControl.Binding {
	typealias Preparer = SegmentedControl.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSegmentedControlBinding() -&gt; SegmentedControl.Binding? { return self }
	static func segmentedControlBinding(_ binding: SegmentedControl.Binding) -&gt; SegmentedControl.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct SegmentDescription {
	let alignment: NSTextAlignment
	let image: NSImage?
	let imageScaling: NSImageScaling
	let isEnabled: Bool
	let isSelected: Bool
	let label: String
	let menu: MenuConvertible?
	let showsMenuIndicator: Bool
	let tag: Int
	let toolTip: String?
	let width: CGFloat
	
	init(label: String, alignment: NSTextAlignment = .center, image: NSImage? = nil, imageScaling: NSImageScaling = .scaleProportionallyDown, isEnabled: Bool = true, isSelected: Bool = false, menu: NSMenu? = nil, showsMenuIndicator: Bool = false, tag: Int = 0, toolTip: String? = nil, width: CGFloat = 0) {
		self.alignment = alignment
		self.image = image
		self.imageScaling = imageScaling
		self.isEnabled = isEnabled
		self.isSelected = isSelected
		self.label = label
		self.menu = menu
		self.showsMenuIndicator = showsMenuIndicator
		self.tag = tag
		self.toolTip = toolTip
		self.width = width
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class Slider: Binder, SliderConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Slider {
	enum Binding: SliderBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsTickMarkValuesOnly(Dynamic&lt;Bool&gt;)
		case altIncrementValue(Dynamic&lt;Double&gt;)
		case isVertical(Dynamic&lt;Bool&gt;)
		case maxValue(Dynamic&lt;Double&gt;)
		case minValue(Dynamic&lt;Double&gt;)
		case numberOfTickMarks(Dynamic&lt;Int&gt;)
		case sliderType(Dynamic&lt;NSSlider.SliderType&gt;)
		case tickMarkPosition(Dynamic&lt;NSSlider.TickMarkPosition&gt;)
		case trackFillColor(Dynamic&lt;NSColor?&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension Slider {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = Slider.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = NSSlider
		
		var inherited = Inherited()
		init() {}
		
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Slider.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .allowsTickMarkValuesOnly(let x): return x.apply(instance) { i, v in i.allowsTickMarkValuesOnly = v }
		case .altIncrementValue(let x): return x.apply(instance) { i, v in i.altIncrementValue = v }
		case .isVertical(let x): return x.apply(instance) { i, v in i.isVertical = v }
		case .maxValue(let x): return x.apply(instance) { i, v in i.maxValue = v }
		case .minValue(let x): return x.apply(instance) { i, v in i.minValue = v }
		case .numberOfTickMarks(let x): return x.apply(instance) { i, v in i.numberOfTickMarks = v }
		case .sliderType(let x): return x.apply(instance) { i, v in i.sliderType = v }
		case .tickMarkPosition(let x): return x.apply(instance) { i, v in i.tickMarkPosition = v }
		case .trackFillColor(let x): return x.apply(instance) { i, v in i.trackFillColor = v }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Slider.Preparer {
	typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SliderBinding {
	typealias SliderName&lt;V&gt; = BindingName&lt;V, Slider.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; Slider.Binding) -&gt; SliderName&lt;V&gt; {
		return SliderName&lt;V&gt;(source: source, downcast: Binding.sliderBinding)
	}
}
extension BindingName where Binding: SliderBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SliderName&lt;$2&gt; { return .name(Slider.Binding.$1) }

	static var allowsTickMarkValuesOnly: SliderName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Slider.Binding.allowsTickMarkValuesOnly) }
	static var altIncrementValue: SliderName&lt;Dynamic&lt;Double&gt;&gt; { return .name(Slider.Binding.altIncrementValue) }
	static var isVertical: SliderName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Slider.Binding.isVertical) }
	static var maxValue: SliderName&lt;Dynamic&lt;Double&gt;&gt; { return .name(Slider.Binding.maxValue) }
	static var minValue: SliderName&lt;Dynamic&lt;Double&gt;&gt; { return .name(Slider.Binding.minValue) }
	static var numberOfTickMarks: SliderName&lt;Dynamic&lt;Int&gt;&gt; { return .name(Slider.Binding.numberOfTickMarks) }
	static var sliderType: SliderName&lt;Dynamic&lt;NSSlider.SliderType&gt;&gt; { return .name(Slider.Binding.sliderType) }
	static var tickMarkPosition: SliderName&lt;Dynamic&lt;NSSlider.TickMarkPosition&gt;&gt; { return .name(Slider.Binding.tickMarkPosition) }
	static var trackFillColor: SliderName&lt;Dynamic&lt;NSColor?&gt;&gt; { return .name(Slider.Binding.trackFillColor) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol SliderConvertible: ControlConvertible {
	func nsSlider() -&gt; Slider.Instance
}
extension SliderConvertible {
	func nsControl() -&gt; Control.Instance { return nsSlider() }
}
extension NSSlider: SliderConvertible /* , HasDelegate // if Preparer is BinderDelegateEmbedderConstructor */ {
	func nsSlider() -&gt; Slider.Instance { return self }
}
extension Slider {
	func nsSlider() -&gt; Slider.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol SliderBinding: ControlBinding {
	static func sliderBinding(_ binding: Slider.Binding) -&gt; Self
	func asSliderBinding() -&gt; Slider.Binding?
}
extension SliderBinding {
	static func controlBinding(_ binding: Control.Binding) -&gt; Self {
		return sliderBinding(.inheritedBinding(binding))
	}
}
extension SliderBinding where Preparer.Inherited.Binding: SliderBinding {
	func asSliderBinding() -&gt; Slider.Binding? {
		return asInheritedBinding()?.asSliderBinding()
	}
}
extension Slider.Binding {
	typealias Preparer = Slider.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSliderBinding() -&gt; Slider.Binding? { return self }
	static func sliderBinding(_ binding: Slider.Binding) -&gt; Slider.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class SplitView: Binder, SplitViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	static var verticalThinBindings: [Binding] {
		return [
			.isVertical -- true,
			.dividerStyle -- .thin
		]
	}
	
	static func verticalThin(type: Instance.Type = Instance.self, _ bindings: Binding...) -&gt; SplitView {
		return SplitView(type: type, parameters: (), bindings: SplitView.verticalThinBindings + bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension SplitView {
	enum Binding: SplitViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case arrangedSubviews(Dynamic&lt;ArrayMutation&lt;SplitSubview&gt;&gt;)
		case autosaveName(Dynamic&lt;NSSplitView.AutosaveName?&gt;)
		case dividerStyle(Dynamic&lt;NSSplitView.DividerStyle&gt;)
		case isVertical(Dynamic&lt;Bool&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case setDividerPosition(Signal&lt;(position: CGFloat, dividerIndex: Int)&gt;)

		// 3. Action bindings are triggered by the object after construction.
		case didResizeSubviews(SignalInput&lt;Int?&gt;)
		case willResizeSubviews(SignalInput&lt;Int?&gt;)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case additionalEffectiveRect((_ splitView: NSSplitView, _ dividerAt: Int) -&gt; NSRect)
		case canCollapseSubview((_ splitView: NSSplitView, _ subview: NSView) -&gt; Bool)
		case constrainMaxCoordinate((_ splitView: NSSplitView, _ proposedMaximumPosition: CGFloat, _ dividerIndex: Int) -&gt; CGFloat)
		case constrainMinCoordinate((_ splitView: NSSplitView, _ proposedMinimumPosition: CGFloat, _ dividerIndex: Int) -&gt; CGFloat)
		case constrainSplitPosition((_ splitView: NSSplitView, _ proposedPosition: CGFloat, _ dividerIndex: Int) -&gt; CGFloat)
		case effectiveRectForDrawnRect((_ splitView: NSSplitView, _ proposedEffectiveRect: NSRect, _ drawnRect: NSRect, _ dividerIndex: Int) -&gt; NSRect)
		case resizeSubviews((NSSplitView, NSSize) -&gt; Void)
		case shouldAdjustSizeOfSubview((_ splitView: NSSplitView, _ subview: NSView) -&gt; Bool)
		case shouldCollapseSubview((_ splitView: NSSplitView, _ subview: NSView, _ dividerIndex: Int) -&gt; Bool)
		case shouldHideDivider((_ splitView: NSSplitView, _ dividerIndex: Int) -&gt; Bool)
	}
}

// MARK: - Binder Part 3: Preparer
extension SplitView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = SplitView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSSplitView
		typealias Parameters = () /* change if non-default construction required */
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var autosaveName: Dynamic&lt;NSSplitView.AutosaveName?&gt;? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension SplitView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)

		case .additionalEffectiveRect(let x): delegate().addSingleHandler2(x, #selector(NSSplitViewDelegate.splitView(_:additionalEffectiveRectOfDividerAt:)))
		case .autosaveName(let x): autosaveName = x
		case .canCollapseSubview(let x): delegate().addSingleHandler2(x, #selector(NSSplitViewDelegate.splitView(_:canCollapseSubview:)))
		case .constrainMaxCoordinate(let x): delegate().addSingleHandler3(x, #selector(NSSplitViewDelegate.splitView(_:constrainMaxCoordinate:ofSubviewAt:)))
		case .constrainMinCoordinate(let x): delegate().addSingleHandler3(x, #selector(NSSplitViewDelegate.splitView(_:constrainMinCoordinate:ofSubviewAt:)))
		case .constrainSplitPosition(let x): delegate().addSingleHandler3(x, #selector(NSSplitViewDelegate.splitView(_:constrainSplitPosition:ofSubviewAt:)))
		case .effectiveRectForDrawnRect(let x): delegate().addSingleHandler4(x, #selector(NSSplitViewDelegate.splitView(_:effectiveRect:forDrawnRect:ofDividerAt:)))
		case .resizeSubviews(let x): delegate().addMultiHandler2(x, #selector(NSSplitViewDelegate.splitView(_:resizeSubviewsWithOldSize:)))
		case .shouldAdjustSizeOfSubview(let x): delegate().addSingleHandler2(x, #selector(NSSplitViewDelegate.splitView(_:shouldAdjustSizeOfSubview:)))
		case .shouldCollapseSubview(let x): delegate().addSingleHandler3(x, #selector(NSSplitViewDelegate.splitView(_:shouldCollapseSubview:forDoubleClickOnDividerAt:)))
		case .shouldHideDivider(let x): delegate().addSingleHandler2(x, #selector(NSSplitViewDelegate.splitView(_:shouldHideDividerAt:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .arrangedSubviews(let x): return x.apply(instance) { i, v in
			v.insertionsAndRemovals(length: i.arrangedSubviews.count, insert: { index, component in
				let view = component.view.nsView()
				view.removeFromSuperview()
				instance.insertArrangedSubview(view, at: index)
				instance.setHoldingPriority(component.holdingPriority, forSubviewAt: index)
				
				let viewAnchor = instance.isVertical ? view.widthAnchor : view.heightAnchor
				let instanceAnchor = instance.isVertical ? i.widthAnchor : i.heightAnchor
				
				NSLayoutConstraint.activate(
					component.constraints.map { $0.scaledConstraintBetween(first: viewAnchor, second: instanceAnchor) }
				)
			}, remove: { index in
				instance.removeArrangedSubview(instance.arrangedSubviews[index])
			})
		}
		case .autosaveName: return nil
		case .dividerStyle(let x): return x.apply(instance) { i, v in i.dividerStyle = v }
		case .isVertical(let x): return x.apply(instance) { i, v in i.isVertical = v }

		// 2. Signal bindings are performed on the object after construction.
		case .setDividerPosition(let x): return x.apply(instance) { i, v in i.setPosition(v.position, ofDividerAt: v.dividerIndex) }

		// 3. Action bindings are triggered by the object after construction.
		case .didResizeSubviews(let x): return Signal.notifications(name: NSSplitView.didResizeSubviewsNotification, object: instance).map { n in return n.userInfo?["NSSplitViewDividerIndex"] as? Int }.cancellableBind(to: x)
		case .willResizeSubviews(let x):return Signal.notifications(name: NSSplitView.willResizeSubviewsNotification, object: instance).map { n in return n.userInfo?["NSSplitViewDividerIndex"] as? Int }.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .additionalEffectiveRect: return nil
		case .canCollapseSubview: return nil
		case .constrainMaxCoordinate: return nil
		case .constrainMinCoordinate: return nil
		case .constrainSplitPosition: return nil
		case .effectiveRectForDrawnRect: return nil
		case .resizeSubviews: return nil
		case .shouldAdjustSizeOfSubview: return nil
		case .shouldCollapseSubview: return nil
		case .shouldHideDivider: return nil
		}
	}

	func finalizeInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime? {
		var lifetimes = [Lifetime]()
		lifetimes += autosaveName?.apply(instance) { i, v in
			i.autosaveName = v
		}

		lifetimes += inheritedFinalizedInstance(instance, storage: storage)
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SplitView.Preparer {
	class Storage: View.Preparer.Storage, NSSplitViewDelegate {
		var constraints: [(Layout.Dimension, NSLayoutConstraint)] = []
	}
	
	class Delegate: DynamicDelegate, NSSplitViewDelegate {
		func splitView(_ splitView: NSSplitView, additionalEffectiveRectOfDividerAt dividerIndex: Int) -&gt; NSRect {
			return singleHandler(splitView, dividerIndex)
		}
		
		func splitView(_ splitView: NSSplitView, canCollapseSubview subview: NSView) -&gt; Bool {
			return singleHandler(splitView, subview)
		}
		
		func splitView(_ splitView: NSSplitView, constrainMaxCoordinate proposedMaximumPosition: CGFloat, ofSubviewAt dividerIndex: Int) -&gt; CGFloat {
			return singleHandler(splitView, proposedMaximumPosition, dividerIndex)
		}
		
		func splitView(_ splitView: NSSplitView, constrainMinCoordinate proposedMinimumPosition: CGFloat, ofSubviewAt dividerIndex: Int) -&gt; CGFloat {
			return singleHandler(splitView, proposedMinimumPosition, dividerIndex)
		}
		
		func splitView(_ splitView: NSSplitView, constrainSplitPosition proposedPosition: CGFloat, ofSubviewAt dividerIndex: Int) -&gt; CGFloat {
			return singleHandler(splitView, proposedPosition, dividerIndex)
		}
		
		func splitView(_ splitView: NSSplitView, effectiveRect proposedEffectiveRect: NSRect, forDrawnRect drawnRect: NSRect, ofDividerAt dividerIndex: Int) -&gt; NSRect {
			return singleHandler(splitView, proposedEffectiveRect, drawnRect, dividerIndex)
		}
		
		func splitView(_ splitView: NSSplitView, resizeSubviewsWithOldSize oldSize: NSSize) {
			multiHandler(splitView, oldSize)
		}
		
		func splitView(_ splitView: NSSplitView, shouldAdjustSizeOfSubview view: NSView) -&gt; Bool {
			return singleHandler(splitView, view)
		}
		
		func splitView(_ splitView: NSSplitView, shouldCollapseSubview subview: NSView, forDoubleClickOnDividerAt dividerIndex: Int) -&gt; Bool {
			return singleHandler(splitView, subview, dividerIndex)
		}
		
		func splitView(_ splitView: NSSplitView, shouldHideDividerAt dividerIndex: Int) -&gt; Bool {
			return singleHandler(splitView, dividerIndex)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SplitViewBinding {
	typealias SplitViewName&lt;V&gt; = BindingName&lt;V, SplitView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; SplitView.Binding) -&gt; SplitViewName&lt;V&gt; {
		return SplitViewName&lt;V&gt;(source: source, downcast: Binding.splitViewBinding)
	}
}
extension BindingName where Binding: SplitViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SplitViewName&lt;$2&gt; { return .name(SplitView.Binding.$1) }

	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var arrangedSubviews: SplitViewName&lt;Dynamic&lt;ArrayMutation&lt;SplitSubview&gt;&gt;&gt; { return .name(SplitView.Binding.arrangedSubviews) }
	static var autosaveName: SplitViewName&lt;Dynamic&lt;NSSplitView.AutosaveName?&gt;&gt; { return .name(SplitView.Binding.autosaveName) }
	static var dividerStyle: SplitViewName&lt;Dynamic&lt;NSSplitView.DividerStyle&gt;&gt; { return .name(SplitView.Binding.dividerStyle) }
	static var isVertical: SplitViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(SplitView.Binding.isVertical) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var setDividerPosition: SplitViewName&lt;Signal&lt;(position: CGFloat, dividerIndex: Int)&gt;&gt; { return .name(SplitView.Binding.setDividerPosition) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didResizeSubviews: SplitViewName&lt;SignalInput&lt;Int?&gt;&gt; { return .name(SplitView.Binding.didResizeSubviews) }
	static var willResizeSubviews: SplitViewName&lt;SignalInput&lt;Int?&gt;&gt; { return .name(SplitView.Binding.willResizeSubviews) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var additionalEffectiveRect: SplitViewName&lt;(_ splitView: NSSplitView, _ dividerAt: Int) -&gt; NSRect&gt; { return .name(SplitView.Binding.additionalEffectiveRect) }
	static var canCollapseSubview: SplitViewName&lt;(_ splitView: NSSplitView, _ subview: NSView) -&gt; Bool&gt; { return .name(SplitView.Binding.canCollapseSubview) }
	static var constrainMaxCoordinate: SplitViewName&lt;(_ splitView: NSSplitView, _ proposedMaximumPosition: CGFloat, _ dividerIndex: Int) -&gt; CGFloat&gt; { return .name(SplitView.Binding.constrainMaxCoordinate) }
	static var constrainMinCoordinate: SplitViewName&lt;(_ splitView: NSSplitView, _ proposedMinimumPosition: CGFloat, _ dividerIndex: Int) -&gt; CGFloat&gt; { return .name(SplitView.Binding.constrainMinCoordinate) }
	static var constrainSplitPosition: SplitViewName&lt;(_ splitView: NSSplitView, _ proposedPosition: CGFloat, _ dividerIndex: Int) -&gt; CGFloat&gt; { return .name(SplitView.Binding.constrainSplitPosition) }
	static var effectiveRectForDrawnRect: SplitViewName&lt;(_ splitView: NSSplitView, _ proposedEffectiveRect: NSRect, _ drawnRect: NSRect, _ dividerIndex: Int) -&gt; NSRect&gt; { return .name(SplitView.Binding.effectiveRectForDrawnRect) }
	static var resizeSubviews: SplitViewName&lt;(NSSplitView, NSSize) -&gt; Void&gt; { return .name(SplitView.Binding.resizeSubviews) }
	static var shouldAdjustSizeOfSubview: SplitViewName&lt;(_ splitView: NSSplitView, _ subview: NSView) -&gt; Bool&gt; { return .name(SplitView.Binding.shouldAdjustSizeOfSubview) }
	static var shouldCollapseSubview: SplitViewName&lt;(_ splitView: NSSplitView, _ subview: NSView, _ dividerIndex: Int) -&gt; Bool&gt; { return .name(SplitView.Binding.shouldCollapseSubview) }
	static var shouldHideDivider: SplitViewName&lt;(_ splitView: NSSplitView, _ dividerIndex: Int) -&gt; Bool&gt; { return .name(SplitView.Binding.shouldHideDivider) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol SplitViewConvertible: ViewConvertible {
	func nsSplitView() -&gt; SplitView.Instance
}
extension SplitViewConvertible {
	func nsView() -&gt; View.Instance { return nsSplitView() }
}
extension NSSplitView: SplitViewConvertible, HasDelegate {
	func nsSplitView() -&gt; SplitView.Instance { return self }
}
extension SplitView {
	func nsSplitView() -&gt; SplitView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol SplitViewBinding: ViewBinding {
	static func splitViewBinding(_ binding: SplitView.Binding) -&gt; Self
	func asSplitViewBinding() -&gt; SplitView.Binding?
}
extension SplitViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return splitViewBinding(.inheritedBinding(binding))
	}
}
extension SplitViewBinding where Preparer.Inherited.Binding: SplitViewBinding {
	func asSplitViewBinding() -&gt; SplitView.Binding? {
		return asInheritedBinding()?.asSplitViewBinding()
	}
}
extension SplitView.Binding {
	typealias Preparer = SplitView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSplitViewBinding() -&gt; SplitView.Binding? { return self }
	static func splitViewBinding(_ binding: SplitView.Binding) -&gt; SplitView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct SplitSubview {
	let view: ViewConvertible
	let holdingPriority: NSLayoutConstraint.Priority
	let constraints: [Layout.Dimension]
	
	init(view: ViewConvertible, holdingPriority: NSLayoutConstraint.Priority, constraints: [Layout.Dimension]) {
		self.view = view
		self.holdingPriority = holdingPriority
		self.constraints = constraints
	}
	
	static func subview(_ viewConvertible: ViewConvertible, holdingPriority: NSLayoutConstraint.Priority = .defaultLow, constraints: Layout.Dimension...) -&gt; SplitSubview {
		return SplitSubview(view: viewConvertible, holdingPriority: holdingPriority, constraints: constraints)
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class TabViewItem: Binder, TabViewItemConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TabViewItem {
	enum Binding: TabViewItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case color(Dynamic&lt;NSColor&gt;)
		case image(Dynamic&lt;NSImage?&gt;)
		case initialFirstResponderTag(Dynamic&lt;Int&gt;)
		case label(Dynamic&lt;String&gt;)
		case toolTip(Dynamic&lt;String&gt;)
		case view(Dynamic&lt;ViewConvertible&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension TabViewItem {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = TabViewItem.Binding
		typealias Inherited = BinderBase
		typealias Instance = NSTabViewItem
		
		var inherited = Inherited()
		init() {}
		
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var initialFirstResponderTag: Dynamic&lt;Int&gt;? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TabViewItem.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -&gt; Instance {
		return type.init(identifier: nil)
	}
	
	mutating func prepareBinding(_ binding: TabViewItem.Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .initialFirstResponderTag(let x): initialFirstResponderTag = x
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .color(let x): return x.apply(instance) { i, v in i.color = v }
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .initialFirstResponderTag: return nil
		case .label(let x): return x.apply(instance) { i, v in i.label = v }
		case .toolTip(let x): return x.apply(instance) { i, v in i.toolTip = v }
		case .view(let x): return x.apply(instance) { i, v in i.view = v.nsView() }
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime? {
		var lifetimes = [Lifetime]()
		lifetimes += initialFirstResponderTag?.apply(instance) { i, v in
			let view = i.view?.viewWithTag(v)
			i.initialFirstResponder = view
		}
		lifetimes += inheritedFinalizedInstance(instance, storage: storage)
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabViewItem.Preparer {
	typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabViewItemBinding {
	typealias TabViewItemName&lt;V&gt; = BindingName&lt;V, TabViewItem.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; TabViewItem.Binding) -&gt; TabViewItemName&lt;V&gt; {
		return TabViewItemName&lt;V&gt;(source: source, downcast: Binding.tabViewItemBinding)
	}
}
extension BindingName where Binding: TabViewItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabViewItemName&lt;$2&gt; { return .name(TabViewItem.Binding.$1) }
	static var color: TabViewItemName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(TabViewItem.Binding.color) }
	static var image: TabViewItemName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(TabViewItem.Binding.image) }
	static var initialFirstResponderTag: TabViewItemName&lt;Dynamic&lt;Int&gt;&gt; { return .name(TabViewItem.Binding.initialFirstResponderTag) }
	static var label: TabViewItemName&lt;Dynamic&lt;String&gt;&gt; { return .name(TabViewItem.Binding.label) }
	static var toolTip: TabViewItemName&lt;Dynamic&lt;String&gt;&gt; { return .name(TabViewItem.Binding.toolTip) }
	static var view: TabViewItemName&lt;Dynamic&lt;ViewConvertible&gt;&gt; { return .name(TabViewItem.Binding.view) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TabViewItemConvertible {
	func nsTabViewItem() -&gt; TabViewItem.Instance
}
extension TabViewItemConvertible {
	func nsBinderBase() -&gt; BinderBase.Instance { return nsTabViewItem() }
}
extension NSTabViewItem: TabViewItemConvertible /* , HasDelegate // if Preparer is BinderDelegateEmbedderConstructor */ {
	func nsTabViewItem() -&gt; TabViewItem.Instance { return self }
}
extension TabViewItem {
	func nsTabViewItem() -&gt; TabViewItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TabViewItemBinding: BinderBaseBinding {
	static func tabViewItemBinding(_ binding: TabViewItem.Binding) -&gt; Self
	func asTabViewItemBinding() -&gt; TabViewItem.Binding?
}
extension TabViewItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return tabViewItemBinding(.inheritedBinding(binding))
	}
}
extension TabViewItemBinding where Preparer.Inherited.Binding: TabViewItemBinding {
	func asTabViewItemBinding() -&gt; TabViewItem.Binding? {
		return asInheritedBinding()?.asTabViewItemBinding()
	}
}
extension TabViewItem.Binding {
	typealias Preparer = TabViewItem.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTabViewItemBinding() -&gt; TabViewItem.Binding? { return self }
	static func tabViewItemBinding(_ binding: TabViewItem.Binding) -&gt; TabViewItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class TabView&lt;Identifier: Equatable&gt;: Binder, TabViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TabView {
	enum Binding: TabViewBinding {
		typealias IdentifierType = Identifier
		
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsTruncatedLabels(Dynamic&lt;Bool&gt;)
		case borderType(Dynamic&lt;NSTabView.TabViewBorderType&gt;)
		case controlSize(Dynamic&lt;NSControl.ControlSize&gt;)
		case drawsBackground(Dynamic&lt;Bool&gt;)
		case font(Dynamic&lt;NSFont&gt;)
		case position(Dynamic&lt;NSTabView.TabPosition&gt;)
		case tabs(Dynamic&lt;ArrayMutation&lt;Identifier&gt;&gt;)
		case type(Dynamic&lt;NSTabView.TabType&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case selectedItem(Dynamic&lt;Identifier&gt;)
		case selectFirstItem(Signal&lt;Void&gt;)
		case selectLastItem(Signal&lt;Void&gt;)
		case selectNextItem(Signal&lt;Void&gt;)
		case selectPreviousItem(Signal&lt;Void&gt;)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didChangeNumberOfItems((NSTabView) -&gt; Void)
		case didSelect((NSTabView, NSTabViewItem?, Identifier?) -&gt; Void)
		case shouldSelect((NSTabView, NSTabViewItem?, Identifier?) -&gt; Bool)
		case tabConstructor((Identifier) -&gt; TabViewItemConvertible)
		case willSelect((NSTabView, NSTabViewItem?, Identifier?) -&gt; Void)
	}
}

// MARK: - Binder Part 3: Preparer
extension TabView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = TabView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSTabView
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var tabConstructor: ((Identifier) -&gt; TabViewItemConvertible)? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TabView.Preparer {
	func constructStorage(instance: Instance) -&gt; Storage {
		return Storage(tabConstructor: tabConstructor)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .didChangeNumberOfItems(let x): delegate().addMultiHandler1(x, #selector(NSTabViewDelegate.tabViewDidChangeNumberOfTabViewItems(_:)))
		case .didSelect(let x): delegate().addMultiHandler3(x, #selector(NSTabViewDelegate.tabView(_:didSelect:)))
		case .shouldSelect(let x): delegate().addSingleHandler3(x, #selector(NSTabViewDelegate.tabView(_:shouldSelect:)))
		case .tabConstructor(let x): tabConstructor = x
		case .willSelect(let x): delegate().addMultiHandler3(x, #selector(NSTabViewDelegate.tabView(_:willSelect:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		// 0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsTruncatedLabels(let x): return x.apply(instance) { i, v in i.allowsTruncatedLabels = v }
		case .borderType(let x): return x.apply(instance) { i, v in i.tabViewBorderType = v }
		case .controlSize(let x): return x.apply(instance) { i, v in i.controlSize = v }
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .position(let x): return x.apply(instance) { i, v in i.tabPosition = v }
		case .selectedItem(let x):
			return x.apply(instance) { i, v in
				for tabItem in i.tabViewItems {
					if let identifier = tabItem.identifier as? Identifier, identifier == v {
						i.selectTabViewItem(tabItem)
						if let window = i.window, let responder = tabItem.initialFirstResponder {
							window.makeFirstResponder(responder)
						}
						break
					}
				}
			}
		case .tabs(let x):
			return x.apply(instance, storage) { i, s, v in
				let constructor = s.tabConstructor ?? { _ in NSTabViewItem(identifier: nil) }
				v.insertionsAndRemovals(
					length: i.numberOfTabViewItems,
					insert: { index, identifier in
						let item = constructor(identifier).nsTabViewItem()
						item.identifier = identifier
						i.insertTabViewItem(item, at: index)
					},
					remove: { index in i.removeTabViewItem(i.tabViewItem(at: index)) }
				)
			}
		case .type(let x): return x.apply(instance) { i, v in i.tabViewType = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .selectFirstItem(let x): return x.apply(instance) { i, v in i.selectFirstTabViewItem(nil) }
		case .selectLastItem(let x): return x.apply(instance) { i, v in i.selectLastTabViewItem(nil) }
		case .selectNextItem(let x): return x.apply(instance) { i, v in i.selectNextTabViewItem(nil) }
		case .selectPreviousItem(let x): return x.apply(instance) { i, v in i.selectPreviousTabViewItem(nil) }
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .didChangeNumberOfItems: return nil
		case .didSelect: return nil
		case .shouldSelect: return nil
		case .tabConstructor: return nil
		case .willSelect: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabView.Preparer {
	class Storage: View.Preparer.Storage, NSTabViewDelegate {
		var tabConstructor: ((Identifier) -&gt; TabViewItemConvertible)?
		init(tabConstructor: ((Identifier) -&gt; TabViewItemConvertible)?) {
			self.tabConstructor = tabConstructor
		}
	}

	class Delegate: DynamicDelegate, NSTabViewDelegate {
		func tabViewDidChangeNumberOfTabViewItems(_ tabView: NSTabView) {
			multiHandler(tabView)
		}
		
		func tabView(_ tabView: NSTabView, didSelect tabViewItem: NSTabViewItem?) {
			multiHandler(tabView, tabViewItem, tabViewItem?.identifier as? Identifier)
		}
		
		func tabView(_ tabView: NSTabView, shouldSelect tabViewItem: NSTabViewItem?) -&gt; Bool {
			return singleHandler(tabView, tabViewItem, tabViewItem?.identifier as? Identifier)
		}
		
		func tabView(_ tabView: NSTabView, willSelect tabViewItem: NSTabViewItem?) {
			multiHandler(tabView, tabViewItem, tabViewItem?.identifier as? Identifier)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabViewBinding {
	typealias TabViewName&lt;V&gt; = BindingName&lt;V, TabView&lt;Binding.IdentifierType&gt;.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; TabView&lt;Binding.IdentifierType&gt;.Binding) -&gt; TabViewName&lt;V&gt; {
		return TabViewName&lt;V&gt;(source: source, downcast: Binding.tabViewBinding)
	}
}
extension BindingName where Binding: TabViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabViewName&lt;$2&gt; { return .name(TabView.Binding.$1) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsTruncatedLabels: TabViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TabView.Binding.allowsTruncatedLabels) }
	static var borderType: TabViewName&lt;Dynamic&lt;NSTabView.TabViewBorderType&gt;&gt; { return .name(TabView.Binding.borderType) }
	static var controlSize: TabViewName&lt;Dynamic&lt;NSControl.ControlSize&gt;&gt; { return .name(TabView.Binding.controlSize) }
	static var drawsBackground: TabViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TabView.Binding.drawsBackground) }
	static var font: TabViewName&lt;Dynamic&lt;NSFont&gt;&gt; { return .name(TabView.Binding.font) }
	static var position: TabViewName&lt;Dynamic&lt;NSTabView.TabPosition&gt;&gt; { return .name(TabView.Binding.position) }
	static var tabs: TabViewName&lt;Dynamic&lt;ArrayMutation&lt;Binding.IdentifierType&gt;&gt;&gt; { return .name(TabView.Binding.tabs) }
	static var type: TabViewName&lt;Dynamic&lt;NSTabView.TabType&gt;&gt; { return .name(TabView.Binding.type) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectedItem: TabViewName&lt;Dynamic&lt;Binding.IdentifierType&gt;&gt; { return .name(TabView.Binding.selectedItem) }
	static var selectFirstItem: TabViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TabView.Binding.selectFirstItem) }
	static var selectLastItem: TabViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TabView.Binding.selectLastItem) }
	static var selectNextItem: TabViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TabView.Binding.selectNextItem) }
	static var selectPreviousItem: TabViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TabView.Binding.selectPreviousItem) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didChangeNumberOfItems: TabViewName&lt;(NSTabView) -&gt; Void&gt; { return .name(TabView.Binding.didChangeNumberOfItems) }
	static var didSelect: TabViewName&lt;(NSTabView, NSTabViewItem?, Binding.IdentifierType?) -&gt; Void&gt; { return .name(TabView.Binding.didSelect) }
	static var shouldSelect: TabViewName&lt;(NSTabView, NSTabViewItem?, Binding.IdentifierType?) -&gt; Bool&gt; { return .name(TabView.Binding.shouldSelect) }
	static var tabConstructor: TabViewName&lt;(Binding.IdentifierType) -&gt; TabViewItemConvertible&gt; { return .name(TabView.Binding.tabConstructor) }
	static var willSelect: TabViewName&lt;(NSTabView, NSTabViewItem?, Binding.IdentifierType?) -&gt; Void&gt; { return .name(TabView.Binding.willSelect) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TabViewConvertible: ViewConvertible {
	func nsTabView() -&gt; NSTabView
}
extension TabViewConvertible {
	func nsView() -&gt; View.Instance { return nsTabView() }
}
extension NSTabView: TabViewConvertible, HasDelegate {
	func nsTabView() -&gt; NSTabView { return self }
}
extension TabView {
	func nsTabView() -&gt; TabView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TabViewBinding: ViewBinding {
	associatedtype IdentifierType: Equatable
	static func tabViewBinding(_ binding: TabView&lt;IdentifierType&gt;.Binding) -&gt; Self
	func asTabViewBinding() -&gt; TabView&lt;IdentifierType&gt;.Binding?
}
extension TabViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return tabViewBinding(.inheritedBinding(binding))
	}
}
extension TabViewBinding where Preparer.Inherited.Binding: TabViewBinding, Preparer.Inherited.Binding.IdentifierType == IdentifierType {
	func asTabViewBinding() -&gt; TabView&lt;IdentifierType&gt;.Binding? {
		return asInheritedBinding()?.asTabViewBinding()
	}
}
extension TabView.Binding {
	typealias Preparer = TabView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTabViewBinding() -&gt; TabView.Binding? { return self }
	static func tabViewBinding(_ binding: TabView&lt;IdentifierType&gt;.Binding) -&gt; TabView&lt;IdentifierType&gt;.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class TableCellView: Binder, TableCellViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TableCellView {
	enum Binding: TableCellViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundStyle(Dynamic&lt;NSView.BackgroundStyle&gt;)
		case rowSizeStyle(Dynamic&lt;NSTableView.RowSizeStyle&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension TableCellView {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = TableCellView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSTableCellView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TableCellView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundStyle(let x): return x.apply(instance) { i, v in i.backgroundStyle = v }
		case .rowSizeStyle(let x): return x.apply(instance) { i, v in i.rowSizeStyle = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableCellView.Preparer {
	typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableCellViewBinding {
	typealias TableCellViewName&lt;V&gt; = BindingName&lt;V, TableCellView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; TableCellView.Binding) -&gt; TableCellViewName&lt;V&gt; {
		return TableCellViewName&lt;V&gt;(source: source, downcast: Binding.tableCellViewBinding)
	}
}
extension BindingName where Binding: TableCellViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableCellViewName&lt;$2&gt; { return .name(TableCellView.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundStyle: TableCellViewName&lt;Dynamic&lt;NSView.BackgroundStyle&gt;&gt; { return .name(TableCellView.Binding.backgroundStyle) }
	static var rowSizeStyle: TableCellViewName&lt;Dynamic&lt;NSTableView.RowSizeStyle&gt;&gt; { return .name(TableCellView.Binding.rowSizeStyle) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TableCellViewConvertible: ViewConvertible {
	func nsTableCellView() -&gt; TableCellView.Instance
}
extension TableCellViewConvertible {
	func nsView() -&gt; View.Instance { return nsTableCellView() }
}
extension NSTableCellView: TableCellViewConvertible {
	func nsTableCellView() -&gt; TableCellView.Instance { return self }
}
extension TableCellView {
	func nsTableCellView() -&gt; TableCellView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TableCellViewBinding: ViewBinding {
	static func tableCellViewBinding(_ binding: TableCellView.Binding) -&gt; Self
	func asTableCellViewBinding() -&gt; TableCellView.Binding?
}
extension TableCellViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return tableCellViewBinding(.inheritedBinding(binding))
	}
}
extension TableCellViewBinding where Preparer.Inherited.Binding: TableCellViewBinding {
	func asTableCellViewBinding() -&gt; TableCellView.Binding? {
		return asInheritedBinding()?.asTableCellViewBinding()
	}
}
extension TableCellView.Binding {
	typealias Preparer = TableCellView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableCellViewBinding() -&gt; TableCellView.Binding? { return self }
	static func tableCellViewBinding(_ binding: TableCellView.Binding) -&gt; TableCellView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
private var associatedInputKey = NSObject()
extension NSTableCellView {
	func associatedRowInput&lt;B&gt;(valueType: B.Type) -&gt; 
		SignalInput&lt;B&gt;? {
			return objc_getAssociatedObject(self, &amp;associatedInputKey) as? SignalInput&lt;B&gt;
	}
	
	func setAssociatedRowInput&lt;B&gt;(to input: SignalInput&lt;B&gt;) {
		objc_setAssociatedObject(self, &amp;associatedInputKey, input, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class TableColumn&lt;RowData&gt;: Binder {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TableColumn {
	enum Binding: TableColumnBinding {
		typealias RowDataType = RowData
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case identifier(Constant&lt;NSUserInterfaceItemIdentifier&gt;)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case headerCell(Dynamic&lt;NSTableHeaderCell&gt;)
		case headerToolTip(Dynamic&lt;String?&gt;)
		case isEditable(Dynamic&lt;Bool&gt;)
		case isHidden(Dynamic&lt;Bool&gt;)
		case maxWidth(Dynamic&lt;CGFloat&gt;)
		case minWidth(Dynamic&lt;CGFloat&gt;)
		case resizingMask(Dynamic&lt;NSTableColumn.ResizingOptions&gt;)
		case sortDescriptorPrototype(Dynamic&lt;NSSortDescriptor?&gt;)
		case sortFunction(Dynamic&lt;(_ isRow: RowData, _ orderedBefore: RowData) -&gt; Bool&gt;)
		case title(Dynamic&lt;String&gt;)
		case width(Dynamic&lt;CGFloat&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case sizeToFit(Signal&lt;Void&gt;)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case cellConstructor((_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti&lt;RowData&gt;) -&gt; TableCellViewConvertible)
		case cellIdentifierForRow((RowData?) -&gt; NSUserInterfaceItemIdentifier)
		case dataMissingCell(() -&gt; TableCellViewConvertible?)
	}
}

// MARK: - Binder Part 3: Preparer
extension TableColumn {
	struct Preparer: BinderConstructor {
		typealias Binding = TableColumn.Binding
		typealias Inherited = BinderBase
		typealias Instance = NSTableColumn
		typealias Output = Storage
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage(tableColumn: instance, cellConstructor: cellConstructor, cellIdentifier: cellIdentifier, dataMissingCell: dataMissingCell) }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var columnIdentifier: NSUserInterfaceItemIdentifier?
		var cellConstructor: ((_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti&lt;RowData&gt;) -&gt; TableCellViewConvertible)?
		var cellIdentifier: ((RowData?) -&gt; NSUserInterfaceItemIdentifier)?
		var dataMissingCell: (() -&gt; TableCellViewConvertible?)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TableColumn.Preparer {
	func constructInstance(type: Instance.Type, parameters: Parameters) -&gt; Instance {
		return type.init(identifier: columnIdentifier ?? NSUserInterfaceItemIdentifier(UUID().uuidString))
	}
	
	func combine(lifetimes: [Lifetime], instance: Instance, storage: Storage) -&gt; Storage {
		return storage
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .identifier(let x): columnIdentifier = x.value
		case .cellConstructor(let x): cellConstructor = x
		case .cellIdentifierForRow(let x): cellIdentifier = x
		case .dataMissingCell(let x): dataMissingCell = x
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .identifier: return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .headerCell(let x): return x.apply(instance) { i, v in i.headerCell = v }
		case .headerToolTip(let x): return x.apply(instance) { i, v in i.headerToolTip = v }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .maxWidth(let x): return x.apply(instance) { i, v in i.maxWidth = v }
		case .minWidth(let x): return x.apply(instance) { i, v in i.minWidth = v }
		case .resizingMask(let x): return x.apply(instance) { i, v in i.resizingMask = v }
		case .sortDescriptorPrototype(let x): return x.apply(instance) { i, v in i.sortDescriptorPrototype = v }
		case .sortFunction(let x): return x.apply(instance, storage) { i, s, v in s.sortFunction = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .width(let x): return x.apply(instance) { i, v in i.width = v }

		// 2. Signal bindings are performed on the object after construction.
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }

		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .cellConstructor: return nil
		case .cellIdentifierForRow: return nil
		case .dataMissingCell: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableColumn.Preparer {
	class Storage: AssociatedBinderStorage {
		let tableColumn: NSTableColumn
		let cellConstructor: ((_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti&lt;RowData&gt;) -&gt; TableCellViewConvertible)?
		let cellIdentifier: ((RowData?) -&gt; NSUserInterfaceItemIdentifier)?
		let dataMissingCell: (() -&gt; TableCellViewConvertible?)?

		var sortFunction: ((_ isRow: RowData, _ orderedBefore: RowData) -&gt; Bool)?

		init(tableColumn: NSTableColumn, cellConstructor: ((_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti&lt;RowData&gt;) -&gt; TableCellViewConvertible)?, cellIdentifier: ((RowData?) -&gt; NSUserInterfaceItemIdentifier)?, dataMissingCell: (() -&gt; TableCellViewConvertible?)?) {
			self.tableColumn = tableColumn
			self.cellConstructor = cellConstructor
			self.cellIdentifier = cellIdentifier
			self.dataMissingCell = dataMissingCell
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableColumnBinding {
	typealias TableColumnName&lt;V&gt; = BindingName&lt;V, TableColumn&lt;Binding.RowDataType&gt;.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; TableColumn&lt;Binding.RowDataType&gt;.Binding) -&gt; TableColumnName&lt;V&gt; {
		return TableColumnName&lt;V&gt;(source: source, downcast: Binding.tableColumnBinding)
	}
}
extension BindingName where Binding: TableColumnBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableColumnName&lt;$2&gt; { return .name(TableColumn.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var identifier: TableColumnName&lt;Constant&lt;NSUserInterfaceItemIdentifier&gt;&gt; { return .name(TableColumn.Binding.identifier) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var headerCell: TableColumnName&lt;Dynamic&lt;NSTableHeaderCell&gt;&gt; { return .name(TableColumn.Binding.headerCell) }
	static var headerToolTip: TableColumnName&lt;Dynamic&lt;String?&gt;&gt; { return .name(TableColumn.Binding.headerToolTip) }
	static var isEditable: TableColumnName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableColumn.Binding.isEditable) }
	static var isHidden: TableColumnName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableColumn.Binding.isHidden) }
	static var maxWidth: TableColumnName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(TableColumn.Binding.maxWidth) }
	static var minWidth: TableColumnName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(TableColumn.Binding.minWidth) }
	static var resizingMask: TableColumnName&lt;Dynamic&lt;NSTableColumn.ResizingOptions&gt;&gt; { return .name(TableColumn.Binding.resizingMask) }
	static var sortDescriptorPrototype: TableColumnName&lt;Dynamic&lt;NSSortDescriptor?&gt;&gt; { return .name(TableColumn.Binding.sortDescriptorPrototype) }
	static var sortFunction: TableColumnName&lt;Dynamic&lt;(_ isRow: Binding.RowDataType, _ orderedBefore: Binding.RowDataType) -&gt; Bool&gt;&gt; { return .name(TableColumn.Binding.sortFunction) }
	static var title: TableColumnName&lt;Dynamic&lt;String&gt;&gt; { return .name(TableColumn.Binding.title) }
	static var width: TableColumnName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(TableColumn.Binding.width) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var sizeToFit: TableColumnName&lt;Signal&lt;Void&gt;&gt; { return .name(TableColumn.Binding.sizeToFit) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var cellConstructor: TableColumnName&lt;(_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti&lt;Binding.RowDataType&gt;) -&gt; TableCellViewConvertible&gt; { return .name(TableColumn.Binding.cellConstructor) }
	static var cellIdentifierForRow: TableColumnName&lt;(Binding.RowDataType?) -&gt; NSUserInterfaceItemIdentifier&gt; { return .name(TableColumn.Binding.cellIdentifierForRow) }
	static var dataMissingCell: TableColumnName&lt;() -&gt; TableCellViewConvertible?&gt; { return .name(TableColumn.Binding.dataMissingCell) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)

// MARK: - Binder Part 8: Downcast protocols
protocol TableColumnBinding: BinderBaseBinding {
	associatedtype RowDataType
	static func tableColumnBinding(_ binding: TableColumn&lt;RowDataType&gt;.Binding) -&gt; Self
	func asTableColumnBinding() -&gt; TableColumn&lt;RowDataType&gt;.Binding?
}
extension TableColumnBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return tableColumnBinding(.inheritedBinding(binding))
	}
}
extension TableColumnBinding where Preparer.Inherited.Binding: TableColumnBinding, Preparer.Inherited.Binding.RowDataType == RowDataType {
	func asTableColumnBinding() -&gt; TableColumn&lt;RowDataType&gt;.Binding? {
		return asInheritedBinding()?.asTableColumnBinding()
	}
}
extension TableColumn.Binding {
	typealias Preparer = TableColumn.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableColumnBinding() -&gt; TableColumn.Binding? { return self }
	static func tableColumnBinding(_ binding: TableColumn.Binding) -&gt; TableColumn.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class TableHeaderView: Binder, TableHeaderViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TableHeaderView {
	enum Binding: TableHeaderViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension TableHeaderView {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = TableHeaderView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSTableHeaderView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TableHeaderView {
}


// MARK: - Binder Part 5: Storage and Delegate
extension TableHeaderView.Preparer {
	typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableHeaderViewBinding {
	typealias TableHeaderViewName&lt;V&gt; = BindingName&lt;V, TableHeaderView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; TableHeaderView.Binding) -&gt; TableHeaderViewName&lt;V&gt; {
		return TableHeaderViewName&lt;V&gt;(source: source, downcast: Binding.tableHeaderViewBinding)
	}
}
extension BindingName where Binding: TableHeaderViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableHeaderViewName&lt;$2&gt; { return .name(TableHeaderView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TableHeaderViewConvertible: ViewConvertible {
	func nsTableHeaderView() -&gt; TableHeaderView.Instance
}
extension TableHeaderViewConvertible {
	func nsView() -&gt; View.Instance { return nsTableHeaderView() }
}
extension NSTableHeaderView: TableHeaderViewConvertible {
	func nsTableHeaderView() -&gt; TableHeaderView.Instance { return self }
}
extension TableHeaderView {
	func nsTableHeaderView() -&gt; TableHeaderView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TableHeaderViewBinding: ViewBinding {
	static func tableHeaderViewBinding(_ binding: TableHeaderView.Binding) -&gt; Self
	func asTableHeaderViewBinding() -&gt; TableHeaderView.Binding?
}
extension TableHeaderViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return tableHeaderViewBinding(.inheritedBinding(binding))
	}
}
extension TableHeaderViewBinding where Preparer.Inherited.Binding: TableHeaderViewBinding {
	func asTableHeaderViewBinding() -&gt; TableHeaderView.Binding? {
		return asInheritedBinding()?.asTableHeaderViewBinding()
	}
}
extension TableHeaderView.Binding {
	typealias Preparer = TableHeaderView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableHeaderViewBinding() -&gt; TableHeaderView.Binding? { return self }
	static func tableHeaderViewBinding(_ binding: TableHeaderView.Binding) -&gt; TableHeaderView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class TableRowView: Binder, TableRowViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TableRowView {
	enum Binding: TableRowViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundColor(Dynamic&lt;NSColor&gt;)
		case draggingDestinationFeedbackStyle(Dynamic&lt;NSTableView.DraggingDestinationFeedbackStyle&gt;)
		case indentationForDropOperation(Dynamic&lt;CGFloat&gt;)
		case isEmphasized(Dynamic&lt;Bool&gt;)
		case isFloating(Dynamic&lt;Bool&gt;)
		case isGroupRowStyle(Dynamic&lt;Bool&gt;)
		case isSelected(Dynamic&lt;Bool&gt;)
		case isTargetForDropOperation(Dynamic&lt;Bool&gt;)
		case selectionHighlightStyle(Dynamic&lt;NSTableView.SelectionHighlightStyle&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension TableRowView {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = TableRowView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSTableRowView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TableRowView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .draggingDestinationFeedbackStyle(let x): return x.apply(instance) { i, v in i.draggingDestinationFeedbackStyle = v }
		case .indentationForDropOperation(let x): return x.apply(instance) { i, v in i.indentationForDropOperation = v }
		case .isEmphasized(let x): return x.apply(instance) { i, v in i.isEmphasized = v }
		case .isFloating(let x): return x.apply(instance) { i, v in i.isFloating = v }
		case .isGroupRowStyle(let x): return x.apply(instance) { i, v in i.isGroupRowStyle = v }
		case .isSelected(let x): return x.apply(instance) { i, v in i.isSelected = v }
		case .isTargetForDropOperation(let x): return x.apply(instance) { i, v in i.isTargetForDropOperation = v }
		case .selectionHighlightStyle(let x): return x.apply(instance) { i, v in i.selectionHighlightStyle = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableRowView.Preparer {
	typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableRowViewBinding {
	typealias TableRowViewName&lt;V&gt; = BindingName&lt;V, TableRowView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; TableRowView.Binding) -&gt; TableRowViewName&lt;V&gt; {
		return TableRowViewName&lt;V&gt;(source: source, downcast: Binding.tableRowViewBinding)
	}
}
extension BindingName where Binding: TableRowViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableRowViewName&lt;$2&gt; { return .name(TableRowView.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundColor: TableRowViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(TableRowView.Binding.backgroundColor) }
	static var draggingDestinationFeedbackStyle: TableRowViewName&lt;Dynamic&lt;NSTableView.DraggingDestinationFeedbackStyle&gt;&gt; { return .name(TableRowView.Binding.draggingDestinationFeedbackStyle) }
	static var indentationForDropOperation: TableRowViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(TableRowView.Binding.indentationForDropOperation) }
	static var isEmphasized: TableRowViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableRowView.Binding.isEmphasized) }
	static var isFloating: TableRowViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableRowView.Binding.isFloating) }
	static var isGroupRowStyle: TableRowViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableRowView.Binding.isGroupRowStyle) }
	static var isSelected: TableRowViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableRowView.Binding.isSelected) }
	static var isTargetForDropOperation: TableRowViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableRowView.Binding.isTargetForDropOperation) }
	static var selectionHighlightStyle: TableRowViewName&lt;Dynamic&lt;NSTableView.SelectionHighlightStyle&gt;&gt; { return .name(TableRowView.Binding.selectionHighlightStyle) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TableRowViewConvertible: ViewConvertible {
	func nsTableRowView() -&gt; TableRowView.Instance
}
extension TableRowViewConvertible {
	func nsView() -&gt; View.Instance { return nsTableRowView() }
}
extension NSTableRowView: TableRowViewConvertible {
	func nsTableRowView() -&gt; TableRowView.Instance { return self }
}
extension TableRowView {
	func nsTableRowView() -&gt; TableRowView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TableRowViewBinding: ViewBinding {
	static func tableRowViewBinding(_ binding: TableRowView.Binding) -&gt; Self
	func asTableRowViewBinding() -&gt; TableRowView.Binding?
}
extension TableRowViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return tableRowViewBinding(.inheritedBinding(binding))
	}
}
extension TableRowViewBinding where Preparer.Inherited.Binding: TableRowViewBinding {
	func asTableRowViewBinding() -&gt; TableRowView.Binding? {
		return asInheritedBinding()?.asTableRowViewBinding()
	}
}
extension TableRowView.Binding {
	typealias Preparer = TableRowView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableRowViewBinding() -&gt; TableRowView.Binding? { return self }
	static func tableRowViewBinding(_ binding: TableRowView.Binding) -&gt; TableRowView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class TableView&lt;RowData&gt;: Binder, TableViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	static func scrollEmbedded(type: NSTableView.Type = NSTableView.self, _ bindings: Binding...) -&gt; ScrollView {
		return ScrollView(
			.borderType -- .noBorder,
			.hasVerticalScroller -- true,
			.hasHorizontalScroller -- true,
			.autohidesScrollers -- true,
			.contentView -- ClipView(
				.documentView -- TableView&lt;RowData&gt;(type: type, bindings: bindings)
			)
		)
	}
}

// MARK: - Binder Part 2: Binding
extension TableView {
	enum Binding: TableViewBinding {
		typealias RowDataType = RowData
		
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsColumnReordering(Dynamic&lt;Bool&gt;)
		case allowsColumnResizing(Dynamic&lt;Bool&gt;)
		case allowsColumnSelection(Dynamic&lt;Bool&gt;)
		case allowsEmptySelection(Dynamic&lt;Bool&gt;)
		case allowsMultipleSelection(Dynamic&lt;Bool&gt;)
		case allowsTypeSelect(Dynamic&lt;Bool&gt;)
		case autosaveName(Dynamic&lt;NSTableView.AutosaveName?&gt;)
		case autosaveTableColumns(Dynamic&lt;Bool&gt;)
		case backgroundColor(Dynamic&lt;NSColor&gt;)
		case columnAutoresizingStyle(Dynamic&lt;NSTableView.ColumnAutoresizingStyle&gt;)
		case columns(Dynamic&lt;[TableColumn&lt;RowData&gt;]&gt;)
		case cornerView(Dynamic&lt;ViewConvertible?&gt;)
		case draggingDestinationFeedbackStyle(Dynamic&lt;NSTableView.DraggingDestinationFeedbackStyle&gt;)
		case floatsGroupRows(Dynamic&lt;Bool&gt;)
		case gridColor(Dynamic&lt;NSColor&gt;)
		case gridStyleMask(Dynamic&lt;NSTableView.GridLineStyle&gt;)
		case headerView(Dynamic&lt;TableHeaderViewConvertible?&gt;)
		case intercellSpacing(Dynamic&lt;NSSize&gt;)
		case rowHeight(Dynamic&lt;CGFloat&gt;)
		case rows(Dynamic&lt;TableRowAnimatable&lt;RowData&gt;&gt;)
		case rowSizeStyle(Dynamic&lt;NSTableView.RowSizeStyle&gt;)
		case selectionHighlightStyle(Dynamic&lt;NSTableView.SelectionHighlightStyle&gt;)
		case userInterfaceLayoutDirection(Dynamic&lt;NSUserInterfaceLayoutDirection&gt;)
		case usesAlternatingRowBackgroundColors(Dynamic&lt;Bool&gt;)
		case usesAutomaticRowHeights(Dynamic&lt;Bool&gt;)
		case verticalMotionCanBeginDrag(Dynamic&lt;Bool&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case deselectAll(Signal&lt;Void&gt;)
		case deselectColumn(Signal&lt;NSUserInterfaceItemIdentifier&gt;)
		case deselectRow(Signal&lt;Int&gt;)
		case hideRowActions(Signal&lt;Void&gt;)
		case hideRows(Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;)
		case highlightColumn(Signal&lt;NSUserInterfaceItemIdentifier?&gt;)
		case moveColumn(Signal&lt;(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)&gt;)
		case scrollColumnToVisible(Signal&lt;NSUserInterfaceItemIdentifier&gt;)
		case scrollRowToVisible(Signal&lt;Int&gt;)
		case selectAll(Signal&lt;Void&gt;)
		case selectColumns(Signal&lt;(identifiers: Set&lt;NSUserInterfaceItemIdentifier&gt;, byExtendingSelection: Bool)&gt;)
		case selectRows(Signal&lt;(indexes: IndexSet, byExtendingSelection: Bool)&gt;)
		case sizeLastColumnToFit(Signal&lt;Void&gt;)
		case sizeToFit(Signal&lt;Void&gt;)
		case unhideRows(Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;)

		// 3. Action bindings are triggered by the object after construction.
		case columnMoved(SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)&gt;)
		case columnResized(SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)&gt;)
		case doubleAction(TargetAction)
		case visibleRowsChanged(SignalInput&lt;CountableRange&lt;Int&gt;&gt;)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case acceptDrop((_ tableView: NSTableView, _ row: Int, _ data: RowData?) -&gt; Bool)
		case didClickTableColumn((NSTableView, NSTableColumn) -&gt; Void)
		case didDragTableColumn((NSTableView, NSTableColumn) -&gt; Void)
		case draggingSessionEnded((_ tableView: NSTableView, _ session: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -&gt; Void)
		case draggingSessionWillBegin((_ tableView: NSTableView, _ session: NSDraggingSession, _ willBeginAt: NSPoint, _ forRowIndexes: IndexSet) -&gt; Void)
		case groupRowCellConstructor((Int) -&gt; TableCellViewConvertible)
		case heightOfRow((_ tableView: NSTableView, _ row: Int, _ rowData: RowData?) -&gt; CGFloat)
		case isGroupRow((_ tableView: NSTableView, _ row: Int, _ rowData: RowData?) -&gt; Bool)
		case mouseDownInHeaderOfTableColumn((NSTableView, NSTableColumn) -&gt; Void)
		case nextTypeSelectMatch((_ tableView: NSTableView, _ startRow: Int, _ endRow: Int, _ searchString: String) -&gt; Int)
		case pasteboardWriter((_ tableView: NSTableView, _ row: Int, _ data: RowData?) -&gt; NSPasteboardWriting)
		case rowActionsForRow((_ tableView: NSTableView, _ row: Int, _ data: RowData?, _ edge: NSTableView.RowActionEdge) -&gt; [NSTableViewRowAction])
		case rowView((_ tableView: NSTableView, _ row: Int, _ rowData: RowData?) -&gt; TableRowViewConvertible?)
		case selectionDidChange((Notification) -&gt; Void)
		case selectionIndexesForProposedSelection((_ tableView: NSTableView, IndexSet) -&gt; IndexSet)
		case selectionShouldChange((_ tableView: NSTableView) -&gt; Bool)
		case shouldReorderColumn((_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier, _ newIndex: Int) -&gt; Bool)
		case shouldSelectRow((_ tableView: NSTableView, _ row: Int, _ rowData: RowData?) -&gt; Bool)
		case shouldSelectTableColumn((_ tableView: NSTableView, _ column: NSTableColumn?) -&gt; Bool)
		case shouldTypeSelectForEvent((_ tableView: NSTableView, _ event: NSEvent, _ searchString: String?) -&gt; Bool)
		case sizeToFitWidthOfColumn((_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier) -&gt; CGFloat)
		case sortDescriptorsDidChange((NSTableView, [NSSortDescriptor]) -&gt; Void)
		case typeSelectString((_ tableView: NSTableView, _ cell: TableCell&lt;RowData&gt;) -&gt; String?)
		case updateDraggingItems((_ tableView: NSTableView, _ forDrag: NSDraggingInfo) -&gt; Void)
		case validateDrop((_ tableView: NSTableView, _ info: NSDraggingInfo, _ proposedRow: Int, _ proposedDropOperation: NSTableView.DropOperation) -&gt; NSDragOperation)
	}
}

// MARK: - Binder Part 3: Preparer
extension TableView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = TableView.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = NSTableView
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage(visibleRowsChanged: visibleRowsChanged) }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var singleAction: TargetAction?
		var doubleAction: TargetAction?
		var visibleRowsChanged: MultiOutput&lt;CountableRange&lt;Int&gt;&gt;?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TableView.Preparer {
	var delegateIsRequired: Bool { return true }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.action(let x)): singleAction = x
		case .inheritedBinding(let x): inherited.prepareBinding(x)
			
		case .acceptDrop(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDataSource.tableView(_:acceptDrop:row:dropOperation:)))
		case .didDragTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDelegate.tableView(_:didDrag:)))
		case .didClickTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDelegate.tableView(_:didClick:)))
		case .doubleAction(let x): doubleAction = x
		case .draggingSessionEnded(let x): delegate().addMultiHandler4(x, #selector(NSTableViewDataSource.tableView(_:draggingSession:endedAt:operation:)))
		case .draggingSessionWillBegin(let x): delegate().addMultiHandler4(x, #selector(NSTableViewDataSource.tableView(_:draggingSession:willBeginAt:forRowIndexes:)))
		case .heightOfRow(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:heightOfRow:)))
		case .isGroupRow(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:isGroupRow:)))
		case .mouseDownInHeaderOfTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDelegate.tableView(_:mouseDownInHeaderOf:)))
		case .nextTypeSelectMatch(let x): delegate().addSingleHandler4(x, #selector(NSTableViewDelegate.tableView(_:nextTypeSelectMatchFromRow:toRow:for:)))
		case .pasteboardWriter(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDataSource.tableView(_:pasteboardWriterForRow:)))
		case .rowActionsForRow(let x): delegate().addSingleHandler4(x, #selector(NSTableViewDelegate.tableView(_:rowActionsForRow:edge:)))
		case .rowView(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:rowViewForRow:)))
		case .selectionDidChange(let x): delegate().addMultiHandler1(x, #selector(NSTableViewDelegate.tableViewSelectionDidChange(_:)))
		case .selectionIndexesForProposedSelection(let x): delegate().addSingleHandler2(x, #selector(NSTableViewDelegate.tableView(_:selectionIndexesForProposedSelection:)))
		case .selectionShouldChange(let x): delegate().addSingleHandler1(x, #selector(NSTableViewDelegate.selectionShouldChange(in:)))
		case .shouldReorderColumn(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:shouldReorderColumn:toColumn:)))
		case .shouldSelectRow(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:shouldSelectRow:)))
		case .shouldSelectTableColumn(let x): delegate().addSingleHandler2(x, #selector(NSTableViewDelegate.tableView(_:shouldSelect:)))
		case .shouldTypeSelectForEvent(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:shouldTypeSelectFor:withCurrentSearch:)))
		case .sizeToFitWidthOfColumn(let x): delegate().addSingleHandler2(x, #selector(NSTableViewDelegate.tableView(_:sizeToFitWidthOfColumn:)))
		case .sortDescriptorsDidChange(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDataSource.tableView(_:sortDescriptorsDidChange:)))
		case .typeSelectString(let x): delegate().addSingleHandler2(x, #selector(NSTableViewDelegate.tableView(_:typeSelectStringFor:row:)))
		case .updateDraggingItems(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDataSource.tableView(_:updateDraggingItemsForDrag:)))
		case .validateDrop(let x): delegate().addSingleHandler4(x, #selector(NSTableViewDataSource.tableView(_:validateDrop:proposedRow:proposedDropOperation:)))
		case .visibleRowsChanged(let x):
			visibleRowsChanged = visibleRowsChanged ?? Input().multicast()
			visibleRowsChanged?.signal.bind(to: x)
		default: break
		}
	}

	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		instance.dataSource = storage
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(.action): return nil
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsColumnReordering(let x): return x.apply(instance) { i, v in i.allowsColumnReordering = v }
		case .allowsColumnResizing(let x): return x.apply(instance) { i, v in i.allowsColumnResizing = v }
		case .allowsColumnSelection(let x): return x.apply(instance) { i, v in i.allowsColumnSelection = v }
		case .allowsEmptySelection(let x): return x.apply(instance) { i, v in i.allowsEmptySelection = v }
		case .allowsMultipleSelection(let x): return x.apply(instance) { i, v in i.allowsMultipleSelection = v }
		case .allowsTypeSelect(let x): return x.apply(instance) { i, v in i.allowsTypeSelect = v }
		case .autosaveName(let x): return x.apply(instance) { i, v in i.autosaveName = v }
		case .autosaveTableColumns(let x): return x.apply(instance) { i, v in i.autosaveTableColumns = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .columnAutoresizingStyle(let x): return x.apply(instance) { i, v in i.columnAutoresizingStyle = v }
		case .columns(let x): return x.apply(instance, storage) { i, s, v in s.updateColumns(v.map { $0.construct() }, in: i) }
		case .cornerView(let x): return x.apply(instance) { i, v in i.cornerView = v?.nsView() }
		case .draggingDestinationFeedbackStyle(let x): return x.apply(instance) { i, v in i.draggingDestinationFeedbackStyle = v }
		case .floatsGroupRows(let x): return x.apply(instance) { i, v in i.floatsGroupRows = v }
		case .gridColor(let x): return x.apply(instance) { i, v in i.gridColor = v }
		case .gridStyleMask(let x): return x.apply(instance) { i, v in i.gridStyleMask = v }
		case .intercellSpacing(let x): return x.apply(instance) { i, v in i.intercellSpacing = v }
		case .rowHeight(let x): return x.apply(instance) { i, v in i.rowHeight = v }
		case .rowSizeStyle(let x): return x.apply(instance) { i, v in i.rowSizeStyle = v }
		case .selectionHighlightStyle(let x): return x.apply(instance) { i, v in i.selectionHighlightStyle = v }
		case .userInterfaceLayoutDirection(let x): return x.apply(instance) { i, v in i.userInterfaceLayoutDirection = v }
		case .usesAlternatingRowBackgroundColors(let x): return x.apply(instance) { i, v in i.usesAlternatingRowBackgroundColors = v }
		case .usesAutomaticRowHeights(let x): return x.apply(instance) { i, v in i.usesAutomaticRowHeights = v }
		case .verticalMotionCanBeginDrag(let x): return x.apply(instance) { i, v in i.verticalMotionCanBeginDrag = v }

		// 2. Signal bindings are performed on the object after construction.
		case .deselectAll(let x): return x.apply(instance) { i, v in i.deselectAll(nil) }
		case .deselectColumn(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v })?.offset {
					i.deselectColumn(index)
				}
			}
		case .deselectRow(let x): return x.apply(instance) { i, v in i.deselectRow(v) }
		case .hideRowActions(let x): return x.apply(instance) { i, v in i.rowActionsVisible = false }
		case .hideRows(let x): return x.apply(instance) { i, v in i.hideRows(at: v.indexes, withAnimation: v.withAnimation) }
		case .highlightColumn(let x):
			return x.apply(instance) { i, v in
				i.highlightedTableColumn = v.flatMap { (identifier: NSUserInterfaceItemIdentifier) -&gt; NSTableColumn? in
					return i.tableColumns.first(where: { $0.identifier == identifier })
				}
			}
		case .moveColumn(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v.identifier })?.offset {
					i.moveColumn(index, toColumn: v.toIndex)
				}
			}
		case .scrollRowToVisible(let x): return x.apply(instance) { i, v in i.scrollRowToVisible(v) }
		case .scrollColumnToVisible(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v })?.offset {
					i.scrollColumnToVisible(index)
				}
			}
		case .selectAll(let x): return x.apply(instance) { i, v in i.selectAll(nil) }
		case .selectColumns(let x):
			return x.apply(instance) { i, v in
				let indexes = v.identifiers.compactMap { identifier in i.tableColumns.enumerated().first(where: { $0.element.identifier == identifier })?.offset }
				let indexSet = IndexSet(indexes)
				i.selectColumnIndexes(indexSet, byExtendingSelection: v.byExtendingSelection)
			}
		case .selectRows(let x): return x.apply(instance) { i, v in i.selectRowIndexes(v.indexes, byExtendingSelection: v.byExtendingSelection) }
		case .sizeLastColumnToFit(let x): return x.apply(instance) { i, v in i.sizeLastColumnToFit() }
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }
		case .unhideRows(let x): return x.apply(instance) { i, v in i.unhideRows(at: v.indexes, withAnimation: v.withAnimation) }

		// 3. Action bindings are triggered by the object after construction.
		case .columnMoved(let x):
			return Signal.notifications(name: NSTableView.columnDidMoveNotification, object: instance).compactMap { [weak instance] notification -&gt; (column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)? in
				guard let index = (notification.userInfo?["NSNewColumn"] as? NSNumber)?.intValue, let column = instance?.tableColumns.at(index) else {
					return nil
				}
				guard let oldIndex = (notification.userInfo?["NSNewColumn"] as? NSNumber)?.intValue else {
					return nil
				}
				return (column: column.identifier, oldIndex: oldIndex, newIndex: index)
			}.cancellableBind(to: x)
		case .columnResized(let x):
			return Signal.notifications(name: NSTableView.columnDidResizeNotification, object: instance).compactMap { notification -&gt; (column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)? in
				guard let column = (notification.userInfo?["NSTableColumn"] as? NSTableColumn) else {
					return nil
				}
				guard let oldWidth = (notification.userInfo?["NSOldWidth"] as? NSNumber)?.doubleValue else {
					return nil
				}
				return (column: column.identifier, oldWidth: CGFloat(oldWidth), newWidth: column.width)
			}.cancellableBind(to: x)
		case .doubleAction: return nil
		case .visibleRowsChanged: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .acceptDrop: return nil
		case .didClickTableColumn: return nil
		case .didDragTableColumn: return nil
		case .draggingSessionEnded: return nil
		case .draggingSessionWillBegin: return nil
		case .groupRowCellConstructor(let x):
			storage.groupRowCellConstructor = x
			return nil
		case .headerView(let x): return x.apply(instance) { i, v in i.headerView = v?.nsTableHeaderView() }
		case .heightOfRow: return nil
		case .isGroupRow: return nil
		case .mouseDownInHeaderOfTableColumn: return nil
		case .nextTypeSelectMatch: return nil
		case .pasteboardWriter: return nil
		case .rowActionsForRow: return nil
		case .rows(let x): return x.apply(instance, storage) { i, s, v in s.applyRowAnimation(v, in: i) }
		case .rowView: return nil
		case .selectionDidChange: return nil
		case .selectionIndexesForProposedSelection: return nil
		case .selectionShouldChange: return nil
		case .shouldReorderColumn: return nil
		case .shouldSelectRow: return nil
		case .shouldSelectTableColumn: return nil
		case .shouldTypeSelectForEvent: return nil
		case .sizeToFitWidthOfColumn: return nil
		case .sortDescriptorsDidChange: return nil
		case .typeSelectString: return nil
		case .updateDraggingItems: return nil
		case .validateDrop: return nil
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime? {
		var lifetimes = [Lifetime]()
		
		switch (singleAction, doubleAction) {
		case (nil, nil): break
		case (.firstResponder(let sa)?, .firstResponder(let da)?):
			instance.action = sa
			instance.doubleAction = da
			instance.target = nil
		case (.singleTarget(let st)?, .singleTarget(let dt)?):
			let target = SignalDoubleActionTarget()
			instance.target = target 
			lifetimes += target.signal.cancellableBind(to: st)
			lifetimes += target.signal.cancellableBind(to: dt)
			instance.action = SignalDoubleActionTarget.selector
			instance.doubleAction = SignalDoubleActionTarget.secondSelector
		case (let s?, nil):
			lifetimes += s.apply(to: instance, constructTarget: SignalActionTarget.init)
		case (nil, let d?):
			lifetimes += d.apply(to: instance, constructTarget: SignalActionTarget.init)
			instance.doubleAction = instance.action
			instance.action = nil
		case (.some, .some): fatalError("Action and double action may not use mix of single target and first responder")
		}
		
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableView.Preparer {
	class Storage: View.Preparer.Storage, NSTableViewDelegate, NSTableViewDataSource {
		let visibleRowsChanged: MultiOutput&lt;CountableRange&lt;Int&gt;&gt;?

		var actionTarget: SignalDoubleActionTarget? = nil
		var rowState: TableRowState&lt;RowData&gt; = TableRowState&lt;RowData&gt;()
		var visibleRows: IndexSet = []
		var groupRowCellConstructor: ((Int) -&gt; TableCellViewConvertible)?
		var columns: [TableColumn&lt;RowData&gt;.Preparer.Storage] = []
		
		init(visibleRowsChanged: MultiOutput&lt;CountableRange&lt;Int&gt;&gt;?) {
			self.visibleRowsChanged = visibleRowsChanged
		}
		
		override var isInUse: Bool { return true }
		
		fileprivate func rowData(at row: Int) -&gt; RowData? {
			return rowState.values?.at(row)
		}
		
		func columnForIdentifier(_ identifier: NSUserInterfaceItemIdentifier) -&gt; (offset: Int, element: TableColumn&lt;RowData&gt;.Preparer.Storage)? {
			return columns.enumerated().first { (tuple: (offset: Int, element: TableColumn&lt;RowData&gt;.Preparer.Storage)) -&gt; Bool in
				tuple.element.tableColumn.identifier == identifier
			}
		}
		
		func numberOfRows(in tableView: NSTableView) -&gt; Int {
			return rowState.globalCount
		}

		func tableView(_ tableView: NSTableView, didAdd: NSTableRowView, forRow: Int) {
			DispatchQueue.main.async {
				if let vrsi = self.visibleRowsChanged?.input {
					let previousMin = self.visibleRows.min() ?? 0
					let previousMax = self.visibleRows.max() ?? previousMin
					self.visibleRows.insert(forRow)
					let newMin = self.visibleRows.min() ?? 0
					let newMax = self.visibleRows.max() ?? newMin
					if previousMin != newMin || previousMax != newMax {
						vrsi.send(value: newMin..&lt;newMax)
					}
				}
			}
		}
		
		func tableView(_ tableView: NSTableView, didRemove: NSTableRowView, forRow: Int) {
			DispatchQueue.main.async {
				if let vrsi = self.visibleRowsChanged?.input {
					let previousMin = self.visibleRows.min() ?? 0
					let previousMax = self.visibleRows.max() ?? previousMin
					self.visibleRows.remove(forRow)
					let newMin = self.visibleRows.min() ?? 0
					let newMax = self.visibleRows.max() ?? newMin
					if previousMin != newMin || previousMax != newMax {
						vrsi.send(value: newMin..&lt;newMax)
					}
				}
			}
		}

		func tableView(_ tableView: NSTableView, objectValueFor tableColumn: NSTableColumn?, row: Int) -&gt; Any? {
			return nil
		}
		
		func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -&gt; NSView? {
			if let tc = tableColumn {
				if let col = columnForIdentifier(tc.identifier) {
					let data = rowState.values?.at(row - rowState.localOffset)
					let identifier = col.element.cellIdentifier?(data) ?? tc.identifier

					let cellView: NSTableCellView
					let cellInput: SignalInput&lt;RowData&gt;?
					if let reusedView = tableView.makeView(withIdentifier: identifier, owner: tableView), let downcast = reusedView as? NSTableCellView {
						cellView = downcast
						cellInput = cellView.associatedRowInput(valueType: RowData.self)
					} else if let cc = col.element.cellConstructor {
						let dataTuple = Signal&lt;RowData&gt;.create()
						let constructed = cc(identifier, dataTuple.signal.multicast()).nsTableCellView()
						if constructed.identifier == nil {
							constructed.identifier = identifier
						}
						cellView = constructed
						cellInput = dataTuple.input
						cellView.setAssociatedRowInput(to: dataTuple.input)
					} else {
						return col.element.dataMissingCell?()?.nsTableCellView()
					}
					
					if let d = data {
						_ = cellInput?.send(value: d)
					}
					return cellView
				}
			} else {
				return groupRowCellConstructor?(row).nsTableCellView()
			}
			return nil
		}

		func updateColumns(_ v: [TableColumn&lt;RowData&gt;.Preparer.Storage], in tableView: NSTableView) {
			columns = v
			let columnsArray = v.map { $0.tableColumn }
			let newColumnSet = Set(columnsArray)
			let oldColumnSet = Set(tableView.tableColumns)
			
			for c in columnsArray {
				if !oldColumnSet.contains(c) {
					tableView.addTableColumn(c)
				}
				if !newColumnSet.contains(c) {
					tableView.removeTableColumn(c)
				}
			}
		}

		func applyRowAnimation(_ rowAnimation: TableRowAnimatable&lt;RowData&gt;, in tableView: NSTableView) {
			rowAnimation.value.apply(toSubrange: &amp;rowState)
			rowAnimation.value.updateMetadata(&amp;rowState)
			
			let animation = rowAnimation.animation ?? []
			let indices = rowAnimation.value.indexSet.offset(by: rowState.localOffset)

			switch rowAnimation.value.kind {
			case .delete:
				tableView.removeRows(at: indices, withAnimation: animation)
			case .move(let destination):
				tableView.beginUpdates()
				for (count, index) in indices.enumerated() {
					tableView.moveRow(at: index, to: destination + count)
				}
				tableView.endUpdates()
			case .insert:
				tableView.insertRows(at: indices, withAnimation: animation)
			case .scroll:
				tableView.reloadData(forRowIndexes: indices, columnIndexes: IndexSet(integersIn: 0..&lt;tableView.tableColumns.count))
			case .update:
				tableView.beginUpdates()
				for rowIndex in indices {
					for columnIndex in 0..&lt;tableView.numberOfColumns {
						guard let cell = tableView.view(atColumn: columnIndex, row: rowIndex, makeIfNecessary: false) as? NSTableCellView, let value = rowState.values?.at(rowIndex - rowState.localOffset) else { continue }
						cell.associatedRowInput(valueType: RowData.self)?.send(value: value)
					}
				}
				tableView.endUpdates()
			case .reload:
				tableView.reloadData()
			}
		}
	}

	class Delegate: DynamicDelegate, NSTableViewDelegate, NSTableViewDataSource {
		private func storage(for tableView: NSTableView) -&gt; Storage? {
			return tableView.delegate as? Storage
		}
		
		func tableView(_ tableView: NSTableView, didDrag tableColumn: NSTableColumn) {
			multiHandler(tableView, tableColumn)
		}

		func tableView(_ tableView: NSTableView, didClick tableColumn: NSTableColumn) {
			multiHandler(tableView, tableColumn)
		}

		func tableView(_ tableView: NSTableView, mouseDownInHeaderOf tableColumn: NSTableColumn) {
			multiHandler(tableView, tableColumn)
		}

		func tableView(_ tableView: NSTableView, rowViewForRow rowIndex: Int) -&gt; NSTableRowView? {
			return (singleHandler(rowIndex, storage(for: tableView)?.rowData(at: rowIndex)) as TableRowViewConvertible?)?.nsTableRowView()
		}

		func tableView(_ tableView: NSTableView, shouldReorderColumn columnIndex: Int, toColumn newColumnIndex: Int) -&gt; Bool {
			if let column = tableView.tableColumns.at(columnIndex) {
				return singleHandler(tableView, column.identifier, newColumnIndex)
			}
			return false
		}

		func tableView(_ tableView: NSTableView, sizeToFitWidthOfColumn column: Int) -&gt; CGFloat {
			if let column = tableView.tableColumns.at(column) {
				return singleHandler(tableView, column.identifier)
			}
			return 0
		}

		func tableView(_ tableView: NSTableView, shouldTypeSelectFor event: NSEvent, withCurrentSearch searchString: String?) -&gt; Bool {
			return singleHandler(tableView, event, searchString)
		}

		func tableView(_ tableView: NSTableView, typeSelectStringFor tableColumn: NSTableColumn?, row: Int) -&gt; String? {
			guard let tc = tableColumn, row &gt;= 0 else { return nil }
			return singleHandler(TableCell&lt;RowData&gt;(row: row, column: tc, tableView: tableView))
		}

		func tableView(_ tableView: NSTableView, nextTypeSelectMatchFromRow startRow: Int, toRow endRow: Int, for searchString: String) -&gt; Int {
			return singleHandler(tableView, startRow, endRow, searchString)
		}

		func tableView(_ tableView: NSTableView, heightOfRow rowIndex: Int) -&gt; CGFloat {
			return singleHandler(rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}

		func tableView(_ tableView: NSTableView, shouldSelect tableColumn: NSTableColumn?) -&gt; Bool {
			return singleHandler(tableView, tableColumn)
		}

		func tableView(_ tableView: NSTableView, selectionIndexesForProposedSelection proposedSelectionIndexes: IndexSet) -&gt; IndexSet {
			return singleHandler(tableView, proposedSelectionIndexes)
		}

		func tableView(_ tableView: NSTableView, shouldSelectRow rowIndex: Int) -&gt; Bool {
			return singleHandler(rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}

		func selectionShouldChange(in tableView: NSTableView) -&gt; Bool {
			return singleHandler(tableView)
		}

		func tableView(_ tableView: NSTableView, isGroupRow rowIndex: Int) -&gt; Bool {
			return singleHandler(rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}

		func tableView(_ tableView: NSTableView, sortDescriptorsDidChange oldDescriptors: [NSSortDescriptor]) {
			multiHandler(tableView, oldDescriptors)
		}

		func tableView(_ tableView: NSTableView, pasteboardWriterForRow rowIndex: Int) -&gt; NSPasteboardWriting? {
			return singleHandler(tableView, rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}
		
		func tableViewSelectionDidChange(_ notification: Notification) {
			multiHandler(notification)
		}
		
		func tableView(_ tableView: NSTableView, acceptDrop info: NSDraggingInfo, row rowIndex: Int, dropOperation: NSTableView.DropOperation) -&gt; Bool {
			return singleHandler(tableView, rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}

		func tableView(_ tableView: NSTableView, validateDrop info: NSDraggingInfo, proposedRow row: Int, proposedDropOperation dropOperation: NSTableView.DropOperation) -&gt; NSDragOperation {
			return singleHandler(tableView, info, row, dropOperation)
		}

		func tableView(_ tableView: NSTableView, draggingSession session: NSDraggingSession, willBeginAt screenPoint: NSPoint, forRowIndexes rowIndexes: IndexSet) {
			return singleHandler(tableView, session, screenPoint, rowIndexes)
		}

		func tableView(_ tableView: NSTableView, updateDraggingItemsForDrag draggingInfo: NSDraggingInfo) {
			return singleHandler(tableView, draggingInfo)
		}

		func tableView(_ tableView: NSTableView, draggingSession session: NSDraggingSession, endedAt screenPoint: NSPoint, operation: NSDragOperation) {
			return singleHandler(tableView, session, screenPoint, operation)
		}

		func tableView(_ tableView: NSTableView, rowActionsForRow row: Int, edge: NSTableView.RowActionEdge) -&gt; [NSTableViewRowAction] {
			return singleHandler(tableView, row, edge)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableViewBinding {
	typealias TableViewName&lt;V&gt; = BindingName&lt;V, TableView&lt;Binding.RowDataType&gt;.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; TableView&lt;Binding.RowDataType&gt;.Binding) -&gt; TableViewName&lt;V&gt; {
		return TableViewName&lt;V&gt;(source: source, downcast: Binding.tableViewBinding)
	}
}
extension BindingName where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableViewName&lt;$2&gt; { return .name(TableView.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsColumnReordering: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.allowsColumnReordering) }
	static var allowsColumnResizing: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.allowsColumnResizing) }
	static var allowsColumnSelection: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.allowsColumnSelection) }
	static var allowsEmptySelection: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.allowsEmptySelection) }
	static var allowsMultipleSelection: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.allowsMultipleSelection) }
	static var allowsTypeSelect: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.allowsTypeSelect) }
	static var autosaveName: TableViewName&lt;Dynamic&lt;NSTableView.AutosaveName?&gt;&gt; { return .name(TableView.Binding.autosaveName) }
	static var autosaveTableColumns: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.autosaveTableColumns) }
	static var backgroundColor: TableViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(TableView.Binding.backgroundColor) }
	static var columnAutoresizingStyle: TableViewName&lt;Dynamic&lt;NSTableView.ColumnAutoresizingStyle&gt;&gt; { return .name(TableView.Binding.columnAutoresizingStyle) }
	static var columns: TableViewName&lt;Dynamic&lt;[TableColumn&lt;Binding.RowDataType&gt;]&gt;&gt; { return .name(TableView.Binding.columns) }
	static var cornerView: TableViewName&lt;Dynamic&lt;ViewConvertible?&gt;&gt; { return .name(TableView.Binding.cornerView) }
	static var draggingDestinationFeedbackStyle: TableViewName&lt;Dynamic&lt;NSTableView.DraggingDestinationFeedbackStyle&gt;&gt; { return .name(TableView.Binding.draggingDestinationFeedbackStyle) }
	static var floatsGroupRows: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.floatsGroupRows) }
	static var gridColor: TableViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(TableView.Binding.gridColor) }
	static var gridStyleMask: TableViewName&lt;Dynamic&lt;NSTableView.GridLineStyle&gt;&gt; { return .name(TableView.Binding.gridStyleMask) }
	static var headerView: TableViewName&lt;Dynamic&lt;TableHeaderViewConvertible?&gt;&gt; { return .name(TableView.Binding.headerView) }
	static var intercellSpacing: TableViewName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(TableView.Binding.intercellSpacing) }
	static var rowHeight: TableViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(TableView.Binding.rowHeight) }
	static var rows: TableViewName&lt;Dynamic&lt;TableRowAnimatable&lt;Binding.RowDataType&gt;&gt;&gt; { return .name(TableView.Binding.rows) }
	static var rowSizeStyle: TableViewName&lt;Dynamic&lt;NSTableView.RowSizeStyle&gt;&gt; { return .name(TableView.Binding.rowSizeStyle) }
	static var selectionHighlightStyle: TableViewName&lt;Dynamic&lt;NSTableView.SelectionHighlightStyle&gt;&gt; { return .name(TableView.Binding.selectionHighlightStyle) }
	static var userInterfaceLayoutDirection: TableViewName&lt;Dynamic&lt;NSUserInterfaceLayoutDirection&gt;&gt; { return .name(TableView.Binding.userInterfaceLayoutDirection) }
	static var usesAlternatingRowBackgroundColors: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.usesAlternatingRowBackgroundColors) }
	static var usesAutomaticRowHeights: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.usesAutomaticRowHeights) }
	static var verticalMotionCanBeginDrag: TableViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TableView.Binding.verticalMotionCanBeginDrag) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var deselectAll: TableViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TableView.Binding.deselectAll) }
	static var deselectColumn: TableViewName&lt;Signal&lt;NSUserInterfaceItemIdentifier&gt;&gt; { return .name(TableView.Binding.deselectColumn) }
	static var deselectRow: TableViewName&lt;Signal&lt;Int&gt;&gt; { return .name(TableView.Binding.deselectRow) }
	static var hideRowActions: TableViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TableView.Binding.hideRowActions) }
	static var hideRows: TableViewName&lt;Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;&gt; { return .name(TableView.Binding.hideRows) }
	static var highlightColumn: TableViewName&lt;Signal&lt;NSUserInterfaceItemIdentifier?&gt;&gt; { return .name(TableView.Binding.highlightColumn) }
	static var moveColumn: TableViewName&lt;Signal&lt;(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)&gt;&gt; { return .name(TableView.Binding.moveColumn) }
	static var scrollColumnToVisible: TableViewName&lt;Signal&lt;NSUserInterfaceItemIdentifier&gt;&gt; { return .name(TableView.Binding.scrollColumnToVisible) }
	static var scrollRowToVisible: TableViewName&lt;Signal&lt;Int&gt;&gt; { return .name(TableView.Binding.scrollRowToVisible) }
	static var selectAll: TableViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TableView.Binding.selectAll) }
	static var selectColumns: TableViewName&lt;Signal&lt;(identifiers: Set&lt;NSUserInterfaceItemIdentifier&gt;, byExtendingSelection: Bool)&gt;&gt; { return .name(TableView.Binding.selectColumns) }
	static var selectRows: TableViewName&lt;Signal&lt;(indexes: IndexSet, byExtendingSelection: Bool)&gt;&gt; { return .name(TableView.Binding.selectRows) }
	static var sizeLastColumnToFit: TableViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TableView.Binding.sizeLastColumnToFit) }
	static var sizeToFit: TableViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TableView.Binding.sizeToFit) }
	static var unhideRows: TableViewName&lt;Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;&gt; { return .name(TableView.Binding.unhideRows) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var columnMoved: TableViewName&lt;SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)&gt;&gt; { return .name(TableView.Binding.columnMoved) }
	static var columnResized: TableViewName&lt;SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)&gt;&gt; { return .name(TableView.Binding.columnResized) }
	static var doubleAction: TableViewName&lt;TargetAction&gt; { return .name(TableView.Binding.doubleAction) }
	static var visibleRowsChanged: TableViewName&lt;SignalInput&lt;CountableRange&lt;Int&gt;&gt;&gt; { return .name(TableView.Binding.visibleRowsChanged) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var acceptDrop: TableViewName&lt;(_ tableView: NSTableView, _ row: Int, _ data: Binding.RowDataType?) -&gt; Bool&gt; { return .name(TableView.Binding.acceptDrop) }
	static var didClickTableColumn: TableViewName&lt;(NSTableView, NSTableColumn) -&gt; Void&gt; { return .name(TableView.Binding.didClickTableColumn) }
	static var didDragTableColumn: TableViewName&lt;(NSTableView, NSTableColumn) -&gt; Void&gt; { return .name(TableView.Binding.didDragTableColumn) }
	static var draggingSessionEnded: TableViewName&lt;(_ tableView: NSTableView, _ session: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -&gt; Void&gt; { return .name(TableView.Binding.draggingSessionEnded) }
	static var draggingSessionWillBegin: TableViewName&lt;(_ tableView: NSTableView, _ session: NSDraggingSession, _ willBeginAt: NSPoint, _ forRowIndexes: IndexSet) -&gt; Void&gt; { return .name(TableView.Binding.draggingSessionWillBegin) }
	static var groupRowCellConstructor: TableViewName&lt;(Int) -&gt; TableCellViewConvertible&gt; { return .name(TableView.Binding.groupRowCellConstructor) }
	static var heightOfRow: TableViewName&lt;(_ tableView: NSTableView, _ row: Int, _ rowData: Binding.RowDataType?) -&gt; CGFloat&gt; { return .name(TableView.Binding.heightOfRow) }
	static var isGroupRow: TableViewName&lt;(_ tableView: NSTableView, _ row: Int, _ rowData: Binding.RowDataType?) -&gt; Bool&gt; { return .name(TableView.Binding.isGroupRow) }
	static var mouseDownInHeaderOfTableColumn: TableViewName&lt;(NSTableView, NSTableColumn) -&gt; Void&gt; { return .name(TableView.Binding.mouseDownInHeaderOfTableColumn) }
	static var nextTypeSelectMatch: TableViewName&lt;(_ tableView: NSTableView, _ startRow: Int, _ endRow: Int, _ searchString: String) -&gt; Int&gt; { return .name(TableView.Binding.nextTypeSelectMatch) }
	static var pasteboardWriter: TableViewName&lt;(_ tableView: NSTableView, _ row: Int, _ data: Binding.RowDataType?) -&gt; NSPasteboardWriting&gt; { return .name(TableView.Binding.pasteboardWriter) }
	static var rowActionsForRow: TableViewName&lt;(_ tableView: NSTableView, _ row: Int, _ data: Binding.RowDataType?, _ edge: NSTableView.RowActionEdge) -&gt; [NSTableViewRowAction]&gt; { return .name(TableView.Binding.rowActionsForRow) }
	static var rowView: TableViewName&lt;(_ tableView: NSTableView, _ row: Int, _ rowData: Binding.RowDataType?) -&gt; TableRowViewConvertible?&gt; { return .name(TableView.Binding.rowView) }
	static var selectionDidChange: TableViewName&lt;(Notification) -&gt; Void&gt; { return .name(TableView.Binding.selectionDidChange) }
	static var selectionIndexesForProposedSelection: TableViewName&lt;(_ tableView: NSTableView, IndexSet) -&gt; IndexSet&gt; { return .name(TableView.Binding.selectionIndexesForProposedSelection) }
	static var selectionShouldChange: TableViewName&lt;(_ tableView: NSTableView) -&gt; Bool&gt; { return .name(TableView.Binding.selectionShouldChange) }
	static var shouldReorderColumn: TableViewName&lt;(_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier, _ newIndex: Int) -&gt; Bool&gt; { return .name(TableView.Binding.shouldReorderColumn) }
	static var shouldSelectRow: TableViewName&lt;(_ tableView: NSTableView, _ row: Int, _ rowData: Binding.RowDataType?) -&gt; Bool&gt; { return .name(TableView.Binding.shouldSelectRow) }
	static var shouldSelectTableColumn: TableViewName&lt;(_ tableView: NSTableView, _ column: NSTableColumn?) -&gt; Bool&gt; { return .name(TableView.Binding.shouldSelectTableColumn) }
	static var shouldTypeSelectForEvent: TableViewName&lt;(_ tableView: NSTableView, _ event: NSEvent, _ searchString: String?) -&gt; Bool&gt; { return .name(TableView.Binding.shouldTypeSelectForEvent) }
	static var sizeToFitWidthOfColumn: TableViewName&lt;(_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier) -&gt; CGFloat&gt; { return .name(TableView.Binding.sizeToFitWidthOfColumn) }
	static var sortDescriptorsDidChange: TableViewName&lt;(NSTableView, [NSSortDescriptor]) -&gt; Void&gt; { return .name(TableView.Binding.sortDescriptorsDidChange) }
	static var typeSelectString: TableViewName&lt;(_ tableView: NSTableView, _ cell: TableCell&lt;Binding.RowDataType&gt;) -&gt; String?&gt; { return .name(TableView.Binding.typeSelectString) }
	static var updateDraggingItems: TableViewName&lt;(_ tableView: NSTableView, _ forDrag: NSDraggingInfo) -&gt; Void&gt; { return .name(TableView.Binding.updateDraggingItems) }
	static var validateDrop: TableViewName&lt;(_ tableView: NSTableView, _ info: NSDraggingInfo, _ proposedRow: Int, _ proposedDropOperation: NSTableView.DropOperation) -&gt; NSDragOperation&gt; { return .name(TableView.Binding.validateDrop) }

	// Composite binding names
	static func doubleAction&lt;Value&gt;(_ keyPath: KeyPath&lt;Binding.Preparer.Instance, Value&gt;) -&gt; TableViewName&lt;SignalInput&lt;Value&gt;&gt; {
		return Binding.keyPathActionName(keyPath, TableView.Binding.doubleAction, Binding.tableViewBinding)
	}
	static func cellSelected&lt;Value&gt;(_ keyPath: KeyPath&lt;TableCell&lt;Binding.RowDataType&gt;, Value&gt;) -&gt; TableViewName&lt;SignalInput&lt;Value?&gt;&gt; {
		return Binding.compositeName(
			value: { (input: SignalInput&lt;Value?&gt;) in
				{ (notification: Notification) -&gt; Void in
					guard let view = (notification.object as? NSTableView) else { return }
					let cell = TableCell&lt;Binding.RowDataType&gt;(row: view.selectedRow, column: view.selectedColumn, tableView: view)
					let value = cell?[keyPath: keyPath]
					_ = input.send(value: value)
				}
			},
			binding: TableView.Binding.selectionDidChange,
			downcast: Binding.tableViewBinding
		)
	}
	static func cellSelected(_ void: Void = ()) -&gt; TableViewName&lt;SignalInput&lt;TableCell&lt;Binding.RowDataType&gt;?&gt;&gt; {
		return Binding.compositeName(
			value: { (input: SignalInput&lt;TableCell&lt;Binding.RowDataType&gt;?&gt;) in
				{ (notification: Notification) -&gt; Void in
					guard let view = (notification.object as? NSTableView) else { return }
					let cell = TableCell&lt;Binding.RowDataType&gt;(row: view.selectedRow, column: view.selectedColumn, tableView: view)
					_ = input.send(value: cell)
				}
			},
			binding: TableView.Binding.selectionDidChange,
			downcast: Binding.tableViewBinding
		)
	}
	static func selectRow(_ void: Void = ()) -&gt; TableViewName&lt;Signal&lt;Int?&gt;&gt; {
		return Binding.compositeName(
			value:
				{ (input: Signal&lt;Int?&gt;) in
					return input.map {
						$0.map { (indexes: IndexSet(integer: $0), byExtendingSelection: false) } ?? (indexes: IndexSet(), byExtendingSelection: false)
					}
				},
			binding: TableView.Binding.selectRows,
			downcast: Binding.tableViewBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TableViewConvertible: ControlConvertible {
	func nsTableView() -&gt; NSTableView
}
extension NSTableView: TableViewConvertible, HasDelegate {
	func nsTableView() -&gt; NSTableView { return self }
}
extension TableViewConvertible {
	func nsControl() -&gt; Control.Instance { return nsTableView() }
}
extension TableView {
	func nsTableView() -&gt; NSTableView { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TableViewBinding: ControlBinding {
	associatedtype RowDataType
	static func tableViewBinding(_ binding: TableView&lt;RowDataType&gt;.Binding) -&gt; Self
	func asTableViewBinding() -&gt; TableView&lt;RowDataType&gt;.Binding?
}
extension TableViewBinding {
	static func controlBinding(_ binding: Control.Binding) -&gt; Self {
		return tableViewBinding(.inheritedBinding(binding))
	}
}
extension TableViewBinding where Preparer.Inherited.Binding: TableViewBinding, Preparer.Inherited.Binding.RowDataType == RowDataType {
	func asTableViewBinding() -&gt; TableView&lt;RowDataType&gt;.Binding? {
		return asInheritedBinding()?.asTableViewBinding()
	}
}
extension TableView.Binding {
	typealias Preparer = TableView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableViewBinding() -&gt; TableView.Binding? { return self }
	static func tableViewBinding(_ binding: TableView&lt;RowDataType&gt;.Binding) -&gt; TableView&lt;RowDataType&gt;.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
typealias TableRowMutation&lt;Element&gt; = SubrangeMutation&lt;Element, ()&gt;
typealias TableRowAnimatable&lt;Element&gt; = Animatable&lt;TableRowMutation&lt;Element&gt;, NSTableView.AnimationOptions&gt;

typealias TableRowState&lt;Element&gt; = SubrangeState&lt;Element, ()&gt;

struct TableCell&lt;RowData&gt; {
	let row: Int?
	let column: Int?
	let columnIdentifier: NSUserInterfaceItemIdentifier?
	let data: RowData?
	
	init?(row: Int, column: Int, tableView: NSTableView) {
		guard row &gt;= 0 || column &gt;= 0 else {
			return nil
		}
		self.row = row &gt; 0 ? row : nil
		self.column = column &gt; 0 ? column : nil
		self.columnIdentifier = tableView.tableColumns.at(column)?.identifier
		self.data = (tableView.delegate as? TableView&lt;RowData&gt;.Preparer.Storage)?.rowData(at: row)
	}
	
	init?(row: Int, column: NSTableColumn, tableView: NSTableView) {
		self.init(row: row, column: tableView.column(withIdentifier: column.identifier), tableView: tableView)
	}
}

extension Sequence {
	func tableData() -&gt; TableRowAnimatable&lt;Element&gt; {
		return .set(.reload(Array(self)))
	}
}

extension Signal {
	func tableData&lt;RowData&gt;(_ choice: AnimationChoice = .subsequent) -&gt; Signal&lt;TableRowAnimatable&lt;RowData&gt;&gt; where IndexedMutation&lt;RowData, ()&gt; == OutputValue {
		return map(initialState: false) { (alreadyReceived: inout Bool, rowMutation: OutputValue) -&gt; TableRowAnimatable&lt;RowData&gt; in
			if alreadyReceived || choice == .always {
				return .animate(TableRowMutation(kind: rowMutation.kind, metadata: nil, indexSet: rowMutation.indexSet, values: rowMutation.values), animation: .effectFade)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(TableRowMutation(kind: rowMutation.kind, metadata: nil, indexSet: rowMutation.indexSet, values: rowMutation.values))
			}
		}
	}

	func tableData&lt;RowData&gt;(_ choice: AnimationChoice = .subsequent) -&gt; Signal&lt;TableRowAnimatable&lt;RowData&gt;&gt; where TableRowMutation&lt;RowData&gt; == OutputValue {
		return map(initialState: false) { (alreadyReceived: inout Bool, rowMutation: OutputValue) -&gt; TableRowAnimatable&lt;RowData&gt; in
			if alreadyReceived || choice == .always {
				return .animate(rowMutation, animation: .effectFade)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(rowMutation)
			}
		}
	}
}

extension Adapter where State == VarState&lt;Int?&gt; {
	func updateFirstRow() -&gt; SignalInput&lt;CountableRange&lt;Int&gt;&gt; {
		return Input().map { $0.first }.bind(to: update())
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class TextField: Binder, TextFieldConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	static var labelBindings: [Binding] {
		return [
			.isEditable -- false,
			.isSelectable -- true,
			.isBordered -- false,
			.drawsBackground -- false
		]
	}
	
	static var wrappingLabelBindings: [Binding] {
		return [
			.isEditable -- false,
			.isSelectable -- true,
			.isBordered -- false,
			.drawsBackground -- false,
			.lineBreakMode -- .byWordWrapping,
			.horizontalContentCompressionResistancePriority -- .defaultLow
		]
	}
	
	static func label(type: Instance.Type = Instance.self, _ bindings: Binding...) -&gt; TextField {
		return TextField(type: type, parameters: (), bindings: TextField.labelBindings + bindings)
	}
	
	static func wrappingLabel(type: Instance.Type = Instance.self, _ bindings: Binding...) -&gt; TextField {
		return TextField(type: type, parameters: (), bindings: TextField.wrappingLabelBindings + bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension TextField {
	enum Binding: TextFieldBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsCharacterPickerTouchBarItem(Dynamic&lt;Bool&gt;)
		case allowsDefaultTighteningForTruncation(Dynamic&lt;Bool&gt;)
		case allowsEditingTextAttributes(Dynamic&lt;Bool&gt;)
		case allowsUndo(Dynamic&lt;Bool&gt;)
		case backgroundColor(Dynamic&lt;NSColor?&gt;)
		case bezelStyle(Dynamic&lt;NSTextField.BezelStyle&gt;)
		case drawsBackground(Dynamic&lt;Bool&gt;)
		case importsGraphics(Dynamic&lt;Bool&gt;)
		case isAutomaticTextCompletionEnabled(Dynamic&lt;Bool&gt;)
		case isBezeled(Dynamic&lt;Bool&gt;)
		case isBordered(Dynamic&lt;Bool&gt;)
		case isEditable(Dynamic&lt;Bool&gt;)
		case isSelectable(Dynamic&lt;Bool&gt;)
		case maximumNumberOfLines(Dynamic&lt;Int&gt;)
		case placeholderAttributedString(Dynamic&lt;NSAttributedString?&gt;)
		case placeholderString(Dynamic&lt;String?&gt;)
		case preferredMaxLayoutWidth(Dynamic&lt;CGFloat&gt;)
		case sendsActionOnEndEditing(Dynamic&lt;Bool&gt;)
		case textColor(Dynamic&lt;NSColor?&gt;)
		case usesSingleLineMode(Dynamic&lt;Bool&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case selectText(Signal&lt;Void&gt;)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case completions((_ control: NSTextField, _ textView: NSTextView, _ completions: [String], _ partialWordRange: NSRange, _ indexOfSelectedItem: UnsafeMutablePointer&lt;Int&gt;) -&gt; [String])
		case didFailToFormatString((_ control: NSTextField, _ string: String, _ errorDescription: String?) -&gt; Bool)
		case didFailToValidatePartialString((_ control: NSTextField, _ partialString: String, _ errorDescription: String?) -&gt; Void)
		case doCommand((_ control: NSTextField, _ textView: NSText, _ doCommandBySelector: Selector) -&gt; Bool)
		case isValidObject((_ control: NSTextField, _ object: AnyObject) -&gt; Bool)
		case shouldBeginEditing((_ control: NSTextField, _ text: NSText) -&gt; Bool)
		case shouldEndEditing((_ control: NSTextField, _ text: NSText) -&gt; Bool)
	}
}

// MARK: - Binder Part 3: Preparer
extension TextField {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = TextField.Binding
		typealias Inherited = Control.Preparer
		typealias Instance = NSTextField
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TextField.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .completions(let x): delegate().addSingleHandler5(x, #selector(NSTextFieldDelegate.control(_:textView:completions:forPartialWordRange:indexOfSelectedItem:)))
		case .didFailToFormatString(let x): delegate().addSingleHandler3(x, #selector(NSTextFieldDelegate.control(_:didFailToFormatString:errorDescription:)))
		case .didFailToValidatePartialString(let x): delegate().addMultiHandler3(x, #selector(NSTextFieldDelegate.control(_:didFailToValidatePartialString:errorDescription:)))
		case .doCommand(let x): delegate().addSingleHandler3(x, #selector(NSTextFieldDelegate.control(_:textView:doCommandBy:)))
		case .isValidObject(let x): delegate().addSingleHandler2(x, #selector(NSTextFieldDelegate.control(_:isValidObject:)))
		case .shouldBeginEditing(let x): delegate().addSingleHandler2(x, #selector(NSTextFieldDelegate.control(_:textShouldBeginEditing:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler2(x, #selector(NSTextFieldDelegate.control(_:textShouldEndEditing:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .allowsCharacterPickerTouchBarItem(let x): return x.apply(instance) { i, v in i.allowsCharacterPickerTouchBarItem = v }
		case .allowsDefaultTighteningForTruncation(let x): return x.apply(instance) { i, v in i.allowsDefaultTighteningForTruncation = v }
		case .allowsEditingTextAttributes(let x): return x.apply(instance) { i, v in i.allowsEditingTextAttributes = v }
		case .allowsUndo(let x): return x.apply(instance) { i, v in i.cell?.allowsUndo = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .isBezeled(let x): return x.apply(instance) { i, v in i.isBezeled = v }
		case .bezelStyle(let x): return x.apply(instance) { i, v in i.bezelStyle = v }
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .importsGraphics(let x): return x.apply(instance) { i, v in i.importsGraphics = v }
		case .isAutomaticTextCompletionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticTextCompletionEnabled = v }
		case .isBordered(let x): return x.apply(instance) { i, v in i.isBordered = v }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .isSelectable(let x): return x.apply(instance) { i, v in i.isSelectable = v }
		case .maximumNumberOfLines(let x): return x.apply(instance) { i, v in i.maximumNumberOfLines = v }
		case .placeholderAttributedString(let x): return x.apply(instance) { i, v in i.placeholderAttributedString = v }
		case .placeholderString(let x): return x.apply(instance) { i, v in i.placeholderString = v }
		case .preferredMaxLayoutWidth(let x): return x.apply(instance) { i, v in i.preferredMaxLayoutWidth = v }
		case .sendsActionOnEndEditing(let x): return x.apply(instance) { i, v in i.cell?.sendsActionOnEndEditing = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		case .usesSingleLineMode(let x): return x.apply(instance) { i, v in i.usesSingleLineMode = v }

		// 2. Signal bindings are performed on the object after construction.
		case .selectText(let x): return x.apply(instance) { i, v in i.selectText(nil) }

		// 3. Action bindings are triggered by the object after construction.
		case .didFailToValidatePartialString: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .completions: return nil
		case .didFailToFormatString: return nil
		case .doCommand: return nil
		case .isValidObject: return nil
		case .shouldBeginEditing: return nil
		case .shouldEndEditing: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TextField.Preparer {
	class Storage: Control.Preparer.Storage, NSTextFieldDelegate {}

	class Delegate: DynamicDelegate, NSTextFieldDelegate {
		func control(_ control: NSControl, isValidObject obj: Any?) -&gt; Bool {
			return singleHandler(control as! NSTextField, obj as AnyObject)
		}
		
		func control(_ control: NSControl, didFailToValidatePartialString string: String, errorDescription error: String?) {
			multiHandler(control, string, error)
		}
		
		func control(_ control: NSControl, didFailToFormatString string: String, errorDescription error: String?) -&gt; Bool {
			return singleHandler(control as! NSTextField, string, error)
		}
		
		func control(_ control: NSControl, textShouldBeginEditing fieldEditor: NSText) -&gt; Bool {
			return singleHandler(control as! NSTextField, fieldEditor)
		}
		
		func control(_ control: NSControl, textShouldEndEditing fieldEditor: NSText) -&gt; Bool {
			return singleHandler(control as! NSTextField, fieldEditor)
		}
		
		func control(_ control: NSControl, textView: NSTextView, completions words: [String], forPartialWordRange charRange: NSRange, indexOfSelectedItem index: UnsafeMutablePointer&lt;Int&gt;) -&gt; [String] {
			return singleHandler(control as! NSTextField, textView, words, charRange, index)
		}
		
		func control(_ control: NSControl, textView: NSTextView, doCommandBy doCommandBySelector: Selector) -&gt; Bool {
			return singleHandler(control as! NSTextField, textView, doCommandBySelector)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TextFieldBinding {
	typealias TextFieldName&lt;V&gt; = BindingName&lt;V, TextField.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; TextField.Binding) -&gt; TextFieldName&lt;V&gt; {
		return TextFieldName&lt;V&gt;(source: source, downcast: Binding.textFieldBinding)
	}
}
extension BindingName where Binding: TextFieldBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TextFieldName&lt;$2&gt; { return .name(TextField.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsCharacterPickerTouchBarItem: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.allowsCharacterPickerTouchBarItem) }
	static var allowsDefaultTighteningForTruncation: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.allowsDefaultTighteningForTruncation) }
	static var allowsEditingTextAttributes: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.allowsEditingTextAttributes) }
	static var allowsUndo: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.allowsUndo) }
	static var backgroundColor: TextFieldName&lt;Dynamic&lt;NSColor?&gt;&gt; { return .name(TextField.Binding.backgroundColor) }
	static var isBezeled: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.isBezeled) }
	static var bezelStyle: TextFieldName&lt;Dynamic&lt;NSTextField.BezelStyle&gt;&gt; { return .name(TextField.Binding.bezelStyle) }
	static var drawsBackground: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.drawsBackground) }
	static var importsGraphics: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.importsGraphics) }
	static var isAutomaticTextCompletionEnabled: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.isAutomaticTextCompletionEnabled) }
	static var isBordered: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.isBordered) }
	static var isEditable: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.isEditable) }
	static var isSelectable: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.isSelectable) }
	static var maximumNumberOfLines: TextFieldName&lt;Dynamic&lt;Int&gt;&gt; { return .name(TextField.Binding.maximumNumberOfLines) }
	static var placeholderAttributedString: TextFieldName&lt;Dynamic&lt;NSAttributedString?&gt;&gt; { return .name(TextField.Binding.placeholderAttributedString) }
	static var placeholderString: TextFieldName&lt;Dynamic&lt;String?&gt;&gt; { return .name(TextField.Binding.placeholderString) }
	static var preferredMaxLayoutWidth: TextFieldName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(TextField.Binding.preferredMaxLayoutWidth) }
	static var sendsActionOnEndEditing: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.sendsActionOnEndEditing) }
	static var textColor: TextFieldName&lt;Dynamic&lt;NSColor?&gt;&gt; { return .name(TextField.Binding.textColor) }
	static var usesSingleLineMode: TextFieldName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextField.Binding.usesSingleLineMode) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectText: TextFieldName&lt;Signal&lt;Void&gt;&gt; { return .name(TextField.Binding.selectText) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var completions: TextFieldName&lt;(_ control: NSTextField, _ textView: NSTextView, _ completions: [String], _ partialWordRange: NSRange, _ indexOfSelectedItem: UnsafeMutablePointer&lt;Int&gt;) -&gt; [String]&gt; { return .name(TextField.Binding.completions) }
	static var didFailToFormatString: TextFieldName&lt;(_ control: NSTextField, _ string: String, _ errorDescription: String?) -&gt; Bool&gt; { return .name(TextField.Binding.didFailToFormatString) }
	static var didFailToValidatePartialString: TextFieldName&lt;(_ control: NSTextField, _ partialString: String, _ errorDescription: String?) -&gt; Void&gt; { return .name(TextField.Binding.didFailToValidatePartialString) }
	static var doCommand: TextFieldName&lt;(_ control: NSTextField, _ textView: NSText, _ doCommandBySelector: Selector) -&gt; Bool&gt; { return .name(TextField.Binding.doCommand) }
	static var isValidObject: TextFieldName&lt;(_ control: NSTextField, _ object: AnyObject) -&gt; Bool&gt; { return .name(TextField.Binding.isValidObject) }
	static var shouldBeginEditing: TextFieldName&lt;(_ control: NSTextField, _ text: NSText) -&gt; Bool&gt; { return .name(TextField.Binding.shouldBeginEditing) }
	static var shouldEndEditing: TextFieldName&lt;(_ control: NSTextField, _ text: NSText) -&gt; Bool&gt; { return .name(TextField.Binding.shouldEndEditing) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TextFieldConvertible: ControlConvertible {
	func nsTextField() -&gt; TextField.Instance
}
extension TextFieldConvertible {
	func nsControl() -&gt; Control.Instance { return nsTextField() }
}
extension NSTextField: TextFieldConvertible, HasDelegate {
	func nsTextField() -&gt; TextField.Instance { return self }
}
extension TextField {
	func nsTextField() -&gt; TextField.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TextFieldBinding: ControlBinding {
	static func textFieldBinding(_ binding: TextField.Binding) -&gt; Self
	func asTextFieldBinding() -&gt; TextField.Binding?
}
extension TextFieldBinding {
	static func controlBinding(_ binding: Control.Binding) -&gt; Self {
		return textFieldBinding(.inheritedBinding(binding))
	}
}
extension TextFieldBinding where Preparer.Inherited.Binding: TextFieldBinding {
	func asTextFieldBinding() -&gt; TextField.Binding? {
		return asInheritedBinding()?.asTextFieldBinding()
	}
}
extension TextField.Binding {
	typealias Preparer = TextField.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTextFieldBinding() -&gt; TextField.Binding? { return self }
	static func textFieldBinding(_ binding: TextField.Binding) -&gt; TextField.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class TextView: Binder, TextViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	static func scrollEmbedded(type: NSTextView.Type = NSTextView.self, _ bindings: Binding...) -&gt; ScrollView {
		return ScrollView(
			.borderType -- .noBorder,
			.hasVerticalScroller -- true,
			.hasHorizontalScroller -- true,
			.autohidesScrollers -- true,
			.contentView -- ClipView(
				.documentView -- TextView(type: type, bindings: bindings)
			)
		)
	}
}

// MARK: - Binder Part 2: Binding
extension TextView {
	enum Binding: TextViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case string(Dynamic&lt;String&gt;)
		case backgroundColor(Dynamic&lt;NSColor&gt;)
		case drawsBackground(Dynamic&lt;Bool&gt;)
		case isEditable(Dynamic&lt;Bool&gt;)
		case isSelectable(Dynamic&lt;Bool&gt;)
		case isFieldEditor(Dynamic&lt;Bool&gt;)
		case isRichText(Dynamic&lt;Bool&gt;)
		case importsGraphics(Dynamic&lt;Bool&gt;)
		case usesFontPanel(Dynamic&lt;Bool&gt;)
		case font(Dynamic&lt;NSFont&gt;)
		case alignment(Dynamic&lt;NSTextAlignment&gt;)
		case textColor(Dynamic&lt;NSColor&gt;)
		case baseWritingDirection(Dynamic&lt;NSWritingDirection&gt;)
		case maxSize(Dynamic&lt;NSSize&gt;)
		case minSize(Dynamic&lt;NSSize&gt;)
		case isVerticallyResizable(Dynamic&lt;Bool&gt;)
		case isHorizontallyResizable(Dynamic&lt;Bool&gt;)
		
		case textContainerInset(Dynamic&lt;NSSize&gt;)
		case allowsDocumentBackgroundColorChange(Dynamic&lt;Bool&gt;)
		case allowsUndo(Dynamic&lt;Bool&gt;)
		case defaultParagraphStyle(Dynamic&lt;NSParagraphStyle&gt;)
		case allowsImageEditing(Dynamic&lt;Bool&gt;)
		case isAutomaticQuoteSubstitutionEnabled(Dynamic&lt;Bool&gt;)
		case isAutomaticLinkDetectionEnabled(Dynamic&lt;Bool&gt;)
		case displaysLinkToolTips(Dynamic&lt;Bool&gt;)
		case usesRuler(Dynamic&lt;Bool&gt;)
		case usesInspectorBar(Dynamic&lt;Bool&gt;)
		case selectionGranularity(Dynamic&lt;NSSelectionGranularity&gt;)
		case insertionPointColor(Dynamic&lt;NSColor&gt;)
		case selectedTextAttributes(Dynamic&lt;[NSAttributedString.Key : Any]&gt;)
		case markedTextAttributes(Dynamic&lt;[NSAttributedString.Key : Any]&gt;)
		case linkTextAttributes(Dynamic&lt;[NSAttributedString.Key : Any]&gt;)
		case typingAttributes(Dynamic&lt;[NSAttributedString.Key : Any]&gt;)
		case isContinuousSpellCheckingEnabled(Dynamic&lt;Bool&gt;)
		case isGrammarCheckingEnabled(Dynamic&lt;Bool&gt;)
		case usesFindPanel(Dynamic&lt;Bool&gt;)
		case enabledTextCheckingTypes(Dynamic&lt;NSTextCheckingTypes&gt;)
		case isAutomaticDashSubstitutionEnabled(Dynamic&lt;Bool&gt;)
		case isAutomaticDataDetectionEnabled(Dynamic&lt;Bool&gt;)
		case isAutomaticSpellingCorrectionEnabled(Dynamic&lt;Bool&gt;)
		case isAutomaticTextReplacementEnabled(Dynamic&lt;Bool&gt;)
		case layoutOrientation(Dynamic&lt;NSLayoutManager.TextLayoutOrientation&gt;)
		case usesFindBar(Dynamic&lt;Bool&gt;)
		case isIncrementalSearchingEnabled(Dynamic&lt;Bool&gt;)
		case allowsCharacterPickerTouchBarItem(Dynamic&lt;Bool&gt;)
		case isAutomaticTextCompletionEnabled(Dynamic&lt;Bool&gt;)
		case usesRolloverButtonForSelection(Dynamic&lt;Bool&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case selectRange(Signal&lt;NSRange&gt;)
		case selectAll(Signal&lt;Void&gt;)
		case copy(Signal&lt;Void&gt;)
		case cut(Signal&lt;Void&gt;)
		case paste(Signal&lt;Void&gt;)
		case copyFont(Signal&lt;Void&gt;)
		case pasteFont(Signal&lt;Void&gt;)
		case copyRuler(Signal&lt;Void&gt;)
		case pasteRuler(Signal&lt;Void&gt;)
		case delete(Signal&lt;Void&gt;)
		case changeFont(Signal&lt;Void&gt;)
		case alignCenter(Signal&lt;Void&gt;)
		case alignLeft(Signal&lt;Void&gt;)
		case alignRight(Signal&lt;Void&gt;)
		case superscript(Signal&lt;Void&gt;)
		case `subscript`(Signal&lt;Void&gt;)
		case unscript(Signal&lt;Void&gt;)
		case underline(Signal&lt;Void&gt;)
		case checkSpelling(Signal&lt;Void&gt;)
		case showGuessPanel(Signal&lt;Void&gt;)
		case sizeToFit(Signal&lt;Void&gt;)
		case scrollRangeToVisible(Signal&lt;NSRange&gt;)

		case showFindIndicator(Signal&lt;NSRange&gt;)
		case changeDocumentBackgroundColor(Signal&lt;Void&gt;)
		case outline(Signal&lt;Void&gt;)
		case alignJustified(Signal&lt;Void&gt;)
		case changeAttributes(Signal&lt;Void&gt;)
		case useStandardKerning(Signal&lt;Void&gt;)
		case lowerBaseline(Signal&lt;Void&gt;)
		case raiseBaseline(Signal&lt;Void&gt;)
		case turnOffKerning(Signal&lt;Void&gt;)
		case loosenKerning(Signal&lt;Void&gt;)
		case tightenKerning(Signal&lt;Void&gt;)
		case useStandardLigatures(Signal&lt;Void&gt;)
		case turnOffLigatures(Signal&lt;Void&gt;)
		case useAllLigatures(Signal&lt;Void&gt;)
		case clicked(Signal&lt;(Any, Int)&gt;)
		case pasteAsPlainText(Signal&lt;Void&gt;)
		case pasteAsRichText(Signal&lt;Void&gt;)
		case breakUndoCoalescing(Signal&lt;Void&gt;)
		case setSpellingState(Signal&lt;(NSAttributedString.SpellingState, NSRange)&gt;)
		case orderFrontSharingServicePicker(Signal&lt;Void&gt;)
		case startSpeaking(Signal&lt;Void&gt;)
		case stopSpeaking(Signal&lt;Void&gt;)
		case performFindPanelAction(Signal&lt;Void&gt;)
		case orderFrontLinkPanel(Signal&lt;Void&gt;)
		case orderFrontListPanel(Signal&lt;Void&gt;)
		case orderFrontSpacingPanel(Signal&lt;Void&gt;)
		case orderFrontTablePanel(Signal&lt;Void&gt;)
		case orderFrontSubstitutionsPanel(Signal&lt;Void&gt;)
		case complete(Signal&lt;Void&gt;)
		case checkTextInDocument(Signal&lt;Void&gt;)
		case checkTextInSelection(Signal&lt;Void&gt;)
		case checkText(Signal&lt;(NSRange, NSTextCheckingTypes, [NSSpellChecker.OptionKey: Any])&gt;)
		case updateQuickLookPreviewPanel(Signal&lt;Void&gt;)
		case toggleQuickLookPreviewPanel(Signal&lt;Void&gt;)
		case updateCandidates(Signal&lt;Void&gt;)
		case updateTextTouchBarItems(Signal&lt;Void&gt;)
		case updateTouchBarItemIdentifiers(Signal&lt;Void&gt;)

		// 3. Action bindings are triggered by the object after construction.
		case didBeginEditing(SignalInput&lt;NSTextView&gt;)
		case didChange(SignalInput&lt;NSTextView&gt;)
		case didEndEditing(SignalInput&lt;(NSTextView, NSTextMovement?)&gt;)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBeginEditing((NSTextView) -&gt; Bool)
		case shouldEndEditing((NSTextView) -&gt; Bool)
	}
}

// MARK: - Binder Part 3: Preparer
extension TextView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = TextView.Binding
		typealias Inherited = View.Preparer
		typealias Instance = NSTextView
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension TextView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .shouldBeginEditing(let x): delegate().addSingleHandler1(x, #selector(NSTextViewDelegate.textShouldBeginEditing(_:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler1(x, #selector(NSTextViewDelegate.textShouldEndEditing(_:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		// 0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .string(let x): return x.apply(instance) { i, v in i.string = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .isSelectable(let x): return x.apply(instance) { i, v in i.isSelectable = v }
		case .isFieldEditor(let x): return x.apply(instance) { i, v in i.isFieldEditor = v }
		case .isRichText(let x): return x.apply(instance) { i, v in i.isRichText = v }
		case .importsGraphics(let x): return x.apply(instance) { i, v in i.importsGraphics = v }
		case .usesFontPanel(let x): return x.apply(instance) { i, v in i.usesFontPanel = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .alignment(let x): return x.apply(instance) { i, v in i.alignment = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		case .baseWritingDirection(let x): return x.apply(instance) { i, v in i.baseWritingDirection = v }
		case .maxSize(let x): return x.apply(instance) { i, v in i.maxSize = v }
		case .minSize(let x): return x.apply(instance) { i, v in i.minSize = v }
		case .isVerticallyResizable(let x): return x.apply(instance) { i, v in i.isVerticallyResizable = v }
		case .isHorizontallyResizable(let x): return x.apply(instance) { i, v in i.isHorizontallyResizable = v }

		case .textContainerInset(let x): return x.apply(instance) { i, v in i.textContainerInset = v }
		case .allowsDocumentBackgroundColorChange(let x): return x.apply(instance) { i, v in i.allowsDocumentBackgroundColorChange = v }
		case .allowsUndo(let x): return x.apply(instance) { i, v in i.allowsUndo = v }
		case .defaultParagraphStyle(let x): return x.apply(instance) { i, v in i.defaultParagraphStyle = v }
		case .allowsImageEditing(let x): return x.apply(instance) { i, v in i.allowsImageEditing = v }
		case .isAutomaticQuoteSubstitutionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticQuoteSubstitutionEnabled = v }
		case .isAutomaticLinkDetectionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticLinkDetectionEnabled = v }
		case .displaysLinkToolTips(let x): return x.apply(instance) { i, v in i.displaysLinkToolTips = v }
		case .usesRuler(let x): return x.apply(instance) { i, v in i.usesRuler = v }
		case .usesInspectorBar(let x): return x.apply(instance) { i, v in i.usesInspectorBar = v }
		case .selectionGranularity(let x): return x.apply(instance) { i, v in i.selectionGranularity = v }
		case .insertionPointColor(let x): return x.apply(instance) { i, v in i.insertionPointColor = v }
		case .selectedTextAttributes(let x): return x.apply(instance) { i, v in i.selectedTextAttributes = v }
		case .markedTextAttributes(let x): return x.apply(instance) { i, v in i.markedTextAttributes = v }
		case .linkTextAttributes(let x): return x.apply(instance) { i, v in i.linkTextAttributes = v }
		case .typingAttributes(let x): return x.apply(instance) { i, v in i.typingAttributes = v }
		case .isContinuousSpellCheckingEnabled(let x): return x.apply(instance) { i, v in i.isContinuousSpellCheckingEnabled = v }
		case .isGrammarCheckingEnabled(let x): return x.apply(instance) { i, v in i.isGrammarCheckingEnabled = v }
		case .usesFindPanel(let x): return x.apply(instance) { i, v in i.usesFindPanel = v }
		case .enabledTextCheckingTypes(let x): return x.apply(instance) { i, v in i.enabledTextCheckingTypes = v }
		case .isAutomaticDashSubstitutionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticDashSubstitutionEnabled = v }
		case .isAutomaticDataDetectionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticDataDetectionEnabled = v }
		case .isAutomaticSpellingCorrectionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticSpellingCorrectionEnabled = v }
		case .isAutomaticTextReplacementEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticTextReplacementEnabled = v }
		case .layoutOrientation(let x): return x.apply(instance) { i, v in i.setLayoutOrientation(v) }
		case .usesFindBar(let x): return x.apply(instance) { i, v in i.usesFindBar = v }
		case .isIncrementalSearchingEnabled(let x): return x.apply(instance) { i, v in i.isIncrementalSearchingEnabled = v }
		case .allowsCharacterPickerTouchBarItem(let x): return x.apply(instance) { i, v in i.allowsCharacterPickerTouchBarItem = v }
		case .isAutomaticTextCompletionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticTextCompletionEnabled = v }
		case .usesRolloverButtonForSelection(let x): return x.apply(instance) { i, v in i.usesRolloverButtonForSelection = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .selectRange(let x): return x.apply(instance) { i, v in i.selectedRange = v }
		case .selectAll(let x): return x.apply(instance) { i, v in i.selectAll(nil) }
		case .copy(let x): return x.apply(instance) { i, v in i.copy(nil) }
		case .cut(let x): return x.apply(instance) { i, v in i.cut(nil) }
		case .paste(let x): return x.apply(instance) { i, v in i.paste(nil) }
		case .copyFont(let x): return x.apply(instance) { i, v in i.copyFont(nil) }
		case .pasteFont(let x): return x.apply(instance) { i, v in i.pasteFont(nil) }
		case .copyRuler(let x): return x.apply(instance) { i, v in i.copyRuler(nil) }
		case .pasteRuler(let x): return x.apply(instance) { i, v in i.pasteRuler(nil) }
		case .delete(let x): return x.apply(instance) { i, v in i.delete(nil) }
		case .changeFont(let x): return x.apply(instance) { i, v in i.changeFont(nil) }
		case .alignCenter(let x): return x.apply(instance) { i, v in i.alignCenter(nil) }
		case .alignLeft(let x): return x.apply(instance) { i, v in i.alignLeft(nil) }
		case .alignRight(let x): return x.apply(instance) { i, v in i.alignRight(nil) }
		case .superscript(let x): return x.apply(instance) { i, v in i.superscript(nil) }
		case .subscript(let x): return x.apply(instance) { i, v in i.superscript(nil) }
		case .unscript(let x): return x.apply(instance) { i, v in i.unscript(nil) }
		case .underline(let x): return x.apply(instance) { i, v in i.underline(nil) }
		case .checkSpelling(let x): return x.apply(instance) { i, v in i.checkSpelling(nil) }
		case .showGuessPanel(let x): return x.apply(instance) { i, v in i.showGuessPanel(nil) }
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }
		case .scrollRangeToVisible(let x): return x.apply(instance) { i, v in i.scrollRangeToVisible(v) }

		case .showFindIndicator(let x): return x.apply(instance) { i, v in i.showFindIndicator(for: v) }
		case .changeDocumentBackgroundColor(let x): return x.apply(instance) { i, v in i.changeDocumentBackgroundColor(nil) }
		case .outline(let x): return x.apply(instance) { i, v in i.outline(nil) }
		case .alignJustified(let x): return x.apply(instance) { i, v in i.alignJustified(nil) }
		case .changeAttributes(let x): return x.apply(instance) { i, v in i.changeAttributes(nil) }
		case .useStandardKerning(let x): return x.apply(instance) { i, v in i.useStandardKerning(nil) }
		case .lowerBaseline(let x): return x.apply(instance) { i, v in i.lowerBaseline(nil) }
		case .raiseBaseline(let x): return x.apply(instance) { i, v in i.raiseBaseline(nil) }
		case .turnOffKerning(let x): return x.apply(instance) { i, v in i.turnOffKerning(nil) }
		case .loosenKerning(let x): return x.apply(instance) { i, v in i.loosenKerning(nil) }
		case .tightenKerning(let x): return x.apply(instance) { i, v in i.tightenKerning(nil) }
		case .useStandardLigatures(let x): return x.apply(instance) { i, v in i.useStandardLigatures(nil) }
		case .turnOffLigatures(let x): return x.apply(instance) { i, v in i.turnOffLigatures(nil) }
		case .useAllLigatures(let x): return x.apply(instance) { i, v in i.useAllLigatures(nil) }
		case .clicked(let x): return x.apply(instance) { i, v in i.clicked(onLink: v.0, at: v.1) }
		case .pasteAsPlainText(let x): return x.apply(instance) { i, v in i.pasteAsPlainText(nil) }
		case .pasteAsRichText(let x): return x.apply(instance) { i, v in i.pasteAsRichText(nil) }
		case .breakUndoCoalescing(let x): return x.apply(instance) { i, v in i.breakUndoCoalescing() }
		case .setSpellingState(let x): return x.apply(instance) { i, v in i.setSpellingState(v.0.rawValue, range: v.1) }
		case .orderFrontSharingServicePicker(let x): return x.apply(instance) { i, v in i.orderFrontSharingServicePicker(nil) }
		case .startSpeaking(let x): return x.apply(instance) { i, v in i.startSpeaking(nil) }
		case .stopSpeaking(let x): return x.apply(instance) { i, v in i.stopSpeaking(nil) }
		case .performFindPanelAction(let x): return x.apply(instance) { i, v in i.performFindPanelAction(nil) }
		case .orderFrontLinkPanel(let x): return x.apply(instance) { i, v in i.orderFrontLinkPanel(nil) }
		case .orderFrontListPanel(let x): return x.apply(instance) { i, v in i.orderFrontListPanel(nil) }
		case .orderFrontSpacingPanel(let x): return x.apply(instance) { i, v in i.orderFrontSpacingPanel(nil) }
		case .orderFrontTablePanel(let x): return x.apply(instance) { i, v in i.orderFrontTablePanel(nil) }
		case .orderFrontSubstitutionsPanel(let x): return x.apply(instance) { i, v in i.orderFrontSubstitutionsPanel(nil) }
		case .complete(let x): return x.apply(instance) { i, v in i.complete(nil) }
		case .checkTextInDocument(let x): return x.apply(instance) { i, v in i.checkTextInDocument(nil) }
		case .checkTextInSelection(let x): return x.apply(instance) { i, v in i.checkTextInSelection(nil) }
		case .checkText(let x): return x.apply(instance) { i, v in i.checkText(in: v.0, types: v.1, options: v.2) }
		case .updateQuickLookPreviewPanel(let x): return x.apply(instance) { i, v in i.updateQuickLookPreviewPanel() }
		case .toggleQuickLookPreviewPanel(let x): return x.apply(instance) { i, v in i.toggleQuickLookPreviewPanel(nil) }
		case .updateCandidates(let x): return x.apply(instance) { i, v in i.updateCandidates() }
		case .updateTextTouchBarItems(let x): return x.apply(instance) { i, v in i.updateTextTouchBarItems() }
		case .updateTouchBarItemIdentifiers(let x): return x.apply(instance) { i, v in i.updateTouchBarItemIdentifiers() }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didBeginEditing(let x): return Signal.notifications(name: NSTextView.didBeginEditingNotification, object: instance).compactMap { notification -&gt; NSTextView? in notification.object as? NSTextView }.cancellableBind(to: x)
		case .didChange(let x): return Signal.notifications(name: NSTextView.didChangeSelectionNotification, object: instance).compactMap { notification -&gt; NSTextView? in notification.object as? NSTextView }.cancellableBind(to: x)
		case .didEndEditing(let x): return Signal.notifications(name: NSTextView.didEndEditingNotification, object: instance).compactMap { notification -&gt; (NSTextView, NSTextMovement?)? in (notification.object as? NSTextView).map { ($0, notification.userInfo?[NSText.movementUserInfoKey] as? NSTextMovement) } }.cancellableBind(to: x)
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldBeginEditing: return nil
		case .shouldEndEditing: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TextView.Preparer {
	class Storage: View.Preparer.Storage, NSTextViewDelegate {}
	
	class Delegate: DynamicDelegate, NSTextViewDelegate {
		func textShouldBeginEditing(_ textObject: NSText) -&gt; Bool {
			return singleHandler(textObject)
		}
		func textShouldEndEditing(_ textObject: NSText) -&gt; Bool {
			return singleHandler(textObject)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TextViewBinding {
	typealias TextViewName&lt;V&gt; = BindingName&lt;V, TextView.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; TextView.Binding) -&gt; TextViewName&lt;V&gt; {
		return TextViewName&lt;V&gt;(source: source, downcast: Binding.textViewBinding)
	}
}
extension BindingName where Binding: TextViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TextViewName&lt;$2&gt; { return .name(TextView.Binding.$1) }

	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var string: TextViewName&lt;Dynamic&lt;String&gt;&gt; { return .name(TextView.Binding.string) }
	static var backgroundColor: TextViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(TextView.Binding.backgroundColor) }
	static var drawsBackground: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.drawsBackground) }
	static var isEditable: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isEditable) }
	static var isSelectable: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isSelectable) }
	static var isFieldEditor: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isFieldEditor) }
	static var isRichText: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isRichText) }
	static var importsGraphics: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.importsGraphics) }
	static var usesFontPanel: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.usesFontPanel) }
	static var font: TextViewName&lt;Dynamic&lt;NSFont&gt;&gt; { return .name(TextView.Binding.font) }
	static var alignment: TextViewName&lt;Dynamic&lt;NSTextAlignment&gt;&gt; { return .name(TextView.Binding.alignment) }
	static var textColor: TextViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(TextView.Binding.textColor) }
	static var baseWritingDirection: TextViewName&lt;Dynamic&lt;NSWritingDirection&gt;&gt; { return .name(TextView.Binding.baseWritingDirection) }
	static var maxSize: TextViewName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(TextView.Binding.maxSize) }
	static var minSize: TextViewName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(TextView.Binding.minSize) }
	static var isVerticallyResizable: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isVerticallyResizable) }
	static var isHorizontallyResizable: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isHorizontallyResizable) }

	static var textContainerInset: TextViewName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(TextView.Binding.textContainerInset) }
	static var allowsDocumentBackgroundColorChange: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.allowsDocumentBackgroundColorChange) }
	static var allowsUndo: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.allowsUndo) }
	static var defaultParagraphStyle: TextViewName&lt;Dynamic&lt;NSParagraphStyle&gt;&gt; { return .name(TextView.Binding.defaultParagraphStyle) }
	static var allowsImageEditing: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.allowsImageEditing) }
	static var isAutomaticQuoteSubstitutionEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isAutomaticQuoteSubstitutionEnabled) }
	static var isAutomaticLinkDetectionEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isAutomaticLinkDetectionEnabled) }
	static var displaysLinkToolTips: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.displaysLinkToolTips) }
	static var usesRuler: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.usesRuler) }
	static var usesInspectorBar: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.usesInspectorBar) }
	static var selectionGranularity: TextViewName&lt;Dynamic&lt;NSSelectionGranularity&gt;&gt; { return .name(TextView.Binding.selectionGranularity) }
	static var insertionPointColor: TextViewName&lt;Dynamic&lt;NSColor&gt;&gt; { return .name(TextView.Binding.insertionPointColor) }
	static var selectedTextAttributes: TextViewName&lt;Dynamic&lt;[NSAttributedString.Key : Any]&gt;&gt; { return .name(TextView.Binding.selectedTextAttributes) }
	static var markedTextAttributes: TextViewName&lt;Dynamic&lt;[NSAttributedString.Key : Any]&gt;&gt; { return .name(TextView.Binding.markedTextAttributes) }
	static var linkTextAttributes: TextViewName&lt;Dynamic&lt;[NSAttributedString.Key : Any]&gt;&gt; { return .name(TextView.Binding.linkTextAttributes) }
	static var typingAttributes: TextViewName&lt;Dynamic&lt;[NSAttributedString.Key : Any]&gt;&gt; { return .name(TextView.Binding.typingAttributes) }
	static var isContinuousSpellCheckingEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isContinuousSpellCheckingEnabled) }
	static var isGrammarCheckingEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isGrammarCheckingEnabled) }
	static var usesFindPanel: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.usesFindPanel) }
	static var enabledTextCheckingTypes: TextViewName&lt;Dynamic&lt;NSTextCheckingTypes&gt;&gt; { return .name(TextView.Binding.enabledTextCheckingTypes) }
	static var isAutomaticDashSubstitutionEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isAutomaticDashSubstitutionEnabled) }
	static var isAutomaticDataDetectionEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isAutomaticDataDetectionEnabled) }
	static var isAutomaticSpellingCorrectionEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isAutomaticSpellingCorrectionEnabled) }
	static var isAutomaticTextReplacementEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isAutomaticTextReplacementEnabled) }
	static var layoutOrientation: TextViewName&lt;Dynamic&lt;NSLayoutManager.TextLayoutOrientation&gt;&gt; { return .name(TextView.Binding.layoutOrientation) }
	static var usesFindBar: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.usesFindBar) }
	static var isIncrementalSearchingEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isIncrementalSearchingEnabled) }
	static var allowsCharacterPickerTouchBarItem: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.allowsCharacterPickerTouchBarItem) }
	static var isAutomaticTextCompletionEnabled: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.isAutomaticTextCompletionEnabled) }
	static var usesRolloverButtonForSelection: TextViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(TextView.Binding.usesRolloverButtonForSelection) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectRange: TextViewName&lt;Signal&lt;NSRange&gt;&gt; { return .name(TextView.Binding.selectRange) }
	static var selectAll: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.selectAll) }
	static var copy: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.copy) }
	static var cut: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.cut) }
	static var paste: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.paste) }
	static var copyFont: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.copyFont) }
	static var pasteFont: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.pasteFont) }
	static var copyRuler: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.copyRuler) }
	static var pasteRuler: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.pasteRuler) }
	static var delete: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.delete) }
	static var changeFont: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.changeFont) }
	static var alignCenter: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.alignCenter) }
	static var alignLeft: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.alignLeft) }
	static var alignRight: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.alignRight) }
	static var superscript: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.superscript) }
	static var `subscript`: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.`subscript`) }
	static var unscript: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.unscript) }
	static var underline: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.underline) }
	static var checkSpelling: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.checkSpelling) }
	static var showGuessPanel: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.showGuessPanel) }
	static var sizeToFit: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.sizeToFit) }
	static var scrollRangeToVisible: TextViewName&lt;Signal&lt;NSRange&gt;&gt; { return .name(TextView.Binding.scrollRangeToVisible) }

	static var showFindIndicator: TextViewName&lt;Signal&lt;NSRange&gt;&gt; { return .name(TextView.Binding.showFindIndicator) }
	static var changeDocumentBackgroundColor: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.changeDocumentBackgroundColor) }
	static var outline: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.outline) }
	static var alignJustified: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.alignJustified) }
	static var changeAttributes: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.changeAttributes) }
	static var useStandardKerning: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.useStandardKerning) }
	static var lowerBaseline: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.lowerBaseline) }
	static var raiseBaseline: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.raiseBaseline) }
	static var turnOffKerning: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.turnOffKerning) }
	static var loosenKerning: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.loosenKerning) }
	static var tightenKerning: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.tightenKerning) }
	static var useStandardLigatures: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.useStandardLigatures) }
	static var turnOffLigatures: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.turnOffLigatures) }
	static var useAllLigatures: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.useAllLigatures) }
	static var clicked: TextViewName&lt;Signal&lt;(Any, Int)&gt;&gt; { return .name(TextView.Binding.clicked) }
	static var pasteAsPlainText: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.pasteAsPlainText) }
	static var pasteAsRichText: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.pasteAsRichText) }
	static var breakUndoCoalescing: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.breakUndoCoalescing) }
	static var setSpellingState: TextViewName&lt;Signal&lt;(NSAttributedString.SpellingState, NSRange)&gt;&gt; { return .name(TextView.Binding.setSpellingState) }
	static var orderFrontSharingServicePicker: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.orderFrontSharingServicePicker) }
	static var startSpeaking: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.startSpeaking) }
	static var stopSpeaking: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.stopSpeaking) }
	static var performFindPanelAction: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.performFindPanelAction) }
	static var orderFrontLinkPanel: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.orderFrontLinkPanel) }
	static var orderFrontListPanel: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.orderFrontListPanel) }
	static var orderFrontSpacingPanel: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.orderFrontSpacingPanel) }
	static var orderFrontTablePanel: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.orderFrontTablePanel) }
	static var orderFrontSubstitutionsPanel: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.orderFrontSubstitutionsPanel) }
	static var complete: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.complete) }
	static var checkTextInDocument: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.checkTextInDocument) }
	static var checkTextInSelection: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.checkTextInSelection) }
	static var checkText: TextViewName&lt;Signal&lt;(NSRange, NSTextCheckingTypes, [NSSpellChecker.OptionKey: Any])&gt;&gt; { return .name(TextView.Binding.checkText) }
	static var updateQuickLookPreviewPanel: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.updateQuickLookPreviewPanel) }
	static var toggleQuickLookPreviewPanel: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.toggleQuickLookPreviewPanel) }
	static var updateCandidates: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.updateCandidates) }
	static var updateTextTouchBarItems: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.updateTextTouchBarItems) }
	static var updateTouchBarItemIdentifiers: TextViewName&lt;Signal&lt;Void&gt;&gt; { return .name(TextView.Binding.updateTouchBarItemIdentifiers) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBeginEditing: TextViewName&lt;SignalInput&lt;NSTextView&gt;&gt; { return .name(TextView.Binding.didBeginEditing) }
	static var didChange: TextViewName&lt;SignalInput&lt;NSTextView&gt;&gt; { return .name(TextView.Binding.didChange) }
	static var didEndEditing: TextViewName&lt;SignalInput&lt;(NSTextView, NSTextMovement?)&gt;&gt; { return .name(TextView.Binding.didEndEditing) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldBeginEditing: TextViewName&lt;(NSTextView) -&gt; Bool&gt; { return .name(TextView.Binding.shouldBeginEditing) }
	static var shouldEndEditing: TextViewName&lt;(NSTextView) -&gt; Bool&gt; { return .name(TextView.Binding.shouldEndEditing) }
	
	// Composite binding names
	static func font(_ void: Void = ()) -&gt; BindingName&lt;Dynamic&lt;NSFont&gt;, BinderBase.Binding, Binding&gt; {
		return Binding.compositeName(
			value: { (x: Dynamic&lt;NSFont&gt;) -&gt; (Any) -&gt; Lifetime? in
				{ (instance: Any) -&gt; Lifetime? in
					return x.apply(instance as! NSTextView) { (i: NSTextView, v: NSFont) -&gt; Void in
						if (i.textStorage?.length ?? 0) == 0 {
							var attributes = i.typingAttributes
							attributes[NSAttributedString.Key.font] = v
							i.typingAttributes = attributes
						} else {
							i.textStorage?.addAttribute(NSAttributedString.Key.font, value: v, range: NSRange(location: 0, length: i.textStorage?.length ?? 0))
						}
					}
				}
			},
			binding: BinderBase.Binding.adHocFinalize,
			downcast: Binding.binderBaseBinding
		)
	}
	
	static func stringChanged(_ void: Void = ()) -&gt; TextViewName&lt;SignalInput&lt;String&gt;&gt; {
		return Binding.compositeName(
			value: { (input: SignalInput&lt;String&gt;) in Input&lt;NSTextView&gt;().compactMap { $0.string }.bind(to: input) },
			binding: TextView.Binding.didChange,
			downcast: Binding.textViewBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol TextViewConvertible: ViewConvertible {
	func nsTextView() -&gt; TextView.Instance
}
extension TextViewConvertible {
	func nsView() -&gt; View.Instance { return nsTextView() }
}
extension NSTextView: TextViewConvertible, HasDelegate {
	func nsTextView() -&gt; TextView.Instance { return self }
}
extension TextView {
	func nsTextView() -&gt; TextView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol TextViewBinding: ViewBinding {
	static func textViewBinding(_ binding: TextView.Binding) -&gt; Self
	func asTextViewBinding() -&gt; TextView.Binding?
}
extension TextViewBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self {
		return textViewBinding(.inheritedBinding(binding))
	}
}
extension TextViewBinding where Preparer.Inherited.Binding: TextViewBinding {
	func asTextViewBinding() -&gt; TextView.Binding? {
		return asInheritedBinding()?.asTextViewBinding()
	}
}
extension TextView.Binding {
	typealias Preparer = TextView.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTextViewBinding() -&gt; TextView.Binding? { return self }
	static func textViewBinding(_ binding: TextView.Binding) -&gt; TextView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class ToolbarItem: Binder, ToolbarItemConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	convenience init(type: Instance.Type = Instance.self, itemIdentifier: NSToolbarItem.Identifier, _ bindings: Binding...) {
		self.init(type: type, parameters: itemIdentifier, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension ToolbarItem {
	enum Binding: ToolbarItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case image(Dynamic&lt;NSImage?&gt;)
		case isEnabled(Dynamic&lt;Bool&gt;)
		case label(Dynamic&lt;String&gt;)
		case maxSize(Dynamic&lt;NSSize&gt;)
		case menuFormRepresentation(Dynamic&lt;MenuItemConvertible&gt;)
		case minSize(Dynamic&lt;NSSize&gt;)
		case paletteLabel(Dynamic&lt;String&gt;)
		case tag(Dynamic&lt;Int&gt;)
		case toolTip(Dynamic&lt;String?&gt;)
		case view(Dynamic&lt;ViewConvertible?&gt;)
		case visibilityPriority(Dynamic&lt;NSToolbarItem.VisibilityPriority&gt;)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case action(TargetAction)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case validate((NSToolbarItem) -&gt; Bool)
	}
}

// MARK: - Binder Part 3: Preparer
extension ToolbarItem {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = ToolbarItem.Binding
		typealias Inherited = BinderBase
		typealias Instance = NSToolbarItem
		typealias Parameters = NSToolbarItem.Identifier
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var validator: ((NSToolbarItem) -&gt; Bool)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension ToolbarItem.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .validate(let x): validator = x
		default: break
		}
	}

	func constructInstance(type: Instance.Type, parameters: NSToolbarItem.Identifier) -&gt; NSToolbarItem {
		return type.init(itemIdentifier: parameters)
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static styles are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .label(let x): return x.apply(instance) { i, v in i.label = v }
		case .maxSize(let x): return x.apply(instance) { i, v in i.maxSize = v }
		case .menuFormRepresentation(let x): return x.apply(instance) { i, v in i.menuFormRepresentation = v.nsMenuItem() }
		case .minSize(let x): return x.apply(instance) { i, v in i.minSize = v }
		case .paletteLabel(let x): return x.apply(instance) { i, v in i.paletteLabel = v }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .toolTip(let x): return x.apply(instance) { i, v in i.toolTip = v }
		case .view(let x): return x.apply(instance) { i, v in i.view = v?.nsView() }
		case .visibilityPriority(let x): return x.apply(instance) { i, v in i.visibilityPriority = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: ToolbarItemTarget.init)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .validate: return nil
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime? {
		// Need to apply the validator *after* the action exists
		if let v = validator, let target = instance.target as? ToolbarItemTarget {
			target.validator = v
		}
		
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ToolbarItem.Preparer {
	typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ToolbarItemBinding {
	typealias ToolbarItemName&lt;V&gt; = BindingName&lt;V, ToolbarItem.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; ToolbarItem.Binding) -&gt; ToolbarItemName&lt;V&gt; {
		return ToolbarItemName&lt;V&gt;(source: source, downcast: Binding.toolbarItemBinding)
	}
}
extension BindingName where Binding: ToolbarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ToolbarItemName&lt;$2&gt; { return .name(ToolbarItem.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var image: ToolbarItemName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(ToolbarItem.Binding.image) }
	static var isEnabled: ToolbarItemName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(ToolbarItem.Binding.isEnabled) }
	static var label: ToolbarItemName&lt;Dynamic&lt;String&gt;&gt; { return .name(ToolbarItem.Binding.label) }
	static var maxSize: ToolbarItemName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(ToolbarItem.Binding.maxSize) }
	static var menuFormRepresentation: ToolbarItemName&lt;Dynamic&lt;MenuItemConvertible&gt;&gt; { return .name(ToolbarItem.Binding.menuFormRepresentation) }
	static var minSize: ToolbarItemName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(ToolbarItem.Binding.minSize) }
	static var paletteLabel: ToolbarItemName&lt;Dynamic&lt;String&gt;&gt; { return .name(ToolbarItem.Binding.paletteLabel) }
	static var tag: ToolbarItemName&lt;Dynamic&lt;Int&gt;&gt; { return .name(ToolbarItem.Binding.tag) }
	static var toolTip: ToolbarItemName&lt;Dynamic&lt;String?&gt;&gt; { return .name(ToolbarItem.Binding.toolTip) }
	static var view: ToolbarItemName&lt;Dynamic&lt;ViewConvertible?&gt;&gt; { return .name(ToolbarItem.Binding.view) }
	static var visibilityPriority: ToolbarItemName&lt;Dynamic&lt;NSToolbarItem.VisibilityPriority&gt;&gt; { return .name(ToolbarItem.Binding.visibilityPriority) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: ToolbarItemName&lt;TargetAction&gt; { return .name(ToolbarItem.Binding.action) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var validate: ToolbarItemName&lt;(NSToolbarItem) -&gt; Bool&gt; { return .name(ToolbarItem.Binding.validate) }

	// Composite binding names
	static func action&lt;Value&gt;(_ keyPath: KeyPath&lt;Binding.Preparer.Instance, Value&gt;) -&gt; ToolbarItemName&lt;SignalInput&lt;Value&gt;&gt; {
		return Binding.keyPathActionName(keyPath, ToolbarItem.Binding.action, Binding.toolbarItemBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ToolbarItemConvertible {
	func nsToolbarItem() -&gt; ToolbarItem.Instance
}
extension NSToolbarItem: ToolbarItemConvertible, TargetActionSender {
	func nsToolbarItem() -&gt; ToolbarItem.Instance { return self }
}
extension ToolbarItem {
	func nsToolbarItem() -&gt; ToolbarItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ToolbarItemBinding: BinderBaseBinding {
	static func toolbarItemBinding(_ binding: ToolbarItem.Binding) -&gt; Self
	func asToolbarItemBinding() -&gt; ToolbarItem.Binding?
}
extension ToolbarItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return toolbarItemBinding(.inheritedBinding(binding))
	}
}
extension ToolbarItemBinding where Preparer.Inherited.Binding: ToolbarItemBinding {
	func asToolbarItemBinding() -&gt; ToolbarItem.Binding? {
		return asInheritedBinding()?.asToolbarItemBinding()
	}
}
extension ToolbarItem.Binding {
	typealias Preparer = ToolbarItem.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asToolbarItemBinding() -&gt; ToolbarItem.Binding? { return self }
	static func toolbarItemBinding(_ binding: ToolbarItem.Binding) -&gt; ToolbarItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
class ToolbarItemTarget: SignalActionTarget {
	var validator: ((NSToolbarItem) -&gt; Bool)?
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class Toolbar: Binder, ToolbarConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	convenience init(type: Instance.Type = Instance.self, identifier: NSToolbar.Identifier, _ bindings: Binding...) {
		self.init(type: type, parameters: identifier, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Toolbar {
	enum Binding: ToolbarBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static styles are applied at construction and are subsequently immutable.
		case itemDescriptions(Constant&lt;[ToolbarItemDescription]&gt;)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsExtensionItems(Dynamic&lt;Bool&gt;)
		case allowsUserCustomization(Dynamic&lt;Bool&gt;)
		case autosavesConfiguration(Dynamic&lt;Bool&gt;)
		case displayMode(Dynamic&lt;NSToolbar.DisplayMode&gt;)
		case isVisible(Dynamic&lt;Bool&gt;)
		case selectedItemIdentifier(Dynamic&lt;NSToolbarItem.Identifier&gt;)
		case showsBaselineSeparator(Dynamic&lt;Bool&gt;)
		case sizeMode(Dynamic&lt;NSToolbar.SizeMode&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case runCustomizationPalette(Signal&lt;Void&gt;)

		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didRemoveItem(SignalInput&lt;Void&gt;)
		case willAddItem(SignalInput&lt;Void&gt;)
	}
}

// MARK: - Binder Part 3: Preparer
extension Toolbar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = Toolbar.Binding
		typealias Delegate = DynamicDelegate
		typealias Inherited = BinderBase
		typealias Instance = NSToolbar
		typealias Parameters = NSToolbar.Identifier
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var itemDescriptions: [ToolbarItemDescription]?
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Toolbar.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Parameters) -&gt; Instance {
		return type.init(identifier: parameters)
	}
	
	mutating func prepareBinding(_ binding: Toolbar.Binding) {
		switch binding {
		case .inheritedBinding(let s): inherited.prepareBinding(s)
		
		case .itemDescriptions(let x): itemDescriptions = x.value
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		if let id = itemDescriptions {
			storage.itemDescriptions = id
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .itemDescriptions:return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .displayMode(let x): return x.apply(instance) { i, v in i.displayMode = v }
		case .showsBaselineSeparator(let x): return x.apply(instance) { i, v in i.showsBaselineSeparator = v }
		case .allowsUserCustomization(let x): return x.apply(instance) { i, v in i.allowsUserCustomization = v }
		case .allowsExtensionItems(let x): return x.apply(instance) { i, v in i.allowsExtensionItems = v }
		case .sizeMode(let x): return x.apply(instance) { i, v in i.sizeMode = v }
		case .selectedItemIdentifier(let x): return x.apply(instance) { i, v in i.selectedItemIdentifier = v }
		case .isVisible(let x): return x.apply(instance) { i, v in i.isVisible = v }
		case .autosavesConfiguration(let x): return x.apply(instance) { i, v in i.autosavesConfiguration = v }
		
		// 2. Signal bindings are performed on the object after construction.
		case .runCustomizationPalette(let x): return x.apply(instance) { i, v in i.runCustomizationPalette(nil) }
		
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .didRemoveItem(let x): return Signal.notifications(name: NSToolbar.didRemoveItemNotification, object: instance).map { _ in () }.cancellableBind(to: x)
		case .willAddItem(let x): return Signal.notifications(name: NSToolbar.willAddItemNotification, object: instance).map { _ in () }.cancellableBind(to: x)
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Toolbar.Preparer {
	class Storage: AssociatedBinderStorage, NSToolbarDelegate {
		override var isInUse: Bool { return true }
		
		var itemDescriptions: [ToolbarItemDescription] = []
		func toolbar(_ toolbar: NSToolbar, itemForItemIdentifier itemIdentifier: NSToolbarItem.Identifier, willBeInsertedIntoToolbar flag: Bool) -&gt; NSToolbarItem? {
			return itemDescriptions.first { $0.identifier == itemIdentifier }?.constructor(itemIdentifier, flag)?.nsToolbarItem()
		}
		
		var allowedItemIdentifiers: [NSToolbarItem.Identifier] = []
		func toolbarAllowedItemIdentifiers(_ toolbar: NSToolbar) -&gt; [NSToolbarItem.Identifier] {
			return itemDescriptions.filter { $0.isAllowed }.map { $0.identifier }
		}
		
		var defaultItemIdentifiers: [NSToolbarItem.Identifier] = []
		func toolbarDefaultItemIdentifiers(_ toolbar: NSToolbar) -&gt; [NSToolbarItem.Identifier] {
			return itemDescriptions.filter { $0.isDefault }.map { $0.identifier }
		}
		
		var selectableItemIdentifiers: [NSToolbarItem.Identifier] = []
		func toolbarSelectableItemIdentifiers(_ toolbar: NSToolbar) -&gt; [NSToolbarItem.Identifier] {
			return itemDescriptions.filter { $0.isSelectable }.map { $0.identifier }
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ToolbarBinding {
	typealias ToolbarName&lt;V&gt; = BindingName&lt;V, Toolbar.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; Toolbar.Binding) -&gt; ToolbarName&lt;V&gt; {
		return ToolbarName&lt;V&gt;(source: source, downcast: Binding.toolbarBinding)
	}
}
extension BindingName where Binding: ToolbarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ToolbarName&lt;$2&gt; { return .name(Toolbar.Binding.$1) }

	//	0. Static styles are applied at construction and are subsequently immutable.
	static var itemDescriptions: ToolbarName&lt;Constant&lt;[ToolbarItemDescription]&gt;&gt; { return .name(Toolbar.Binding.itemDescriptions) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsExtensionItems: ToolbarName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Toolbar.Binding.allowsExtensionItems) }
	static var allowsUserCustomization: ToolbarName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Toolbar.Binding.allowsUserCustomization) }
	static var autosavesConfiguration: ToolbarName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Toolbar.Binding.autosavesConfiguration) }
	static var displayMode: ToolbarName&lt;Dynamic&lt;NSToolbar.DisplayMode&gt;&gt; { return .name(Toolbar.Binding.displayMode) }
	static var isVisible: ToolbarName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Toolbar.Binding.isVisible) }
	static var selectedItemIdentifier: ToolbarName&lt;Dynamic&lt;NSToolbarItem.Identifier&gt;&gt; { return .name(Toolbar.Binding.selectedItemIdentifier) }
	static var showsBaselineSeparator: ToolbarName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Toolbar.Binding.showsBaselineSeparator) }
	static var sizeMode: ToolbarName&lt;Dynamic&lt;NSToolbar.SizeMode&gt;&gt; { return .name(Toolbar.Binding.sizeMode) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var runCustomizationPalette: ToolbarName&lt;Signal&lt;Void&gt;&gt; { return .name(Toolbar.Binding.runCustomizationPalette) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didRemoveItem: ToolbarName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Toolbar.Binding.didRemoveItem) }
	static var willAddItem: ToolbarName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Toolbar.Binding.willAddItem) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol ToolbarConvertible {
	func nsToolbar() -&gt; Toolbar.Instance
}
extension NSToolbar: ToolbarConvertible, DefaultConstructable, HasDelegate {
	func nsToolbar() -&gt; Toolbar.Instance { return self }
}
extension Toolbar {
	func nsToolbar() -&gt; Toolbar.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ToolbarBinding: BinderBaseBinding {
	static func toolbarBinding(_ binding: Toolbar.Binding) -&gt; Self
	func asToolbarBinding() -&gt; Toolbar.Binding?
}
extension ToolbarBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return toolbarBinding(.inheritedBinding(binding))
	}
}
extension ToolbarBinding where Preparer.Inherited.Binding: ToolbarBinding {
	func asToolbarBinding() -&gt; Toolbar.Binding? {
		return asInheritedBinding()?.asToolbarBinding()
	}
}
extension Toolbar.Binding {
	typealias Preparer = Toolbar.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asToolbarBinding() -&gt; Toolbar.Binding? { return self }
	static func toolbarBinding(_ binding: Toolbar.Binding) -&gt; Toolbar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
struct ToolbarItemDescription {
	let identifier: NSToolbarItem.Identifier
	let isDefault: Bool
	let isAllowed: Bool
	let isSelectable: Bool
	let constructor: (_ itemIdentifier: NSToolbarItem.Identifier, _ willBeInserted: Bool) -&gt; ToolbarItemConvertible?
	
	init(identifier: NSToolbarItem.Identifier, isDefault: Bool = true, isAllowed: Bool = true, isSelectable: Bool = false, constructor: @escaping (_ itemIdentifier: NSToolbarItem.Identifier, _ willBeInserted: Bool) -&gt; ToolbarItemConvertible?) {
		self.identifier = identifier
		self.isDefault = isDefault
		self.isAllowed = isAllowed
		self.isSelectable = isSelectable
		self.constructor = constructor
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class View: Binder, ViewConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension View {
	enum Binding: ViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static styles are applied at construction and are subsequently immutable.
		case layer(Constant&lt;Layer&gt;)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case appearance(Dynamic&lt;NSAppearance?&gt;)
		case canDrawSubviewsIntoLayer(Dynamic&lt;Bool&gt;)
		case focusRingType(Dynamic&lt;NSFocusRingType&gt;)
		case frameRotation(Dynamic&lt;CGFloat&gt;)
		case gestureRecognizers(Dynamic&lt;[GestureRecognizerConvertible]&gt;)
		case horizontalContentCompressionResistancePriority(Dynamic&lt;NSLayoutConstraint.Priority&gt;)
		case horizontalContentHuggingPriority(Dynamic&lt;NSLayoutConstraint.Priority&gt;)
		case identifier(Dynamic&lt;NSUserInterfaceItemIdentifier?&gt;)
		case isHidden(Dynamic&lt;Bool&gt;)
		case layerContentsRedrawPolicy(Dynamic&lt;NSView.LayerContentsRedrawPolicy&gt;)
		case layout(Dynamic&lt;Layout&gt;)
		case pressureConfiguration(Dynamic&lt;NSPressureConfiguration&gt;)
		case registeredDragTypes(Dynamic&lt;[NSPasteboard.PasteboardType]&gt;)
		case tooltip(Dynamic&lt;String&gt;)
		case verticalContentCompressionResistancePriority(Dynamic&lt;NSLayoutConstraint.Priority&gt;)
		case verticalContentHuggingPriority(Dynamic&lt;NSLayoutConstraint.Priority&gt;)
		
		// 2. Signal bindings are performed on the object after construction.
		case becomeFirstResponder(Signal&lt;Void&gt;)
		case needsDisplay(Signal&lt;Bool&gt;)
		case printView(Signal&lt;Void&gt;)
		case scrollRectToVisible(Signal&lt;NSRect&gt;)
		case setNeedsDisplayInRect(Signal&lt;NSRect&gt;)
		
		// 3. Action bindings are triggered by the object after construction.
		case boundsDidChange(SignalInput&lt;NSRect&gt;)
		case frameDidChange(SignalInput&lt;NSRect&gt;)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
extension View {
	struct Preparer: BinderEmbedderConstructor {
		typealias Binding = View.Binding
		typealias Inherited = BinderBase
		typealias Instance = NSView
		
		var inherited = Inherited()
		init() {}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var backingLayer: Layer? = nil
		var postsFrameChangedNotifications: Bool = false
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension View.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .layer(let x): backingLayer = x.value
		case .boundsDidChange: postsFrameChangedNotifications = true 
		case .frameDidChange: postsFrameChangedNotifications = true
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		if let layer = backingLayer {
			instance.wantsLayer = true
			layer.apply(to: instance.layer!)
		}
		if postsFrameChangedNotifications {
			instance.postsFrameChangedNotifications = true
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static styles are applied at construction and are subsequently immutable.
		case .layer: return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .appearance(let x): return x.apply(instance) { i, v in i.appearance = v }
		case .canDrawSubviewsIntoLayer(let x): return x.apply(instance) { i, v in i.canDrawSubviewsIntoLayer = v }
		case .focusRingType(let x): return x.apply(instance) { i, v in i.focusRingType = v }
		case .frameRotation(let x): return x.apply(instance) { i, v in i.frameRotation = v }
		case .gestureRecognizers(let x): return x.apply(instance) { i, v in i.gestureRecognizers = v.map { $0.nsGestureRecognizer() } }
		case .horizontalContentCompressionResistancePriority(let x): return x.apply(instance) { i, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Orientation.horizontal) }
		case .horizontalContentHuggingPriority(let x): return x.apply(instance) { i, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Orientation.horizontal) }
		case .identifier(let x): return x.apply(instance) { i, v in i.identifier = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .layerContentsRedrawPolicy(let x): return x.apply(instance) { i, v in i.layerContentsRedrawPolicy = v }
		case .layout(let x): return x.apply(instance) { i, v in i.applyLayout(v) }
		case .pressureConfiguration(let x): return x.apply(instance) { i, v in i.pressureConfiguration = v }
		case .registeredDragTypes(let x):
			return x.apply(instance) { i, v in
				if v.isEmpty {
					i.unregisterDraggedTypes()
				} else {
					i.registerForDraggedTypes(v)
				}
			}
		case .tooltip(let x): return x.apply(instance) { i, v in i.toolTip = v }
		case .verticalContentCompressionResistancePriority(let x): return x.apply(instance) { i, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Orientation.vertical) }
		case .verticalContentHuggingPriority(let x): return x.apply(instance) { i, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Orientation.vertical) }
			
		// 2. Signal bindings are performed on the object after construction.
		case .becomeFirstResponder(let x): return x.apply(instance) { i, _ in i.window?.makeFirstResponder(i) }
		case .needsDisplay(let x): return x.apply(instance) { i, v in i.needsDisplay = v }
		case .printView(let x): return x.apply(instance) { i, v in i.printView(nil) }
		case .setNeedsDisplayInRect(let x): return x.apply(instance) { i, v in i.setNeedsDisplay(v) }
		case .scrollRectToVisible(let x): return x.apply(instance) { i, v in i.scrollToVisible(v) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .frameDidChange(let x):
			instance.postsFrameChangedNotifications = true
			return Signal.notifications(name: NSView.frameDidChangeNotification, object: instance).compactMap { notification -&gt; NSRect? in (notification.object as? NSView)?.frame }.cancellableBind(to: x)
		case .boundsDidChange(let x):
			instance.postsBoundsChangedNotifications = true
			return Signal.notifications(name: NSView.boundsDidChangeNotification, object: instance).compactMap { notification -&gt; NSRect? in (notification.object as? NSView)?.bounds }.cancellableBind(to: x)
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension View.Preparer {
	typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ViewBinding {
	typealias ViewName&lt;V&gt; = BindingName&lt;V, View.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; View.Binding) -&gt; ViewName&lt;V&gt; {
		return ViewName&lt;V&gt;(source: source, downcast: Binding.viewBinding)
	}
}
extension BindingName where Binding: ViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ViewName&lt;$2&gt; { return .name(View.Binding.$1) }
	
	//	0. Static styles are applied at construction and are subsequently immutable.
	static var layer: ViewName&lt;Constant&lt;Layer&gt;&gt; { return .name(View.Binding.layer) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var appearance: ViewName&lt;Dynamic&lt;NSAppearance?&gt;&gt; { return .name(View.Binding.appearance) }
	static var canDrawSubviewsIntoLayer: ViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(View.Binding.canDrawSubviewsIntoLayer) }
	static var focusRingType: ViewName&lt;Dynamic&lt;NSFocusRingType&gt;&gt; { return .name(View.Binding.focusRingType) }
	static var frameRotation: ViewName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(View.Binding.frameRotation) }
	static var gestureRecognizers: ViewName&lt;Dynamic&lt;[GestureRecognizerConvertible]&gt;&gt; { return .name(View.Binding.gestureRecognizers) }
	static var horizontalContentCompressionResistancePriority: ViewName&lt;Dynamic&lt;NSLayoutConstraint.Priority&gt;&gt; { return .name(View.Binding.horizontalContentCompressionResistancePriority) }
	static var horizontalContentHuggingPriority: ViewName&lt;Dynamic&lt;NSLayoutConstraint.Priority&gt;&gt; { return .name(View.Binding.horizontalContentHuggingPriority) }
	static var identifier: ViewName&lt;Dynamic&lt;NSUserInterfaceItemIdentifier?&gt;&gt; { return .name(View.Binding.identifier) }
	static var isHidden: ViewName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(View.Binding.isHidden) }
	static var layerContentsRedrawPolicy: ViewName&lt;Dynamic&lt;NSView.LayerContentsRedrawPolicy&gt;&gt; { return .name(View.Binding.layerContentsRedrawPolicy) }
	static var layout: ViewName&lt;Dynamic&lt;Layout&gt;&gt; { return .name(View.Binding.layout) }
	static var pressureConfiguration: ViewName&lt;Dynamic&lt;NSPressureConfiguration&gt;&gt; { return .name(View.Binding.pressureConfiguration) }
	static var registeredDragTypes: ViewName&lt;Dynamic&lt;[NSPasteboard.PasteboardType]&gt;&gt; { return .name(View.Binding.registeredDragTypes) }
	static var tooltip: ViewName&lt;Dynamic&lt;String&gt;&gt; { return .name(View.Binding.tooltip) }
	static var verticalContentCompressionResistancePriority: ViewName&lt;Dynamic&lt;NSLayoutConstraint.Priority&gt;&gt; { return .name(View.Binding.verticalContentCompressionResistancePriority) }
	static var verticalContentHuggingPriority: ViewName&lt;Dynamic&lt;NSLayoutConstraint.Priority&gt;&gt; { return .name(View.Binding.verticalContentHuggingPriority) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var becomeFirstResponder: ViewName&lt;Signal&lt;Void&gt;&gt; { return .name(View.Binding.becomeFirstResponder) }
	static var needsDisplay: ViewName&lt;Signal&lt;Bool&gt;&gt; { return .name(View.Binding.needsDisplay) }
	static var printView: ViewName&lt;Signal&lt;Void&gt;&gt; { return .name(View.Binding.printView) }
	static var scrollRectToVisible: ViewName&lt;Signal&lt;NSRect&gt;&gt; { return .name(View.Binding.scrollRectToVisible) }
	static var setNeedsDisplayInRect: ViewName&lt;Signal&lt;NSRect&gt;&gt; { return .name(View.Binding.setNeedsDisplayInRect) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var boundsDidChange: ViewName&lt;SignalInput&lt;NSRect&gt;&gt; { return .name(View.Binding.boundsDidChange) }
	static var frameDidChange: ViewName&lt;SignalInput&lt;NSRect&gt;&gt; { return .name(View.Binding.frameDidChange) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension NSView: DefaultConstructable {}
extension View {
	func nsView() -&gt; Layout.View { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol ViewBinding: BinderBaseBinding {
	static func viewBinding(_ binding: View.Binding) -&gt; Self
	func asViewBinding() -&gt; View.Binding?
}
extension ViewBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return viewBinding(.inheritedBinding(binding))
	}
}
extension ViewBinding where Preparer.Inherited.Binding: ViewBinding {
	func asViewBinding() -&gt; View.Binding? {
		return asInheritedBinding()?.asViewBinding()
	}
}
extension View.Binding {
	typealias Preparer = View.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asViewBinding() -&gt; View.Binding? { return self }
	static func viewBinding(_ binding: View.Binding) -&gt; View.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
extension ViewConvertible {
	func nsView(frame: NSRect) -&gt; Layout.View {
		let v = nsView()
		v.frame = frame
		return v
	}
	func nsView(width: CGFloat, height: CGFloat) -&gt; Layout.View {
		return nsView(frame: NSRect(x: 0, y: 0, width: width, height: height))
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
class Window: Binder, WindowConvertible {
	var state: BinderState&lt;Preparer&gt;
	required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
extension Window {
	enum Binding: WindowBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case deferCreation(Constant&lt;Bool&gt;)
		case initialFirstResponderTag(Constant&lt;Int&gt;)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case acceptsMouseMovedEvents(Dynamic&lt;Bool&gt;)
		case allowsConcurrentViewDrawing(Dynamic&lt;Bool&gt;)
		case allowsToolTipsWhenApplicationIsInactive(Dynamic&lt;Bool&gt;)
		case alphaValue(Dynamic&lt;CGFloat&gt;)
		case animationBehavior(Dynamic&lt;NSWindow.AnimationBehavior&gt;)
		case appearance(Dynamic&lt;NSAppearance?&gt;)
		case autorecalculatesKeyViewLoop(Dynamic&lt;Bool&gt;)
		case backingType(Dynamic&lt;NSWindow.BackingStoreType&gt;)
		case canBecomeVisibleWithoutLogin(Dynamic&lt;Bool&gt;)
		case canHide(Dynamic&lt;Bool&gt;)
		case collectionBehavior(Dynamic&lt;NSWindow.CollectionBehavior&gt;)
		case colorSpace(Dynamic&lt;NSColorSpace&gt;)
		case contentAspectRatio(Dynamic&lt;NSSize&gt;)
		case contentHeight(Dynamic&lt;WindowDimension&gt;)
		case contentMaxSize(Dynamic&lt;NSSize&gt;)
		case contentMinSize(Dynamic&lt;NSSize&gt;)
		case contentResizeIncrements(Dynamic&lt;NSSize&gt;)
		case contentRelativity(Dynamic&lt;WindowDimension.Relativity&gt;)
		case contentView(Dynamic&lt;ViewConvertible&gt;)
		case contentWidth(Dynamic&lt;WindowDimension&gt;)
		case depthLimit(Dynamic&lt;NSWindow.Depth?&gt;)
		case displaysWhenScreenProfileChanges(Dynamic&lt;Bool&gt;)
		case frameAutosaveName(Dynamic&lt;NSWindow.FrameAutosaveName&gt;)
		case frameHorizontal(Dynamic&lt;WindowDimension&gt;)
		case frameVertical(Dynamic&lt;WindowDimension&gt;)
		case hasShadow(Dynamic&lt;Bool&gt;)
		case hidesOnDeactivate(Dynamic&lt;Bool&gt;)
		case ignoresMouseEvents(Dynamic&lt;Bool&gt;)
		case isDocumentEdited(Dynamic&lt;Bool&gt;)
		case isExcludedFromWindowsMenu(Dynamic&lt;Bool&gt;)
		case isMovable(Dynamic&lt;Bool&gt;)
		case isMovableByWindowBackground(Dynamic&lt;Bool&gt;)
		case isOpaque(Dynamic&lt;Bool&gt;)
		case isRestorable(Dynamic&lt;Bool&gt;)
		case key(Dynamic&lt;Bool&gt;)
		case level(Dynamic&lt;NSWindow.Level&gt;)
		case main(Dynamic&lt;Bool&gt;)
		case maxFullScreenContentSize(Dynamic&lt;NSSize&gt;)
		case minFullScreenContentSize(Dynamic&lt;NSSize&gt;)
		case miniwindowImage(Dynamic&lt;NSImage?&gt;)
		case miniwindowTitle(Dynamic&lt;String&gt;)
		case order(Dynamic&lt;WindowOrder&gt;)
		case preservesContentDuringLiveResize(Dynamic&lt;Bool&gt;)
		case preventsApplicationTerminationWhenModal(Dynamic&lt;Bool&gt;)
		case representedURL(Dynamic&lt;URL?&gt;)
		case resizeStyle(Dynamic&lt;WindowResizeStyle&gt;)
		case restorationClass(Dynamic&lt;NSWindowRestoration.Type&gt;)
		case screen(Dynamic&lt;NSScreen?&gt;)
		case sharingType(Dynamic&lt;NSWindow.SharingType&gt;)
		case styleMask(Dynamic&lt;NSWindow.StyleMask&gt;)
		case title(Dynamic&lt;String&gt;)
		case titlebarAppearsTransparent(Dynamic&lt;Bool&gt;)
		case titleVisibility(Dynamic&lt;NSWindow.TitleVisibility&gt;)
		case toolbar(Dynamic&lt;ToolbarConvertible&gt;)

		// 2. Signal bindings are performed on the object after construction.
		case close(Signal&lt;WindowCloseBehavior&gt;)
		case criticalSheet(Signal&lt;Callback&lt;NSWindow, NSApplication.ModalResponse&gt;&gt;)
		case deminiaturize(Signal&lt;Void&gt;)
		case display(Signal&lt;Bool&gt;)
		case invalidateShadow(Signal&lt;Void&gt;)
		case miniaturize(Signal&lt;Bool&gt;)
		case presentError(Signal&lt;Callback&lt;Error, Bool&gt;&gt;)
		case printWindow(Signal&lt;Void&gt;)
		case recalculateKeyViewLoop(Signal&lt;Void&gt;)
		case runToolbarCustomizationPalette(Signal&lt;Void&gt;)
		case selectNextKeyView(Signal&lt;Void&gt;)
		case selectPreviousKeyView(Signal&lt;Void&gt;)
		case sheet(Signal&lt;Callback&lt;NSWindow, NSApplication.ModalResponse&gt;&gt;)
		case toggleFullScreen(Signal&lt;Void&gt;)
		case toggleToolbarShown(Signal&lt;Void&gt;)
		case zoom(Signal&lt;Bool&gt;)
		
		// 3. Action bindings are triggered by the object after construction.
		case effectiveAppearanceName(SignalInput&lt;NSAppearance.Name&gt;)
		case didBecomeKey(SignalInput&lt;Void&gt;)
		case didBecomeMain(SignalInput&lt;Void&gt;)
		case didChangeBackingProperties(SignalInput&lt;(oldColorSpace: NSColorSpace?, oldScaleFactor: CGFloat?)&gt;)
		case didChangeOcclusionState(SignalInput&lt;Void&gt;)
		case didChangeScreen(SignalInput&lt;Void&gt;)
		case didChangeScreenProfile(SignalInput&lt;Void&gt;)
		case didDeminiaturize(SignalInput&lt;Void&gt;)
		case didEndLiveResize(SignalInput&lt;Void&gt;)
		case didEndSheet(SignalInput&lt;Void&gt;)
		case didEnterFullScreen(SignalInput&lt;Void&gt;)
		case didEnterVersionBrowser(SignalInput&lt;Void&gt;)
		case didExitFullScreen(SignalInput&lt;Void&gt;)
		case didExitVersionBrowser(SignalInput&lt;Void&gt;)
		case didExpose(SignalInput&lt;NSRect&gt;)
		case didMiniaturize(SignalInput&lt;Void&gt;)
		case didMove(SignalInput&lt;Void&gt;)
		case didResignKey(SignalInput&lt;Void&gt;)
		case didResignMain(SignalInput&lt;Void&gt;)
		case didResize(SignalInput&lt;Void&gt;)
		case didUpdate(SignalInput&lt;Void&gt;)
		case willBeginSheet(SignalInput&lt;Void&gt;)
		case willClose(SignalInput&lt;Void&gt;)
		case willEnterFullScreen(SignalInput&lt;Void&gt;)
		case willEnterVersionBrowser(SignalInput&lt;Void&gt;)
		case willExitFullScreen(SignalInput&lt;Void&gt;)
		case willExitVersionBrowser(SignalInput&lt;Void&gt;)
		case willMiniaturize(SignalInput&lt;Void&gt;)
		case willMove(SignalInput&lt;Void&gt;)
		case willStartLiveResize(SignalInput&lt;Void&gt;)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldClose((NSWindow) -&gt; Bool)
		case shouldPopUpDocumentPathMenu((NSWindow, NSMenu) -&gt; Bool)
		case shouldZoom((NSWindow, NSRect) -&gt; Bool)
		case willResize((NSWindow, NSSize) -&gt; NSSize)
		case willResizeForVersionBrowser((_ window: NSWindow, _ maxPreferredSize: NSSize, _ maxAllowedSize: NSSize) -&gt; NSSize)
		case willUseFullScreenContentSize((NSWindow, NSSize) -&gt; NSSize)
		case willUseFullScreenPresentationOptions((NSWindow, NSApplication.PresentationOptions) -&gt; NSApplication.PresentationOptions)
		case willUseStandardFrame((NSWindow, NSRect) -&gt; NSRect)
	}
}

// MARK: - Binder Part 3: Preparer
extension Window {
	struct Preparer: BinderDelegateEmbedderConstructor {
		typealias Binding = Window.Binding
		typealias Inherited = BinderBase
		typealias Instance = NSWindow
		
		var inherited = Inherited()
		var dynamicDelegate: Delegate? = nil
		let delegateClass: Delegate.Type
		init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		func constructStorage(instance: Instance) -&gt; Storage { return Storage() }
		func inheritedBinding(from: Binding) -&gt; Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var deferCreation: Bool? = nil
		var initialFirstResponder: Int? = nil
		
		var contentWidth = InitialSubsequent&lt;WindowDimension&gt;()
		var contentHeight = InitialSubsequent&lt;WindowDimension&gt;()
		var windowSizeRelativity = InitialSubsequent&lt;WindowDimension.Relativity&gt;()
		var screen = InitialSubsequent&lt;NSScreen?&gt;()
		var styleMask = InitialSubsequent&lt;NSWindow.StyleMask&gt;()
		var backingType = InitialSubsequent&lt;NSWindow.BackingStoreType&gt;()
		
		var contentView: Dynamic&lt;ViewConvertible&gt;? = nil
		var frameAutosaveName: Dynamic&lt;String&gt;? = nil
		var frameHorizontal: Dynamic&lt;WindowDimension&gt;? = nil
		var frameVertical: Dynamic&lt;WindowDimension&gt;? = nil
		var key: Dynamic&lt;Bool&gt;? = nil
		var main: Dynamic&lt;Bool&gt;? = nil
		var order: Dynamic&lt;WindowOrder&gt;? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
extension Window.Preparer {
	func constructInstance(type: NSWindow.Type, parameters: Void) -&gt; NSWindow {
		let width = contentWidth.initial ?? WindowDimension(constant: WindowDimension.fallbackWindowSize)
		let height = contentHeight.initial ?? WindowDimension(constant: WindowDimension.fallbackWindowSize)
		let relativity = windowSizeRelativity.initial ?? .independent
		let screen = self.screen.initial ?? NSScreen.screens.first
		let styleMask = self.styleMask.initial ?? [.titled, .resizable, .closable, .miniaturizable]
		let backingType = self.backingType.initial ?? .buffered
		
		// Apply the ContentSize binding
		let contentSize = WindowDimension.contentSize(width: width, height: height, relativity: relativity, onScreen: screen, windowClass: type, styleMask: styleMask)
		
		var frameRect = type.frameRect(forContentRect: NSRect(x: 0, y: 0, width: contentSize.width, height: contentSize.height), styleMask: styleMask)
		frameRect.origin.y = screen.map { $0.visibleFrame.origin.y + $0.visibleFrame.size.height - frameRect.size.height } ?? 0
		
		let cr = type.contentRect(forFrameRect: frameRect, styleMask: styleMask)
		
		// Create the window
		let w = type.init(contentRect: cr, styleMask: styleMask, backing: backingType, defer: deferCreation ?? true, screen: screen)
		w.isReleasedWhenClosed = false
		
		// To be consistent with setting ".Screen", constrain the window to the screen.
		if let scr = screen {
			let r = w.constrainFrameRect(w.frame, to:scr)
			w.setFrameOrigin(r.origin)
		}
		return w
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .backingType(let x): backingType = x.initialSubsequent()
		case .contentHeight(let x): contentHeight = x.initialSubsequent()
		case .contentWidth(let x): contentWidth = x.initialSubsequent()
		case .contentView(let x): contentView = x
		case .deferCreation(let x): deferCreation = x.value
		case .frameAutosaveName(let x): frameAutosaveName = x
		case .frameHorizontal(let x): frameHorizontal = x
		case .frameVertical(let x): frameVertical = x
		case .key(let x): key = x
		case .initialFirstResponderTag(let x): initialFirstResponder = x.value
		case .main(let x): main = x
		case .order(let x): order = x
		case .screen(let x): screen = x.initialSubsequent()
		case .shouldClose(let x): delegate().addSingleHandler1(x, #selector(NSWindowDelegate.windowShouldClose(_:)))
		case .shouldPopUpDocumentPathMenu(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.window(_:shouldPopUpDocumentPathMenu:)))
		case .shouldZoom(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.windowShouldZoom(_:toFrame:)))
		case .styleMask(let x): styleMask = x.initialSubsequent()
		case .willResize(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.windowWillResize(_:to:)))
		case .willResizeForVersionBrowser(let x): delegate().addSingleHandler3(x, #selector(NSWindowDelegate.window(_:willResizeForVersionBrowserWithMaxPreferredSize:maxAllowedSize:)))
		case .willUseFullScreenContentSize(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.window(_:willUseFullScreenContentSize:)))
		case .willUseFullScreenPresentationOptions(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.window(_:willUseFullScreenPresentationOptions:)))
		case .willUseStandardFrame(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.windowWillUseStandardFrame(_:defaultFrame:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: NSWindow, storage: Window.Preparer.Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		if let relativity = windowSizeRelativity.initial {
			storage.windowSizeRelativity = relativity
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -&gt; Lifetime? {
		switch binding {
		case .inheritedBinding(let s): return inherited.applyBinding(s, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .deferCreation: return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .acceptsMouseMovedEvents(let x): return x.apply(instance) { i, v in i.acceptsMouseMovedEvents = v }
		case .allowsConcurrentViewDrawing(let x): return x.apply(instance) { i, v in i.allowsConcurrentViewDrawing = v }
		case .allowsToolTipsWhenApplicationIsInactive(let x): return x.apply(instance) { i, v in i.allowsToolTipsWhenApplicationIsInactive = v }
		case .alphaValue(let x): return x.apply(instance) { i, v in i.alphaValue = v }
		case .animationBehavior(let x): return x.apply(instance) { i, v in i.animationBehavior = v }
		case .appearance(let x): return x.apply(instance) { i, v in i.appearance = v }
		case .autorecalculatesKeyViewLoop(let x): return x.apply(instance) { i, v in i.autorecalculatesKeyViewLoop = v }
		case .backingType: return backingType.resume()?.apply(instance) { i, v in i.backingType = v }
		case .canBecomeVisibleWithoutLogin(let x): return x.apply(instance) { i, v in i.canBecomeVisibleWithoutLogin = v }
		case .canHide(let x): return x.apply(instance) { i, v in i.canHide = v }
		case .collectionBehavior(let x): return x.apply(instance) { i, v in i.collectionBehavior = v }
		case .colorSpace(let x): return x.apply(instance) { i, v in i.colorSpace = v }
		case .contentAspectRatio(let x): return x.apply(instance) { i, v in i.contentAspectRatio = v }
		case .contentHeight: return contentHeight.resume()?.apply(instance, storage) { i, s, v in
			let widthSize = WindowDimension(ratio: 0, constant: i.contentView!.frame.size.width)
			i.setContentSize(WindowDimension.contentSize(width: widthSize, height: v, relativity: s.windowSizeRelativity, onScreen: i.screen, windowClass: type(of: i), styleMask: i.styleMask))
		}
		case .contentMaxSize(let x): return x.apply(instance) { i, v in i.contentMaxSize = v }
		case .contentMinSize(let x): return x.apply(instance) { i, v in i.contentMinSize = v }
		case .contentRelativity(let x): return x.apply(instance, storage) { i, s, v in
			let widthSize = WindowDimension(ratio: 0, constant: i.contentView!.frame.size.width)
			let heightSize = WindowDimension(ratio: 0, constant: i.contentView!.frame.size.height)
			s.windowSizeRelativity = v
			i.setContentSize(WindowDimension.contentSize(width: widthSize, height: heightSize, relativity: s.windowSizeRelativity, onScreen: i.screen, windowClass: type(of: i), styleMask: i.styleMask))
		}
		case .contentResizeIncrements(let x): return x.apply(instance) { i, v in i.contentResizeIncrements = v }
		case .contentView: return nil
		case .contentWidth: return contentWidth.resume()?.apply(instance, storage) { i, s, v in
			let heightSize = WindowDimension(ratio: 0, constant: i.contentView!.frame.size.height)
			i.setContentSize(WindowDimension.contentSize(width: v, height: heightSize, relativity: s.windowSizeRelativity, onScreen: i.screen, windowClass: type(of: i), styleMask: i.styleMask))
		}
		case .depthLimit(let x): return x.apply(instance) { i, v in v.map { i.depthLimit = $0 } ?? i.setDynamicDepthLimit(true) }
		case .displaysWhenScreenProfileChanges(let x): return x.apply(instance) { i, v in i.displaysWhenScreenProfileChanges = v }
		case .frameAutosaveName: return nil
		case .frameHorizontal: return nil
		case .frameVertical: return nil
		case .hasShadow(let x): return x.apply(instance) { i, v in i.hasShadow = v }
		case .hidesOnDeactivate(let x): return x.apply(instance) { i, v in i.hidesOnDeactivate = v }
		case .ignoresMouseEvents(let x): return x.apply(instance) { i, v in i.ignoresMouseEvents = v }
		case .isDocumentEdited(let x): return x.apply(instance) { i, v in i.isDocumentEdited = v }
		case .isExcludedFromWindowsMenu(let x): return x.apply(instance) { i, v in i.isExcludedFromWindowsMenu = v }
		case .isMovable(let x): return x.apply(instance) { i, v in i.isMovable = v }
		case .isMovableByWindowBackground(let x): return x.apply(instance) { i, v in i.isMovableByWindowBackground = v }
		case .isOpaque(let x): return x.apply(instance) { i, v in i.isOpaque = v }
		case .isRestorable(let x): return x.apply(instance) { i, v in i.isRestorable = v }
		case .initialFirstResponderTag: return nil
		case .key: return nil
		case .level(let x): return x.apply(instance) { i, v in i.level = v }
		case .main: return nil
		case .minFullScreenContentSize(let x): return x.apply(instance) { i, v in i.minFullScreenContentSize = v }
		case .miniwindowImage(let x): return x.apply(instance) { i, v in i.miniwindowImage = v }
		case .miniwindowTitle(let x): return x.apply(instance) { i, v in i.miniwindowTitle = v }
		case .maxFullScreenContentSize(let x): return x.apply(instance) { i, v in i.maxFullScreenContentSize = v }
		case .order: return nil
		case .preservesContentDuringLiveResize(let x): return x.apply(instance) { i, v in i.preservesContentDuringLiveResize = v }
		case .preventsApplicationTerminationWhenModal(let x): return x.apply(instance) { i, v in i.preventsApplicationTerminationWhenModal = v }
		case .representedURL(let x): return x.apply(instance) { i, v in i.representedURL = v }
		case .resizeStyle(let x):
			return x.apply(instance) { i, v in
				switch v {
				case .increment(let s):
					i.resizeIncrements = s
				case .contentAspect(let s):
					i.contentAspectRatio = s
				}
			}
		case .restorationClass(let x): return x.apply(instance) { i, v in i.restorationClass = v }
		case .screen:
			return screen.apply(instance) { i, v in
				let r = i.constrainFrameRect(i.frame, to:v)
				i.setFrameOrigin(r.origin)
			}
		case .sharingType(let x): return x.apply(instance) { i, v in i.sharingType = v }
		case .styleMask: return styleMask.apply(instance) { i, v in i.styleMask = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .titlebarAppearsTransparent(let x): return x.apply(instance) { i, v in i.titlebarAppearsTransparent = v }
		case .titleVisibility(let x): return x.apply(instance) { i, v in i.titleVisibility = v }
		case .toolbar(let x): return x.apply(instance) { i, v in i.toolbar = v.nsToolbar() }
		
		// 2. Signal bindings are performed on the object after construction.
		case .close(let x):
			return x.apply(instance) { i, v in
				switch v {
				case .stopModal(let c):
					if i.isSheet {
						i.sheetParent?.endSheet(i, returnCode: c)
					} else if NSApplication.shared.modalWindow == i {
						NSApplication.shared.stopModal(withCode: c)
					} else {
						i.close()
					}
				case _ where i.isSheet: i.sheetParent?.endSheet(i)
				case _ where NSApplication.shared.modalWindow == i: NSApplication.shared.stopModal()
				case .perform: i.performClose(nil)
				case .dismiss: i.close()
				}
			}
		case .criticalSheet(let x): return x.apply(instance) { i, v in i.beginCriticalSheet(v.value) { r in _ = v.callback.send(value: r) } }
		case .deminiaturize(let x): return x.apply(instance) { i, v in i.deminiaturize(nil) }
		case .display(let x): return x.apply(instance) { i, v in v ? i.displayIfNeeded() : i.display() }
		case .invalidateShadow(let x): return x.apply(instance) { i, v in i.invalidateShadow() }
		case .miniaturize(let x): return x.apply(instance) { i, v in v ? i.performMiniaturize(nil) : i.miniaturize(nil) }
		case .presentError(let x):
			return x.apply(instance, storage) { i, s, v in
				let ptr = Unmanaged.passRetained(v.callback).toOpaque()
				let sel = #selector(Window.Preparer.Storage.didPresentError(recovered:contextInfo:))
				i.presentError(v.value, modalFor: i, delegate: s, didPresent: sel, contextInfo: ptr)
			}
		case .printWindow(let x): return x.apply(instance) { i, v in i.printWindow(nil) }
		case .recalculateKeyViewLoop(let x): return x.apply(instance) { i, v in i.recalculateKeyViewLoop() }
		case .runToolbarCustomizationPalette(let x): return x.apply(instance) { i, v in i.runToolbarCustomizationPalette(nil) }
		case .selectNextKeyView(let x): return x.apply(instance) { i, v in i.selectNextKeyView(nil) }
		case .selectPreviousKeyView(let x): return x.apply(instance) { i, v in i.selectPreviousKeyView(nil) }
		case .sheet(let x): return x.apply(instance) { i, v in i.beginSheet(v.value) { r in _ = v.callback.send(value: r) } }
		case .toggleFullScreen(let x): return x.apply(instance) { i, v in i.toggleFullScreen(nil) }
		case .toggleToolbarShown(let x): return x.apply(instance) { i, v in i.toggleToolbarShown(nil) }
		case .zoom(let x): return x.apply(instance) { i, v in v ? i.performZoom(nil) : i.zoom(nil) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .effectiveAppearanceName(let x):
			return instance.observe(\.effectiveAppearance, options: [.initial, .new]) { instance, change in
				if let value = change.newValue {
					x.send(value: value.name)
				}
			}
		case .didBecomeKey(let x): return Signal.notifications(name: NSWindow.didBecomeKeyNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didBecomeMain(let x): return Signal.notifications(name: NSWindow.didBecomeMainNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeBackingProperties(let x):
			return Signal.notifications(name: NSWindow.didChangeBackingPropertiesNotification, object: instance).map { n in
				let cs = n.userInfo.flatMap { $0[NSWindow.oldColorSpaceUserInfoKey] as? NSColorSpace }
				let sf = n.userInfo.flatMap { ($0[NSWindow.oldScaleFactorUserInfoKey] as? NSNumber).map { CGFloat($0.doubleValue) } }
				return (oldColorSpace: cs, oldScaleFactor: sf )
			}.cancellableBind(to: x)
		case .didChangeOcclusionState(let x): return Signal.notifications(name: NSWindow.didChangeOcclusionStateNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeScreen(let x): return Signal.notifications(name: NSWindow.didChangeScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeScreenProfile(let x): return Signal.notifications(name: NSWindow.didChangeScreenProfileNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didDeminiaturize(let x): return Signal.notifications(name: NSWindow.didDeminiaturizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEndLiveResize(let x): return Signal.notifications(name: NSWindow.didEndLiveResizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEndSheet(let x): return Signal.notifications(name: NSWindow.didEndSheetNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEnterFullScreen(let x): return Signal.notifications(name: NSWindow.didEnterFullScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEnterVersionBrowser(let x): return Signal.notifications(name: NSWindow.didEnterVersionBrowserNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didExitFullScreen(let x): return Signal.notifications(name: NSWindow.didExitFullScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didExitVersionBrowser(let x): return Signal.notifications(name: NSWindow.didExitVersionBrowserNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didExpose(let x): return Signal.notifications(name: NSWindow.didExposeNotification, object: instance).compactMap { (n: Notification) -&gt; NSRect? in return (n.userInfo?["NSExposedRect"] as? NSValue)?.rectValue ?? nil }.cancellableBind(to: x)
		case .didMiniaturize(let x): return Signal.notifications(name: NSWindow.didMiniaturizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didMove(let x): return Signal.notifications(name: NSWindow.didMoveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didResignKey(let x): return Signal.notifications(name: NSWindow.didResignKeyNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didResignMain(let x): return Signal.notifications(name: NSWindow.didResignMainNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didResize(let x): return Signal.notifications(name: NSWindow.didResizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didUpdate(let x): return Signal.notifications(name: NSWindow.didUpdateNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willBeginSheet(let x): return Signal.notifications(name: NSWindow.willBeginSheetNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willClose(let x): return Signal.notifications(name: NSWindow.willCloseNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willEnterFullScreen(let x): return Signal.notifications(name: NSWindow.willEnterFullScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willEnterVersionBrowser(let x): return Signal.notifications(name: NSWindow.willEnterVersionBrowserNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willExitFullScreen(let x): return Signal.notifications(name: NSWindow.willExitFullScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willExitVersionBrowser(let x): return Signal.notifications(name: NSWindow.willExitVersionBrowserNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willMiniaturize(let x): return Signal.notifications(name: NSWindow.willMiniaturizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willMove(let x): return Signal.notifications(name: NSWindow.willMoveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willStartLiveResize(let x): return Signal.notifications(name: NSWindow.willStartLiveResizeNotification, object: instance).map { n in () }.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldClose: return nil
		case .shouldPopUpDocumentPathMenu: return nil
		case .shouldZoom: return nil
		case .willResize: return nil
		case .willResizeForVersionBrowser: return nil
		case .willUseFullScreenContentSize: return nil
		case .willUseFullScreenPresentationOptions: return nil
		case .willUseStandardFrame: return nil
		}
	}

	func finalizeInstance(_ instance: Instance, storage: Storage) -&gt; Lifetime? {
		var lifetimes = [Lifetime]()
		
		// Apply the autosave size
		let originalFrame = instance.frame
		lifetimes += frameAutosaveName?.apply(instance) { i, v in
			i.setFrameAutosaveName(v)
		}
		
		// The window's content size is now correct, so we can add and layout content.
		// NOTE: this must be done *after* the content size is established, otherwise some container-dependent layout will be done incorrectly.
		lifetimes += contentView?.apply(instance) { i, v in
			i.contentView = v.nsView()
		}
		instance.layoutIfNeeded()
		if let initialFirstResponder = initialFirstResponder {
			instance.initialFirstResponder = instance.contentView?.viewWithTag(initialFirstResponder)
		}
		
		// With content laid out, we can place the frame. NOTE: if autolayout has already placed the frame, respect that placement.
		var skipInitialPlacementIfAutosavePlacementOccurred = instance.frame != originalFrame
		lifetimes += frameHorizontal?.apply(instance) { i, v in
			if !skipInitialPlacementIfAutosavePlacementOccurred {
				i.setFrameOrigin(v.applyFrameHorizontal(i.screen, frameRect: i.frame))
			}
		}
		lifetimes += frameVertical?.apply(instance) { i, v in
			if !skipInitialPlacementIfAutosavePlacementOccurred {
				i.setFrameOrigin(v.applyFrameVertical(i.screen, frameRect: i.frame))
			}
		}
		skipInitialPlacementIfAutosavePlacementOccurred = false
		
		// Set intial order, key and main after everything else
		let captureOrder = order?.initialSubsequent()
		let captureKey = key?.initialSubsequent()
		let captureMain = main?.initialSubsequent()
		switch (captureOrder?.initial ?? .front) {
		case .front where captureKey?.initial == true: instance.makeKeyAndOrderFront(nil)
		case .front: fallthrough
		case .back: WindowOrder.back.applyToWindow(instance)
		case .out: break
		}
		if (captureMain?.initial ?? true) == true {
			instance.makeMain()
		}
		
		// Resume order, key and main
		lifetimes += captureOrder?.resume()?.apply(instance) { i, v in v.applyToWindow(i) }
		lifetimes += captureKey?.resume()?.apply(instance) { i, v in v ? i.makeKey() : i.resignKey() }
		lifetimes += captureMain?.resume()?.apply(instance) { i, v in v ? i.makeMain() : i.resignMain() }
		
		lifetimes += inheritedFinalizedInstance(instance, storage: storage)
		
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Window.Preparer {
	class Storage: View.Preparer.Storage, NSWindowDelegate {
		var windowSizeRelativity: WindowDimension.Relativity = .independent
		@objc func didPresentError(recovered: Bool, contextInfo: UnsafeMutableRawPointer?) {
			if let ptr = contextInfo {
				Unmanaged&lt;SignalInput&lt;Bool&gt;&gt;.fromOpaque(ptr).takeRetainedValue().send(value: recovered)
			}
		}
	}

	class Delegate: DynamicDelegate, NSWindowDelegate {
		func windowWillResize(_ window: NSWindow, to toSize: NSSize) -&gt; NSSize {
			return singleHandler(window, toSize)
		}
		
		func windowWillUseStandardFrame(_ window: NSWindow, defaultFrame: NSRect) -&gt; NSRect {
			return singleHandler(window, defaultFrame)
		}
		
		func windowShouldZoom(_ window: NSWindow, toFrame: NSRect) -&gt; Bool {
			return singleHandler(window, toFrame)
		}
		
		func window(_ window: NSWindow, willUseFullScreenContentSize param: NSSize) -&gt; NSSize {
			return singleHandler(window, param)
		}
		
		func window(_ window: NSWindow, willUseFullScreenPresentationOptions param: NSApplication.PresentationOptions) -&gt; NSApplication.PresentationOptions {
			return singleHandler(window, param)
		}
		
		func windowShouldClose(_ window: NSWindow) -&gt; Bool {
			return singleHandler(window)
		}
		
		func window(_ window: NSWindow, shouldPopUpDocumentPathMenu param: NSMenu) -&gt; Bool {
			return singleHandler(window, param)
		}
		
		func window(_ window: NSWindow, willResizeForVersionBrowserWithMaxPreferredSize: NSSize, maxAllowedSize: NSSize) -&gt; NSSize {
			return singleHandler(window, willResizeForVersionBrowserWithMaxPreferredSize, maxAllowedSize)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: WindowBinding {
	typealias WindowName&lt;V&gt; = BindingName&lt;V, Window.Binding, Binding&gt;
	private static func name&lt;V&gt;(_ source: @escaping (V) -&gt; Window.Binding) -&gt; WindowName&lt;V&gt; {
		return WindowName&lt;V&gt;(source: source, downcast: Binding.windowBinding)
	}
}
extension BindingName where Binding: WindowBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: WindowName&lt;$2&gt; { return .name(Window.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Static styles are applied at construction and are subsequently immutable.
	static var deferCreation: WindowName&lt;Constant&lt;Bool&gt;&gt; { return .name(Window.Binding.deferCreation) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var acceptsMouseMovedEvents: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.acceptsMouseMovedEvents) }
	static var allowsConcurrentViewDrawing: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.allowsConcurrentViewDrawing) }
	static var allowsToolTipsWhenApplicationIsInactive: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.allowsToolTipsWhenApplicationIsInactive) }
	static var alphaValue: WindowName&lt;Dynamic&lt;CGFloat&gt;&gt; { return .name(Window.Binding.alphaValue) }
	static var animationBehavior: WindowName&lt;Dynamic&lt;NSWindow.AnimationBehavior&gt;&gt; { return .name(Window.Binding.animationBehavior) }
	static var appearance: WindowName&lt;Dynamic&lt;NSAppearance?&gt;&gt; { return .name(Window.Binding.appearance) }
	static var autorecalculatesKeyViewLoop: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.autorecalculatesKeyViewLoop) }
	static var backingType: WindowName&lt;Dynamic&lt;NSWindow.BackingStoreType&gt;&gt; { return .name(Window.Binding.backingType) }
	static var canBecomeVisibleWithoutLogin: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.canBecomeVisibleWithoutLogin) }
	static var canHide: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.canHide) }
	static var collectionBehavior: WindowName&lt;Dynamic&lt;NSWindow.CollectionBehavior&gt;&gt; { return .name(Window.Binding.collectionBehavior) }
	static var colorSpace: WindowName&lt;Dynamic&lt;NSColorSpace&gt;&gt; { return .name(Window.Binding.colorSpace) }
	static var contentAspectRatio: WindowName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(Window.Binding.contentAspectRatio) }
	static var contentHeight: WindowName&lt;Dynamic&lt;WindowDimension&gt;&gt; { return .name(Window.Binding.contentHeight) }
	static var contentMaxSize: WindowName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(Window.Binding.contentMaxSize) }
	static var contentMinSize: WindowName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(Window.Binding.contentMinSize) }
	static var contentResizeIncrements: WindowName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(Window.Binding.contentResizeIncrements) }
	static var contentRelativity: WindowName&lt;Dynamic&lt;WindowDimension.Relativity&gt;&gt; { return .name(Window.Binding.contentRelativity) }
	static var contentView: WindowName&lt;Dynamic&lt;ViewConvertible&gt;&gt; { return .name(Window.Binding.contentView) }
	static var contentWidth: WindowName&lt;Dynamic&lt;WindowDimension&gt;&gt; { return .name(Window.Binding.contentWidth) }
	static var depthLimit: WindowName&lt;Dynamic&lt;NSWindow.Depth?&gt;&gt; { return .name(Window.Binding.depthLimit) }
	static var displaysWhenScreenProfileChanges: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.displaysWhenScreenProfileChanges) }
	static var frameAutosaveName: WindowName&lt;Dynamic&lt;NSWindow.FrameAutosaveName&gt;&gt; { return .name(Window.Binding.frameAutosaveName) }
	static var frameHorizontal: WindowName&lt;Dynamic&lt;WindowDimension&gt;&gt; { return .name(Window.Binding.frameHorizontal) }
	static var frameVertical: WindowName&lt;Dynamic&lt;WindowDimension&gt;&gt; { return .name(Window.Binding.frameVertical) }
	static var hasShadow: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.hasShadow) }
	static var hidesOnDeactivate: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.hidesOnDeactivate) }
	static var ignoresMouseEvents: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.ignoresMouseEvents) }
	static var isDocumentEdited: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.isDocumentEdited) }
	static var isExcludedFromWindowsMenu: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.isExcludedFromWindowsMenu) }
	static var isMovable: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.isMovable) }
	static var isMovableByWindowBackground: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.isMovableByWindowBackground) }
	static var isOpaque: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.isOpaque) }
	static var isRestorable: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.isRestorable) }
	static var key: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.key) }
	static var level: WindowName&lt;Dynamic&lt;NSWindow.Level&gt;&gt; { return .name(Window.Binding.level) }
	static var main: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.main) }
	static var maxFullScreenContentSize: WindowName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(Window.Binding.maxFullScreenContentSize) }
	static var minFullScreenContentSize: WindowName&lt;Dynamic&lt;NSSize&gt;&gt; { return .name(Window.Binding.minFullScreenContentSize) }
	static var miniwindowImage: WindowName&lt;Dynamic&lt;NSImage?&gt;&gt; { return .name(Window.Binding.miniwindowImage) }
	static var miniwindowTitle: WindowName&lt;Dynamic&lt;String&gt;&gt; { return .name(Window.Binding.miniwindowTitle) }
	static var order: WindowName&lt;Dynamic&lt;WindowOrder&gt;&gt; { return .name(Window.Binding.order) }
	static var preservesContentDuringLiveResize: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.preservesContentDuringLiveResize) }
	static var preventsApplicationTerminationWhenModal: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.preventsApplicationTerminationWhenModal) }
	static var representedURL: WindowName&lt;Dynamic&lt;URL?&gt;&gt; { return .name(Window.Binding.representedURL) }
	static var resizeStyle: WindowName&lt;Dynamic&lt;WindowResizeStyle&gt;&gt; { return .name(Window.Binding.resizeStyle) }
	static var restorationClass: WindowName&lt;Dynamic&lt;NSWindowRestoration.Type&gt;&gt; { return .name(Window.Binding.restorationClass) }
	static var screen: WindowName&lt;Dynamic&lt;NSScreen?&gt;&gt; { return .name(Window.Binding.screen) }
	static var sharingType: WindowName&lt;Dynamic&lt;NSWindow.SharingType&gt;&gt; { return .name(Window.Binding.sharingType) }
	static var styleMask: WindowName&lt;Dynamic&lt;NSWindow.StyleMask&gt;&gt; { return .name(Window.Binding.styleMask) }
	static var title: WindowName&lt;Dynamic&lt;String&gt;&gt; { return .name(Window.Binding.title) }
	static var titlebarAppearsTransparent: WindowName&lt;Dynamic&lt;Bool&gt;&gt; { return .name(Window.Binding.titlebarAppearsTransparent) }
	static var titleVisibility: WindowName&lt;Dynamic&lt;NSWindow.TitleVisibility&gt;&gt; { return .name(Window.Binding.titleVisibility) }
	static var toolbar: WindowName&lt;Dynamic&lt;ToolbarConvertible&gt;&gt; { return .name(Window.Binding.toolbar) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var close: WindowName&lt;Signal&lt;WindowCloseBehavior&gt;&gt; { return .name(Window.Binding.close) }
	static var criticalSheet: WindowName&lt;Signal&lt;Callback&lt;NSWindow, NSApplication.ModalResponse&gt;&gt;&gt; { return .name(Window.Binding.criticalSheet) }
	static var deminiaturize: WindowName&lt;Signal&lt;Void&gt;&gt; { return .name(Window.Binding.deminiaturize) }
	static var display: WindowName&lt;Signal&lt;Bool&gt;&gt; { return .name(Window.Binding.display) }
	static var invalidateShadow: WindowName&lt;Signal&lt;Void&gt;&gt; { return .name(Window.Binding.invalidateShadow) }
	static var miniaturize: WindowName&lt;Signal&lt;Bool&gt;&gt; { return .name(Window.Binding.miniaturize) }
	static var presentError: WindowName&lt;Signal&lt;Callback&lt;Error, Bool&gt;&gt;&gt; { return .name(Window.Binding.presentError) }
	static var printWindow: WindowName&lt;Signal&lt;Void&gt;&gt; { return .name(Window.Binding.printWindow) }
	static var recalculateKeyViewLoop: WindowName&lt;Signal&lt;Void&gt;&gt; { return .name(Window.Binding.recalculateKeyViewLoop) }
	static var runToolbarCustomizationPalette: WindowName&lt;Signal&lt;Void&gt;&gt; { return .name(Window.Binding.runToolbarCustomizationPalette) }
	static var selectNextKeyView: WindowName&lt;Signal&lt;Void&gt;&gt; { return .name(Window.Binding.selectNextKeyView) }
	static var selectPreviousKeyView: WindowName&lt;Signal&lt;Void&gt;&gt; { return .name(Window.Binding.selectPreviousKeyView) }
	static var sheet: WindowName&lt;Signal&lt;Callback&lt;NSWindow, NSApplication.ModalResponse&gt;&gt;&gt; { return .name(Window.Binding.sheet) }
	static var toggleFullScreen: WindowName&lt;Signal&lt;Void&gt;&gt; { return .name(Window.Binding.toggleFullScreen) }
	static var toggleToolbarShown: WindowName&lt;Signal&lt;Void&gt;&gt; { return .name(Window.Binding.toggleToolbarShown) }
	static var zoom: WindowName&lt;Signal&lt;Bool&gt;&gt; { return .name(Window.Binding.zoom) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var effectiveAppearanceName: WindowName&lt;SignalInput&lt;NSAppearance.Name&gt;&gt; { return .name(Window.Binding.effectiveAppearanceName) }
	static var didBecomeKey: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didBecomeKey) }
	static var didBecomeMain: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didBecomeMain) }
	static var didChangeBackingProperties: WindowName&lt;SignalInput&lt;(oldColorSpace: NSColorSpace?, oldScaleFactor: CGFloat?)&gt;&gt; { return .name(Window.Binding.didChangeBackingProperties) }
	static var didChangeOcclusionState: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didChangeOcclusionState) }
	static var didChangeScreen: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didChangeScreen) }
	static var didChangeScreenProfile: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didChangeScreenProfile) }
	static var didDeminiaturize: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didDeminiaturize) }
	static var didEndLiveResize: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didEndLiveResize) }
	static var didEndSheet: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didEndSheet) }
	static var didEnterFullScreen: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didEnterFullScreen) }
	static var didEnterVersionBrowser: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didEnterVersionBrowser) }
	static var didExitFullScreen: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didExitFullScreen) }
	static var didExitVersionBrowser: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didExitVersionBrowser) }
	static var didExpose: WindowName&lt;SignalInput&lt;NSRect&gt;&gt; { return .name(Window.Binding.didExpose) }
	static var didMiniaturize: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didMiniaturize) }
	static var didMove: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didMove) }
	static var didResignKey: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didResignKey) }
	static var didResignMain: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didResignMain) }
	static var didResize: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didResize) }
	static var didUpdate: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.didUpdate) }
	static var willBeginSheet: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.willBeginSheet) }
	static var willClose: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.willClose) }
	static var willEnterFullScreen: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.willEnterFullScreen) }
	static var willEnterVersionBrowser: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.willEnterVersionBrowser) }
	static var willExitFullScreen: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.willExitFullScreen) }
	static var willExitVersionBrowser: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.willExitVersionBrowser) }
	static var willMiniaturize: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.willMiniaturize) }
	static var willMove: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.willMove) }
	static var willStartLiveResize: WindowName&lt;SignalInput&lt;Void&gt;&gt; { return .name(Window.Binding.willStartLiveResize) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldClose: WindowName&lt;(NSWindow) -&gt; Bool&gt; { return .name(Window.Binding.shouldClose) }
	static var shouldPopUpDocumentPathMenu: WindowName&lt;(NSWindow, NSMenu) -&gt; Bool&gt; { return .name(Window.Binding.shouldPopUpDocumentPathMenu) }
	static var shouldZoom: WindowName&lt;(NSWindow, NSRect) -&gt; Bool&gt; { return .name(Window.Binding.shouldZoom) }
	static var willResize: WindowName&lt;(NSWindow, NSSize) -&gt; NSSize&gt; { return .name(Window.Binding.willResize) }
	static var willResizeForVersionBrowser: WindowName&lt;(_ window: NSWindow, _ maxPreferredSize: NSSize, _ maxAllowedSize: NSSize) -&gt; NSSize&gt; { return .name(Window.Binding.willResizeForVersionBrowser) }
	static var willUseFullScreenContentSize: WindowName&lt;(NSWindow, NSSize) -&gt; NSSize&gt; { return .name(Window.Binding.willUseFullScreenContentSize) }
	static var willUseFullScreenPresentationOptions: WindowName&lt;(NSWindow, NSApplication.PresentationOptions) -&gt; NSApplication.PresentationOptions&gt; { return .name(Window.Binding.willUseFullScreenPresentationOptions) }
	static var willUseStandardFrame: WindowName&lt;(NSWindow, NSRect) -&gt; NSRect&gt; { return .name(Window.Binding.willUseStandardFrame) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
protocol WindowConvertible {
	func nsWindow() -&gt; Window.Instance
}
extension NSWindow: WindowConvertible, DefaultConstructable, HasDelegate {
	func nsWindow() -&gt; Window.Instance { return self }
}
extension Window {
	func nsWindow() -&gt; Window.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
protocol WindowBinding: BinderBaseBinding {
	static func windowBinding(_ binding: Window.Binding) -&gt; Self
	func asWindowBinding() -&gt; Window.Binding?
}
extension WindowBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -&gt; Self {
		return windowBinding(.inheritedBinding(binding))
	}
}
extension WindowBinding where Preparer.Inherited.Binding: WindowBinding {
	func asWindowBinding() -&gt; Window.Binding? {
		return asInheritedBinding()?.asWindowBinding()
	}
}
extension Window.Binding {
	typealias Preparer = Window.Preparer
	func asInheritedBinding() -&gt; Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asWindowBinding() -&gt; Window.Binding? { return self }
	static func windowBinding(_ binding: Window.Binding) -&gt; Window.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
enum WindowCloseBehavior {
	case dismiss
	case perform
	case stopModal(NSApplication.ModalResponse)
}

enum WindowOrder {
	case front
	case back
	case out
	
	func applyToWindow(_ window: NSWindow) {
		switch self {
		case .front: window.orderFront(nil)
		case .back: window.orderBack(nil)
		case .out: window.orderOut(nil)
		}
	}
}

enum WindowResizeStyle {
	case increment(NSSize)
	case contentAspect(NSSize)
	
	static func normal() -&gt; WindowResizeStyle {
		return .increment(NSSize(width: 1.0, height: 1.0))
	}
}

struct WindowDimension: ExpressibleByIntegerLiteral, ExpressibleByFloatLiteral {
	typealias FloatLiteralType = Double
	typealias IntegerLiteralType = Int

	enum Relativity {
		case independent
		case widthRelativeToHeight
		case heightRelativeToWidth
	}
	
	let ratio: CGFloat
	let constant: CGFloat
	
	init(integerLiteral value: Int) {
		self.init(constant: CGFloat(value))
	}

	init(floatLiteral value: Double) {
		self.ratio = 0
		self.constant = CGFloat(value)
	}
	
	init(ratio: CGFloat = 0, constant: CGFloat = 0) {
		self.ratio = ratio
		self.constant = constant
	}
	
	static func ratio(_ ratio: CGFloat = 0, constant: CGFloat = 0) -&gt; WindowDimension {
		return WindowDimension(ratio: ratio, constant: constant)
	}
	
	static let fallbackWindowSize: CGFloat = 400
	
	static func contentSize&lt;W: NSWindow&gt;(width widthSize: WindowDimension, height heightSize: WindowDimension, relativity: Relativity, onScreen: NSScreen?, windowClass: W.Type, styleMask: NSWindow.StyleMask) -&gt; NSSize {
		let width: CGFloat
		let height: CGFloat
		switch relativity {
		case .widthRelativeToHeight:
			if heightSize.ratio != 0, let s = onScreen {
				let screenFrame = windowClass.contentRect(forFrameRect: s.visibleFrame, styleMask: styleMask)
				height = heightSize.ratio * screenFrame.height + heightSize.constant
			} else {
				height = heightSize.constant
			}
			width = widthSize.ratio * height + widthSize.constant
		case .heightRelativeToWidth:
			if widthSize.ratio != 0, let s = onScreen {
				let screenFrame = windowClass.contentRect(forFrameRect: s.visibleFrame, styleMask: styleMask)
				width = widthSize.ratio * screenFrame.height + widthSize.constant
			} else {
				width = widthSize.constant
			}
			height = heightSize.ratio * width + heightSize.constant
		case .independent:
			if (widthSize.ratio != 0 || heightSize.ratio != 0), let s = onScreen {
				let screenFrame = windowClass.contentRect(forFrameRect: s.visibleFrame, styleMask: styleMask)
				width = widthSize.ratio * screenFrame.height + widthSize.constant
				height = heightSize.ratio * screenFrame.height + heightSize.constant
			} else {
				width = widthSize.constant
				height = heightSize.constant
			}
		}
		return NSSize(width: width, height: height)
	}

	fileprivate func applyFrameValue(frameLength: CGFloat, screenAvailable: CGFloat) -&gt; CGFloat {
		let space = screenAvailable - frameLength
		if space &gt; 0 {
			return space * ratio + constant
		} else {
			return 0
		}
	}
	
	func applyFrameVertical(_ screen: NSScreen?, frameRect: NSRect) -&gt; NSPoint {
		guard let visible = screen?.visibleFrame else {
			return frameRect.origin
		}
		
		let offset = applyFrameValue(frameLength: frameRect.size.height, screenAvailable: visible.size.height)
		let y = visible.origin.y + visible.size.height - frameRect.size.height - offset
		return NSPoint(x: frameRect.origin.x, y: y)
	}
	
	func applyFrameHorizontal(_ screen: NSScreen?, frameRect: NSRect) -&gt; NSPoint {
		guard let visible = screen?.visibleFrame else {
			return frameRect.origin
		}
		
		let offset = applyFrameValue(frameLength: frameRect.size.width, screenAvailable: visible.size.width)
		let x = visible.origin.x + offset
		return NSPoint(x: x, y: frameRect.origin.y)
	}
}

extension NSWindow: Lifetime {
	static var titleBarHeight: CGFloat {
		return NSWindow.frameRect(forContentRect: .zero, styleMask: [.titled]).height
	}
	
	static var integratedToolbarHeight: CGFloat {
		return 24 + 8 + 8 // is there a smarter way to calculate this?
	}
	
	func cancel() {
		return nsWindow().close()
	}
}

#endif
</string>
			<key>Group</key>
			<string>Dependencies</string>
		</dict>
		<key>Info.plist:DeploymentTarget</key>
		<string>&lt;key&gt;LSMinimumSystemVersion&lt;/key&gt;&lt;string&gt;$(MACOSX_DEPLOYMENT_TARGET)&lt;/string&gt;</string>
		<key>Info.plist:Icon</key>
		<string>&lt;key&gt;CFBundleIconFile&lt;/key&gt;&lt;string&gt;NSApplication&lt;/string&gt;</string>
		<key>Info.plist:MainNib</key>
		<string></string>
		<key>Info.plist:PrincipalClass</key>
		<string>&lt;key&gt;NSPrincipalClass&lt;/key&gt;&lt;string&gt;NSApplication&lt;/string&gt;</string>
		<key>Model/Document.swift</key>
		<dict>
			<key>Group</key>
			<string>Model</string>
		</dict>
		<key>Model/Document.swift:content</key>
		<string>struct Document {
	struct Contents: Codable {
		var rows: [String]
		var lastAddedIndex: Int
	}
	
	let services: Services
	var contents: Contents
}

extension Document {
	enum Action {
		case add
		case save
		case removeAtIndex(Int)
	}
	enum Change {
		case addedRowIndex(Int)
		case removedRowIndex(Int)
		case reload
		case none
	}
	
	func save() throws {
		try services.fileService.writeData(JSONEncoder().encode(contents), to: Document.saveUrl(services: services))	
	}
	
	mutating func apply(_ change: Action) throws -&gt; Change {
		switch change {
		case .add:
			contents.lastAddedIndex += 1
			contents.rows.append(String(describing: contents.lastAddedIndex))
			return .addedRowIndex(contents.rows.count - 1)
		case .removeAtIndex(let i):
			if contents.rows.indices.contains(i) {
				contents.rows.remove(at: i)
				return .removedRowIndex(i)
			}
			return .none
		case .save:
			try save()
			return .none
		}
	}
}

extension Document {
	
	init(services: Services) {
		self.services = services
		do {
			let url = try Document.saveUrl(services: services)
			if services.fileService.fileExists(at: url) {
				self.contents = try JSONDecoder().decode(Document.Contents.self, from: services.fileService.data(contentsOf: url))
				return
			}
		} catch {
		}
		
		self.contents = Document.initialContents()
	}
	
	static func initialContents() -&gt; Document.Contents {
		return Document.Contents(rows: ["1", "2", "3"], lastAddedIndex: 3)
	}
	
	static func saveUrl(services: Services) throws -&gt; URL {
		return try services.fileService.applicationSupportURL().appendingPathComponent(.documentFileName)
	}
	
}

private extension String {
	static let documentFileName = "document.json"
}</string>
		<key>Model/DocumentAdapter.swift</key>
		<dict>
			<key>Group</key>
			<string>Model</string>
		</dict>
		<key>Model/DocumentAdapter.swift:content</key>
		<string>typealias DocumentAdapter = Adapter&lt;ModelState&lt;Document, Document.Action, Document.Change&gt;&gt;
extension Adapter where State == ModelState&lt;Document, Document.Action, Document.Change&gt; {
	init(document: Document) {
		self.init(adapterState: ModelState(
			async: false,
			initial: document,
			resumer: { model -&gt; Document.Change? in
				.reload
			},
			reducer: { model, message, feedback -&gt; Document.Change? in try? model.apply(message) }
		))
	}
	
	func rowsSignal() -&gt; Signal&lt;TableRowMutation&lt;String&gt;&gt; {
		return slice(resume: .reload) { document, notification -&gt; Signal&lt;TableRowMutation&lt;String&gt;&gt;.Next in
			switch notification {
			case .addedRowIndex(let i): return .value(.inserted(document.contents.rows[i], at: i))
			case .removedRowIndex(let i): return .value(.deleted(at: i))
			case .reload: return .value(.reload(document.contents.rows))
			case .none: return .none
			}
		}
	}
}</string>
		<key>Services.swift:content</key>
		<string>struct Services {
	let fileService: FileService
}

protocol FileService {
	func applicationSupportURL() throws -&gt; URL
	func data(contentsOf: URL) throws -&gt; Data
	func writeData(_ data: Data, to: URL) throws
	func fileExists(at: URL) -&gt; Bool
}

extension FileManager: FileService {
	func applicationSupportURL() throws -&gt; URL {
		return try FileManager.default.url(for: .applicationSupportDirectory, in: .userDomainMask, appropriateFor: nil, create: true)
	}
	
	func data(contentsOf url: URL) throws -&gt; Data {
		return try Data(contentsOf: url)
	}
	
	func writeData(_ data: Data, to url: URL) throws {
		try data.write(to: url)
	}
	
	func fileExists(at url: URL) -&gt; Bool {
		var isDirectory: ObjCBool = false
		let exists = FileManager.default.fileExists(atPath: url.path, isDirectory: &amp;isDirectory)
		return exists &amp;&amp; !isDirectory.boolValue
	}
}</string>
		<key>View/DetailView.swift</key>
		<dict>
			<key>Group</key>
			<string>View</string>
		</dict>
		<key>View/DetailView.swift:content</key>
		<string>struct DetailState: CodableContainer {
	let index: Int
	let value: String
}

func detailContainer(_ windowState: WindowState) -&gt; ViewConvertible {
	return View(
		.layout &lt;-- windowState.rowSelection.map { selection in
			.vertical(
				animation: Layout.Animation(style: .fade, duration: 0.1),
				.inset(
					margins: NSEdgeInsets(top: 8, left: 8, bottom: 8, right: 8),
					.view(selection.map(detailView) ?? emptyDetail())
				)
			)
		}
	)
}

func emptyDetail() -&gt; ViewConvertible {
	return TextField.label(
		.stringValue -- .noItemSelected,
		.verticalContentHuggingPriority -- .layoutLow
	)
}

private func detailView(_ detailState: DetailState) -&gt; ViewConvertible {
	return TextField.label(
		.stringValue -- .contentLabel(detailState.value),
		.verticalContentHuggingPriority -- .layoutLow
	)
}

private extension String {
	static func contentLabel(_ row: String) -&gt; String {
		return String.localizedStringWithFormat(NSLocalizedString("Row %@ selected", comment: ""), row)
	}
	static let noItemSelected = NSLocalizedString("No item selected", comment: "")
}</string>
		<key>View/MainMenu.swift</key>
		<dict>
			<key>Group</key>
			<string>View</string>
		</dict>
		<key>View/MainMenu.swift:content</key>
		<string>import CoreMedia

func mainMenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(.submenu -- applicationMenu()),
			MenuItem(.submenu -- fileMenu()),
			MenuItem(.submenu -- editMenu()),
			MenuItem(.submenu -- formatMenu()),
			MenuItem(.submenu -- viewMenu()),
			MenuItem(.submenu -- windowsMenu()),
			MenuItem(.submenu -- helpMenu()),
		]
	)
}

fileprivate let executableName = (Bundle.main.localizedInfoDictionary?[kCFBundleNameKey as String] as? String) ?? (Bundle.main.localizedInfoDictionary?[kCFBundleExecutableKey as String] as? String) ?? ProcessInfo.processInfo.processName

func applicationMenu() -&gt; Menu {
	return Menu(
		.systemName -- .apple,
		.title -- executableName,
		.items -- [
			MenuItem(
				.title -- String(format: NSLocalizedString("About %@", tableName: "MainMenu", comment: "Application menu item"), executableName),
				.action --&gt; #selector(NSApplication.orderFrontStandardAboutPanel(_:))
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Preferencesâ¦", tableName: "MainMenu", comment: "Application menu item"),
				.keyEquivalent -- ","
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Services", tableName: "MainMenu", comment: "Application menu item"),
				.submenu -- Menu(.systemName -- .services)
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- String(format: NSLocalizedString("Hide %@", tableName: "MainMenu", comment: "Application menu item"), executableName),
				.action --&gt; #selector(NSApplication.hide(_:)),
				.keyEquivalent -- "h"
			),
			MenuItem(
				.title -- NSLocalizedString("Hide Others", tableName: "MainMenu", comment: "Application menu item"),
				.action --&gt; #selector(NSApplication.hideOtherApplications(_:)),
				.keyEquivalent -- "h",
				.keyEquivalentModifierMask -- [.option, .command]
			),
			MenuItem(
				.title -- NSLocalizedString("Show All", tableName: "MainMenu", comment: "Application menu item"),
				.action --&gt; #selector(NSApplication.unhideAllApplications(_:))
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- String(format: NSLocalizedString("Quit %@", tableName: "MainMenu", comment: "Application menu item"), executableName),
				.action --&gt; #selector(NSApplication.terminate(_:)),
				.keyEquivalent -- "q"
			)
		]
	)
}

func fileMenu() -&gt; Menu {
	return Menu(
		.title -- NSLocalizedString("File", tableName: "MainMenu", comment: "Standard menu title"),
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("New", tableName: "MainMenu", comment: "File menu item"),
				.action --&gt; #selector(NSDocumentController.newDocument(_:)),
				.keyEquivalent -- "n"
			),
			MenuItem(
				.title -- NSLocalizedString("Openâ¦", tableName: "MainMenu", comment: "File menu item"),
				.action --&gt; #selector(NSDocumentController.openDocument(_:)),
				.keyEquivalent -- "o"
			),
			MenuItem(
				.title -- NSLocalizedString("Open Recent", tableName: "MainMenu", comment: "File menu item"),
				.submenu -- Menu(
					.systemName -- .recentDocuments,
					.items -- [
						MenuItem(
							.title -- NSLocalizedString("Clear Menu", tableName: "MainMenu", comment: "File menu item"),
							.action --&gt; #selector(NSDocumentController.clearRecentDocuments(_:))
						)
					]
				)
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Close", tableName: "MainMenu", comment: "File menu item"),
				.action --&gt; #selector(NSWindow.performClose(_:)),
				.keyEquivalent -- "w"
			),
			MenuItem(
				.title -- NSLocalizedString("Saveâ¦", tableName: "MainMenu", comment: "File menu item"),
				.action --&gt; #selector(NSDocument.save(_:)),
				.keyEquivalent -- "s"
			),
			MenuItem(
				.title -- NSLocalizedString("Save Asâ¦", tableName: "MainMenu", comment: "File menu item"),
				.action --&gt; #selector(NSDocument.saveAs(_:)),
				.keyEquivalent -- "s",
				.keyEquivalentModifierMask -- [.shift, .command]
			),
			MenuItem(
				.title -- NSLocalizedString("Revert to Saved", tableName: "MainMenu", comment: "File menu item"),
				.action --&gt; #selector(NSDocument.revertToSaved(_:)),
				.keyEquivalent -- "r"
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Page Setupâ¦", tableName: "MainMenu", comment: "File menu item"),
				.action --&gt; #selector(NSDocument.runPageLayout(_:)),
				.keyEquivalent -- "p",
				.keyEquivalentModifierMask -- [.shift, .command]
			),
			MenuItem(
				.title -- NSLocalizedString("Printâ¦", tableName: "MainMenu", comment: "File menu item"),
				.action --&gt; #selector(NSDocument.printDocument),
				.keyEquivalent -- "p"
			)
		]
	)
}

func editMenu() -&gt; Menu {
	return Menu(
		.title -- NSLocalizedString("Edit", tableName: "MainMenu", comment: "Standard menu title"),
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Undo", tableName: "MainMenu", comment: "Edit menu item"),
				.action --&gt; Selector(("undo:")),
				.keyEquivalent -- "z"
			),
			MenuItem(
				.title -- NSLocalizedString("Redo", tableName: "MainMenu", comment: "Edit menu item"),
				.action --&gt; Selector(("redo:")),
				.keyEquivalent -- "Z",
				.keyEquivalentModifierMask -- [.shift, .command]
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Cut", tableName: "MainMenu", comment: "Edit menu item"),
				.action --&gt; #selector(NSText.cut(_:)),
				.keyEquivalent -- "x"
			),
			MenuItem(
				.title -- NSLocalizedString("Copy", tableName: "MainMenu", comment: "Edit menu item"),
				.action --&gt; #selector(NSText.copy(_:)),
				.keyEquivalent -- "c"
			),
			MenuItem(
				.title -- NSLocalizedString("Paste", tableName: "MainMenu", comment: "Edit menu item"),
				.action --&gt; #selector(NSText.paste(_:)),
				.keyEquivalent -- "v"
			),
			MenuItem(
				.title -- NSLocalizedString("Paste and Match Style", tableName: "MainMenu", comment: "Edit menu item"),
				.action --&gt; #selector(NSTextView.pasteAsPlainText(_:)),
				.keyEquivalent -- "v",
				.keyEquivalentModifierMask -- [.shift, .option, .command]
			),
			MenuItem(
				.title -- NSLocalizedString("Delete", tableName: "MainMenu", comment: "Edit menu item"),
				.action --&gt; #selector(NSText.delete(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Select All", tableName: "MainMenu", comment: "Edit menu item"),
				.action --&gt; #selector(NSText.selectAll(_:)),
				.keyEquivalent -- "a"
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Find", tableName: "MainMenu", comment: "Edit menu item"),
				.submenu -- findSubmenu()
			),
			MenuItem(
				.title -- NSLocalizedString("Spelling and Grammar", tableName: "MainMenu", comment: "Edit menu item"),
				.submenu -- spellingAndGrammarSubmenu()
			),
			MenuItem(
				.title -- NSLocalizedString("Substitutions", tableName: "MainMenu", comment: "Edit menu item"),
				.submenu -- substitutionsSubmenu()
			),
			MenuItem(
				.title -- NSLocalizedString("Transformations", tableName: "MainMenu", comment: "Edit menu item"),
				.submenu -- transformationsSubmenu()
			),
			MenuItem(
				.title -- NSLocalizedString("Speech", tableName: "MainMenu", comment: "Edit menu item"),
				.submenu -- speechSubmenu() 
			)
		]
	)
}

func formatMenu() -&gt; Menu {
	return Menu(
		.title -- NSLocalizedString("Format", tableName: "MainMenu", comment: "Standard menu title"),
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Font", tableName: "MainMenu", comment: "Format menu item"),
				.submenu -- fontSubmenu()
			),
			MenuItem(
				.title -- NSLocalizedString("Text", tableName: "MainMenu", comment: "Format menu item"),
				.submenu -- textSubmenu()
			)
		]
	)
}

func viewMenu() -&gt; Menu {
	return Menu(
		.title -- NSLocalizedString("View", tableName: "MainMenu", comment: "Standard menu title"),
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Show Toolbar", tableName: "MainMenu", comment: "View menu item"),
				.action --&gt; #selector(NSWindow.toggleToolbarShown(_:)),
				.keyEquivalent -- "t",
				.keyEquivalentModifierMask -- [.option, .command]
			),
			MenuItem(
				.title -- NSLocalizedString("Customize Toolbarâ¦", tableName: "MainMenu", comment: "View menu item"),
				.action --&gt; #selector(NSWindow.runToolbarCustomizationPalette(_:))
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Show Sidebar", tableName: "MainMenu", comment: "View menu item"),
				.action --&gt; NSSelectorFromString("toggleSourceList:"),
				.keyEquivalent -- "s",
				.keyEquivalentModifierMask -- [.control, .command]
			),
			MenuItem(
				.title -- NSLocalizedString("Enter Full Screen", tableName: "MainMenu", comment: "View menu item"),
				.action --&gt; #selector(NSWindow.toggleFullScreen(_:)),
				.keyEquivalent -- "f",
				.keyEquivalentModifierMask -- [.control, .command]
			)
		]
	)
}

func windowsMenu() -&gt; Menu {
	return Menu(
		.systemName -- .windows,
		.title -- NSLocalizedString("Window", tableName: "MainMenu", comment: "Standard menu title"),
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Minimize", tableName: "MainMenu", comment: "Window menu item"),
				.action --&gt; #selector(NSWindow.performMiniaturize(_:)),
				.keyEquivalent -- "m"
			),
			MenuItem(
				.title -- NSLocalizedString("Zoom", tableName: "MainMenu", comment: "Window menu item"),
				.action --&gt; #selector(NSWindow.performZoom(_:))
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Bring All to Front", tableName: "MainMenu", comment: "Window menu item"),
				.action --&gt; #selector(NSApplication.arrangeInFront(_:)),
				.keyEquivalent -- "s",
				.keyEquivalentModifierMask -- [.control, .command]
			)
		]
	)
}

func helpMenu() -&gt; Menu {
	return Menu(
		.systemName -- .help,
		.title -- NSLocalizedString("Help", tableName: "MainMenu", comment: "Standard menu title"),
		.items -- [
			MenuItem(
				.title -- String(format: NSLocalizedString("%@ Help", tableName: "MainMenu", comment: "Help menu item"), executableName),
				.action --&gt; #selector(NSApplication.showHelp(_:)),
				.keyEquivalent -- "?"
			)
		]
	)
}

func findSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Findâ¦", tableName: "MainMenu", comment: "Find menu item"),
				.action --&gt; #selector(NSTextView.performFindPanelAction(_:)),
				.keyEquivalent -- "f",
				.tag -- 1
			),
			MenuItem(
				.title -- NSLocalizedString("Find and Replaceâ¦", tableName: "MainMenu", comment: "Find menu item"),
				.action --&gt; #selector(NSTextView.performFindPanelAction(_:)),
				.keyEquivalent -- "f",
				.keyEquivalentModifierMask -- [.option, .command],
				.tag -- 12
			),
			MenuItem(
				.title -- NSLocalizedString("Find Next", tableName: "MainMenu", comment: "Find menu item"),
				.action --&gt; #selector(NSTextView.performFindPanelAction(_:)),
				.keyEquivalent -- "g",
				.tag -- 2
			),
			MenuItem(
				.title -- NSLocalizedString("Find Previous", tableName: "MainMenu", comment: "Find menu item"),
				.action --&gt; #selector(NSTextView.performFindPanelAction(_:)),
				.keyEquivalent -- "g",
				.keyEquivalentModifierMask -- [.shift, .command],
				.tag -- 3
			),
			MenuItem(
				.title -- NSLocalizedString("Use Selection for Find", tableName: "MainMenu", comment: "Find menu item"),
				.action --&gt; #selector(NSTextView.performFindPanelAction(_:)),
				.keyEquivalent -- "e",
				.tag -- 7
			),
			MenuItem(
				.title -- NSLocalizedString("Jump to Selection", tableName: "MainMenu", comment: "Find menu item"),
				.action --&gt; #selector(NSResponder.centerSelectionInVisibleArea(_:)),
				.keyEquivalent -- "j"
			)
		]
	)
}

func spellingAndGrammarSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Show Spelling and Grammar", tableName: "MainMenu", comment: "Spelling menu item"),
				.action --&gt; #selector(NSText.showGuessPanel(_:)),
				.keyEquivalent -- ":"
			),
			MenuItem(
				.title -- NSLocalizedString("Check Document Now", tableName: "MainMenu", comment: "Spelling menu item"),
				.action --&gt; #selector(NSText.checkSpelling(_:)),
				.keyEquivalent -- ";"
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Check Spelling While Typing", tableName: "MainMenu", comment: "Spelling menu item"),
				.action --&gt; #selector(NSTextView.toggleContinuousSpellChecking(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Check Grammar With Spelling", tableName: "MainMenu", comment: "Spelling menu item"),
				.action --&gt; #selector(NSTextView.toggleGrammarChecking(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Correct Spelling Automatically", tableName: "MainMenu", comment: "Spelling menu item"),
				.action --&gt; #selector(NSTextView.toggleAutomaticSpellingCorrection(_:))
			)
		]
	)
}

func substitutionsSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Show Substitutions", tableName: "MainMenu", comment: "Substitutions menu item"),
				.action --&gt; #selector(NSTextView.orderFrontSubstitutionsPanel(_:)),
				.keyEquivalent -- ":"
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Smart Copy/Paste", tableName: "MainMenu", comment: "Substitutions menu item"),
				.action --&gt; #selector(NSTextView.toggleSmartInsertDelete(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Smart Quotes", tableName: "MainMenu", comment: "Substitutions menu item"),
				.action --&gt; #selector(NSTextView.toggleAutomaticQuoteSubstitution(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Smart Dashes", tableName: "MainMenu", comment: "Substitutions menu item"),
				.action --&gt; #selector(NSTextView.toggleAutomaticDashSubstitution(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Smart Links", tableName: "MainMenu", comment: "Substitutions menu item"),
				.action --&gt; #selector(NSTextView.toggleAutomaticLinkDetection(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Data Detectors", tableName: "MainMenu", comment: "Substitutions menu item"),
				.action --&gt; #selector(NSTextView.toggleAutomaticDataDetection(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Text Replacement", tableName: "MainMenu", comment: "Substitutions menu item"),
				.action --&gt; #selector(NSTextView.toggleAutomaticTextReplacement(_:))
			)
		]
	)
}

func transformationsSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Make Upper Case", tableName: "MainMenu", comment: "Tubstitutions menu item"),
				.action --&gt; #selector(NSResponder.uppercaseWord(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Make Lower Case", tableName: "MainMenu", comment: "Tubstitutions menu item"),
				.action --&gt; #selector(NSResponder.lowercaseWord(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Capitalize", tableName: "MainMenu", comment: "Tubstitutions menu item"),
				.action --&gt; #selector(NSResponder.capitalizeWord(_:))
			)
		]
	)
}

func speechSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Start Speaking", tableName: "MainMenu", comment: "Speech menu item"),
				.action --&gt; #selector(NSTextView.startSpeaking(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Stop Speaking", tableName: "MainMenu", comment: "Speech menu item"),
				.action --&gt; #selector(NSTextView.stopSpeaking(_:))
			)
		]
	)
}

func fontSubmenu() -&gt; Menu {
	return Menu(
		.systemName -- .font,
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Show Fonts", tableName: "MainMenu", comment: "Font menu item"),
				.action --&gt; #selector(NSFontManager.orderFrontFontPanel(_:)),
				.keyEquivalent -- "t"
			),
			MenuItem(
				.title -- NSLocalizedString("Bold", tableName: "MainMenu", comment: "Font menu item"),
				.action --&gt; #selector(NSFontManager.addFontTrait(_:)),
				.keyEquivalent -- "b",
				.tag -- 2
			),
			MenuItem(
				.title -- NSLocalizedString("Italic", tableName: "MainMenu", comment: "Font menu item"),
				.action --&gt; #selector(NSFontManager.addFontTrait(_:)),
				.keyEquivalent -- "i",
				.tag -- 1
			),
			MenuItem(
				.title -- NSLocalizedString("Underline", tableName: "MainMenu", comment: "Font menu item"),
				.action --&gt; #selector(NSText.underline(_:)),
				.keyEquivalent -- "u"
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Bigger", tableName: "MainMenu", comment: "Font menu item"),
				.action --&gt; #selector(NSFontManager.modifyFont(_:)),
				.keyEquivalent -- "+",
				.tag -- 3
			),
			MenuItem(
				.title -- NSLocalizedString("Smaller", tableName: "MainMenu", comment: "Font menu item"),
				.action --&gt; #selector(NSFontManager.modifyFont(_:)),
				.keyEquivalent -- "-",
				.tag -- 4
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Kern", tableName: "MainMenu", comment: "Font menu item"),
				.submenu -- kernSubmenu()
			),
			MenuItem(
				.title -- NSLocalizedString("Ligatures", tableName: "MainMenu", comment: "Font menu item"),
				.submenu -- ligaturesSubmenu()
			),
			MenuItem(
				.title -- NSLocalizedString("Baseline", tableName: "MainMenu", comment: "Font menu item"),
				.submenu -- baselineSubmenu()
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Show Colors", tableName: "MainMenu", comment: "Font menu item"),
				.action --&gt; #selector(NSApplication.orderFrontColorPanel(_:)),
				.keyEquivalent -- "c",
				.keyEquivalentModifierMask -- [.shift, .command]
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Copy Style", tableName: "MainMenu", comment: "Font menu item"),
				.action --&gt; #selector(NSText.copyFont(_:)),
				.keyEquivalent -- "c",
				.keyEquivalentModifierMask -- [.option, .command]
			),
			MenuItem(
				.title -- NSLocalizedString("Paste Style", tableName: "MainMenu", comment: "Font menu item"),
				.action --&gt; #selector(NSText.pasteFont(_:)),
				.keyEquivalent -- "v",
				.keyEquivalentModifierMask -- [.option, .command]
			)
		]
	)
}

func textSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Align Left", tableName: "MainMenu", comment: "Text menu item"),
				.action --&gt; #selector(NSText.alignLeft(_:)),
				.keyEquivalent -- "{"
			),
			MenuItem(
				.title -- NSLocalizedString("Center", tableName: "MainMenu", comment: "Text menu item"),
				.action --&gt; #selector(NSText.alignCenter(_:)),
				.keyEquivalent -- "|"
			),
			MenuItem(
				.title -- NSLocalizedString("Justify", tableName: "MainMenu", comment: "Text menu item"),
				.action --&gt; #selector(NSTextView.alignJustified(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Align Right", tableName: "MainMenu", comment: "Text menu item"),
				.action --&gt; #selector(NSText.alignLeft(_:)),
				.keyEquivalent -- "}"
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Writing Direction", tableName: "MainMenu", comment: "Text menu item"),
				.submenu -- writingDirectionSubmenu()
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Show Ruler", tableName: "MainMenu", comment: "Text menu item"),
				.action --&gt; #selector(NSText.toggleRuler(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Copy Ruler", tableName: "MainMenu", comment: "Text menu item"),
				.action --&gt; #selector(NSText.copyRuler(_:)),
				.keyEquivalent -- "c",
				.keyEquivalentModifierMask -- [.control, .command]
			),
			MenuItem(
				.title -- NSLocalizedString("Paste Ruler", tableName: "MainMenu", comment: "Text menu item"),
				.action --&gt; #selector(NSText.pasteRuler(_:)),
				.keyEquivalent -- "v",
				.keyEquivalentModifierMask -- [.control, .command]
			)
		]
	)
}

func kernSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Use Default", tableName: "MainMenu", comment: "Kern menu item"),
				.action --&gt; #selector(NSTextView.useStandardKerning(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Use None", tableName: "MainMenu", comment: "Kern menu item"),
				.action --&gt; #selector(NSTextView.turnOffKerning(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Tighten", tableName: "MainMenu", comment: "Kern menu item"),
				.action --&gt; #selector(NSTextView.tightenKerning(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Loosen", tableName: "MainMenu", comment: "Kern menu item"),
				.action --&gt; #selector(NSTextView.loosenKerning(_:))
			)
		]
	)
}

func ligaturesSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Use Default", tableName: "MainMenu", comment: "Ligatures menu item"),
				.action --&gt; #selector(NSTextView.useStandardLigatures(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Use None", tableName: "MainMenu", comment: "Ligatures menu item"),
				.action --&gt; #selector(NSTextView.turnOffLigatures(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Use All", tableName: "MainMenu", comment: "Ligatures menu item"),
				.action --&gt; #selector(NSTextView.useAllLigatures(_:))
			)
		]
	)
}

func baselineSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Use Default", tableName: "MainMenu", comment: "Baseline menu item"),
				.action --&gt; #selector(NSTextView.unscript(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Superscript", tableName: "MainMenu", comment: "Baseline menu item"),
				.action --&gt; #selector(NSTextView.superscript(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Subscript", tableName: "MainMenu", comment: "Baseline menu item"),
				.action --&gt; #selector(NSTextView.subscript(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Raise", tableName: "MainMenu", comment: "Baseline menu item"),
				.action --&gt; #selector(NSTextView.raiseBaseline(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("Lower", tableName: "MainMenu", comment: "Baseline menu item"),
				.action --&gt; #selector(NSTextView.lowerBaseline(_:))
			)
		]
	)
}

func writingDirectionSubmenu() -&gt; Menu {
	return Menu(
		.items -- [
			MenuItem(
				.title -- NSLocalizedString("Paragraph", tableName: "MainMenu", comment: "Writing direction menu item"),
				.isEnabled -- false
			),
			MenuItem(
				.title -- NSLocalizedString("\tDefault", tableName: "MainMenu", comment: "Writing direction menu item"),
				.action --&gt; #selector(NSResponder.makeBaseWritingDirectionNatural(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("\tLeft to Right", tableName: "MainMenu", comment: "Writing direction menu item"),
				.action --&gt; #selector(NSResponder.makeBaseWritingDirectionLeftToRight(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("\tRight to Left", tableName: "MainMenu", comment: "Writing direction menu item"),
				.action --&gt; #selector(NSResponder.makeBaseWritingDirectionRightToLeft(_:))
			),
			NSMenuItem.separator(),
			MenuItem(
				.title -- NSLocalizedString("Selection", tableName: "MainMenu", comment: "Writing direction menu item"),
				.isEnabled -- false
			),
			MenuItem(
				.title -- NSLocalizedString("\tDefault", tableName: "MainMenu", comment: "Writing direction menu item"),
				.action --&gt; #selector(NSResponder.makeTextWritingDirectionNatural(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("\tLeft to Right", tableName: "MainMenu", comment: "Writing direction menu item"),
				.action --&gt; #selector(NSResponder.makeTextWritingDirectionLeftToRight(_:))
			),
			MenuItem(
				.title -- NSLocalizedString("\tRight to Left", tableName: "MainMenu", comment: "Writing direction menu item"),
				.action --&gt; #selector(NSResponder.makeTextWritingDirectionRightToLeft(_:))
			)
		]
	)
}</string>
		<key>View/Window.swift</key>
		<dict>
			<key>Group</key>
			<string>View</string>
		</dict>
		<key>View/Window.swift:content</key>
		<string>struct WindowState: CodableContainer {
	let rowSelection: Var&lt;DetailState?&gt;
	init() {
		rowSelection = Var(nil)
	}
}

func window(_ windowState: WindowState, _ doc: DocumentAdapter) -&gt; WindowConvertible {
	return Window(
		.contentWidth -- 650,
		.contentHeight -- 350,
		.frameAutosaveName -- Bundle.main.bundleIdentifier! + ".window",
		.frameHorizontal -- 15,
		.frameVertical -- 15,
		.styleMask -- [.titled, .resizable, .closable, .miniaturizable],
		.title -- .windowTitle,
		.contentView -- SplitView.verticalThin(
			.autosaveName -- Bundle.main.bundleIdentifier! + ".split",
			.arrangedSubviews -- [
				.subview(
					masterView(windowState, doc),
					holdingPriority: .layoutMid,
					constraints: .equalTo(ratio: 0.3, priority: .layoutLow)
				),
				.subview(
					detailContainer(windowState)
				)
			]
		)
	)
}

private func masterView(_ windowState: WindowState, _ doc: DocumentAdapter) -&gt; ViewConvertible {
	return View(
		.layout -- .vertical(
			align: .fill,
			.view(
				length: .fillRemaining,
				TableView&lt;String&gt;.scrollEmbedded(
					.rows &lt;-- doc.rowsSignal().tableData(),
					.focusRingType -- .none,
					.usesAutomaticRowHeights -- true,
					.columns -- [
						TableColumn&lt;String&gt;(
							.title -- .rowsColumnTitle,
							.cellConstructor(cellView)
						)
					],
					.cellSelected() --&gt; Input().map(DetailState.init).bind(to: windowState.rowSelection)
				)
			),
			.space(),
			.horizontal(
				.space(),
				.pair(
					.view(Button(
						.bezelStyle -- .rounded,
						.title -- "Add",
						.action() --&gt; Input().map { .add }.bind(to: doc)
					)),
					.view(Button(
						.bezelStyle -- .rounded,
						.title -- "Remove",
						.isEnabled &lt;-- windowState.rowSelection.map { $0 != nil },
						.action() --&gt; Input()
							.withLatestFrom(windowState.rowSelection)
							.compactMap { detail in (detail?.index).map { .removeAtIndex($0) } }
							.bind(to: doc)
					))
				),
				.space()
			),
			.space()
		)
	)
}

private func cellView(_ identifier: NSUserInterfaceItemIdentifier, _ cellData: SignalMulti&lt;String&gt;) -&gt; TableCellViewConvertible {
	return TableCellView(
		.layout -- .inset(
			margins: NSEdgeInsets(top: 8, left: 16, bottom: 8, right: 16),
			.view(
				TextField.label(
					.stringValue &lt;-- cellData.map { .rowLabel($0) },
					.font -- .preferredFont(forTextStyle: .label, size: .controlRegular)
				)
			)
		)
	)
}

private extension DetailState {
	init?(possibleCell: TableCell&lt;String&gt;?) {
		guard let cell = possibleCell, let data = cell.data, let row = cell.row else { return nil }
		self.init(index: row, value: data)
	}
}

private extension String {
	static func rowLabel(_ row: String) -&gt; String {
		return String.localizedStringWithFormat(NSLocalizedString("Row %@", comment: ""), row)
	}
	
	static let rowsColumnTitle = NSLocalizedString("Rows", comment: "")
	static let windowTitle = NSLocalizedString("My Window", comment: "Window title")
}</string>
		<key>main.swift:content</key>
		<string>func application(_ windowVar: Var&lt;WindowState&gt;, _ doc: DocumentAdapter) -&gt; Application {
	return Application(
		.mainMenu -- mainMenu(),
		.lifetimes &lt;-- windowVar.map {[
			window($0, doc).nsWindow()
		]},
		.willEncodeRestorableState -- windowVar.storeToArchive(),
		.didDecodeRestorableState -- windowVar.loadFromArchive(),
		.shouldTerminateAfterLastWindowClosed() -- true
	)
}

private let services = Services(fileService: FileManager.default)
private let doc = DocumentAdapter(document: Document(services: services))
private let windowVar = Var(WindowState())

#if DEBUG
	let docLog = doc.logJson(keyPath: \.contents, prefix: "Document changed: ")
	let viewLog = windowVar.logJson(prefix: "View-state changed: ")
#endif

applicationMain { application(windowVar, doc) }</string>
	</dict>
	<key>Description</key>
	<string>Creates an AppKit Mac application using the CwlViews framework.</string>
	<key>Identifier</key>
	<string>com.cocoawithlove.views-app-macOS</string>
	<key>Kind</key>
	<string>Xcode.Xcode3.ProjectTemplateUnitKind</string>
	<key>Name</key>
	<string>CwlViews</string>
	<key>Nodes</key>
	<array>
		<string>main.swift:comments</string>
		<string>main.swift:imports:importAppKit</string>
		<string>main.swift:content</string>
		<string>Services.swift:comments</string>
		<string>Services.swift:imports:importFoundation</string>
		<string>Services.swift:content</string>
		<string>Model/Document.swift:comments</string>
		<string>Model/Document.swift:imports:importFoundation</string>
		<string>Model/Document.swift:content</string>
		<string>Model/DocumentAdapter.swift:comments</string>
		<string>Model/DocumentAdapter.swift:imports:importFoundation</string>
		<string>Model/DocumentAdapter.swift:content</string>
		<string>View/Window.swift:comments</string>
		<string>View/Window.swift:imports:importAppKit</string>
		<string>View/Window.swift:content</string>
		<string>View/DetailView.swift:comments</string>
		<string>View/DetailView.swift:imports:importAppKit</string>
		<string>View/DetailView.swift:content</string>
		<string>View/MainMenu.swift:comments</string>
		<string>View/MainMenu.swift:imports:importAppKit</string>
		<string>View/MainMenu.swift:content</string>
		<string>Dependencies/CwlUtils.swift</string>
		<string>Dependencies/CwlSignal.swift</string>
		<string>Dependencies/CwlViewsCore.swift</string>
		<string>Dependencies/CwlViews_macOS.swift</string>
		<string>Assets.xcassets</string>
		<string>Info.plist:Icon</string>
		<string>Info.plist:DeploymentTarget</string>
		<string>Info.plist:PrincipalClass</string>
		<string>Info.plist:NSHumanReadableCopyright</string>
	</array>
	<key>Options</key>
	<array>
		<dict>
			<key>Default</key>
			<string>Swift</string>
			<key>Description</key>
			<string>The implementation language</string>
			<key>Identifier</key>
			<string>languageChoice</string>
			<key>Name</key>
			<string>Language:</string>
			<key>Required</key>
			<integer>1</integer>
			<key>Type</key>
			<string>popup</string>
			<key>Values</key>
			<array>
				<string>Swift</string>
			</array>
			<key>Variables</key>
			<dict>
				<key>Swift</key>
				<dict>
					<key>ibCustomModuleProvider</key>
					<string>target</string>
					<key>moduleNamePrefixForClasses</key>
					<string>$(PRODUCT_MODULE_NAME).</string>
				</dict>
			</dict>
		</dict>
		<dict>
			<key>Default</key>
			<string>true</string>
			<key>Identifier</key>
			<string>hasUnitTests</string>
			<key>Name</key>
			<string>Include Unit Tests</string>
			<key>NotPersisted</key>
			<integer>0</integer>
			<key>SortOrder</key>
			<integer>100</integer>
			<key>Type</key>
			<string>checkbox</string>
			<key>Units</key>
			<dict>
				<key>true</key>
				<dict>
					<key>Components</key>
					<array>
						<dict>
							<key>Identifier</key>
							<string>com.cocoawithlove.views-unit.cocoaApplicationUnitTestBundle</string>
							<key>Name</key>
							<string>___PACKAGENAME___Tests</string>
						</dict>
					</array>
				</dict>
			</dict>
		</dict>
		<dict>
			<key>Default</key>
			<string>true</string>
			<key>Identifier</key>
			<string>hasUITests</string>
			<key>Name</key>
			<string>Include UI Tests</string>
			<key>NotPersisted</key>
			<integer>0</integer>
			<key>SortOrder</key>
			<integer>101</integer>
			<key>Type</key>
			<string>checkbox</string>
			<key>Units</key>
			<dict>
				<key>true</key>
				<dict>
					<key>Components</key>
					<array>
						<dict>
							<key>Identifier</key>
							<string>com.apple.dt.unit.cocoaApplicationUITestBundle</string>
							<key>Name</key>
							<string>___PACKAGENAME___UITests</string>
						</dict>
					</array>
				</dict>
			</dict>
		</dict>
	</array>
	<key>Platforms</key>
	<array>
		<string>com.apple.platform.macosx</string>
	</array>
	<key>Project</key>
	<dict>
		<key>SDK</key>
		<string>macosx</string>
	</dict>
	<key>SortOrder</key>
	<integer>1</integer>
	<key>Targets</key>
	<array>
		<dict>
			<key>SharedSettings</key>
			<dict>
				<key>ASSETCATALOG_COMPILER_APPICON_NAME</key>
				<string>AppIcon</string>
				<key>COMBINE_HIDPI_IMAGES</key>
				<string>YES</string>
				<key>LD_RUNPATH_SEARCH_PATHS</key>
				<string>$(inherited) @executable_path/Frameworks</string>
				<key>TARGETED_DEVICE_FAMILY</key>
				<string>1,2</string>
			</dict>
			<key>TargetIdentifier</key>
			<string>com.apple.dt.cocoaApplicationTarget</string>
		</dict>
	</array>
</dict>
</plist>
