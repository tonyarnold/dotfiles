<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Ancestors</key>
	<array>
		<string>com.apple.dt.unit.osxUnitTestBundleBase</string>
	</array>
	<key>Definitions</key>
	<dict>
		<key>*:imports:importProject</key>
		<string>@testable import ___VARIABLE_productName:identifier___</string>
		<key>CwlViews_macOSTesting.swift:content</key>
		<string>//
//  This file is part of a concatenation of the CwlViews framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-05-11 02:03:28 +0000 from the following files:
//   CwlBindingParser.swift
//   CwlApplicationTesting_macOS.swift
//   CwlButtonTesting_macOS.swift
//   CwlClickGestureRecognizerTesting_macOS.swift
//   CwlClipViewTesting_macOS.swift
//   CwlControlTesting_macOS.swift
//   CwlGestureRecognizerTesting_macOS.swift
//   CwlImageViewTesting_macOS.swift
//   CwlMagnificationGestureRecognizerTesting_macOS.swift
//   CwlMenuItemTesting_macOS.swift
//   CwlMenuTesting_macOS.swift
//   CwlOutlineViewTesting_macOS.swift
//   CwlPanGestureRecognizerTesting_macOS.swift
//   CwlPopUpButtonTesting_macOS.swift
//   CwlPressGestureRecognizerTesting_macOS.swift
//   CwlRotationGestureRecognizerTesting_macOS.swift
//   CwlScrollViewTesting_macOS.swift
//   CwlSegmentedControlTesting_macOS.swift
//   CwlSliderTesting_macOS.swift
//   CwlSplitViewTesting_macOS.swift
//   CwlTabViewItemTesting_macOS.swift
//   CwlTabViewTesting_macOS.swift
//   CwlTableCellViewTesting_macOS.swift
//   CwlTableColumnTesting_macOS.swift
//   CwlTableHeaderViewTesting_macOS.swift
//   CwlTableRowViewTesting_macOS.swift
//   CwlTableViewTesting_macOS.swift
//   CwlTextFieldTesting_macOS.swift
//   CwlTextViewTesting_macOS.swift
//   CwlToolbarItemTesting_macOS.swift
//   CwlToolbarTesting_macOS.swift
//   CwlViewTesting_macOS.swift
//   CwlWindowTesting_macOS.swift

import AppKit

struct BindingParser&lt;Value, Binding, Downcast&gt; {
	var extract: (Binding) -&gt; Value?
	var upcast: (Downcast) -&gt; Binding?
	init(extract: @escaping (Binding) -&gt; Value?, upcast: @escaping (Downcast) -&gt; Binding?) {
		self.extract = extract
		self.upcast = upcast
	}
	func parse(_ downcast: Downcast) -&gt; Value? {
		return upcast(downcast).flatMap { extract($0) }
	}
}


enum BindingParserErrors: Error {
	case multipleMatchesFound
	case noMatchesFound
	case unexpectedArgumentType
}

extension Dynamic {
	var values: [Value] {
		switch self {
		case .constant(let v): return [v]
		case .dynamic(let s): return s.capture().values
		}
	}
	
	var signal: Signal&lt;Value&gt; {
		switch self {
		case .constant(let f): return Signal.just(f)
		case .dynamic(let s): return s
		}
	}
}

extension Binder {
	static func consume(from possibleBinder: Any) throws -&gt; (type: Self.Preparer.Instance.Type, parameters: Self.Preparer.Parameters, bindings: [Self.Preparer.Binding]) {
		if let b = possibleBinder as? Self {
			return b.consume()
		}
		throw BindingParserErrors.unexpectedArgumentType
	}
	
	static func consumeBindings(from possibleBinder: Any) throws -&gt; [Self.Preparer.Binding] {
		return try consume(from: possibleBinder).bindings
	}
	
	static func latestValue&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;Dynamic&lt;V&gt;, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; V where S.Element == Downcast {
		var found: V? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.values.first
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func latestArray&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;Dynamic&lt;V&gt;, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; [V] where S.Element == Downcast {
		var found: [V]? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.values
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func constantValue&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;Constant&lt;V&gt;, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; V where S.Element == Downcast {
		var found: V? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.value
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func valueSignal&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;Dynamic&lt;V&gt;, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; Signal&lt;V&gt; where S.Element == Downcast {
		var found: Signal&lt;V&gt;? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.signal
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func argument&lt;Downcast, V, S: Sequence&gt;(for parser: BindingParser&lt;V, Preparer.Binding, Downcast&gt;, in bindings: S) throws -&gt; V where S.Element == Downcast {
		var found: V? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

#if os(macOS)

import CloudKit

extension BindingParser where Downcast: ApplicationBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Application.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asApplicationBinding() }) }
	
	//	0. Static styles are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var activationPolicy: BindingParser&lt;Dynamic&lt;NSApplication.ActivationPolicy&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .activationPolicy(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var applicationIconImage: BindingParser&lt;Dynamic&lt;NSImage?&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .applicationIconImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var dockMenu: BindingParser&lt;Dynamic&lt;MenuConvertible?&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .dockMenu(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var mainMenu: BindingParser&lt;Dynamic&lt;MenuConvertible?&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .mainMenu(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var menuBarVisible: BindingParser&lt;Dynamic&lt;Bool&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .menuBarVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var presentationOptions: BindingParser&lt;Dynamic&lt;NSApplication.PresentationOptions&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .presentationOptions(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var relauchOnLogin: BindingParser&lt;Dynamic&lt;Bool&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .relauchOnLogin(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var remoteNotifications: BindingParser&lt;Dynamic&lt;NSApplication.RemoteNotificationType&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .remoteNotifications(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	
	@available(macOS 10.14, *) static var appearance: BindingParser&lt;Dynamic&lt;NSAppearance?&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .appearance(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var activate: BindingParser&lt;Signal&lt;Bool&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .activate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var arrangeInFront: BindingParser&lt;Signal&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .arrangeInFront(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var deactivate: BindingParser&lt;Signal&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .deactivate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var hide: BindingParser&lt;Signal&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .hide(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var hideOtherApplications: BindingParser&lt;Signal&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .hideOtherApplications(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var miniaturizeAll: BindingParser&lt;Signal&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .miniaturizeAll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var orderFrontCharacterPalette: BindingParser&lt;Signal&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .orderFrontCharacterPalette(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var orderFrontColorPanel: BindingParser&lt;Signal&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .orderFrontColorPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var orderFrontStandardAboutPanel: BindingParser&lt;Signal&lt;Dictionary&lt;NSApplication.AboutPanelOptionKey, Any&gt;&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .orderFrontStandardAboutPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var presentError: BindingParser&lt;Signal&lt;Callback&lt;Error, Bool&gt;&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .presentError(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var requestUserAttention: BindingParser&lt;Signal&lt;(NSApplication.RequestUserAttentionType, Signal&lt;Void&gt;)&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .requestUserAttention(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var terminate: BindingParser&lt;Signal&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .terminate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var unhide: BindingParser&lt;Signal&lt;Bool&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .unhide(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var unhideAllApplications: BindingParser&lt;Signal&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .unhideAllApplications(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBecomeActive: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .didBecomeActive(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didChangeOcclusionState: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .didChangeOcclusionState(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didChangeScreenParameters: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .didChangeScreenParameters(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didFinishLaunching: BindingParser&lt;SignalInput&lt;[AnyHashable: Any]&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .didFinishLaunching(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didFinishRestoringWindows: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .didFinishRestoringWindows(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didHide: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .didHide(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didResignActive: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .didResignActive(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didUnhide: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .didUnhide(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didUpdate: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .didUpdate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willBecomeActive: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .willBecomeActive(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willFinishLaunching: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .willFinishLaunching(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willHide: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .willHide(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willResignActive: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .willResignActive(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willUnhide: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .willUnhide(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willUpdate: BindingParser&lt;SignalInput&lt;Void&gt;, Application.Binding, Downcast&gt; { return .init(extract: { if case .willUpdate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var continueUserActivity: BindingParser&lt;(_ application: NSApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([NSUserActivityRestoring]) -&gt; Void) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .continueUserActivity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didDecodeRestorableState: BindingParser&lt;(_ application: NSApplication, NSCoder) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didDecodeRestorableState(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didFailToContinueUserActivity: BindingParser&lt;(_ application: NSApplication, _ userActivityType: String, _ error: Error) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didFailToContinueUserActivity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didFailToRegisterForRemoteNotifications: BindingParser&lt;(_ application: NSApplication, _ error: Error) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didFailToRegisterForRemoteNotifications(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didReceiveRemoteNotification: BindingParser&lt;(_ application: NSApplication, _ notification: [String: Any]) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didReceiveRemoteNotification(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didRegisterForRemoteNotifications: BindingParser&lt;(_ application: NSApplication, _ token: Data) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didRegisterForRemoteNotifications(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var didUpdateUserActivity: BindingParser&lt;(_ application: NSApplication, NSUserActivity) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .didUpdateUserActivity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var openFile: BindingParser&lt;(_ application: NSApplication, _ filename: String) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .openFile(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var openFiles: BindingParser&lt;(_ application: NSApplication, _ filenames: [String]) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .openFiles(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var openFileWithoutUI: BindingParser&lt;(_ application: Any, _ filename: String) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .openFileWithoutUI(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var openTempFile: BindingParser&lt;(_ application: NSApplication, _ filename: String) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .openTempFile(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var openUntitledFile: BindingParser&lt;(_ application: NSApplication) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .openUntitledFile(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var printFile: BindingParser&lt;(_ application: NSApplication, _ filename: String) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .printFile(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var printFiles: BindingParser&lt;(_ application: NSApplication, _ filenames: [String], _ settings: [NSPrintInfo.AttributeKey: Any], _ showPrintPanels: Bool) -&gt; NSApplication.PrintReply, Application.Binding, Downcast&gt; { return .init(extract: { if case .printFiles(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var shouldHandleReopen: BindingParser&lt;(_ application: NSApplication, _ hasVisibleWindows: Bool) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .shouldHandleReopen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var shouldOpenUntitledFile: BindingParser&lt;(_ application: NSApplication) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .shouldOpenUntitledFile(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var shouldTerminate: BindingParser&lt;(_ application: NSApplication) -&gt; NSApplication.TerminateReply, Application.Binding, Downcast&gt; { return .init(extract: { if case .shouldTerminate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var shouldTerminateAfterLastWindowClosed: BindingParser&lt;(_ application: NSApplication) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .shouldTerminateAfterLastWindowClosed(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var userDidAcceptCloudKitShare: BindingParser&lt;(_ application: NSApplication, CKShare.Metadata) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .userDidAcceptCloudKitShare(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willContinueUserActivity: BindingParser&lt;(_ application: NSApplication, _ type: String) -&gt; Bool, Application.Binding, Downcast&gt; { return .init(extract: { if case .willContinueUserActivity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willEncodeRestorableState: BindingParser&lt;(_ application: NSApplication, NSCoder) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .willEncodeRestorableState(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willPresentError: BindingParser&lt;(_ application: NSApplication, Error) -&gt; Error, Application.Binding, Downcast&gt; { return .init(extract: { if case .willPresentError(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
	static var willTerminate: BindingParser&lt;(_ notification: Notification) -&gt; Void, Application.Binding, Downcast&gt; { return .init(extract: { if case .willTerminate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asApplicationBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: ButtonBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Button.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asButtonBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMixedState: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .allowsMixedState(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var alternateImage: BindingParser&lt;Dynamic&lt;NSImage?&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .alternateImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var alternateTitle: BindingParser&lt;Dynamic&lt;String&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .alternateTitle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var attributedAlternateTitle: BindingParser&lt;Dynamic&lt;NSAttributedString&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .attributedAlternateTitle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var attributedTitle: BindingParser&lt;Dynamic&lt;NSAttributedString&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .attributedTitle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var bezelColor: BindingParser&lt;Dynamic&lt;NSColor?&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .bezelColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var bezelStyle: BindingParser&lt;Dynamic&lt;NSButton.BezelStyle&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .bezelStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var buttonType: BindingParser&lt;Dynamic&lt;NSButton.ButtonType&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .buttonType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var highlight: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .highlight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var image: BindingParser&lt;Dynamic&lt;NSImage?&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .image(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var imageHugsTitle: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .imageHugsTitle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var imagePosition: BindingParser&lt;Dynamic&lt;NSControl.ImagePosition&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .imagePosition(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var imageScaling: BindingParser&lt;Dynamic&lt;NSImageScaling&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .imageScaling(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var isBordered: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .isBordered(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var isSpringLoaded: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .isSpringLoaded(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var isTransparent: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .isTransparent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var keyEquivalent: BindingParser&lt;Dynamic&lt;String&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .keyEquivalent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var keyEquivalentModifierMask: BindingParser&lt;Dynamic&lt;NSEvent.ModifierFlags&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .keyEquivalentModifierMask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var maxAcceleratorLevel: BindingParser&lt;Dynamic&lt;Int&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .maxAcceleratorLevel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var performKeyEquivalent: BindingParser&lt;Dynamic&lt;NSEvent&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .performKeyEquivalent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var periodicDelay: BindingParser&lt;Dynamic&lt;(delay: Float, interval: Float)&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .periodicDelay(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var showsBorderOnlyWhileMouseInside: BindingParser&lt;Dynamic&lt;Bool&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .showsBorderOnlyWhileMouseInside(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var sound: BindingParser&lt;Dynamic&lt;NSSound?&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .sound(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var state: BindingParser&lt;Dynamic&lt;NSControl.StateValue&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .state(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;String&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }

	@available(macOS 10.14, *) static var contentTintColor: BindingParser&lt;Dynamic&lt;NSColor?&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .contentTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }

	//	2. Signal bindings are performed on the object after construction.
	static var setNextState: BindingParser&lt;Signal&lt;Void&gt;, Button.Binding, Downcast&gt; { return .init(extract: { if case .setNextState(let x) = $0 { return x } else { return nil } }, upcast: { $0.asButtonBinding() }) }

	//	3. Action bindings are triggered by the object after construction.

	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: ClickGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ClickGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asClickGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var buttonMask: BindingParser&lt;Dynamic&lt;Int&gt;, ClickGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .buttonMask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClickGestureRecognizerBinding() }) }
	static var numberOfClicksRequired: BindingParser&lt;Dynamic&lt;Int&gt;, ClickGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .numberOfClicksRequired(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClickGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: ClipViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ClipView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asClipViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, ClipView.Binding, Downcast&gt; { return .init(extract: { if case .backgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClipViewBinding() }) }
	static var bottomConstraintPriority: BindingParser&lt;Dynamic&lt;Layout.Dimension.Priority&gt;, ClipView.Binding, Downcast&gt; { return .init(extract: { if case .bottomConstraintPriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClipViewBinding() }) }
	static var copiesOnScroll: BindingParser&lt;Dynamic&lt;Bool&gt;, ClipView.Binding, Downcast&gt; { return .init(extract: { if case .copiesOnScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClipViewBinding() }) }
	static var documentCursor: BindingParser&lt;Dynamic&lt;NSCursor?&gt;, ClipView.Binding, Downcast&gt; { return .init(extract: { if case .documentCursor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClipViewBinding() }) }
	static var documentView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, ClipView.Binding, Downcast&gt; { return .init(extract: { if case .documentView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClipViewBinding() }) }
	static var drawsBackground: BindingParser&lt;Dynamic&lt;Bool&gt;, ClipView.Binding, Downcast&gt; { return .init(extract: { if case .drawsBackground(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClipViewBinding() }) }
	static var trailingConstraintPriority: BindingParser&lt;Dynamic&lt;Layout.Dimension.Priority&gt;, ClipView.Binding, Downcast&gt; { return .init(extract: { if case .trailingConstraintPriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClipViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var scrollTo: BindingParser&lt;Signal&lt;CGPoint&gt;, ClipView.Binding, Downcast&gt; { return .init(extract: { if case .scrollTo(let x) = $0 { return x } else { return nil } }, upcast: { $0.asClipViewBinding() }) }

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: ControlBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Control.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asControlBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var alignment: BindingParser&lt;Dynamic&lt;NSTextAlignment&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .alignment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var allowsExpansionToolTips: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .allowsExpansionToolTips(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var attributedStringValue: BindingParser&lt;Dynamic&lt;NSAttributedString&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .attributedStringValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var baseWritingDirection: BindingParser&lt;Dynamic&lt;NSWritingDirection&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .baseWritingDirection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var doubleValue: BindingParser&lt;Dynamic&lt;Double&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .doubleValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var floatValue: BindingParser&lt;Dynamic&lt;Float&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .floatValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var font: BindingParser&lt;Dynamic&lt;NSFont&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .font(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var formatter: BindingParser&lt;Dynamic&lt;Foundation.Formatter?&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .formatter(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var ignoresMultiClick: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .ignoresMultiClick(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var integerValue: BindingParser&lt;Dynamic&lt;Int&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .integerValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var intValue: BindingParser&lt;Dynamic&lt;Int32&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .intValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var isContinuous: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .isContinuous(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var isEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .isEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var isHighlighted: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .isHighlighted(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var lineBreakMode: BindingParser&lt;Dynamic&lt;NSLineBreakMode&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .lineBreakMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var objectValue: BindingParser&lt;Dynamic&lt;Any&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .objectValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var refusesFirstResponder: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .refusesFirstResponder(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var sendActionOn: BindingParser&lt;Dynamic&lt;NSEvent.EventTypeMask&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .sendActionOn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var size: BindingParser&lt;Dynamic&lt;NSControl.ControlSize&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .size(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var stringValue: BindingParser&lt;Dynamic&lt;String&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .stringValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var tag: BindingParser&lt;Dynamic&lt;Int&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .tag(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var usesSingleLineMode: BindingParser&lt;Dynamic&lt;Bool&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .usesSingleLineMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var abortEditing: BindingParser&lt;Signal&lt;Void&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .abortEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var performClick: BindingParser&lt;Signal&lt;Void&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .performClick(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var sizeToFit: BindingParser&lt;Signal&lt;Void&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .sizeToFit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var validateEditing: BindingParser&lt;Signal&lt;Void&gt;, Control.Binding, Downcast&gt; { return .init(extract: { if case .validateEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var action: BindingParser&lt;TargetAction, Control.Binding, Downcast&gt; { return .init(extract: { if case .action(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var textDidBeginEditing: BindingParser&lt;(NSText) -&gt; Void, Control.Binding, Downcast&gt; { return .init(extract: { if case .textDidBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var textDidChange: BindingParser&lt;(NSText) -&gt; Void, Control.Binding, Downcast&gt; { return .init(extract: { if case .textDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
	static var textDidEndEditing: BindingParser&lt;(NSText) -&gt; Void, Control.Binding, Downcast&gt; { return .init(extract: { if case .textDidEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asControlBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: GestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowedTouchTypes: BindingParser&lt;Dynamic&lt;NSTouch.TouchTypeMask&gt;, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .allowedTouchTypes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var pressureConfiguration: BindingParser&lt;Dynamic&lt;NSPressureConfiguration&gt;, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .pressureConfiguration(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: BindingParser&lt;TargetAction, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .action(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldAttemptToRecognize: BindingParser&lt;(NSGestureRecognizer, NSEvent) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldAttemptToRecognize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldBegin: BindingParser&lt;(NSGestureRecognizer) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldBegin(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldRecognizeSimultaneously: BindingParser&lt;(NSGestureRecognizer, NSGestureRecognizer) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldRecognizeSimultaneously(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldRequireFailure: BindingParser&lt;(NSGestureRecognizer, NSGestureRecognizer) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldRequireFailure(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldRequireToFail: BindingParser&lt;(NSGestureRecognizer, NSGestureRecognizer) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldRequireToFail(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
	static var shouldReceiveTouch: BindingParser&lt;(NSGestureRecognizer, NSTouch) -&gt; Bool, GestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .shouldReceiveTouch(let x) = $0 { return x } else { return nil } }, upcast: { $0.asGestureRecognizerBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: ImageViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asImageViewBinding() }) }
		
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsCutCopyPaste: BindingParser&lt;Dynamic&lt;Bool&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .allowsCutCopyPaste(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var animates: BindingParser&lt;Dynamic&lt;Bool&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .animates(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var image: BindingParser&lt;Dynamic&lt;NSImage?&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .image(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var imageAlignment: BindingParser&lt;Dynamic&lt;NSImageAlignment&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .imageAlignment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var imageFrameStyle: BindingParser&lt;Dynamic&lt;NSImageView.FrameStyle&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .imageFrameStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var imageScaling: BindingParser&lt;Dynamic&lt;NSImageScaling&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .imageScaling(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	static var isEditable: BindingParser&lt;Dynamic&lt;Bool&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .isEditable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }
	@available(macOS 10.14, *) static var contentTintColor: BindingParser&lt;Dynamic&lt;NSColor?&gt;, ImageView.Binding, Downcast&gt; { return .init(extract: { if case .contentTintColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asImageViewBinding() }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: MagnificationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, MagnificationGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asMagnificationGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var magnification: BindingParser&lt;Dynamic&lt;CGFloat&gt;, MagnificationGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .magnification(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMagnificationGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: MenuItemBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asMenuItemBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .isEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var isHidden: BindingParser&lt;Dynamic&lt;Bool&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .isHidden(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var isAlternate: BindingParser&lt;Dynamic&lt;Bool&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .isAlternate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;String&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var attributedTitle: BindingParser&lt;Dynamic&lt;NSAttributedString?&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .attributedTitle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var tag: BindingParser&lt;Dynamic&lt;Int&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .tag(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var representedObject: BindingParser&lt;Dynamic&lt;AnyObject?&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .representedObject(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var state: BindingParser&lt;Dynamic&lt;NSControl.StateValue&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .state(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var indentationLevel: BindingParser&lt;Dynamic&lt;Int&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .indentationLevel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var image: BindingParser&lt;Dynamic&lt;NSImage?&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .image(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var onStateImage: BindingParser&lt;Dynamic&lt;NSImage?&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .onStateImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var offStateImage: BindingParser&lt;Dynamic&lt;NSImage?&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .offStateImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var mixedStateImage: BindingParser&lt;Dynamic&lt;NSImage?&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .mixedStateImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var submenu: BindingParser&lt;Dynamic&lt;MenuConvertible?&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .submenu(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var keyEquivalent: BindingParser&lt;Dynamic&lt;String&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .keyEquivalent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var keyEquivalentModifierMask: BindingParser&lt;Dynamic&lt;NSEvent.ModifierFlags&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .keyEquivalentModifierMask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var toolTip: BindingParser&lt;Dynamic&lt;String?&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .toolTip(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	static var view: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .view(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: BindingParser&lt;TargetAction, MenuItem.Binding, Downcast&gt; { return .init(extract: { if case .action(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuItemBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: MenuBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Menu.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asMenuBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var systemName: BindingParser&lt;Constant&lt;SystemMenu&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .systemName(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsContextMenuPlugIns: BindingParser&lt;Dynamic&lt;Bool&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .allowsContextMenuPlugIns(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var autoenablesItems: BindingParser&lt;Dynamic&lt;Bool&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .autoenablesItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var font: BindingParser&lt;Dynamic&lt;NSFont&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .font(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var items: BindingParser&lt;Dynamic&lt;[MenuItemConvertible]&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .items(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var minimumWidth: BindingParser&lt;Dynamic&lt;CGFloat&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .minimumWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var showsStateColumn: BindingParser&lt;Dynamic&lt;Bool&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .showsStateColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;String&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var userInterfaceLayoutDirection: BindingParser&lt;Dynamic&lt;NSUserInterfaceLayoutDirection&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .userInterfaceLayoutDirection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var cancelTracking: BindingParser&lt;Signal&lt;Void&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .cancelTracking(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var cancelTrackingWithoutAnimation: BindingParser&lt;Signal&lt;Void&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .cancelTrackingWithoutAnimation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var performAction: BindingParser&lt;Signal&lt;Int&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .performAction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var popUp: BindingParser&lt;Signal&lt;(item: Int, at: NSPoint, in: NSView?)&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .popUp(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var popUpContextMenu: BindingParser&lt;Signal&lt;(with: NSEvent, for: NSView)&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .popUpContextMenu(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBeginTracking: BindingParser&lt;SignalInput&lt;Void&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .didBeginTracking(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var didEndTracking: BindingParser&lt;SignalInput&lt;Void&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .didEndTracking(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var didSendAction: BindingParser&lt;SignalInput&lt;Int&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .didSendAction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var willSendAction: BindingParser&lt;SignalInput&lt;Int&gt;, Menu.Binding, Downcast&gt; { return .init(extract: { if case .willSendAction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var confinementRect: BindingParser&lt;(_ menu: NSMenu, _ screen: NSScreen?) -&gt; NSRect, Menu.Binding, Downcast&gt; { return .init(extract: { if case .confinementRect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var didClose: BindingParser&lt;(_ menu: NSMenu) -&gt; Void, Menu.Binding, Downcast&gt; { return .init(extract: { if case .didClose(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var willHighlight: BindingParser&lt;(_ menu: NSMenu, _ item: NSMenuItem?, _ index: Int?) -&gt; Void, Menu.Binding, Downcast&gt; { return .init(extract: { if case .willHighlight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
	static var willOpen: BindingParser&lt;(_ menu: NSMenu) -&gt; Void, Menu.Binding, Downcast&gt; { return .init(extract: { if case .willOpen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asMenuBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: OutlineViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asOutlineViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsColumnReordering: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsColumnReordering(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var allowsColumnResizing: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsColumnResizing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var allowsColumnSelection: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsColumnSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var allowsEmptySelection: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsEmptySelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var allowsMultipleSelection: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsMultipleSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var allowsTypeSelect: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsTypeSelect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var autoresizesOutlineColumn: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .autoresizesOutlineColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var autosaveExpandedItems: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .autosaveExpandedItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var autosaveName: BindingParser&lt;Dynamic&lt;NSTableView.AutosaveName?&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .autosaveName(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var autosaveTableColumns: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .autosaveTableColumns(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var backgroundColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .backgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var columnAutoresizingStyle: BindingParser&lt;Dynamic&lt;NSTableView.ColumnAutoresizingStyle&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .columnAutoresizingStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var columns: BindingParser&lt;Dynamic&lt;[TableColumn&lt;Downcast.NodeDataType&gt;]&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .columns(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var cornerView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .cornerView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var draggingDestinationFeedbackStyle: BindingParser&lt;Dynamic&lt;NSTableView.DraggingDestinationFeedbackStyle&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .draggingDestinationFeedbackStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var floatsGroupRows: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .floatsGroupRows(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var gridColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .gridColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var gridStyleMask: BindingParser&lt;Dynamic&lt;NSTableView.GridLineStyle&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .gridStyleMask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var headerView: BindingParser&lt;Dynamic&lt;TableHeaderViewConvertible?&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .headerView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var indentationMarkerFollowsCell: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .indentationMarkerFollowsCell(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var indentationPerLevel: BindingParser&lt;Dynamic&lt;CGFloat&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .indentationPerLevel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var intercellSpacing: BindingParser&lt;Dynamic&lt;NSSize&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .intercellSpacing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var outlineTableColumnIdentifier: BindingParser&lt;Dynamic&lt;NSUserInterfaceItemIdentifier&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .outlineTableColumnIdentifier(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var rowHeight: BindingParser&lt;Dynamic&lt;CGFloat&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .rowHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var rowSizeStyle: BindingParser&lt;Dynamic&lt;NSTableView.RowSizeStyle&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .rowSizeStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var selectionHighlightStyle: BindingParser&lt;Dynamic&lt;NSTableView.SelectionHighlightStyle&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionHighlightStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var stronglyReferencesItems: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .stronglyReferencesItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var treeData: BindingParser&lt;Dynamic&lt;TreeAnimation&lt;Downcast.NodeDataType&gt;&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .treeData(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var userInterfaceLayoutDirection: BindingParser&lt;Dynamic&lt;NSUserInterfaceLayoutDirection&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .userInterfaceLayoutDirection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var usesAlternatingRowBackgroundColors: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .usesAlternatingRowBackgroundColors(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var verticalMotionCanBeginDrag: BindingParser&lt;Dynamic&lt;Bool&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .verticalMotionCanBeginDrag(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var collapseIndexPath: BindingParser&lt;Signal&lt;(indexPath: IndexPath?, collapseChildren: Bool)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .collapseIndexPath(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var deselectAll: BindingParser&lt;Signal&lt;Void&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .deselectAll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var deselectColumn: BindingParser&lt;Signal&lt;NSUserInterfaceItemIdentifier&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .deselectColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var deselectIndexPath: BindingParser&lt;Signal&lt;IndexPath&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .deselectIndexPath(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var expandIndexPath: BindingParser&lt;Signal&lt;(indexPath: IndexPath?, expandChildren: Bool)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .expandIndexPath(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var hideRowActions: BindingParser&lt;Signal&lt;Void&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .hideRowActions(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var hideRows: BindingParser&lt;Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .hideRows(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var highlightColumn: BindingParser&lt;Signal&lt;NSUserInterfaceItemIdentifier?&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .highlightColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var moveColumn: BindingParser&lt;Signal&lt;(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .moveColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var scrollColumnToVisible: BindingParser&lt;Signal&lt;NSUserInterfaceItemIdentifier&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .scrollColumnToVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var scrollIndexPathToVisible: BindingParser&lt;Signal&lt;IndexPath&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .scrollIndexPathToVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var selectAll: BindingParser&lt;Signal&lt;Void&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectAll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var selectColumns: BindingParser&lt;Signal&lt;(identifiers: Set&lt;NSUserInterfaceItemIdentifier&gt;, byExtendingSelection: Bool)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectColumns(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var selectIndexPaths: BindingParser&lt;Signal&lt;(indexPaths: Set&lt;IndexPath&gt;, byExtendingSelection: Bool)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectIndexPaths(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var setDropIndexPath: BindingParser&lt;Signal&lt;(indexPath: IndexPath?, dropChildIndex: Int)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .setDropIndexPath(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var sizeLastColumnToFit: BindingParser&lt;Signal&lt;Void&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sizeLastColumnToFit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var sizeToFit: BindingParser&lt;Signal&lt;Void&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sizeToFit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var unhideRows: BindingParser&lt;Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .unhideRows(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var columnMoved: BindingParser&lt;SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .columnMoved(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var columnResized: BindingParser&lt;SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .columnResized(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var doubleAction: BindingParser&lt;TargetAction, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .doubleAction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var selectionChanged: BindingParser&lt;SignalInput&lt;(selectedColumns: Set&lt;NSUserInterfaceItemIdentifier&gt;, selectedIndexPaths: Set&lt;IndexPath&gt;)&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionChanged(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var selectionIsChanging: BindingParser&lt;SignalInput&lt;Void&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionIsChanging(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var indexPathDidCollapse: BindingParser&lt;SignalInput&lt;IndexPath&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .indexPathDidCollapse(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var indexPathDidExpand: BindingParser&lt;SignalInput&lt;IndexPath&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .indexPathDidExpand(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var indexPathWillCollapse: BindingParser&lt;SignalInput&lt;IndexPath&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .indexPathWillCollapse(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var indexPathWillExpand: BindingParser&lt;SignalInput&lt;IndexPath&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .indexPathWillExpand(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var visibleIndexPathsChanged: BindingParser&lt;SignalInput&lt;Set&lt;IndexPath&gt;&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .visibleIndexPathsChanged(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var acceptDrop: BindingParser&lt;(_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ indexPath: IndexPath?, _ childIndex: Int) -&gt; Bool, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .acceptDrop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var didClickTableColumn: BindingParser&lt;(NSOutlineView, NSTableColumn) -&gt; Void, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didClickTableColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var didDragTableColumn: BindingParser&lt;(NSOutlineView, NSTableColumn) -&gt; Void, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didDragTableColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var draggingSessionEnded: BindingParser&lt;(_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -&gt; Void, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .draggingSessionEnded(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var draggingSessionWillBegin: BindingParser&lt;(_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ willBeginAt: NSPoint, _ forItems: [IndexPath]) -&gt; Void, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .draggingSessionWillBegin(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var groupRowCellConstructor: BindingParser&lt;(Int) -&gt; TableCellViewConvertible, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .groupRowCellConstructor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var heightOfRow: BindingParser&lt;(NSOutlineView, _ indexPath: IndexPath) -&gt; CGFloat, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .heightOfRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var isIndexPathExpandable: BindingParser&lt;(_ outlineView: NSOutlineView, IndexPath) -&gt; Bool, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .isIndexPathExpandable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var mouseDownInHeaderOfTableColumn: BindingParser&lt;(NSOutlineView, NSTableColumn) -&gt; Void, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .mouseDownInHeaderOfTableColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var nextTypeSelectMatch: BindingParser&lt;(_ outlineView: NSOutlineView, _ from: IndexPath, _ to: IndexPath, _ for: String) -&gt; IndexPath?, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .nextTypeSelectMatch(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var pasteboardWriter: BindingParser&lt;(_ outlineView: NSOutlineView, _ forIndexPath: IndexPath) -&gt; NSPasteboardWriting?, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .pasteboardWriter(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var rowView: BindingParser&lt;(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; TableRowViewConvertible?, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .rowView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var selectionIndexesForProposedSelection: BindingParser&lt;(_ outlineView: NSOutlineView, _ proposedSelectionIndexes: Set&lt;IndexPath&gt;) -&gt; Set&lt;IndexPath&gt;, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionIndexesForProposedSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var selectionShouldChange: BindingParser&lt;(_ outlineView: NSOutlineView) -&gt; Bool, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionShouldChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var shouldCollapse: BindingParser&lt;(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; Bool, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldCollapse(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var shouldExpand: BindingParser&lt;(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; Bool, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldExpand(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var shouldReorderColumn: BindingParser&lt;(_ outlineView: NSOutlineView, _ column: NSTableColumn, _ newIndex: Int) -&gt; Bool, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldReorderColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var shouldSelectIndexPath: BindingParser&lt;(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -&gt; Bool, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldSelectIndexPath(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var shouldSelectTableColumn: BindingParser&lt;(_ outlineView: NSOutlineView, _ column: NSTableColumn?) -&gt; Bool, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldSelectTableColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var shouldTypeSelectForEvent: BindingParser&lt;(_ outlineView: NSOutlineView, _ event: NSEvent, _ searchString: String?) -&gt; Bool, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldTypeSelectForEvent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var sizeToFitWidthOfColumn: BindingParser&lt;(_ outlineView: NSOutlineView, _ column: NSTableColumn) -&gt; CGFloat, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sizeToFitWidthOfColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var sortDescriptorsDidChange: BindingParser&lt;(NSOutlineView, [NSSortDescriptor]) -&gt; Void, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sortDescriptorsDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var typeSelectString: BindingParser&lt;(_ outlineView: NSOutlineView, _ column: NSTableColumn?, _ indexPath: IndexPath) -&gt; String?, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .typeSelectString(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var updateDraggingItems: BindingParser&lt;(_ outlineView: NSOutlineView, _ forDrag: NSDraggingInfo) -&gt; Void, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .updateDraggingItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
	static var validateDrop: BindingParser&lt;(_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ proposedIndexPath: IndexPath?, _ proposedChildIndex: Int) -&gt; NSDragOperation, OutlineView&lt;Downcast.NodeDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .validateDrop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asOutlineViewBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: PanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, PanGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asPanGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var buttonMask: BindingParser&lt;Dynamic&lt;Int&gt;, PanGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .buttonMask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPanGestureRecognizerBinding() }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: PopUpButtonBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, PopUpButton.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asPopUpButtonBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var autoenablesItems: BindingParser&lt;Dynamic&lt;Bool&gt;, PopUpButton.Binding, Downcast&gt; { return .init(extract: { if case .autoenablesItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPopUpButtonBinding() }) }
	static var menu: BindingParser&lt;Dynamic&lt;MenuConvertible&gt;, PopUpButton.Binding, Downcast&gt; { return .init(extract: { if case .menu(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPopUpButtonBinding() }) }
	static var preferredEdge: BindingParser&lt;Dynamic&lt;NSRectEdge&gt;, PopUpButton.Binding, Downcast&gt; { return .init(extract: { if case .preferredEdge(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPopUpButtonBinding() }) }
	static var pullsDown: BindingParser&lt;Dynamic&lt;Bool&gt;, PopUpButton.Binding, Downcast&gt; { return .init(extract: { if case .pullsDown(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPopUpButtonBinding() }) }
	static var selectedIndex: BindingParser&lt;Dynamic&lt;Int&gt;, PopUpButton.Binding, Downcast&gt; { return .init(extract: { if case .selectedIndex(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPopUpButtonBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;String&gt;, PopUpButton.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPopUpButtonBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var willPopUp: BindingParser&lt;SignalInput&lt;Void&gt;, PopUpButton.Binding, Downcast&gt; { return .init(extract: { if case .willPopUp(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPopUpButtonBinding() }) }

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: PressGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, PressGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asPressGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowableMovement: BindingParser&lt;Dynamic&lt;CGFloat&gt;, PressGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .allowableMovement(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPressGestureRecognizerBinding() }) }
	static var buttonMask: BindingParser&lt;Dynamic&lt;Int&gt;, PressGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .buttonMask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPressGestureRecognizerBinding() }) }
	static var minimumPressDuration: BindingParser&lt;Dynamic&lt;TimeInterval&gt;, PressGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .minimumPressDuration(let x) = $0 { return x } else { return nil } }, upcast: { $0.asPressGestureRecognizerBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: RotationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, RotationGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asRotationGestureRecognizerBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var rotationInRadians: BindingParser&lt;Dynamic&lt;CGFloat&gt;, RotationGestureRecognizer.Binding, Downcast&gt; { return .init(extract: { if case .rotationInRadians(let x) = $0 { return x } else { return nil } }, upcast: { $0.asRotationGestureRecognizerBinding() }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: ScrollViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asScrollViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMagnification: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .allowsMagnification(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var autohidesScrollers: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .autohidesScrollers(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var automaticallyAdjustsContentInsets: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .automaticallyAdjustsContentInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var backgroundColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .backgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var borderType: BindingParser&lt;Dynamic&lt;NSBorderType&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .borderType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var contentInsets: BindingParser&lt;Dynamic&lt;NSEdgeInsets&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .contentInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var contentView: BindingParser&lt;Dynamic&lt;ClipViewConvertible&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .contentView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var documentCursor: BindingParser&lt;Dynamic&lt;NSCursor?&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .documentCursor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var drawsBackground: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .drawsBackground(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var findBarPosition: BindingParser&lt;Dynamic&lt;NSScrollView.FindBarPosition&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .findBarPosition(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var floatingSubviews: BindingParser&lt;Dynamic&lt;[(view: ViewConvertible, axis: NSEvent.GestureAxis)]&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .floatingSubviews(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var hasHorizontalRuler: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .hasHorizontalRuler(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var hasHorizontalScroller: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .hasHorizontalScroller(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var hasVerticalRuler: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .hasVerticalRuler(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var hasVerticalScroller: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .hasVerticalScroller(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var horizontalLineScroll: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .horizontalLineScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var horizontalPageScroll: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .horizontalPageScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var horizontalScrollElasticity: BindingParser&lt;Dynamic&lt;NSScrollView.Elasticity&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .horizontalScrollElasticity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var magnification: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .magnification(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var maxMagnification: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .maxMagnification(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var minMagnification: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .minMagnification(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var rulersVisible: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .rulersVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var scrollerInsets: BindingParser&lt;Dynamic&lt;NSEdgeInsets&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .scrollerInsets(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var scrollerKnobStyle: BindingParser&lt;Dynamic&lt;NSScroller.KnobStyle&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .scrollerKnobStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var scrollerStyle: BindingParser&lt;Dynamic&lt;NSScroller.Style&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .scrollerStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var scrollsDynamically: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .scrollsDynamically(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var usesPredominantAxisScrolling: BindingParser&lt;Dynamic&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .usesPredominantAxisScrolling(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var verticalLineScroll: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .verticalLineScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var verticalPageScroll: BindingParser&lt;Dynamic&lt;CGFloat&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .verticalPageScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var verticalScrollElasticity: BindingParser&lt;Dynamic&lt;NSScrollView.Elasticity&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .verticalScrollElasticity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var flashScrollers: BindingParser&lt;Signal&lt;Bool&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .flashScrollers(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var magnificationCenteredAtPoint: BindingParser&lt;Signal&lt;(CGFloat, NSPoint)&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .magnificationCenteredAtPoint(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var magnifyToFitRect: BindingParser&lt;Signal&lt;CGRect&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .magnifyToFitRect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var scrollWheel: BindingParser&lt;Signal&lt;NSEvent&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .scrollWheel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didEndLiveMagnify: BindingParser&lt;SignalInput&lt;Void&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didEndLiveMagnify(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var didEndLiveScroll: BindingParser&lt;SignalInput&lt;Void&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didEndLiveScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var didLiveScroll: BindingParser&lt;SignalInput&lt;Void&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .didLiveScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var willStartLiveMagnify: BindingParser&lt;SignalInput&lt;Void&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .willStartLiveMagnify(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }
	static var willStartLiveScroll: BindingParser&lt;SignalInput&lt;Void&gt;, ScrollView.Binding, Downcast&gt; { return .init(extract: { if case .willStartLiveScroll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asScrollViewBinding() }) }

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: SegmentedControlBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, SegmentedControl.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asSegmentedControlBinding() }) }
		
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isSpringLoaded: BindingParser&lt;Dynamic&lt;Bool&gt;, SegmentedControl.Binding, Downcast&gt; { return .init(extract: { if case .isSpringLoaded(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSegmentedControlBinding() }) }
	static var distribution: BindingParser&lt;Dynamic&lt;NSSegmentedControl.Distribution&gt;, SegmentedControl.Binding, Downcast&gt; { return .init(extract: { if case .distribution(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSegmentedControlBinding() }) }
	static var segments: BindingParser&lt;Dynamic&lt;[SegmentDescription]&gt;, SegmentedControl.Binding, Downcast&gt; { return .init(extract: { if case .segments(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSegmentedControlBinding() }) }
	static var segmentStyle: BindingParser&lt;Dynamic&lt;NSSegmentedControl.Style&gt;, SegmentedControl.Binding, Downcast&gt; { return .init(extract: { if case .segmentStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSegmentedControlBinding() }) }
	static var selectedSegment: BindingParser&lt;Dynamic&lt;Int&gt;, SegmentedControl.Binding, Downcast&gt; { return .init(extract: { if case .selectedSegment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSegmentedControlBinding() }) }
	static var trackingMode: BindingParser&lt;Dynamic&lt;NSSegmentedControl.SwitchTracking&gt;, SegmentedControl.Binding, Downcast&gt; { return .init(extract: { if case .trackingMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSegmentedControlBinding() }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: SliderBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Slider.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asSliderBinding() }) }
		
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsTickMarkValuesOnly: BindingParser&lt;Dynamic&lt;Bool&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .allowsTickMarkValuesOnly(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var altIncrementValue: BindingParser&lt;Dynamic&lt;Double&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .altIncrementValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var isVertical: BindingParser&lt;Dynamic&lt;Bool&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .isVertical(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var maxValue: BindingParser&lt;Dynamic&lt;Double&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .maxValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var minValue: BindingParser&lt;Dynamic&lt;Double&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .minValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var numberOfTickMarks: BindingParser&lt;Dynamic&lt;Int&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .numberOfTickMarks(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var sliderType: BindingParser&lt;Dynamic&lt;NSSlider.SliderType&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .sliderType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var tickMarkPosition: BindingParser&lt;Dynamic&lt;NSSlider.TickMarkPosition&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .tickMarkPosition(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }
	static var trackFillColor: BindingParser&lt;Dynamic&lt;NSColor?&gt;, Slider.Binding, Downcast&gt; { return .init(extract: { if case .trackFillColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSliderBinding() }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: SplitViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asSplitViewBinding() }) }
		
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var arrangedSubviews: BindingParser&lt;Dynamic&lt;ArrayMutation&lt;SplitSubview&gt;&gt;, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .arrangedSubviews(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var autosaveName: BindingParser&lt;Dynamic&lt;NSSplitView.AutosaveName?&gt;, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .autosaveName(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var dividerStyle: BindingParser&lt;Dynamic&lt;NSSplitView.DividerStyle&gt;, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .dividerStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var isVertical: BindingParser&lt;Dynamic&lt;Bool&gt;, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .isVertical(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var setDividerPosition: BindingParser&lt;Signal&lt;(position: CGFloat, dividerIndex: Int)&gt;, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .setDividerPosition(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didResizeSubviews: BindingParser&lt;SignalInput&lt;Int?&gt;, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .didResizeSubviews(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var willResizeSubviews: BindingParser&lt;SignalInput&lt;Int?&gt;, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .willResizeSubviews(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var additionalEffectiveRect: BindingParser&lt;(_ splitView: NSSplitView, _ dividerAt: Int) -&gt; NSRect, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .additionalEffectiveRect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var canCollapseSubview: BindingParser&lt;(_ splitView: NSSplitView, _ subview: NSView) -&gt; Bool, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .canCollapseSubview(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var constrainMaxCoordinate: BindingParser&lt;(_ splitView: NSSplitView, _ proposedMaximumPosition: CGFloat, _ dividerIndex: Int) -&gt; CGFloat, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .constrainMaxCoordinate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var constrainMinCoordinate: BindingParser&lt;(_ splitView: NSSplitView, _ proposedMinimumPosition: CGFloat, _ dividerIndex: Int) -&gt; CGFloat, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .constrainMinCoordinate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var constrainSplitPosition: BindingParser&lt;(_ splitView: NSSplitView, _ proposedPosition: CGFloat, _ dividerIndex: Int) -&gt; CGFloat, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .constrainSplitPosition(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var effectiveRectForDrawnRect: BindingParser&lt;(_ splitView: NSSplitView, _ proposedEffectiveRect: NSRect, _ drawnRect: NSRect, _ dividerIndex: Int) -&gt; NSRect, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .effectiveRectForDrawnRect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var resizeSubviews: BindingParser&lt;(NSSplitView, NSSize) -&gt; Void, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .resizeSubviews(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var shouldAdjustSizeOfSubview: BindingParser&lt;(_ splitView: NSSplitView, _ subview: NSView) -&gt; Bool, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .shouldAdjustSizeOfSubview(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var shouldCollapseSubview: BindingParser&lt;(_ splitView: NSSplitView, _ subview: NSView, _ dividerIndex: Int) -&gt; Bool, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .shouldCollapseSubview(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
	static var shouldHideDivider: BindingParser&lt;(_ splitView: NSSplitView, _ dividerIndex: Int) -&gt; Bool, SplitView.Binding, Downcast&gt; { return .init(extract: { if case .shouldHideDivider(let x) = $0 { return x } else { return nil } }, upcast: { $0.asSplitViewBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: TabViewItemBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TabViewItem.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTabViewItemBinding() }) }
		
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var color: BindingParser&lt;Dynamic&lt;NSColor&gt;, TabViewItem.Binding, Downcast&gt; { return .init(extract: { if case .color(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewItemBinding() }) }
	static var image: BindingParser&lt;Dynamic&lt;NSImage?&gt;, TabViewItem.Binding, Downcast&gt; { return .init(extract: { if case .image(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewItemBinding() }) }
	static var initialFirstResponderTag: BindingParser&lt;Dynamic&lt;Int&gt;, TabViewItem.Binding, Downcast&gt; { return .init(extract: { if case .initialFirstResponderTag(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewItemBinding() }) }
	static var label: BindingParser&lt;Dynamic&lt;String&gt;, TabViewItem.Binding, Downcast&gt; { return .init(extract: { if case .label(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewItemBinding() }) }
	static var toolTip: BindingParser&lt;Dynamic&lt;String&gt;, TabViewItem.Binding, Downcast&gt; { return .init(extract: { if case .toolTip(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewItemBinding() }) }
	static var view: BindingParser&lt;Dynamic&lt;ViewConvertible&gt;, TabViewItem.Binding, Downcast&gt; { return .init(extract: { if case .view(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewItemBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: TabViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTabViewBinding() }) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsTruncatedLabels: BindingParser&lt;Dynamic&lt;Bool&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsTruncatedLabels(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var borderType: BindingParser&lt;Dynamic&lt;NSTabView.TabViewBorderType&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .borderType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var controlSize: BindingParser&lt;Dynamic&lt;NSControl.ControlSize&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .controlSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var drawsBackground: BindingParser&lt;Dynamic&lt;Bool&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .drawsBackground(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var font: BindingParser&lt;Dynamic&lt;NSFont&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .font(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var position: BindingParser&lt;Dynamic&lt;NSTabView.TabPosition&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .position(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var tabs: BindingParser&lt;Dynamic&lt;ArrayMutation&lt;Downcast.IdentifierType&gt;&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .tabs(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var type: BindingParser&lt;Dynamic&lt;NSTabView.TabType&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .type(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectedItem: BindingParser&lt;Dynamic&lt;Downcast.IdentifierType&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectedItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var selectFirstItem: BindingParser&lt;Signal&lt;Void&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectFirstItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var selectLastItem: BindingParser&lt;Signal&lt;Void&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectLastItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var selectNextItem: BindingParser&lt;Signal&lt;Void&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectNextItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var selectPreviousItem: BindingParser&lt;Signal&lt;Void&gt;, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectPreviousItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didChangeNumberOfItems: BindingParser&lt;(NSTabView) -&gt; Void, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didChangeNumberOfItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var didSelect: BindingParser&lt;(NSTabView, NSTabViewItem?, Downcast.IdentifierType?) -&gt; Void, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didSelect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var shouldSelect: BindingParser&lt;(NSTabView, NSTabViewItem?, Downcast.IdentifierType?) -&gt; Bool, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldSelect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var tabConstructor: BindingParser&lt;(Downcast.IdentifierType) -&gt; TabViewItemConvertible, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .tabConstructor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
	static var willSelect: BindingParser&lt;(NSTabView, NSTabViewItem?, Downcast.IdentifierType?) -&gt; Void, TabView&lt;Downcast.IdentifierType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .willSelect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTabViewBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: TableCellViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TableCellView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTableCellViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundStyle: BindingParser&lt;Dynamic&lt;NSView.BackgroundStyle&gt;, TableCellView.Binding, Downcast&gt; { return .init(extract: { if case .backgroundStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableCellViewBinding() }) }
	static var rowSizeStyle: BindingParser&lt;Dynamic&lt;NSTableView.RowSizeStyle&gt;, TableCellView.Binding, Downcast&gt; { return .init(extract: { if case .rowSizeStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableCellViewBinding() }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: TableColumnBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTableColumnBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var identifier: BindingParser&lt;Constant&lt;NSUserInterfaceItemIdentifier&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .identifier(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var headerCell: BindingParser&lt;Dynamic&lt;NSTableHeaderCell&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .headerCell(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var headerToolTip: BindingParser&lt;Dynamic&lt;String?&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .headerToolTip(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var isEditable: BindingParser&lt;Dynamic&lt;Bool&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .isEditable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var isHidden: BindingParser&lt;Dynamic&lt;Bool&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .isHidden(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var maxWidth: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .maxWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var minWidth: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .minWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var resizingMask: BindingParser&lt;Dynamic&lt;NSTableColumn.ResizingOptions&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .resizingMask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var sortDescriptorPrototype: BindingParser&lt;Dynamic&lt;NSSortDescriptor?&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sortDescriptorPrototype(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var sortFunction: BindingParser&lt;Dynamic&lt;(_ isRow: Downcast.RowDataType, _ orderedBefore: Downcast.RowDataType) -&gt; Bool&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sortFunction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;String&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var width: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .width(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var sizeToFit: BindingParser&lt;Signal&lt;Void&gt;, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sizeToFit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var cellConstructor: BindingParser&lt;(_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti&lt;Downcast.RowDataType&gt;) -&gt; TableCellViewConvertible, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .cellConstructor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var cellIdentifierForRow: BindingParser&lt;(Downcast.RowDataType?) -&gt; NSUserInterfaceItemIdentifier, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .cellIdentifierForRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
	static var dataMissingCell: BindingParser&lt;() -&gt; TableCellViewConvertible?, TableColumn&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .dataMissingCell(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableColumnBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: TableHeaderViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TableHeaderView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTableHeaderViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: TableRowViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTableRowViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .backgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableRowViewBinding() }) }
	static var draggingDestinationFeedbackStyle: BindingParser&lt;Dynamic&lt;NSTableView.DraggingDestinationFeedbackStyle&gt;, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .draggingDestinationFeedbackStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableRowViewBinding() }) }
	static var indentationForDropOperation: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .indentationForDropOperation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableRowViewBinding() }) }
	static var isEmphasized: BindingParser&lt;Dynamic&lt;Bool&gt;, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .isEmphasized(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableRowViewBinding() }) }
	static var isFloating: BindingParser&lt;Dynamic&lt;Bool&gt;, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .isFloating(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableRowViewBinding() }) }
	static var isGroupRowStyle: BindingParser&lt;Dynamic&lt;Bool&gt;, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .isGroupRowStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableRowViewBinding() }) }
	static var isSelected: BindingParser&lt;Dynamic&lt;Bool&gt;, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .isSelected(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableRowViewBinding() }) }
	static var isTargetForDropOperation: BindingParser&lt;Dynamic&lt;Bool&gt;, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .isTargetForDropOperation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableRowViewBinding() }) }
	static var selectionHighlightStyle: BindingParser&lt;Dynamic&lt;NSTableView.SelectionHighlightStyle&gt;, TableRowView.Binding, Downcast&gt; { return .init(extract: { if case .selectionHighlightStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableRowViewBinding() }) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension TableViewBinding {
	static func tableStructure&lt;S: Sequence&gt;(in bindings: S) throws -&gt; TableRowState&lt;RowDataType&gt; where S.Element == TableView&lt;RowDataType&gt;.Binding {
		var found: TableRowState&lt;RowDataType&gt;? = nil
		for b in bindings {
			if case .rows(let x) = b {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				let values = x.values
				var rowState = TableRowState&lt;RowDataType&gt;()
				for v in values {
					v.value.apply(toSubrange: &amp;rowState)
				}
				found = rowState
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

extension BindingParser where Downcast: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTableViewBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsColumnReordering: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsColumnReordering(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var allowsColumnResizing: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsColumnResizing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var allowsColumnSelection: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsColumnSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var allowsEmptySelection: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsEmptySelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var allowsMultipleSelection: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsMultipleSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var allowsTypeSelect: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .allowsTypeSelect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var autosaveName: BindingParser&lt;Dynamic&lt;NSTableView.AutosaveName?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .autosaveName(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var autosaveTableColumns: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .autosaveTableColumns(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var backgroundColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .backgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var columnAutoresizingStyle: BindingParser&lt;Dynamic&lt;NSTableView.ColumnAutoresizingStyle&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .columnAutoresizingStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var columns: BindingParser&lt;Dynamic&lt;[TableColumn&lt;Downcast.RowDataType&gt;]&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .columns(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var cornerView: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .cornerView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var draggingDestinationFeedbackStyle: BindingParser&lt;Dynamic&lt;NSTableView.DraggingDestinationFeedbackStyle&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .draggingDestinationFeedbackStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var floatsGroupRows: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .floatsGroupRows(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var gridColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .gridColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var gridStyleMask: BindingParser&lt;Dynamic&lt;NSTableView.GridLineStyle&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .gridStyleMask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var headerView: BindingParser&lt;Dynamic&lt;TableHeaderViewConvertible?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .headerView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var intercellSpacing: BindingParser&lt;Dynamic&lt;NSSize&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .intercellSpacing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var rowHeight: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .rowHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var rows: BindingParser&lt;Dynamic&lt;TableRowAnimatable&lt;Downcast.RowDataType&gt;&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .rows(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var rowSizeStyle: BindingParser&lt;Dynamic&lt;NSTableView.RowSizeStyle&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .rowSizeStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var selectionHighlightStyle: BindingParser&lt;Dynamic&lt;NSTableView.SelectionHighlightStyle&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionHighlightStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var userInterfaceLayoutDirection: BindingParser&lt;Dynamic&lt;NSUserInterfaceLayoutDirection&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .userInterfaceLayoutDirection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var usesAlternatingRowBackgroundColors: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .usesAlternatingRowBackgroundColors(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var usesAutomaticRowHeights: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .usesAutomaticRowHeights(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var verticalMotionCanBeginDrag: BindingParser&lt;Dynamic&lt;Bool&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .verticalMotionCanBeginDrag(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var deselectAll: BindingParser&lt;Signal&lt;Void&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .deselectAll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var deselectColumn: BindingParser&lt;Signal&lt;NSUserInterfaceItemIdentifier&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .deselectColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var deselectRow: BindingParser&lt;Signal&lt;Int&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .deselectRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var hideRowActions: BindingParser&lt;Signal&lt;Void&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .hideRowActions(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var hideRows: BindingParser&lt;Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .hideRows(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var highlightColumn: BindingParser&lt;Signal&lt;NSUserInterfaceItemIdentifier?&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .highlightColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var moveColumn: BindingParser&lt;Signal&lt;(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .moveColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var scrollColumnToVisible: BindingParser&lt;Signal&lt;NSUserInterfaceItemIdentifier&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .scrollColumnToVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var scrollRowToVisible: BindingParser&lt;Signal&lt;Int&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .scrollRowToVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var selectAll: BindingParser&lt;Signal&lt;Void&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectAll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var selectColumns: BindingParser&lt;Signal&lt;(identifiers: Set&lt;NSUserInterfaceItemIdentifier&gt;, byExtendingSelection: Bool)&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectColumns(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var selectRows: BindingParser&lt;Signal&lt;(indexes: IndexSet, byExtendingSelection: Bool)&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectRows(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sizeLastColumnToFit: BindingParser&lt;Signal&lt;Void&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sizeLastColumnToFit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sizeToFit: BindingParser&lt;Signal&lt;Void&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sizeToFit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var unhideRows: BindingParser&lt;Signal&lt;(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .unhideRows(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var columnMoved: BindingParser&lt;SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .columnMoved(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var columnResized: BindingParser&lt;SignalInput&lt;(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .columnResized(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var doubleAction: BindingParser&lt;TargetAction, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .doubleAction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var visibleRowsChanged: BindingParser&lt;SignalInput&lt;CountableRange&lt;Int&gt;&gt;, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .visibleRowsChanged(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var acceptDrop: BindingParser&lt;(_ tableView: NSTableView, _ row: Int, _ data: Downcast.RowDataType?) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .acceptDrop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didClickTableColumn: BindingParser&lt;(NSTableView, NSTableColumn) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didClickTableColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var didDragTableColumn: BindingParser&lt;(NSTableView, NSTableColumn) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .didDragTableColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var draggingSessionEnded: BindingParser&lt;(_ tableView: NSTableView, _ session: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .draggingSessionEnded(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var draggingSessionWillBegin: BindingParser&lt;(_ tableView: NSTableView, _ session: NSDraggingSession, _ willBeginAt: NSPoint, _ forRowIndexes: IndexSet) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .draggingSessionWillBegin(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var groupRowCellConstructor: BindingParser&lt;(Int) -&gt; TableCellViewConvertible, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .groupRowCellConstructor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var heightOfRow: BindingParser&lt;(_ tableView: NSTableView, _ row: Int, _ rowData: Downcast.RowDataType?) -&gt; CGFloat, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .heightOfRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var isGroupRow: BindingParser&lt;(_ tableView: NSTableView, _ row: Int, _ rowData: Downcast.RowDataType?) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .isGroupRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var mouseDownInHeaderOfTableColumn: BindingParser&lt;(NSTableView, NSTableColumn) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .mouseDownInHeaderOfTableColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var nextTypeSelectMatch: BindingParser&lt;(_ tableView: NSTableView, _ startRow: Int, _ endRow: Int, _ searchString: String) -&gt; Int, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .nextTypeSelectMatch(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var pasteboardWriter: BindingParser&lt;(_ tableView: NSTableView, _ row: Int, _ data: Downcast.RowDataType?) -&gt; NSPasteboardWriting, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .pasteboardWriter(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var rowActionsForRow: BindingParser&lt;(_ tableView: NSTableView, _ row: Int, _ data: Downcast.RowDataType?, _ edge: NSTableView.RowActionEdge) -&gt; [NSTableViewRowAction], TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .rowActionsForRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var rowView: BindingParser&lt;(_ tableView: NSTableView, _ row: Int, _ rowData: Downcast.RowDataType?) -&gt; TableRowViewConvertible?, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .rowView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var selectionDidChange: BindingParser&lt;(Notification) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var selectionIndexesForProposedSelection: BindingParser&lt;(_ tableView: NSTableView, IndexSet) -&gt; IndexSet, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionIndexesForProposedSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var selectionShouldChange: BindingParser&lt;(_ tableView: NSTableView) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .selectionShouldChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var shouldReorderColumn: BindingParser&lt;(_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier, _ newIndex: Int) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldReorderColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var shouldSelectRow: BindingParser&lt;(_ tableView: NSTableView, _ row: Int, _ rowData: Downcast.RowDataType?) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldSelectRow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var shouldSelectTableColumn: BindingParser&lt;(_ tableView: NSTableView, _ column: NSTableColumn?) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldSelectTableColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var shouldTypeSelectForEvent: BindingParser&lt;(_ tableView: NSTableView, _ event: NSEvent, _ searchString: String?) -&gt; Bool, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .shouldTypeSelectForEvent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sizeToFitWidthOfColumn: BindingParser&lt;(_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier) -&gt; CGFloat, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sizeToFitWidthOfColumn(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var sortDescriptorsDidChange: BindingParser&lt;(NSTableView, [NSSortDescriptor]) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .sortDescriptorsDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var typeSelectString: BindingParser&lt;(_ tableView: NSTableView, _ cell: TableCell&lt;Downcast.RowDataType&gt;) -&gt; String?, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .typeSelectString(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var updateDraggingItems: BindingParser&lt;(_ tableView: NSTableView, _ forDrag: NSDraggingInfo) -&gt; Void, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .updateDraggingItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
	static var validateDrop: BindingParser&lt;(_ tableView: NSTableView, _ info: NSDraggingInfo, _ proposedRow: Int, _ proposedDropOperation: NSTableView.DropOperation) -&gt; NSDragOperation, TableView&lt;Downcast.RowDataType&gt;.Binding, Downcast&gt; { return .init(extract: { if case .validateDrop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTableViewBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: TextFieldBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TextField.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTextFieldBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsCharacterPickerTouchBarItem: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .allowsCharacterPickerTouchBarItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var allowsDefaultTighteningForTruncation: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .allowsDefaultTighteningForTruncation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var allowsEditingTextAttributes: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .allowsEditingTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var allowsUndo: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .allowsUndo(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var backgroundColor: BindingParser&lt;Dynamic&lt;NSColor?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .backgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var bezelStyle: BindingParser&lt;Dynamic&lt;NSTextField.BezelStyle&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .bezelStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var drawsBackground: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .drawsBackground(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var importsGraphics: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .importsGraphics(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var isAutomaticTextCompletionEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .isAutomaticTextCompletionEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var isBezeled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .isBezeled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var isBordered: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .isBordered(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var isEditable: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .isEditable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var isSelectable: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .isSelectable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var maximumNumberOfLines: BindingParser&lt;Dynamic&lt;Int&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .maximumNumberOfLines(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var placeholderAttributedString: BindingParser&lt;Dynamic&lt;NSAttributedString?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .placeholderAttributedString(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var placeholderString: BindingParser&lt;Dynamic&lt;String?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .placeholderString(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var preferredMaxLayoutWidth: BindingParser&lt;Dynamic&lt;CGFloat&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .preferredMaxLayoutWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var sendsActionOnEndEditing: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .sendsActionOnEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var textColor: BindingParser&lt;Dynamic&lt;NSColor?&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .textColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var usesSingleLineMode: BindingParser&lt;Dynamic&lt;Bool&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .usesSingleLineMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectText: BindingParser&lt;Signal&lt;Void&gt;, TextField.Binding, Downcast&gt; { return .init(extract: { if case .selectText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var completions: BindingParser&lt;(_ control: NSTextField, _ textView: NSTextView, _ completions: [String], _ partialWordRange: NSRange, _ indexOfSelectedItem: UnsafeMutablePointer&lt;Int&gt;) -&gt; [String], TextField.Binding, Downcast&gt; { return .init(extract: { if case .completions(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var didFailToFormatString: BindingParser&lt;(_ control: NSTextField, _ string: String, _ errorDescription: String?) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .didFailToFormatString(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var didFailToValidatePartialString: BindingParser&lt;(_ control: NSTextField, _ partialString: String, _ errorDescription: String?) -&gt; Void, TextField.Binding, Downcast&gt; { return .init(extract: { if case .didFailToValidatePartialString(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var doCommand: BindingParser&lt;(_ control: NSTextField, _ textView: NSText, _ doCommandBySelector: Selector) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .doCommand(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var isValidObject: BindingParser&lt;(_ control: NSTextField, _ object: AnyObject) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .isValidObject(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var shouldBeginEditing: BindingParser&lt;(_ control: NSTextField, _ text: NSText) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .shouldBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
	static var shouldEndEditing: BindingParser&lt;(_ control: NSTextField, _ text: NSText) -&gt; Bool, TextField.Binding, Downcast&gt; { return .init(extract: { if case .shouldEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextFieldBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: TextViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, TextView.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asTextViewBinding() }) }
		
	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var string: BindingParser&lt;Dynamic&lt;String&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .string(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var backgroundColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .backgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var drawsBackground: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .drawsBackground(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isEditable: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isEditable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isSelectable: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isSelectable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isFieldEditor: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isFieldEditor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isRichText: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isRichText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var importsGraphics: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .importsGraphics(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var usesFontPanel: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .usesFontPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var font: BindingParser&lt;Dynamic&lt;NSFont&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .font(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var alignment: BindingParser&lt;Dynamic&lt;NSTextAlignment&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .alignment(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var textColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .textColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var baseWritingDirection: BindingParser&lt;Dynamic&lt;NSWritingDirection&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .baseWritingDirection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var maxSize: BindingParser&lt;Dynamic&lt;NSSize&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .maxSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var minSize: BindingParser&lt;Dynamic&lt;NSSize&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .minSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isVerticallyResizable: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isVerticallyResizable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isHorizontallyResizable: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isHorizontallyResizable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	
	static var textContainerInset: BindingParser&lt;Dynamic&lt;NSSize&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .textContainerInset(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var allowsDocumentBackgroundColorChange: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .allowsDocumentBackgroundColorChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var allowsUndo: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .allowsUndo(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var defaultParagraphStyle: BindingParser&lt;Dynamic&lt;NSParagraphStyle&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .defaultParagraphStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var allowsImageEditing: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .allowsImageEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isAutomaticQuoteSubstitutionEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isAutomaticQuoteSubstitutionEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isAutomaticLinkDetectionEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isAutomaticLinkDetectionEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var displaysLinkToolTips: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .displaysLinkToolTips(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var usesRuler: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .usesRuler(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var usesInspectorBar: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .usesInspectorBar(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var selectionGranularity: BindingParser&lt;Dynamic&lt;NSSelectionGranularity&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .selectionGranularity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var insertionPointColor: BindingParser&lt;Dynamic&lt;NSColor&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .insertionPointColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var selectedTextAttributes: BindingParser&lt;Dynamic&lt;[NSAttributedString.Key : Any]&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .selectedTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var markedTextAttributes: BindingParser&lt;Dynamic&lt;[NSAttributedString.Key : Any]&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .markedTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var linkTextAttributes: BindingParser&lt;Dynamic&lt;[NSAttributedString.Key : Any]&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .linkTextAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var typingAttributes: BindingParser&lt;Dynamic&lt;[NSAttributedString.Key : Any]&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .typingAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isContinuousSpellCheckingEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isContinuousSpellCheckingEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isGrammarCheckingEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isGrammarCheckingEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var usesFindPanel: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .usesFindPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var enabledTextCheckingTypes: BindingParser&lt;Dynamic&lt;NSTextCheckingTypes&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .enabledTextCheckingTypes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isAutomaticDashSubstitutionEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isAutomaticDashSubstitutionEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isAutomaticDataDetectionEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isAutomaticDataDetectionEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isAutomaticSpellingCorrectionEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isAutomaticSpellingCorrectionEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isAutomaticTextReplacementEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isAutomaticTextReplacementEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var layoutOrientation: BindingParser&lt;Dynamic&lt;NSLayoutManager.TextLayoutOrientation&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .layoutOrientation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var usesFindBar: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .usesFindBar(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isIncrementalSearchingEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isIncrementalSearchingEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var allowsCharacterPickerTouchBarItem: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .allowsCharacterPickerTouchBarItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var isAutomaticTextCompletionEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .isAutomaticTextCompletionEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var usesRolloverButtonForSelection: BindingParser&lt;Dynamic&lt;Bool&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .usesRolloverButtonForSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectRange: BindingParser&lt;Signal&lt;NSRange&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .selectRange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var selectAll: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .selectAll(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var copy: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .copy(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var cut: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .cut(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var paste: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .paste(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var copyFont: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .copyFont(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var pasteFont: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .pasteFont(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var copyRuler: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .copyRuler(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var pasteRuler: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .pasteRuler(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var delete: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .delete(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var changeFont: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .changeFont(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var alignCenter: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .alignCenter(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var alignLeft: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .alignLeft(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var alignRight: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .alignRight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var superscript: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .superscript(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var `subscript`: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .`subscript`(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var unscript: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .unscript(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var underline: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .underline(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var checkSpelling: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .checkSpelling(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var showGuessPanel: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .showGuessPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var sizeToFit: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .sizeToFit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var scrollRangeToVisible: BindingParser&lt;Signal&lt;NSRange&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .scrollRangeToVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	
	static var showFindIndicator: BindingParser&lt;Signal&lt;NSRange&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .showFindIndicator(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var changeDocumentBackgroundColor: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .changeDocumentBackgroundColor(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var outline: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .outline(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var alignJustified: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .alignJustified(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var changeAttributes: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .changeAttributes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var useStandardKerning: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .useStandardKerning(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var lowerBaseline: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .lowerBaseline(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var raiseBaseline: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .raiseBaseline(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var turnOffKerning: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .turnOffKerning(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var loosenKerning: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .loosenKerning(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var tightenKerning: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .tightenKerning(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var useStandardLigatures: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .useStandardLigatures(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var turnOffLigatures: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .turnOffLigatures(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var useAllLigatures: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .useAllLigatures(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var clicked: BindingParser&lt;Signal&lt;(Any, Int)&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .clicked(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var pasteAsPlainText: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .pasteAsPlainText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var pasteAsRichText: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .pasteAsRichText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var breakUndoCoalescing: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .breakUndoCoalescing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var setSpellingState: BindingParser&lt;Signal&lt;(NSAttributedString.SpellingState, NSRange)&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .setSpellingState(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var orderFrontSharingServicePicker: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .orderFrontSharingServicePicker(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var startSpeaking: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .startSpeaking(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var stopSpeaking: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .stopSpeaking(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var performFindPanelAction: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .performFindPanelAction(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var orderFrontLinkPanel: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .orderFrontLinkPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var orderFrontListPanel: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .orderFrontListPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var orderFrontSpacingPanel: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .orderFrontSpacingPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var orderFrontTablePanel: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .orderFrontTablePanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var orderFrontSubstitutionsPanel: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .orderFrontSubstitutionsPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var complete: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .complete(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var checkTextInDocument: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .checkTextInDocument(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var checkTextInSelection: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .checkTextInSelection(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var checkText: BindingParser&lt;Signal&lt;(NSRange, NSTextCheckingTypes, [NSSpellChecker.OptionKey: Any])&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .checkText(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var updateQuickLookPreviewPanel: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .updateQuickLookPreviewPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var toggleQuickLookPreviewPanel: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .toggleQuickLookPreviewPanel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var updateCandidates: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .updateCandidates(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var updateTextTouchBarItems: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .updateTextTouchBarItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var updateTouchBarItemIdentifiers: BindingParser&lt;Signal&lt;Void&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .updateTouchBarItemIdentifiers(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBeginEditing: BindingParser&lt;SignalInput&lt;NSTextView&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .didBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var didChange: BindingParser&lt;SignalInput&lt;NSTextView&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .didChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var didEndEditing: BindingParser&lt;SignalInput&lt;(NSTextView, NSTextMovement?)&gt;, TextView.Binding, Downcast&gt; { return .init(extract: { if case .didEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldBeginEditing: BindingParser&lt;(NSTextView) -&gt; Bool, TextView.Binding, Downcast&gt; { return .init(extract: { if case .shouldBeginEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
	static var shouldEndEditing: BindingParser&lt;(NSTextView) -&gt; Bool, TextView.Binding, Downcast&gt; { return .init(extract: { if case .shouldEndEditing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asTextViewBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: ToolbarItemBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asToolbarItemBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var image: BindingParser&lt;Dynamic&lt;NSImage?&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .image(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var isEnabled: BindingParser&lt;Dynamic&lt;Bool&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .isEnabled(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var label: BindingParser&lt;Dynamic&lt;String&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .label(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var maxSize: BindingParser&lt;Dynamic&lt;NSSize&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .maxSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var menuFormRepresentation: BindingParser&lt;Dynamic&lt;MenuItemConvertible&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .menuFormRepresentation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var minSize: BindingParser&lt;Dynamic&lt;NSSize&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .minSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var paletteLabel: BindingParser&lt;Dynamic&lt;String&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .paletteLabel(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var tag: BindingParser&lt;Dynamic&lt;Int&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .tag(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var toolTip: BindingParser&lt;Dynamic&lt;String?&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .toolTip(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var view: BindingParser&lt;Dynamic&lt;ViewConvertible?&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .view(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	static var visibilityPriority: BindingParser&lt;Dynamic&lt;NSToolbarItem.VisibilityPriority&gt;, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .visibilityPriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: BindingParser&lt;TargetAction, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .action(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var validate: BindingParser&lt;(NSToolbarItem) -&gt; Bool, ToolbarItem.Binding, Downcast&gt; { return .init(extract: { if case .validate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarItemBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: ToolbarBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asToolbarBinding() }) }
		
	//	0. Static styles are applied at construction and are subsequently immutable.
	static var itemDescriptions: BindingParser&lt;Constant&lt;[ToolbarItemDescription]&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .itemDescriptions(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsExtensionItems: BindingParser&lt;Dynamic&lt;Bool&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .allowsExtensionItems(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var allowsUserCustomization: BindingParser&lt;Dynamic&lt;Bool&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .allowsUserCustomization(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var autosavesConfiguration: BindingParser&lt;Dynamic&lt;Bool&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .autosavesConfiguration(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var displayMode: BindingParser&lt;Dynamic&lt;NSToolbar.DisplayMode&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .displayMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var isVisible: BindingParser&lt;Dynamic&lt;Bool&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .isVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var selectedItemIdentifier: BindingParser&lt;Dynamic&lt;NSToolbarItem.Identifier&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .selectedItemIdentifier(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var showsBaselineSeparator: BindingParser&lt;Dynamic&lt;Bool&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .showsBaselineSeparator(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var sizeMode: BindingParser&lt;Dynamic&lt;NSToolbar.SizeMode&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .sizeMode(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var runCustomizationPalette: BindingParser&lt;Signal&lt;Void&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .runCustomizationPalette(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didRemoveItem: BindingParser&lt;SignalInput&lt;Void&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .didRemoveItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
	static var willAddItem: BindingParser&lt;SignalInput&lt;Void&gt;, Toolbar.Binding, Downcast&gt; { return .init(extract: { if case .willAddItem(let x) = $0 { return x } else { return nil } }, upcast: { $0.asToolbarBinding() }) }
}

#endif

#if os(macOS)

extension BindingParser where Downcast: ViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, View.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asViewBinding() }) }
		
	//	0. Static styles are applied at construction and are subsequently immutable.
	static var layer: BindingParser&lt;Constant&lt;Layer&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .layer(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var appearance: BindingParser&lt;Dynamic&lt;NSAppearance?&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .appearance(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var canDrawSubviewsIntoLayer: BindingParser&lt;Dynamic&lt;Bool&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .canDrawSubviewsIntoLayer(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var focusRingType: BindingParser&lt;Dynamic&lt;NSFocusRingType&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .focusRingType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var frameRotation: BindingParser&lt;Dynamic&lt;CGFloat&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .frameRotation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var gestureRecognizers: BindingParser&lt;Dynamic&lt;[GestureRecognizerConvertible]&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .gestureRecognizers(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var horizontalContentCompressionResistancePriority: BindingParser&lt;Dynamic&lt;NSLayoutConstraint.Priority&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .horizontalContentCompressionResistancePriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var horizontalContentHuggingPriority: BindingParser&lt;Dynamic&lt;NSLayoutConstraint.Priority&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .horizontalContentHuggingPriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var identifier: BindingParser&lt;Dynamic&lt;NSUserInterfaceItemIdentifier?&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .identifier(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var isHidden: BindingParser&lt;Dynamic&lt;Bool&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .isHidden(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var layerContentsRedrawPolicy: BindingParser&lt;Dynamic&lt;NSView.LayerContentsRedrawPolicy&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .layerContentsRedrawPolicy(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var layout: BindingParser&lt;Dynamic&lt;Layout&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .layout(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var pressureConfiguration: BindingParser&lt;Dynamic&lt;NSPressureConfiguration&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .pressureConfiguration(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var registeredDragTypes: BindingParser&lt;Dynamic&lt;[NSPasteboard.PasteboardType]&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .registeredDragTypes(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var tooltip: BindingParser&lt;Dynamic&lt;String&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .tooltip(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var verticalContentCompressionResistancePriority: BindingParser&lt;Dynamic&lt;NSLayoutConstraint.Priority&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .verticalContentCompressionResistancePriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var verticalContentHuggingPriority: BindingParser&lt;Dynamic&lt;NSLayoutConstraint.Priority&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .verticalContentHuggingPriority(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var becomeFirstResponder: BindingParser&lt;Signal&lt;Void&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .becomeFirstResponder(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var needsDisplay: BindingParser&lt;Signal&lt;Bool&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .needsDisplay(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var printView: BindingParser&lt;Signal&lt;Void&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .printView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var scrollRectToVisible: BindingParser&lt;Signal&lt;NSRect&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .scrollRectToVisible(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var setNeedsDisplayInRect: BindingParser&lt;Signal&lt;NSRect&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .setNeedsDisplayInRect(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var boundsDidChange: BindingParser&lt;SignalInput&lt;NSRect&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .boundsDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	static var frameDidChange: BindingParser&lt;SignalInput&lt;NSRect&gt;, View.Binding, Downcast&gt; { return .init(extract: { if case .frameDidChange(let x) = $0 { return x } else { return nil } }, upcast: { $0.asViewBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

#endif

#if os(macOS)

extension BindingParser where Downcast: WindowBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser&lt;$2, Window.Binding, Downcast&gt; { return .init(extract: { if case .$1(let x) = \$0 { return x } else { return nil } }, upcast: { \$0.asWindowBinding() }) }
		
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var deferCreation: BindingParser&lt;Constant&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .deferCreation(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var initialFirstResponderTag: BindingParser&lt;Constant&lt;Int&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .initialFirstResponderTag(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var acceptsMouseMovedEvents: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .acceptsMouseMovedEvents(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var allowsConcurrentViewDrawing: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .allowsConcurrentViewDrawing(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var allowsToolTipsWhenApplicationIsInactive: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .allowsToolTipsWhenApplicationIsInactive(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var alphaValue: BindingParser&lt;Dynamic&lt;CGFloat&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .alphaValue(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var animationBehavior: BindingParser&lt;Dynamic&lt;NSWindow.AnimationBehavior&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .animationBehavior(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var appearance: BindingParser&lt;Dynamic&lt;NSAppearance?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .appearance(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var autorecalculatesKeyViewLoop: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .autorecalculatesKeyViewLoop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var backingType: BindingParser&lt;Dynamic&lt;NSWindow.BackingStoreType&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .backingType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var canBecomeVisibleWithoutLogin: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .canBecomeVisibleWithoutLogin(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var canHide: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .canHide(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var collectionBehavior: BindingParser&lt;Dynamic&lt;NSWindow.CollectionBehavior&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .collectionBehavior(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var colorSpace: BindingParser&lt;Dynamic&lt;NSColorSpace&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .colorSpace(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var contentAspectRatio: BindingParser&lt;Dynamic&lt;NSSize&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .contentAspectRatio(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var contentHeight: BindingParser&lt;Dynamic&lt;WindowDimension&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .contentHeight(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var contentMaxSize: BindingParser&lt;Dynamic&lt;NSSize&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .contentMaxSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var contentMinSize: BindingParser&lt;Dynamic&lt;NSSize&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .contentMinSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var contentResizeIncrements: BindingParser&lt;Dynamic&lt;NSSize&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .contentResizeIncrements(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var contentRelativity: BindingParser&lt;Dynamic&lt;WindowDimension.Relativity&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .contentRelativity(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var contentView: BindingParser&lt;Dynamic&lt;ViewConvertible&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .contentView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var contentWidth: BindingParser&lt;Dynamic&lt;WindowDimension&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .contentWidth(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var depthLimit: BindingParser&lt;Dynamic&lt;NSWindow.Depth?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .depthLimit(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var displaysWhenScreenProfileChanges: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .displaysWhenScreenProfileChanges(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var frameAutosaveName: BindingParser&lt;Dynamic&lt;NSWindow.FrameAutosaveName&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .frameAutosaveName(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var frameHorizontal: BindingParser&lt;Dynamic&lt;WindowDimension&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .frameHorizontal(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var frameVertical: BindingParser&lt;Dynamic&lt;WindowDimension&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .frameVertical(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var hasShadow: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .hasShadow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var hidesOnDeactivate: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .hidesOnDeactivate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var ignoresMouseEvents: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .ignoresMouseEvents(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var isDocumentEdited: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .isDocumentEdited(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var isExcludedFromWindowsMenu: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .isExcludedFromWindowsMenu(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var isMovable: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .isMovable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var isMovableByWindowBackground: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .isMovableByWindowBackground(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var isOpaque: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .isOpaque(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var isRestorable: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .isRestorable(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var key: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .key(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var level: BindingParser&lt;Dynamic&lt;NSWindow.Level&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .level(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var main: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .main(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var maxFullScreenContentSize: BindingParser&lt;Dynamic&lt;NSSize&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .maxFullScreenContentSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var minFullScreenContentSize: BindingParser&lt;Dynamic&lt;NSSize&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .minFullScreenContentSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var miniwindowImage: BindingParser&lt;Dynamic&lt;NSImage?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .miniwindowImage(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var miniwindowTitle: BindingParser&lt;Dynamic&lt;String&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .miniwindowTitle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var order: BindingParser&lt;Dynamic&lt;WindowOrder&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .order(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var preservesContentDuringLiveResize: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .preservesContentDuringLiveResize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var preventsApplicationTerminationWhenModal: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .preventsApplicationTerminationWhenModal(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var representedURL: BindingParser&lt;Dynamic&lt;URL?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .representedURL(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var resizeStyle: BindingParser&lt;Dynamic&lt;WindowResizeStyle&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .resizeStyle(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var restorationClass: BindingParser&lt;Dynamic&lt;NSWindowRestoration.Type&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .restorationClass(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var screen: BindingParser&lt;Dynamic&lt;NSScreen?&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .screen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var sharingType: BindingParser&lt;Dynamic&lt;NSWindow.SharingType&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .sharingType(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var styleMask: BindingParser&lt;Dynamic&lt;NSWindow.StyleMask&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .styleMask(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var title: BindingParser&lt;Dynamic&lt;String&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .title(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var titlebarAppearsTransparent: BindingParser&lt;Dynamic&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .titlebarAppearsTransparent(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var titleVisibility: BindingParser&lt;Dynamic&lt;NSWindow.TitleVisibility&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .titleVisibility(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var toolbar: BindingParser&lt;Dynamic&lt;ToolbarConvertible&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .toolbar(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var close: BindingParser&lt;Signal&lt;WindowCloseBehavior&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .close(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var criticalSheet: BindingParser&lt;Signal&lt;Callback&lt;NSWindow, NSApplication.ModalResponse&gt;&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .criticalSheet(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var deminiaturize: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .deminiaturize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var display: BindingParser&lt;Signal&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .display(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var invalidateShadow: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .invalidateShadow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var miniaturize: BindingParser&lt;Signal&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .miniaturize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var presentError: BindingParser&lt;Signal&lt;Callback&lt;Error, Bool&gt;&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .presentError(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var printWindow: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .printWindow(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var recalculateKeyViewLoop: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .recalculateKeyViewLoop(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var runToolbarCustomizationPalette: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .runToolbarCustomizationPalette(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var selectNextKeyView: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .selectNextKeyView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var selectPreviousKeyView: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .selectPreviousKeyView(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var sheet: BindingParser&lt;Signal&lt;Callback&lt;NSWindow, NSApplication.ModalResponse&gt;&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .sheet(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var toggleFullScreen: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .toggleFullScreen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var toggleToolbarShown: BindingParser&lt;Signal&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .toggleToolbarShown(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var zoom: BindingParser&lt;Signal&lt;Bool&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .zoom(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var effectiveAppearanceName: BindingParser&lt;SignalInput&lt;NSAppearance.Name&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .effectiveAppearanceName(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didBecomeKey: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didBecomeKey(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didBecomeMain: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didBecomeMain(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didChangeBackingProperties: BindingParser&lt;SignalInput&lt;(oldColorSpace: NSColorSpace?, oldScaleFactor: CGFloat?)&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didChangeBackingProperties(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didChangeOcclusionState: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didChangeOcclusionState(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didChangeScreen: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didChangeScreen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didChangeScreenProfile: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didChangeScreenProfile(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didDeminiaturize: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didDeminiaturize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didEndLiveResize: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didEndLiveResize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didEndSheet: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didEndSheet(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didEnterFullScreen: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didEnterFullScreen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didEnterVersionBrowser: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didEnterVersionBrowser(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didExitFullScreen: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didExitFullScreen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didExitVersionBrowser: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didExitVersionBrowser(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didExpose: BindingParser&lt;SignalInput&lt;NSRect&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didExpose(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didMiniaturize: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didMiniaturize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didMove: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didMove(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didResignKey: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didResignKey(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didResignMain: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didResignMain(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didResize: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didResize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var didUpdate: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .didUpdate(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willBeginSheet: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .willBeginSheet(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willClose: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .willClose(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willEnterFullScreen: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .willEnterFullScreen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willEnterVersionBrowser: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .willEnterVersionBrowser(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willExitFullScreen: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .willExitFullScreen(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willExitVersionBrowser: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .willExitVersionBrowser(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willMiniaturize: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .willMiniaturize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willMove: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .willMove(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willStartLiveResize: BindingParser&lt;SignalInput&lt;Void&gt;, Window.Binding, Downcast&gt; { return .init(extract: { if case .willStartLiveResize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldClose: BindingParser&lt;(NSWindow) -&gt; Bool, Window.Binding, Downcast&gt; { return .init(extract: { if case .shouldClose(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var shouldPopUpDocumentPathMenu: BindingParser&lt;(NSWindow, NSMenu) -&gt; Bool, Window.Binding, Downcast&gt; { return .init(extract: { if case .shouldPopUpDocumentPathMenu(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var shouldZoom: BindingParser&lt;(NSWindow, NSRect) -&gt; Bool, Window.Binding, Downcast&gt; { return .init(extract: { if case .shouldZoom(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willResize: BindingParser&lt;(NSWindow, NSSize) -&gt; NSSize, Window.Binding, Downcast&gt; { return .init(extract: { if case .willResize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willResizeForVersionBrowser: BindingParser&lt;(_ window: NSWindow, _ maxPreferredSize: NSSize, _ maxAllowedSize: NSSize) -&gt; NSSize, Window.Binding, Downcast&gt; { return .init(extract: { if case .willResizeForVersionBrowser(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willUseFullScreenContentSize: BindingParser&lt;(NSWindow, NSSize) -&gt; NSSize, Window.Binding, Downcast&gt; { return .init(extract: { if case .willUseFullScreenContentSize(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willUseFullScreenPresentationOptions: BindingParser&lt;(NSWindow, NSApplication.PresentationOptions) -&gt; NSApplication.PresentationOptions, Window.Binding, Downcast&gt; { return .init(extract: { if case .willUseFullScreenPresentationOptions(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
	static var willUseStandardFrame: BindingParser&lt;(NSWindow, NSRect) -&gt; NSRect, Window.Binding, Downcast&gt; { return .init(extract: { if case .willUseStandardFrame(let x) = $0 { return x } else { return nil } }, upcast: { $0.asWindowBinding() }) }
}

#endif
</string>
		<key>MockServices.swift:content</key>
		<string>import Foundation

class MockFileService: FileService {
	enum FileError: Error {
		case notFound
	}
	static let appSupport = URL(fileURLWithPath: "/Application Support/")
	var files: [URL: Data] = [:]
	
	func applicationSupportURL() throws -&gt; URL {
		return MockFileService.appSupport
	}
	
	func data(contentsOf url: URL) throws -&gt; Data {
		guard let file = files[url] else { throw FileError.notFound }
		return file
	}
	
	func writeData(_ data: Data, to url: URL) throws {
		files[url] = data
	}
	
	func fileExists(at url: URL) -&gt; Bool {
		return files[url] != nil
	}
}</string>
		<key>TableViewTests.swift:content</key>
		<string>import XCTest

class TableViewTests: XCTestCase {
	
	var services: Services!
	var doc: DocumentAdapter!
	var windowState: WindowState!
	
	var tableBindings: [TableView&lt;String&gt;.Binding] = []
	var addButtonBindings: [Button.Binding] = []
	var removeButtonBindings: [Button.Binding] = []
	
	override func setUp() {
		services = Services(fileService: MockFileService())
		doc = DocumentAdapter(document: Document(services: services))
		windowState = WindowState()

		let windowBindings = try! Window.consumeBindings(from: window(windowState, doc))
		let splitViewBindings = try! SplitView.consumeBindings(from: Window.latestValue(for: .contentView, in: windowBindings))
		let masterViewBindings = try! View.consumeBindings(from: SplitView.latestValue(for: .arrangedSubviews, in: splitViewBindings).values.first!.view)
		let layout = try! View.latestValue(for: .layout, in: masterViewBindings)
		let scrollViewBindings = try! ScrollView.consumeBindings(from: layout.view(at: 0)!)
		let clipViewBindings = try! ClipView.consumeBindings(from: ScrollView.latestValue(for: .contentView, in: scrollViewBindings))
		let tableView = try! ClipView.latestValue(for: .documentView, in: clipViewBindings)!
		
		tableBindings = try! TableView&lt;String&gt;.consumeBindings(from: tableView)
		addButtonBindings = try! Button.consumeBindings(from: layout.view(at: 1)!)
		removeButtonBindings = try! Button.consumeBindings(from: layout.view(at: 2)!)
	}
	
	override func tearDown() {
	}
	
	func testInitialTableRows() throws {
		let tableState = try TableView&lt;String&gt;.Binding.tableStructure(in: tableBindings)
		XCTAssertEqual(Array(tableState.values?.map { $0 } ?? []), Document.initialContents().rows)
	}
	
	func testCreateRow() throws {
		let targetAction = try! Control.argument(for: .action, in: addButtonBindings)
		
		switch targetAction {
		case .singleTarget(let input): input.send(nil)
		default: fatalError()
		}
		
		let tableState = try TableView&lt;String&gt;.Binding.tableStructure(in: tableBindings)
		XCTAssertEqual(Array(tableState.values ?? []), Document.initialContents().rows + ["4"])
	}
	
	func testDeleteRow() throws {
		let targetAction = try! Control.argument(for: .action, in: removeButtonBindings)
		
		windowState.rowSelection.set().send(DetailState(index: 0, value: ""))
		
		switch targetAction {
		case .singleTarget(let input): input.send(nil)
		default: fatalError()
		}
		
		let tableState = try TableView&lt;String&gt;.Binding.tableStructure(in: tableBindings)
		var expected = Document.initialContents().rows
		expected.remove(at: 0)

		XCTAssertEqual(Array(tableState.values ?? []), expected)
	}
}</string>
	</dict>
	<key>Identifier</key>
	<string>com.cocoawithlove.views-unit.cocoaApplicationUnitTestBundle</string>
	<key>Kind</key>
	<string>Xcode.Xcode3.ProjectTemplateUnitKind</string>
	<key>Nodes</key>
	<array>
		<string>CwlViews_macOSTesting.swift:comments</string>
		<string>CwlViews_macOSTesting.swift:imports:importProject</string>
		<string>CwlViews_macOSTesting.swift:content</string>
		<string>MockServices.swift:comments</string>
		<string>MockServices.swift:imports:importProject</string>
		<string>MockServices.swift:content</string>
		<string>TableViewTests.swift:comments</string>
		<string>TableViewTests.swift:imports:importProject</string>
		<string>TableViewTests.swift:content</string>
	</array>
	<key>Targets</key>
	<array>
		<dict>
			<key>TargetIdentifier</key>
			<string>com.apple.dt.cocoaApplicationUnitTestBundleTarget</string>
			<key>TargetIdentifierToBeTested</key>
			<string>com.apple.dt.cocoaApplicationTarget</string>
		</dict>
	</array>
</dict>
</plist>
