//
//  This file is part of a concatenation of the CwlViews framework with public
//  interfaces for exposing from libraries or use in Swift Playgrounds).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-05-11 02:03:26 +0000 from the following files:
//   CwlAlertAction_iOS.swift
//   CwlAlertController_iOS.swift
//   CwlApplication_iOS.swift
//   CwlBarButtonItem_iOS.swift
//   CwlBarItem_iOS.swift
//   CwlButton_iOS.swift
//   CwlControl_iOS.swift
//   CwlExtendedViewController_iOS.swift
//   CwlGestureRecognizer_iOS.swift
//   CwlImageView_iOS.swift
//   CwlLabel_iOS.swift
//   CwlLongPressGestureRecognizer_iOS.swift
//   CwlNavigationBar_iOS.swift
//   CwlNavigationController_iOS.swift
//   CwlNavigationItem_iOS.swift
//   CwlPageControl.swift
//   CwlPageViewController_iOS.swift
//   CwlPanGestureRecognizer_iOS.swift
//   CwlPinchGestureRecognizer_iOS.swift
//   CwlRotationGestureRecognizer_iOS.swift
//   CwlScreenEdgePanGestureRecognizer_iOS.swift
//   CwlScrollView_iOS.swift
//   CwlSearchBar_iOS.swift
//   CwlSlider_iOS.swift
//   CwlSplitViewController_iOS.swift
//   CwlSwipeGestureRecognizer_iOS.swift
//   CwlSwitch_iOS.swift
//   CwlTabBarController_iOS.swift
//   CwlTabBarItem_iOS.swift
//   CwlTabBar_iOS.swift
//   CwlTableViewCell_iOS.swift
//   CwlTableView_iOS.swift
//   CwlTapGestureRecognizer_iOS.swift
//   CwlTextField_iOS.swift
//   CwlTextInputTraits_iOS.swift
//   CwlTextView_iOS.swift
//   CwlToolbar_iOS.swift
//   CwlViewController_iOS.swift
//   CwlView_iOS.swift
//   CwlWindow_iOS.swift

import UIKit

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class AlertAction: Binder, AlertActionConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension AlertAction {
	enum Binding: AlertActionBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case style(Constant<UIAlertAction.Style>)
		case title(Constant<String>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case handler(SignalInput<Void>)

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension AlertAction {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = AlertAction.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = UIAlertAction
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		public var title: String? = nil
		public var style: UIAlertAction.Style = .default
		public var handler: MultiOutput<Void>? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension AlertAction.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance {
		return type.init(title: title, style: style, handler: handler.map { h in
			{ _ in h.input.send(value: ()) }
		})
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let s): return inherited.prepareBinding(s)
		
		case .style(let x): style = x.value
		case .title(let x): title = x.value
		
		case .handler(let x):
			handler = handler ?? Input<Void>().multicast()
			handler?.signal.bind(to: x)
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .style: return nil
		case .title: return nil
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case .handler: return handler?.input

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension AlertAction.Preparer {
	public typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: AlertActionBinding {
	public typealias AlertActionName<V> = BindingName<V, AlertAction.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> AlertAction.Binding) -> AlertActionName<V> {
		return AlertActionName<V>(source: source, downcast: Binding.alertActionBinding)
	}
}
public extension BindingName where Binding: AlertActionBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: AlertActionName<$2> { return .name(AlertAction.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var style: AlertActionName<Constant<UIAlertAction.Style>> { return .name(AlertAction.Binding.style) }
	static var title: AlertActionName<Constant<String>> { return .name(AlertAction.Binding.title) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: AlertActionName<Dynamic<Bool>> { return .name(AlertAction.Binding.isEnabled) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	static var handler: AlertActionName<SignalInput<Void>> { return .name(AlertAction.Binding.handler) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol AlertActionConvertible {
	func uiAlertAction() -> AlertAction.Instance
}
extension UIAlertAction: AlertActionConvertible, DefaultConstructable {
	public func uiAlertAction() -> AlertAction.Instance { return self }
}
public extension AlertAction {
	func uiAlertAction() -> AlertAction.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol AlertActionBinding: BinderBaseBinding {
	static func alertActionBinding(_ binding: AlertAction.Binding) -> Self
	func asAlertActionBinding() -> AlertAction.Binding?
}
public extension AlertActionBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return alertActionBinding(.inheritedBinding(binding))
	}
}
public extension AlertActionBinding where Preparer.Inherited.Binding: AlertActionBinding {
	func asAlertActionBinding() -> AlertAction.Binding? {
		return asInheritedBinding()?.asAlertActionBinding()
	}
}
public extension AlertAction.Binding {
	typealias Preparer = AlertAction.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asAlertActionBinding() -> AlertAction.Binding? { return self }
	static func alertActionBinding(_ binding: AlertAction.Binding) -> AlertAction.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class AlertController: Binder, AlertControllerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension AlertController {
	enum Binding: AlertControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case actions(Constant<[AlertActionConvertible]>)
		case preferredStyle(Constant<UIAlertController.Style>)
		case textFields(Constant<[TextField]>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case message(Dynamic<String?>)
		case preferredActionIndex(Dynamic<Int?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension AlertController {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = AlertController.Binding
		public typealias Inherited = ViewController.Preparer
		public typealias Instance = UIAlertController
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var title = InitialSubsequent<String>()
		var message = InitialSubsequent<String?>()
		var preferredStyle: UIAlertController.Style = .alert
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension AlertController.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance {
		return type.init(title: title.initial, message: message.initial ?? nil, preferredStyle: preferredStyle)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.title(let x)): title = x.initialSubsequent()
		case .inheritedBinding(let s): return inherited.prepareBinding(s)
		case .preferredStyle(let x): preferredStyle = x.value
		case .message(let x): message = x.initialSubsequent()
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .actions(let x):
			for a in x.value {
				instance.addAction(a.uiAlertAction())
			}
			return nil
		case .preferredStyle: return nil
		case .textFields(let x):
			for bindings in x.value {
				instance.addTextField { textField in bindings.apply(to: textField) }
			}
			return nil
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .message(let x): return x.apply(instance) { i, v in i.message = v }
		case .preferredActionIndex(let x): return x.apply(instance) { i, v in i.preferredAction = v.map { i.actions[$0] } }
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension AlertController.Preparer {
	public typealias Storage = ViewController.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: AlertControllerBinding {
	public typealias AlertControllerName<V> = BindingName<V, AlertController.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> AlertController.Binding) -> AlertControllerName<V> {
		return AlertControllerName<V>(source: source, downcast: Binding.alertControllerBinding)
	}
}
public extension BindingName where Binding: AlertControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: AlertControllerName<$2> { return .name(AlertController.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var actions: AlertControllerName<Constant<[AlertActionConvertible]>> { return .name(AlertController.Binding.actions) }
	static var preferredStyle: AlertControllerName<Constant<UIAlertController.Style>> { return .name(AlertController.Binding.preferredStyle) }
	static var textFields: AlertControllerName<Constant<[TextField]>> { return .name(AlertController.Binding.textFields) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var message: AlertControllerName<Dynamic<String?>> { return .name(AlertController.Binding.message) }
	static var preferredActionIndex: AlertControllerName<Dynamic<Int?>> { return .name(AlertController.Binding.preferredActionIndex) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol AlertControllerConvertible: ViewControllerConvertible {
	func uiAlertController() -> AlertController.Instance
}
extension AlertControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiAlertController() }
}
extension UIAlertController: AlertControllerConvertible {
	public func uiAlertController() -> AlertController.Instance { return self }
}
public extension AlertController {
	func uiAlertController() -> AlertController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol AlertControllerBinding: ViewControllerBinding {
	static func alertControllerBinding(_ binding: AlertController.Binding) -> Self
	func asAlertControllerBinding() -> AlertController.Binding?
}
public extension AlertControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return alertControllerBinding(.inheritedBinding(binding))
	}
}
public extension AlertControllerBinding where Preparer.Inherited.Binding: AlertControllerBinding {
	func asAlertControllerBinding() -> AlertController.Binding? {
		return asInheritedBinding()?.asAlertControllerBinding()
	}
}
public extension AlertController.Binding {
	typealias Preparer = AlertController.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asAlertControllerBinding() -> AlertController.Binding? { return self }
	static func alertControllerBinding(_ binding: AlertController.Binding) -> AlertController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

import UIKit

public func applicationMain(type: UIApplication.Type = UIApplication.self, _ application: @escaping () -> Application) -> Never {
	Application.Preparer.Storage.storedApplicationConstructor = application
	_ = UIApplicationMain(CommandLine.argc, CommandLine.unsafeArgv, NSStringFromClass(type), NSStringFromClass(Application.Preparer.Storage.self))
	fatalError("UIApplicationMain completed unexpectedly")
}

// MARK: - Binder Part 1: Binder
public class Application: Binder {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		precondition(type == Preparer.Instance.self, "Custom application subclass must be specified as parameter to `applicationMain`")
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Application {
	enum Binding: ApplicationBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case iconBadgeNumber(Dynamic<Int>)
		case isIdleTimerDisabled(Dynamic<Bool>)
		case isNetworkActivityIndicatorVisible(Dynamic<Bool>)
		case shortcutItems(Dynamic<[UIApplicationShortcutItem]?>)
		case supportShakeToEdit(Dynamic<Bool>)
		case window(Dynamic<WindowConvertible?>)

		//	2. Signal bindings are performed on the object after construction.
		case ignoreInteractionEvents(Signal<Bool>)
		case registerForRemoteNotifications(Signal<Bool>)

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case continueUserActivity((_ application: UIApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool)
		case didBecomeActive((UIApplication) -> Void)
		case didDecodeRestorableState((UIApplication, NSKeyedUnarchiver) -> Void)
		case didEnterBackground((UIApplication) -> Void)
		case didFailToContinueUserActivity((UIApplication, String, Error) -> Void)
		case didFinishLaunching((_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool)
		case didReceiveMemoryWarning((UIApplication) -> Void)
		case didReceiveRemoteNotification((UIApplication, [AnyHashable: Any], @escaping (UIBackgroundFetchResult) -> Void) -> Void)
		case didRegisterRemoteNotifications((UIApplication, Error) -> Void)
		case didUpdate((_ application: UIApplication, NSUserActivity) -> Void)
		case handleEventsForBackgroundURLSession((UIApplication, String, @escaping () -> Void) -> Void)
		case handleWatchKitExtensionRequest((UIApplication, [AnyHashable : Any]?, @escaping ([AnyHashable : Any]?) -> Void) -> Void)
		case open((_ application: UIApplication, _ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool)
		case performAction((UIApplication, UIApplicationShortcutItem, @escaping (Bool) -> Void) -> Void)
		case performFetch((UIApplication, @escaping (UIBackgroundFetchResult) -> Void) -> Void)
		case protectedDataDidBecomeAvailable((UIApplication) -> Void)
		case protectedDataWillBecomeUnavailable((UIApplication) -> Void)
		case shouldAllowExtensionPointIdentifier((_ application: UIApplication, UIApplication.ExtensionPointIdentifier) -> Bool)
		case shouldRequestHealthAuthorization((_ application: UIApplication) -> Void)
		case significantTimeChange((UIApplication) -> Void)
		case viewControllerWithRestorationPath((_ application: UIApplication, _ path: [String], _ coder: NSCoder) -> UIViewController?)
		case willContinueUserActivity((_ application: UIApplication, String) -> Bool)
		case willEncodeRestorableState((_ application: UIApplication, NSKeyedArchiver) -> Void)
		case willEnterForeground((UIApplication) -> Void)
		case willFinishLaunching((_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool)
		case willResignActive((UIApplication) -> Void)
		case willTerminate((_ application: UIApplication) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension Application {
	struct Preparer: BinderDelegateEmbedder {
		public typealias Binding = Application.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = UIApplication
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage.storedStorage! }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Application.Preparer {
	var delegateIsRequired: Bool { return true }

	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let s): inherited.prepareBinding(s)

		case .continueUserActivity(let x): delegate().addSingleHandler3(x, #selector(UIApplicationDelegate.application(_:continue:restorationHandler:)))
		case .didBecomeActive(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationDidBecomeActive(_:)))
		case .didDecodeRestorableState(let x):
			delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:didDecodeRestorableStateWith:)))
			delegate().addSingleHandler2({ (a: UIApplication, c: NSCoder) in true }, #selector(UIApplicationDelegate.application(_:shouldRestoreApplicationState:)))
		case .didEnterBackground(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationDidEnterBackground(_:)))
		case .didFailToContinueUserActivity(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:didFailToContinueUserActivityWithType:error:)))
		case .didFinishLaunching(let x): delegate().addSingleHandler2(x, #selector(UIApplicationDelegate.application(_:didFinishLaunchingWithOptions:)))
		case .didReceiveMemoryWarning(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationDidReceiveMemoryWarning(_:)))
		case .didReceiveRemoteNotification(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:didReceiveRemoteNotification:fetchCompletionHandler:)))
		case .didRegisterRemoteNotifications(let x):
			delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:didRegisterForRemoteNotificationsWithDeviceToken:)))
			delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:didFailToRegisterForRemoteNotificationsWithError:)))
		case .didUpdate(let x): delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:didUpdate:)))
		case .handleEventsForBackgroundURLSession(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:handleEventsForBackgroundURLSession:completionHandler:)))
		case .handleWatchKitExtensionRequest(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:handleWatchKitExtensionRequest:reply:)))
		case .open(let x): delegate().addSingleHandler3(x, #selector(UIApplicationDelegate.application(_:open:options:)))
		case .performAction(let x): delegate().addMultiHandler3(x, #selector(UIApplicationDelegate.application(_:performActionFor:completionHandler:)))
		case .performFetch(let x): delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:performFetchWithCompletionHandler:)))
		case .protectedDataWillBecomeUnavailable(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationProtectedDataWillBecomeUnavailable(_:)))
		case .protectedDataDidBecomeAvailable(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationProtectedDataDidBecomeAvailable(_:)))
		case .shouldAllowExtensionPointIdentifier(let x): delegate().addSingleHandler2(x, #selector(UIApplicationDelegate.application(_:shouldAllowExtensionPointIdentifier:)))
		case .shouldRequestHealthAuthorization(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationShouldRequestHealthAuthorization(_:)))
		case .significantTimeChange(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationSignificantTimeChange(_:)))
		case .viewControllerWithRestorationPath(let x): delegate().addSingleHandler3(x, #selector(UIApplicationDelegate.application(_:viewControllerWithRestorationIdentifierPath:coder:)))
		case .willContinueUserActivity(let x): delegate().addSingleHandler2(x, #selector(UIApplicationDelegate.application(_:willContinueUserActivityWithType:)))
		case .willEncodeRestorableState(let x):
			delegate().addMultiHandler2(x, #selector(UIApplicationDelegate.application(_:willEncodeRestorableStateWith:)))
			delegate().addSingleHandler2({ (a: UIApplication, c: NSCoder) in true }, #selector(UIApplicationDelegate.application(_:shouldSaveApplicationState:)))
		case .willEnterForeground(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationWillEnterForeground(_:)))
		case .willResignActive(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationWillResignActive(_:)))
		case .willTerminate(let x): delegate().addMultiHandler1(x, #selector(UIApplicationDelegate.applicationWillTerminate(_:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .iconBadgeNumber(let x): return x.apply(instance) { i, v in i.applicationIconBadgeNumber = v }
		case .isIdleTimerDisabled(let x): return x.apply(instance) { i, v in i.isIdleTimerDisabled = v }
		case .isNetworkActivityIndicatorVisible(let x): return x.apply(instance) { i, v in i.isNetworkActivityIndicatorVisible = v }
		case .shortcutItems(let x): return x.apply(instance) { i, v in i.shortcutItems = v }
		case .supportShakeToEdit(let x): return x.apply(instance) { i, v in i.applicationSupportsShakeToEdit = v }
		case .window(let x): return x.apply(instance, storage) { i, s, v in s.window = v?.uiWindow() }

		//	2. Signal bindings are performed on the object after construction.
		case .ignoreInteractionEvents(let x):
			return x.apply(instance) { i, v in
				switch (i.isIgnoringInteractionEvents, v) {
				case (false, true): i.beginIgnoringInteractionEvents()
				case (true, false): i.endIgnoringInteractionEvents()
				default: break
				}
			}
		case .registerForRemoteNotifications(let x):
			return x.apply(instance) { i, v in
				switch (i.isRegisteredForRemoteNotifications, v) {
				case (false, true): i.registerForRemoteNotifications()
				case (true, false): i.unregisterForRemoteNotifications()
				default: break
				}
			}

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .didBecomeActive: return nil
		case .didEnterBackground: return nil
		case .didFailToContinueUserActivity: return nil
		case .didReceiveMemoryWarning: return nil
		case .didReceiveRemoteNotification: return nil
		case .didRegisterRemoteNotifications: return nil
		case .handleEventsForBackgroundURLSession: return nil
		case .handleWatchKitExtensionRequest: return nil
		case .performAction: return nil
		case .performFetch: return nil
		case .protectedDataDidBecomeAvailable: return nil
		case .protectedDataWillBecomeUnavailable: return nil
		case .significantTimeChange: return nil
		case .willEnterForeground: return nil
		case .willResignActive: return nil
		case .continueUserActivity: return nil
		case .didDecodeRestorableState: return nil
		case .didFinishLaunching: return nil
		case .didUpdate: return nil
		case .open: return nil
		case .shouldAllowExtensionPointIdentifier: return nil
		case .shouldRequestHealthAuthorization: return nil
		case .viewControllerWithRestorationPath: return nil
		case .willContinueUserActivity: return nil
		case .willEncodeRestorableState: return nil
		case .willFinishLaunching(let x):
			storage.willFinishLaunching = x
			return nil
		case .willTerminate: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Application.Preparer {
	open class Storage: AssociatedBinderStorage, UIApplicationDelegate {
		static var storedApplicationConstructor: (() -> Application)? = nil
		static var storedStorage: Storage? = nil
		
		open var window: UIWindow? = nil
		open var additionalWindows: [UIWindow] = []
		open var willFinishLaunching: ((UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool)?

		open override var isInUse: Bool {
			return true
		}
		
		open func applyToSharedApplication() {
			// If the storageApplicationConstructor is not set, this function is a no-op. This is useful during testing.
			guard let application = Storage.storedApplicationConstructor else { return }
			
			// Disconnect the delegate since we're about to change the handled delegate methods
			UIApplication.shared.delegate = nil
			Application.Preparer.Storage.storedStorage = self
			
			// Apply the styles to the application and delegate.
			application().apply(to: UIApplication.shared)
			
			Application.Preparer.Storage.storedApplicationConstructor = nil
			Application.Preparer.Storage.storedStorage = nil
			
			// Ensure that the delegate was reapplied
			assert(UIApplication.shared.delegate === self, "Failed to reconnect delegate")
			
			// Apply the view hierarchy
			window?.makeKeyAndVisible()
		}
		
		public func application(_ application: UIApplication, willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
			applyToSharedApplication()
			
			// Invoke any user-supplied code
			return willFinishLaunching?(application, launchOptions) ?? true
		}
	}

	open class Delegate: DynamicDelegate, UIApplicationDelegate {
		public func applicationDidBecomeActive(_ application: UIApplication) {
			multiHandler(application)
		}
		
		public func applicationWillResignActive(_ application: UIApplication) {
			multiHandler(application)
		}
		
		public func applicationDidEnterBackground(_ application: UIApplication) {
			multiHandler(application)
		}
		
		public func applicationWillEnterForeground(_ application: UIApplication) {
			multiHandler(application)
		}
		
		public func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
			multiHandler(application)
		}
		
		public func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
			return singleHandler(application, launchOptions)
		}
		
		public func applicationWillTerminate(_ application: UIApplication) {
			return singleHandler(application)
		}
		
		public func applicationProtectedDataWillBecomeUnavailable(_ application: UIApplication) {
			multiHandler(application)
		}
		
		public func applicationProtectedDataDidBecomeAvailable(_ application: UIApplication) {
			multiHandler(application)
		}
		
		public func application(_ application: UIApplication, willEncodeRestorableStateWith coder: NSCoder) {
			return multiHandler(application, coder as! NSKeyedArchiver)
		}
		
		public func application(_ application: UIApplication, didDecodeRestorableStateWith coder: NSCoder) {
			return multiHandler(application, coder as! NSKeyedUnarchiver)
		}
		
		public func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
			multiHandler(application, completionHandler)
		}
		
		public func application(_ application: UIApplication, handleEventsForBackgroundURLSession session: String, completionHandler: @escaping () -> Void) {
			multiHandler(application, session, completionHandler)
		}
		
		public func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
			multiHandler(application, deviceToken)
		}
		
		public func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
			multiHandler(application, error)
		}
		
		public func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
			multiHandler(application, userInfo, completionHandler)
		}
		
		public func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable: Any], completionHandler: @escaping () -> Void) {
			multiHandler(application, identifier, userInfo, completionHandler)
		}
		
		public func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable: Any], withResponseInfo responseInfo: [AnyHashable : Any], completionHandler: @escaping () -> Void) {
			multiHandler(application, identifier, userInfo, responseInfo, completionHandler)
		}
		
		public func application(_ application: UIApplication, didFailToContinueUserActivityWithType userActivityType: String, error: Error) {
			multiHandler(application, userActivityType, error)
		}
		
		public func application(_ application: UIApplication, handleWatchKitExtensionRequest userInfo: [AnyHashable : Any]?, reply: @escaping ([AnyHashable : Any]?) -> Void) {
			multiHandler(application, userInfo, reply)
		}
		
		public func applicationShouldRequestHealthAuthorization(_ application: UIApplication) {
			multiHandler(application)
		}
		
		public func application(_ application: UIApplication, willContinueUserActivityWithType userActivityType: String) -> Bool {
			return singleHandler(application, userActivityType)
		}
		
		public func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
			return singleHandler(application, userActivity, restorationHandler)
		}
		
		public func application(_ application: UIApplication, didUpdate userActivity: NSUserActivity) {
			multiHandler(application, userActivity)
		}
		
		public func application(_ application: UIApplication, shouldSaveApplicationState coder: NSCoder) -> Bool {
			// The existence of this selector on the dynamic delegate triggers an always true response
			return true
		}
		
		public func application(_ application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -> Bool {
			// The existence of this selector on the dynamic delegate triggers an always true response
			return true
		}
		
		public func applicationSignificantTimeChange(_ application: UIApplication) {
			multiHandler(application)
		}
		
		public func application(_ application: UIApplication, viewControllerWithRestorationIdentifierPath identifierComponents: [String], coder: NSCoder) -> UIViewController? {
			return singleHandler(application, identifierComponents, coder)
		}
		
		public func application(_ application: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
			return singleHandler(application, url, options)
		}
		
		public func application(_ application: UIApplication, shouldAllowExtensionPointIdentifier extensionPointIdentifier: UIApplication.ExtensionPointIdentifier) -> Bool {
			return singleHandler(application, extensionPointIdentifier)
		}
		
		public func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {
			multiHandler(application, shortcutItem, completionHandler)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ApplicationBinding {
	public typealias ApplicationName<V> = BindingName<V, Application.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Application.Binding) -> ApplicationName<V> {
		return ApplicationName<V>(source: source, downcast: Binding.applicationBinding)
	}
}
public extension BindingName where Binding: ApplicationBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ApplicationName<$2> { return .name(Application.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var iconBadgeNumber: ApplicationName<Dynamic<Int>> { return .name(Application.Binding.iconBadgeNumber) }
	static var isIdleTimerDisabled: ApplicationName<Dynamic<Bool>> { return .name(Application.Binding.isIdleTimerDisabled) }
	static var isNetworkActivityIndicatorVisible: ApplicationName<Dynamic<Bool>> { return .name(Application.Binding.isNetworkActivityIndicatorVisible) }
	static var shortcutItems: ApplicationName<Dynamic<[UIApplicationShortcutItem]?>> { return .name(Application.Binding.shortcutItems) }
	static var supportShakeToEdit: ApplicationName<Dynamic<Bool>> { return .name(Application.Binding.supportShakeToEdit) }
	static var window: ApplicationName<Dynamic<WindowConvertible?>> { return .name(Application.Binding.window) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var ignoreInteractionEvents: ApplicationName<Signal<Bool>> { return .name(Application.Binding.ignoreInteractionEvents) }
	static var registerForRemoteNotifications: ApplicationName<Signal<Bool>> { return .name(Application.Binding.registerForRemoteNotifications) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var continueUserActivity: ApplicationName<(_ application: UIApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool> { return .name(Application.Binding.continueUserActivity) }
	static var didBecomeActive: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.didBecomeActive) }
	static var didDecodeRestorableState: ApplicationName<(_ application: UIApplication, NSKeyedUnarchiver) -> Void> { return .name(Application.Binding.didDecodeRestorableState) }
	static var didEnterBackground: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.didEnterBackground) }
	static var didFailToContinueUserActivity: ApplicationName<(UIApplication, String, Error) -> Void> { return .name(Application.Binding.didFailToContinueUserActivity) }
	static var didFinishLaunching: ApplicationName<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool> { return .name(Application.Binding.didFinishLaunching) }
	static var didReceiveMemoryWarning: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.didReceiveMemoryWarning) }
	static var didReceiveRemoteNotification: ApplicationName<(UIApplication, [AnyHashable: Any], @escaping (UIBackgroundFetchResult) -> Void) -> Void> { return .name(Application.Binding.didReceiveRemoteNotification) }
	static var didRegisterRemoteNotifications: ApplicationName<(UIApplication, Error) -> Void> { return .name(Application.Binding.didRegisterRemoteNotifications) }
	static var didUpdate: ApplicationName<(_ application: UIApplication, NSUserActivity) -> Void> { return .name(Application.Binding.didUpdate) }
	static var handleEventsForBackgroundURLSession: ApplicationName<(UIApplication, String, @escaping () -> Void) -> Void> { return .name(Application.Binding.handleEventsForBackgroundURLSession) }
	static var handleWatchKitExtensionRequest: ApplicationName<(UIApplication, [AnyHashable : Any]?, @escaping ([AnyHashable : Any]?) -> Void) -> Void> { return .name(Application.Binding.handleWatchKitExtensionRequest) }
	static var open: ApplicationName<(_ application: UIApplication, _ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool> { return .name(Application.Binding.open) }
	static var performAction: ApplicationName<(UIApplication, UIApplicationShortcutItem, @escaping (Bool) -> Void) -> Void> { return .name(Application.Binding.performAction) }
	static var performFetch: ApplicationName<(UIApplication, @escaping (UIBackgroundFetchResult) -> Void) -> Void> { return .name(Application.Binding.performFetch) }
	static var protectedDataDidBecomeAvailable: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.protectedDataDidBecomeAvailable) }
	static var protectedDataWillBecomeUnavailable: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.protectedDataWillBecomeUnavailable) }
	static var shouldAllowExtensionPointIdentifier: ApplicationName<(_ application: UIApplication, UIApplication.ExtensionPointIdentifier) -> Bool> { return .name(Application.Binding.shouldAllowExtensionPointIdentifier) }
	static var shouldRequestHealthAuthorization: ApplicationName<(_ application: UIApplication) -> Void> { return .name(Application.Binding.shouldRequestHealthAuthorization) }
	static var significantTimeChange: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.significantTimeChange) }
	static var viewControllerWithRestorationPath: ApplicationName<(_ application: UIApplication, _ path: [String], _ coder: NSCoder) -> UIViewController?> { return .name(Application.Binding.viewControllerWithRestorationPath) }
	static var willContinueUserActivity: ApplicationName<(_ application: UIApplication, String) -> Bool> { return .name(Application.Binding.willContinueUserActivity) }
	static var willEncodeRestorableState: ApplicationName<(_ application: UIApplication, NSKeyedArchiver) -> Void> { return .name(Application.Binding.willEncodeRestorableState) }
	static var willEnterForeground: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.willEnterForeground) }
	static var willFinishLaunching: ApplicationName<(_ application: UIApplication, [UIApplication.LaunchOptionsKey: Any]?) -> Bool> { return .name(Application.Binding.willFinishLaunching) }
	static var willResignActive: ApplicationName<(UIApplication) -> Void> { return .name(Application.Binding.willResignActive) }
	static var willTerminate: ApplicationName<(_ application: UIApplication) -> Void> { return .name(Application.Binding.willTerminate) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension UIApplication: HasDelegate {}

// MARK: - Binder Part 8: Downcast protocols
public protocol ApplicationBinding: BinderBaseBinding {
	static func applicationBinding(_ binding: Application.Binding) -> Self
	func asApplicationBinding() -> Application.Binding?
}
public extension ApplicationBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return applicationBinding(.inheritedBinding(binding))
	}
}
public extension ApplicationBinding where Preparer.Inherited.Binding: ApplicationBinding {
	func asApplicationBinding() -> Application.Binding? {
		return asInheritedBinding()?.asApplicationBinding()
	}
}
public extension Application.Binding {
	typealias Preparer = Application.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asApplicationBinding() -> Application.Binding? { return self }
	static func applicationBinding(_ binding: Application.Binding) -> Application.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public enum ApplicationTerminateReply {
	case now
	case cancel
	case later(Signal<Bool>)
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class BarButtonItem: Binder, BarButtonItemConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension BarButtonItem {
	enum Binding: BarButtonItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case systemItem(Constant<UIBarButtonItem.SystemItem>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case backButtonBackgroundImage(Dynamic<ScopedValues<StateAndMetrics, UIImage?>>)
		case backButtonTitlePositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, UIOffset>>)
		case backgroundImage(Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>)
		case backgroundVerticalPositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, CGFloat>>)
		case customView(Dynamic<ViewConvertible?>)
		case itemStyle(Dynamic<UIBarButtonItem.Style>)
		case possibleTitles(Dynamic<Set<String>?>)
		case tintColor(Dynamic<UIColor?>)
		case titlePositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, UIOffset>>)
		case width(Dynamic<CGFloat>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case action(TargetAction)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension BarButtonItem {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = BarButtonItem.Binding
		public typealias Inherited = BarItem.Preparer
		public typealias Instance = UIBarButtonItem
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		public var systemItem: UIBarButtonItem.SystemItem?
		public var customView = InitialSubsequent<ViewConvertible?>()
		public var itemStyle = InitialSubsequent<UIBarButtonItem.Style>()
		public var image = InitialSubsequent<UIImage?>()
		public var landscapeImagePhone = InitialSubsequent<UIImage?>()
		public var title = InitialSubsequent<String>()
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension BarButtonItem.Preparer {
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		let x: UIBarButtonItem
		if let si = systemItem {
			x = type.init(barButtonSystemItem: si, target: nil, action: nil)
		} else if case .some(.some(let cv)) = customView.initial {
			x = type.init(customView: cv.uiView())
		} else if case .some(.some(let i)) = image.initial {
			x = type.init(image: i, landscapeImagePhone: landscapeImagePhone.initial ?? nil, style: itemStyle.initial ?? .plain, target: nil, action: nil)
		} else {
			x = type.init(title: title.initial ?? nil, style: itemStyle.initial ?? .plain, target: nil, action: nil)
		}
		return x
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.image(let x)): image = x.initialSubsequent()
		case .inheritedBinding(.landscapeImagePhone(let x)): landscapeImagePhone = x.initialSubsequent()
		case .inheritedBinding(.title(let x)): title = x.initialSubsequent()
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .systemItem(let x): systemItem = x.value
		case .customView(let x): customView = x.initialSubsequent()
		case .itemStyle(let x): itemStyle = x.initialSubsequent()
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(.image): return image.apply(instance) { i, v in i.image = v }
		case .inheritedBinding(.landscapeImagePhone): return landscapeImagePhone.apply(instance) { i, v in i.landscapeImagePhone = v }
		case .inheritedBinding(.title): return title.apply(instance) { i, v in i.title = v }
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .systemItem: return nil
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .backButtonBackgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackButtonBackgroundImage(nil, for: scope.controlState, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackButtonBackgroundImage(v, for: scope.controlState, barMetrics: scope.barMetrics) }
			)
		case .backButtonTitlePositionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackButtonTitlePositionAdjustment(UIOffset(), for: scope) },
				applyNew: { i, scope, v in i.setBackButtonTitlePositionAdjustment(v, for: scope) }
			)
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, for: scope.controlState, style: scope.itemStyle, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, for: scope.controlState, style: scope.itemStyle, barMetrics: scope.barMetrics) }
			)
		case .backgroundVerticalPositionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundVerticalPositionAdjustment(0, for: scope) },
				applyNew: { i, scope, v in i.setBackgroundVerticalPositionAdjustment(v, for: scope) }
			)
		case .customView: return customView.apply(instance) { i, v in i.customView = v?.uiView() }
		case .itemStyle: return itemStyle.apply(instance) { i, v in i.style = v }
		case .possibleTitles(let x): return x.apply(instance) { i, v in i.possibleTitles = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
		case .titlePositionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitlePositionAdjustment(UIOffset(), for: scope) },
				applyNew: { i, scope, v in i.setTitlePositionAdjustment(v, for: scope) }
			)
		case .width(let x): return x.apply(instance) { i, v in i.width = v }
			
		//	2. Signal bindings are performed on the object after construction.
			
		//	3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: SignalActionTarget.init)
			
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension BarButtonItem.Preparer {
	public typealias Storage = BarItem.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: BarButtonItemBinding {
	public typealias BarButtonItemName<V> = BindingName<V, BarButtonItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> BarButtonItem.Binding) -> BarButtonItemName<V> {
		return BarButtonItemName<V>(source: source, downcast: Binding.barButtonItemBinding)
	}
}
public extension BindingName where Binding: BarButtonItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BarButtonItemName<$2> { return .name(BarButtonItem.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var systemItem: BarButtonItemName<Constant<UIBarButtonItem.SystemItem>> { return .name(BarButtonItem.Binding.systemItem) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var backButtonBackgroundImage: BarButtonItemName<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>> { return .name(BarButtonItem.Binding.backButtonBackgroundImage) }
	static var backButtonTitlePositionAdjustment: BarButtonItemName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>> { return .name(BarButtonItem.Binding.backButtonTitlePositionAdjustment) }
	static var backgroundImage: BarButtonItemName<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>> { return .name(BarButtonItem.Binding.backgroundImage) }
	static var backgroundVerticalPositionAdjustment: BarButtonItemName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>> { return .name(BarButtonItem.Binding.backgroundVerticalPositionAdjustment) }
	static var customView: BarButtonItemName<Dynamic<ViewConvertible?>> { return .name(BarButtonItem.Binding.customView) }
	static var itemStyle: BarButtonItemName<Dynamic<UIBarButtonItem.Style>> { return .name(BarButtonItem.Binding.itemStyle) }
	static var possibleTitles: BarButtonItemName<Dynamic<Set<String>?>> { return .name(BarButtonItem.Binding.possibleTitles) }
	static var tintColor: BarButtonItemName<Dynamic<UIColor?>> { return .name(BarButtonItem.Binding.tintColor) }
	static var titlePositionAdjustment: BarButtonItemName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>> { return .name(BarButtonItem.Binding.titlePositionAdjustment) }
	static var width: BarButtonItemName<Dynamic<CGFloat>> { return .name(BarButtonItem.Binding.width) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	static var action: BarButtonItemName<TargetAction> { return .name(BarButtonItem.Binding.action) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.

	// Composite binding names
	static func action<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> BarButtonItemName<SignalInput<Value>> {
		return Binding.keyPathActionName(keyPath, BarButtonItem.Binding.action, Binding.barButtonItemBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol BarButtonItemConvertible: BarItemConvertible {
	func uiBarButtonItem() -> BarButtonItem.Instance
}
extension BarButtonItemConvertible {
	public func uiBarItem() -> BarItem.Instance { return uiBarButtonItem() }
}
extension UIBarButtonItem: BarButtonItemConvertible, TargetActionSender {
	public func uiBarButtonItem() -> BarButtonItem.Instance { return self }
}
public extension BarButtonItem {
	func uiBarButtonItem() -> BarButtonItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol BarButtonItemBinding: BarItemBinding {
	static func barButtonItemBinding(_ binding: BarButtonItem.Binding) -> Self
	func asBarButtonItemBinding() -> BarButtonItem.Binding?
}
public extension BarButtonItemBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return barButtonItemBinding(.inheritedBinding(binding))
	}
}
public extension BarButtonItemBinding where Preparer.Inherited.Binding: BarButtonItemBinding {
	func asBarButtonItemBinding() -> BarButtonItem.Binding? {
		return asInheritedBinding()?.asBarButtonItemBinding()
	}
}
public extension BarButtonItem.Binding {
	typealias Preparer = BarButtonItem.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asBarButtonItemBinding() -> BarButtonItem.Binding? { return self }
	static func barButtonItemBinding(_ binding: BarButtonItem.Binding) -> BarButtonItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public struct StateStyleAndMetrics {
	public let controlState: UIControl.State
	public let itemStyle: UIBarButtonItem.Style
	public let barMetrics: UIBarMetrics
	public init(state: UIControl.State = .normal, style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.itemStyle = style
		self.barMetrics = metrics
	}
}

public struct StateAndMetrics {
	public let controlState: UIControl.State
	public let barMetrics: UIBarMetrics
	public init(state: UIControl.State = .normal, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == StateAndMetrics {
	public static func normal(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .normal, metrics: metrics))
	}
	public static func highlighted(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .highlighted, metrics: metrics))
	}
	public static func disabled(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .disabled, metrics: metrics))
	}
	public static func selected(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .selected, metrics: metrics))
	}
	public static func focused(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .focused, metrics: metrics))
	}
	public static func application(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .application, metrics: metrics))
	}
	public static func reserved(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == StateStyleAndMetrics {
	public static func normal(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .normal, metrics: metrics))
	}
	public static func highlighted(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .highlighted, metrics: metrics))
	}
	public static func disabled(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .disabled, metrics: metrics))
	}
	public static func selected(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .selected, metrics: metrics))
	}
	public static func focused(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .focused, metrics: metrics))
	}
	public static func application(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .application, metrics: metrics))
	}
	public static func reserved(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == UIBarMetrics {
	public static func `default`(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .default, value: value)
	}
	public static func compact(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compact, value: value)
	}
	public static func defaultPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .defaultPrompt, value: value)
	}
	public static func compactPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compactPrompt, value: value)
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class BarItem: Binder, BarItemConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension BarItem {
	enum Binding: BarItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case image(Dynamic<UIImage?>)
		case imageInsets(Dynamic<UIEdgeInsets>)
		case isEnabled(Dynamic<Bool>)
		case landscapeImagePhone(Dynamic<UIImage?>)
		case landscapeImagePhoneInsets(Dynamic<UIEdgeInsets>)
		case tag(Dynamic<Int>)
		case title(Dynamic<String>)
		case titleTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension BarItem {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = BarItem.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = UIBarItem
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension BarItem.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .imageInsets(let x): return x.apply(instance) { i, v in i.imageInsets = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .landscapeImagePhone(let x): return x.apply(instance) { i, v in i.landscapeImagePhone = v }
		case .landscapeImagePhoneInsets(let x): return x.apply(instance) { i, v in i.landscapeImagePhoneInsets = v }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .titleTextAttributes(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitleTextAttributes([:], for: scope) },
				applyNew: { i, scope, v in i.setTitleTextAttributes(v, for: scope) }
			)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension BarItem.Preparer {
	public typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: BarItemBinding {
	public typealias BarItemName<V> = BindingName<V, BarItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> BarItem.Binding) -> BarItemName<V> {
		return BarItemName<V>(source: source, downcast: Binding.barItemBinding)
	}
}
public extension BindingName where Binding: BarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BarItemName<$2> { return .name(BarItem.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var image: BarItemName<Dynamic<UIImage?>> { return .name(BarItem.Binding.image) }
	static var imageInsets: BarItemName<Dynamic<UIEdgeInsets>> { return .name(BarItem.Binding.imageInsets) }
	static var isEnabled: BarItemName<Dynamic<Bool>> { return .name(BarItem.Binding.isEnabled) }
	static var landscapeImagePhone: BarItemName<Dynamic<UIImage?>> { return .name(BarItem.Binding.landscapeImagePhone) }
	static var landscapeImagePhoneInsets: BarItemName<Dynamic<UIEdgeInsets>> { return .name(BarItem.Binding.landscapeImagePhoneInsets) }
	static var tag: BarItemName<Dynamic<Int>> { return .name(BarItem.Binding.tag) }
	static var title: BarItemName<Dynamic<String>> { return .name(BarItem.Binding.title) }
	static var titleTextAttributes: BarItemName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>> { return .name(BarItem.Binding.titleTextAttributes) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol BarItemConvertible {
	func uiBarItem() -> BarItem.Instance
}
extension UIBarItem: BarItemConvertible, DefaultConstructable {
	public func uiBarItem() -> BarItem.Instance { return self }
}
public extension BarItem {
	func uiBarItem() -> BarItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol BarItemBinding: BinderBaseBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self
	func asBarItemBinding() -> BarItem.Binding?
}
public extension BarItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return barItemBinding(.inheritedBinding(binding))
	}
}
public extension BarItemBinding where Preparer.Inherited.Binding: BarItemBinding {
	func asBarItemBinding() -> BarItem.Binding? {
		return asInheritedBinding()?.asBarItemBinding()
	}
}
public extension BarItem.Binding {
	typealias Preparer = BarItem.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asBarItemBinding() -> BarItem.Binding? { return self }
	static func barItemBinding(_ binding: BarItem.Binding) -> BarItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class Button: Binder, ButtonConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Button {
	enum Binding: ButtonBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case imageView(Constant<ImageView>)
		case titleLabel(Constant<Label>)
		case type(Constant<UIButton.ButtonType>)
	
		// 1. Value bindings may be applied at construction and may subsequently change.
		case adjustsImageWhenDisabled(Dynamic<Bool>)
		case adjustsImageWhenHighlighted(Dynamic<Bool>)
		case attributedTitle(Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>)
		case backgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case contentEdgeInsets(Dynamic<UIEdgeInsets>)
		case image(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case imageEdgeInsets(Dynamic<UIEdgeInsets>)
		case showsTouchWhenHighlighted(Dynamic<Bool>)
		case title(Dynamic<ScopedValues<UIControl.State, String?>>)
		case titleColor(Dynamic<ScopedValues<UIControl.State, UIColor?>>)
		case titleEdgeInsets(Dynamic<UIEdgeInsets>)
		case titleShadowColor(Dynamic<ScopedValues<UIControl.State, UIColor?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension Button {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = Button.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = UIButton
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var type: UIButton.ButtonType = .roundedRect
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Button.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance {
		return type.init(type: self.type)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .type(let x): type = x.value
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .imageView(let x):
			if let iv = instance.imageView {
				x.value.apply(to: iv)
			}
			return nil
		case .titleLabel(let x):
			if let tl = instance.titleLabel {
				x.value.apply(to: tl)
			}
			return nil
		case .type: return nil
	
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .adjustsImageWhenDisabled(let x): return x.apply(instance) { i, v in i.adjustsImageWhenDisabled = v }
		case .adjustsImageWhenHighlighted(let x): return x.apply(instance) { i, v in i.adjustsImageWhenHighlighted = v }
		case .attributedTitle(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setAttributedTitle(nil, for: scope) },
				applyNew: { i, scope, v in i.setAttributedTitle(v, for: scope) }
			)
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, for: scope) }
			)
		case .contentEdgeInsets(let x): return x.apply(instance) { i, v in i.contentEdgeInsets = v }
		case .image(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setImage(v, for: scope) }
			)
		case .imageEdgeInsets(let x): return x.apply(instance) { i, v in i.imageEdgeInsets = v }
		case .showsTouchWhenHighlighted(let x): return x.apply(instance) { i, v in i.showsTouchWhenHighlighted = v }
		case .title(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitle(nil, for: scope) },
				applyNew: { i, scope, v in i.setTitle(v, for: scope) }
			)
		case .titleColor(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitleColor(nil, for: scope) },
				applyNew: { i, scope, v in i.setTitleColor(v, for: scope) }
			)
		case .titleEdgeInsets(let x): return x.apply(instance) { i, v in i.titleEdgeInsets = v }
		case .titleShadowColor(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitleShadowColor(nil, for: scope) },
				applyNew: { i, scope, v in i.setTitleShadowColor(v, for: scope) }
			)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Button.Preparer {
	public typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ButtonBinding {
	public typealias ButtonName<V> = BindingName<V, Button.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Button.Binding) -> ButtonName<V> {
		return ButtonName<V>(source: source, downcast: Binding.buttonBinding)
	}
}
public extension BindingName where Binding: ButtonBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ButtonName<$2> { return .name(Button.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var imageView: ButtonName<Constant<ImageView>> { return .name(Button.Binding.imageView) }
	static var titleLabel: ButtonName<Constant<Label>> { return .name(Button.Binding.titleLabel) }
	static var type: ButtonName<Constant<UIButton.ButtonType>> { return .name(Button.Binding.type) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsImageWhenDisabled: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.adjustsImageWhenDisabled) }
	static var adjustsImageWhenHighlighted: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.adjustsImageWhenHighlighted) }
	static var attributedTitle: ButtonName<Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>> { return .name(Button.Binding.attributedTitle) }
	static var backgroundImage: ButtonName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Button.Binding.backgroundImage) }
	static var contentEdgeInsets: ButtonName<Dynamic<UIEdgeInsets>> { return .name(Button.Binding.contentEdgeInsets) }
	static var image: ButtonName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Button.Binding.image) }
	static var imageEdgeInsets: ButtonName<Dynamic<UIEdgeInsets>> { return .name(Button.Binding.imageEdgeInsets) }
	static var showsTouchWhenHighlighted: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.showsTouchWhenHighlighted) }
	static var title: ButtonName<Dynamic<ScopedValues<UIControl.State, String?>>> { return .name(Button.Binding.title) }
	static var titleColor: ButtonName<Dynamic<ScopedValues<UIControl.State, UIColor?>>> { return .name(Button.Binding.titleColor) }
	static var titleEdgeInsets: ButtonName<Dynamic<UIEdgeInsets>> { return .name(Button.Binding.titleEdgeInsets) }
	static var titleShadowColor: ButtonName<Dynamic<ScopedValues<UIControl.State, UIColor?>>> { return .name(Button.Binding.titleShadowColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ButtonConvertible: ControlConvertible {
	func uiButton() -> Button.Instance
}
extension ButtonConvertible {
	public func uiControl() -> Control.Instance { return uiButton() }
}
extension UIButton: ButtonConvertible {
	public func uiButton() -> Button.Instance { return self }
}
public extension Button {
	func uiButton() -> Button.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ButtonBinding: ControlBinding {
	static func buttonBinding(_ binding: Button.Binding) -> Self
	func asButtonBinding() -> Button.Binding?
}
public extension ButtonBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return buttonBinding(.inheritedBinding(binding))
	}
}
public extension ButtonBinding where Preparer.Inherited.Binding: ButtonBinding {
	func asButtonBinding() -> Button.Binding? {
		return asInheritedBinding()?.asButtonBinding()
	}
}
public extension Button.Binding {
	typealias Preparer = Button.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asButtonBinding() -> Button.Binding? { return self }
	static func buttonBinding(_ binding: Button.Binding) -> Button.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class Control: Binder, ControlConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Control {
	enum Binding: ControlBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)
		case isSelected(Dynamic<Bool>)
		case isHighlighted(Dynamic<Bool>)
		case contentVerticalAlignment(Dynamic<UIControl.ContentVerticalAlignment>)
		case contentHorizontalAlignment(Dynamic<UIControl.ContentHorizontalAlignment>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case actions(ControlActions)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension Control {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = Control.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UIControl
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Control.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .contentHorizontalAlignment(let x): return x.apply(instance) { i, v in i.contentHorizontalAlignment = v }
		case .contentVerticalAlignment(let x): return x.apply(instance) { i, v in i.contentVerticalAlignment = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.isHighlighted = v }
		case .isSelected(let x): return x.apply(instance) { i, v in i.isSelected = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case .actions(let x):
			var lifetimes = [Lifetime]()
			for (scope, value) in x.pairs {
				switch value {
				case .firstResponder(let s):
					instance.addTarget(nil, action: s, for: scope)
				case .singleTarget(let s):
					let target = SignalControlEventActionTarget()
					instance.addTarget(target, action: target.selector, for: scope)
					lifetimes += target.source.cancellableBind(to: s)
				}
			}
			return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Control.Preparer {
	public typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ControlBinding {
	public typealias ControlName<V> = BindingName<V, Control.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Control.Binding) -> ControlName<V> {
		return ControlName<V>(source: source, downcast: Binding.controlBinding)
	}
}
public extension BindingName where Binding: ControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ControlName<$2> { return .name(Control.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: ControlName<Dynamic<Bool>> { return .name(Control.Binding.isEnabled) }
	static var isSelected: ControlName<Dynamic<Bool>> { return .name(Control.Binding.isSelected) }
	static var isHighlighted: ControlName<Dynamic<Bool>> { return .name(Control.Binding.isHighlighted) }
	static var contentVerticalAlignment: ControlName<Dynamic<UIControl.ContentVerticalAlignment>> { return .name(Control.Binding.contentVerticalAlignment) }
	static var contentHorizontalAlignment: ControlName<Dynamic<UIControl.ContentHorizontalAlignment>> { return .name(Control.Binding.contentHorizontalAlignment) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var actions: ControlName<ControlActions> { return .name(Control.Binding.actions) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.

	// Composite binding names
	static func action<Value>(_ scope: UIControl.Event, _ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> ControlName<SignalInput<Value>> {
		return Binding.mappedWrappedInputName(
			map: { tuple in
				(tuple.0 as! Binding.Preparer.Instance)[keyPath: keyPath]
			},
			wrap: { input in ControlActions(scope: scope, value: ControlAction.singleTarget(input)) },
			binding: Control.Binding.actions,
			downcast: Binding.controlBinding
		)
	}
	static func action(_ scope: UIControl.Event) -> ControlName<SignalInput<Void>> {
		return Binding.mappedWrappedInputName(
			map: { tuple in () },
			wrap: { input in ControlActions(scope: scope, value: ControlAction.singleTarget(input)) },
			binding: Control.Binding.actions,
			downcast: Binding.controlBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ControlConvertible: ViewConvertible {
	func uiControl() -> Control.Instance
}
extension ControlConvertible {
	public func uiView() -> View.Instance { return uiControl() }
}
extension UIControl: ControlConvertible {
	public func uiControl() -> Control.Instance { return self }
}
public extension Control {
	func uiControl() -> Control.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ControlBinding: ViewBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self
	func asControlBinding() -> Control.Binding?
}
public extension ControlBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return controlBinding(.inheritedBinding(binding))
	}
}
public extension ControlBinding where Preparer.Inherited.Binding: ControlBinding {
	func asControlBinding() -> Control.Binding? {
		return asInheritedBinding()?.asControlBinding()
	}
}
public extension Control.Binding {
	typealias Preparer = Control.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asControlBinding() -> Control.Binding? { return self }
	static func controlBinding(_ binding: Control.Binding) -> Control.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public enum ControlAction {
	case firstResponder(Selector)
	case singleTarget(SignalInput<(control: UIControl, event: UIEvent)>)
}

public typealias ControlActions = ScopedValues<UIControl.Event, ControlAction>

extension ScopedValues where Scope == UIControl.State {
	public static func normal(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .normal)
	}
	public static func highlighted(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .highlighted)
	}
	public static func disabled(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .disabled)
	}
	public static func selected(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .selected)
	}
	public static func focused(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .focused)
	}
	public static func application(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .application)
	}
	public static func reserved(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .reserved)
	}
}

open class SignalControlEventActionTarget: NSObject {
	private var signalInput: SignalInput<(control: UIControl, event: UIEvent)>? = nil
	
	// Ownership note: we are owned by the output signal so we only weakly retain it.
	private weak var signalOutput: SignalMulti<(control: UIControl, event: UIEvent)>? = nil
	
	/// The `signal` emits the actions received
	public var source: SignalMulti<(control: UIControl, event: UIEvent)> {
		// If there's a current signal output, return it
		if let so = signalOutput {
			return so
		}
		
		let s = Signal<(control: UIControl, event: UIEvent)>.generate { i in self.signalInput = i }.continuous()
		self.signalOutput = s
		return s
	}
	
	/// Receiver function for the target-action events
	///
	/// - Parameter sender: typical target-action "sender" parameter
	@IBAction public func cwlSendAction(_ sender: UIControl, forEvent event: UIEvent) {
		_ = signalInput?.send(value: (sender, event))
	}
	
	/// Convenience accessor for `#selector(SignalActionTarget<Value>.action(_:))`
	public var selector: Selector { return #selector(SignalControlEventActionTarget.cwlSendAction(_:forEvent:)) }
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class ExtendedViewController<Subclass: UIViewController & ViewControllerWithDelegate & HasDelegate>: Binder, ViewControllerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Subclass.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

extension ExtendedViewController where Subclass == CwlExtendedViewController {
	public convenience init(bindings: [Preparer.Binding]) {
		self.init(type: CwlExtendedViewController.self, parameters: (), bindings: bindings)
	}
	
	public convenience init(_ bindings: Preparer.Binding...) {
		self.init(type: CwlExtendedViewController.self, parameters: (), bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ExtendedViewController {
	enum Binding: ExtendedViewControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didAppear((UIViewController, Bool) -> Void)
		case didDisappear((UIViewController, Bool) -> Void)
		case didReceiveMemoryWarning((UIViewController) -> Void)
		case loadView(() -> ViewConvertible)
		case traitCollectionDidChange((UIViewController, UITraitCollection?) -> Void)
		case willAppear((UIViewController, Bool) -> Void)
		case willDisappear((UIViewController, Bool) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension ExtendedViewController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = ExtendedViewController.Binding
		public typealias Inherited = ViewController.Preparer
		public typealias Instance = Subclass
		public typealias Parameters = () /* change if non-default construction required */
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		public var loadView: (() -> ViewConvertible)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ExtendedViewController.Preparer {
	var delegateIsRequired: Bool { return dynamicDelegate != nil || loadView != nil }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.view(let x)):
			precondition(loadView == nil, "Construct the view using either .loadView or .view, not both.")
			inherited.prepareBinding(.view(x))
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .didAppear(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.viewDidAppear(controller:animated:)))
		case .didDisappear(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.viewDidDisappear(controller:animated:)))
		case .traitCollectionDidChange(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.traitCollectionDidChange(controller:previousTraitCollection:)))
		case .willAppear(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.viewWillAppear(controller:animated:)))
		case .willDisappear(let x): delegate().addMultiHandler2(x, #selector(ViewControllerDelegate.viewWillDisappear(controller:animated:)))
		case .didReceiveMemoryWarning(let x): delegate().addMultiHandler1(x, #selector(ViewControllerDelegate.didReceiveMemoryWarning(controller:)))
		case .loadView(let x):
			precondition(inherited.view == nil, "Construct the view using either .loadView or .view, not both.")
			loadView = x
		}
	}
	
	func prepareInstance(_ instance: Subclass, storage: ExtendedViewController<Subclass>.Preparer.Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		if let lv = loadView {
			storage.viewConstructor = lv
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .didAppear: return nil
		case .didDisappear: return nil
		case .traitCollectionDidChange: return nil
		case .willAppear: return nil
		case .willDisappear: return nil
			
		case .didReceiveMemoryWarning: return nil
		case .loadView: return nil
		}
	}
	
	func finalizeInstance(_ instance: Subclass, storage: ExtendedViewController<Subclass>.Preparer.Storage) -> Lifetime? {
		// Send the initial "traitsCollection" once construction is complete.
		if let dd = dynamicDelegate, dd.handlesSelector(#selector(ViewControllerDelegate.traitCollectionDidChange(controller:previousTraitCollection:))) {
			dd.traitCollectionDidChange(controller: instance, previousTraitCollection: nil)
		}
		
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ExtendedViewController.Preparer {
	open class Storage: ViewController.Preparer.Storage, ViewControllerDelegate {
		open var viewConstructor: (() -> ViewConvertible?)?
		
		public func loadView(controller: UIViewController) -> UIView? {
			if let wrapper = viewConstructor?() {
				return wrapper.uiView()
			}
			return nil
		}
		
		public func didReceiveMemoryWarning(controller: UIViewController) {
			if let dd = dynamicDelegate, dd.handlesSelector(#selector(ViewControllerDelegate.didReceiveMemoryWarning(controller:))) {
				(dd as? ViewControllerDelegate)?.didReceiveMemoryWarning?(controller: controller)
			}
			
			if viewConstructor != nil, let view = controller.viewIfLoaded, view.window == nil {
				controller.view = nil
			}
		}
	}

	open class Delegate: DynamicDelegate, ViewControllerDelegate {
		public func loadView(controller: UIViewController) -> UIView? {
			return nil
		}
		
		public func didReceiveMemoryWarning(controller: UIViewController) {
			multiHandler(controller)
		}
		
		public func traitCollectionDidChange(controller: UIViewController, previousTraitCollection: UITraitCollection?) {
			multiHandler(controller, previousTraitCollection)
		}
		
		public func viewWillAppear(controller: UIViewController, animated: Bool) {
			multiHandler(controller, animated)
		}
		
		public func viewDidAppear(controller: UIViewController, animated: Bool) {
			multiHandler(controller, animated)
		}
		
		public func viewWillDisappear(controller: UIViewController, animated: Bool) {
			multiHandler(controller, animated)
		}
		
		public func viewDidDisappear(controller: UIViewController, animated: Bool) {
			multiHandler(controller, animated)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ExtendedViewControllerBinding {
	public typealias ExtendedViewControllerName<V> = BindingName<V, ExtendedViewController<Binding.SubclassType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ExtendedViewController<Binding.SubclassType>.Binding) -> ExtendedViewControllerName<V> {
		return ExtendedViewControllerName<V>(source: source, downcast: Binding.extendedViewControllerBinding)
	}
}
public extension BindingName where Binding: ExtendedViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ExtendedViewControllerName<$2> { return .name(ExtendedViewController.Binding.$1) }

	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didAppear: ExtendedViewControllerName<(UIViewController, Bool) -> Void> { return .name(ExtendedViewController.Binding.didAppear) }
	static var didDisappear: ExtendedViewControllerName<(UIViewController, Bool) -> Void> { return .name(ExtendedViewController.Binding.didDisappear) }
	static var didReceiveMemoryWarning: ExtendedViewControllerName<(UIViewController) -> Void> { return .name(ExtendedViewController.Binding.didReceiveMemoryWarning) }
	static var loadView: ExtendedViewControllerName<() -> ViewConvertible> { return .name(ExtendedViewController.Binding.loadView) }
	static var traitCollectionDidChange: ExtendedViewControllerName<(UIViewController, UITraitCollection?) -> Void> { return .name(ExtendedViewController.Binding.traitCollectionDidChange) }
	static var willAppear: ExtendedViewControllerName<(UIViewController, Bool) -> Void> { return .name(ExtendedViewController.Binding.willAppear) }
	static var willDisappear: ExtendedViewControllerName<(UIViewController, Bool) -> Void> { return .name(ExtendedViewController.Binding.willDisappear) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public extension ExtendedViewController {
	func uiViewController() -> ViewController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ExtendedViewControllerBinding: ViewControllerBinding {
	associatedtype SubclassType: UIViewController & ViewControllerWithDelegate & HasDelegate
	static func extendedViewControllerBinding(_ binding: ExtendedViewController<SubclassType>.Binding) -> Self
	func asExtendedViewControllerBinding() -> ExtendedViewController<SubclassType>.Binding?
}
public extension ExtendedViewControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return extendedViewControllerBinding(.inheritedBinding(binding))
	}
}
public extension ExtendedViewControllerBinding where Preparer.Inherited.Binding: ExtendedViewControllerBinding, Preparer.Inherited.Binding.SubclassType == SubclassType {
	func asExtendedViewControllerBinding() -> ExtendedViewController<SubclassType>.Binding? {
		return asInheritedBinding()?.asExtendedViewControllerBinding()
	}
}
public extension ExtendedViewController.Binding {
	typealias Preparer = ExtendedViewController.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asExtendedViewControllerBinding() -> ExtendedViewController.Binding? { return self }
	static func extendedViewControllerBinding(_ binding: ExtendedViewController.Binding) -> ExtendedViewController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
@objc public protocol ViewControllerDelegate: class {
	@objc optional func loadView(controller: UIViewController) -> UIView?
	@objc optional func didReceiveMemoryWarning(controller: UIViewController)
	@objc optional func traitCollectionDidChange(controller: UIViewController, previousTraitCollection: UITraitCollection?)
	@objc optional func viewWillAppear(controller: UIViewController, animated: Bool)
	@objc optional func viewDidAppear(controller: UIViewController, animated: Bool)
	@objc optional func viewWillDisappear(controller: UIViewController, animated: Bool)
	@objc optional func viewDidDisappear(controller: UIViewController, animated: Bool)
}

public protocol ViewControllerWithDelegate {
	var delegate: ViewControllerDelegate? { get set }
}

/// Implementation of ViewControllerWithDelegate on top of the base UIViewController.
/// You can use this view controller directly, subclass it or implement `ViewControllerWithDelegate` and `HasDelegate` on top of another `UIViewController` to use that view controller with the `ExtendedViewController` binder.
open class CwlExtendedViewController: UIViewController, ViewControllerWithDelegate, HasDelegate {
	public unowned var delegate: ViewControllerDelegate?
	
	open override func loadView() {
		if let loaded = delegate?.loadView?(controller: self) {
			view = loaded
		} else {
			super.loadView()
		}
	}
	
	open override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
		delegate?.traitCollectionDidChange?(controller: self, previousTraitCollection: previousTraitCollection)
		super.traitCollectionDidChange(previousTraitCollection)
	}
	
	open override func viewWillAppear(_ animated: Bool) {
		delegate?.viewWillAppear?(controller: self, animated: animated)
		super.viewWillAppear(animated)
	}
	
	open override func viewDidAppear(_ animated: Bool) {
		delegate?.viewDidAppear?(controller: self, animated: animated)
		super.viewDidAppear(animated)
	}
	
	open override func viewWillDisappear(_ animated: Bool) {
		delegate?.viewWillDisappear?(controller: self, animated: animated)
		super.viewWillDisappear(animated)
	}
	
	open override func viewDidDisappear(_ animated: Bool) {
		delegate?.viewDidDisappear?(controller: self, animated: animated)
		super.viewDidDisappear(animated)
	}
	
	open override func didReceiveMemoryWarning() {
		delegate?.didReceiveMemoryWarning?(controller: self)
		super.didReceiveMemoryWarning()
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class GestureRecognizer: Binder, GestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension GestureRecognizer {
	enum Binding: GestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowedPressTypes(Dynamic<[NSNumber]>)
		case allowedTouchTypes(Dynamic<[NSNumber]>)
		case cancelsTouchesInView(Dynamic<Bool>)
		case delaysTouchesBegan(Dynamic<Bool>)
		case delaysTouchesEnded(Dynamic<Bool>)
		case requiresExclusiveTouchType(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case action(SignalInput<Any?>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBegin((UIGestureRecognizer) -> Bool)
		case shouldBeRequiredToFail((UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool)
		case shouldReceivePress((UIGestureRecognizer, UIPress) -> Bool)
		case shouldReceiveTouch((UIGestureRecognizer, UITouch) -> Bool)
		case shouldRecognizeSimultanously((UIGestureRecognizer, UIGestureRecognizer) -> Bool)
		case shouldRequireFailure((UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
public extension GestureRecognizer {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = GestureRecognizer.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = UIGestureRecognizer
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension GestureRecognizer.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .shouldBegin(let x): delegate().addSingleHandler1(x, #selector(UIGestureRecognizerDelegate.gestureRecognizerShouldBegin(_:)))
		case .shouldBeRequiredToFail(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldBeRequiredToFailBy:)))
		case .shouldReceivePress(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UIPress) -> Bool)?))
		case .shouldReceiveTouch(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UITouch) -> Bool)?))
		case .shouldRecognizeSimultanously(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:)))
		case .shouldRequireFailure(let x): delegate().addSingleHandler2(x, #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRequireFailureOf:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowedPressTypes(let x): return x.apply(instance) { i, v in i.allowedPressTypes = v }
		case .allowedTouchTypes(let x): return x.apply(instance) { i, v in i.allowedTouchTypes = v }
		case .cancelsTouchesInView(let x): return x.apply(instance) { i, v in i.cancelsTouchesInView = v }
		case .delaysTouchesBegan(let x): return x.apply(instance) { i, v in i.delaysTouchesBegan = v }
		case .delaysTouchesEnded(let x): return x.apply(instance) { i, v in i.delaysTouchesEnded = v }
		
		case .requiresExclusiveTouchType(let x): return x.apply(instance) { i, v in i.requiresExclusiveTouchType = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case .action(let x):
			let target = SignalActionTarget()
			instance.addTarget(target, action: SignalActionTarget.selector)
			return target.signal.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldBegin: return nil
		case .shouldReceiveTouch: return nil
		case .shouldRecognizeSimultanously: return nil
		case .shouldRequireFailure: return nil
		case .shouldBeRequiredToFail: return nil
		case .shouldReceivePress: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension GestureRecognizer.Preparer {
	open class Storage: AssociatedBinderStorage, UIGestureRecognizerDelegate {}

	open class Delegate: DynamicDelegate, UIGestureRecognizerDelegate {
		open func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer)
		}
		
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool {
			return singleHandler(gestureRecognizer, touch)
		}
		
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive press: UIPress) -> Bool {
			return singleHandler(gestureRecognizer, press)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: GestureRecognizerBinding {
	public typealias GestureRecognizerName<V> = BindingName<V, GestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> GestureRecognizer.Binding) -> GestureRecognizerName<V> {
		return GestureRecognizerName<V>(source: source, downcast: Binding.gestureRecognizerBinding)
	}
}
public extension BindingName where Binding: GestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: GestureRecognizerName<$2> { return .name(GestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowedPressTypes: GestureRecognizerName<Dynamic<[NSNumber]>> { return .name(GestureRecognizer.Binding.allowedPressTypes) }
	static var allowedTouchTypes: GestureRecognizerName<Dynamic<[NSNumber]>> { return .name(GestureRecognizer.Binding.allowedTouchTypes) }
	static var cancelsTouchesInView: GestureRecognizerName<Dynamic<Bool>> { return .name(GestureRecognizer.Binding.cancelsTouchesInView) }
	static var delaysTouchesBegan: GestureRecognizerName<Dynamic<Bool>> { return .name(GestureRecognizer.Binding.delaysTouchesBegan) }
	static var delaysTouchesEnded: GestureRecognizerName<Dynamic<Bool>> { return .name(GestureRecognizer.Binding.delaysTouchesEnded) }
	static var requiresExclusiveTouchType: GestureRecognizerName<Dynamic<Bool>> { return .name(GestureRecognizer.Binding.requiresExclusiveTouchType) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: GestureRecognizerName<SignalInput<Any?>> { return .name(GestureRecognizer.Binding.action) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldBegin: GestureRecognizerName<(UIGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldBegin) }
	static var shouldBeRequiredToFail: GestureRecognizerName<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldBeRequiredToFail) }
	static var shouldReceivePress: GestureRecognizerName<(UIGestureRecognizer, UIPress) -> Bool> { return .name(GestureRecognizer.Binding.shouldReceivePress) }
	static var shouldReceiveTouch: GestureRecognizerName<(UIGestureRecognizer, UITouch) -> Bool> { return .name(GestureRecognizer.Binding.shouldReceiveTouch) }
	static var shouldRecognizeSimultanously: GestureRecognizerName<(UIGestureRecognizer, UIGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldRecognizeSimultanously) }
	static var shouldRequireFailure: GestureRecognizerName<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldRequireFailure) }

	// Composite binding names
	static func action<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> GestureRecognizerName<SignalInput<Value>> {
		return Binding.mappedInputName(
			map: { sender in (sender as! Binding.Preparer.Instance)[keyPath: keyPath] },
			binding: GestureRecognizer.Binding.action,
			downcast: Binding.gestureRecognizerBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol GestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance
}
extension UIGestureRecognizer: GestureRecognizerConvertible, DefaultConstructable, HasDelegate {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return self }
}
public extension GestureRecognizer {
	func uiGestureRecognizer() -> GestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol GestureRecognizerBinding: BinderBaseBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self
	func asGestureRecognizerBinding() -> GestureRecognizer.Binding?
}
public extension GestureRecognizerBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return gestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension GestureRecognizerBinding where Preparer.Inherited.Binding: GestureRecognizerBinding {
	func asGestureRecognizerBinding() -> GestureRecognizer.Binding? {
		return asInheritedBinding()?.asGestureRecognizerBinding()
	}
}
public extension GestureRecognizer.Binding {
	typealias Preparer = GestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asGestureRecognizerBinding() -> GestureRecognizer.Binding? { return self }
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> GestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class ImageView: Binder, ImageViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ImageView {
	enum Binding: ImageViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case image(Dynamic<UIImage?>)
		case highlightedImage(Dynamic<UIImage?>)
		case animationImages(Dynamic<[UIImage]?>)
		case highlightedAnimationImages(Dynamic<[UIImage]?>)
		case animationDuration(Dynamic<TimeInterval>)
		case animationRepeatCount(Dynamic<Int>)
		case isHighlighted(Dynamic<Bool>)
		
		// 2. Signal bindings are performed on the object after construction.
		case animating(Signal<Bool>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension ImageView {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = ImageView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UIImageView
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var image = InitialSubsequent<UIImage?>()
		var highlightedImage = InitialSubsequent<UIImage?>()
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ImageView.Preparer {
	func constructInstance(type: UIImageView.Type, parameters: Void) -> UIImageView {
		return type.init(image: image.initial ?? nil, highlightedImage: highlightedImage.initial ?? nil)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .image(let x): image = x.initialSubsequent()
		case .highlightedImage(let x): highlightedImage = x.initialSubsequent()
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .animationDuration(let x): return x.apply(instance) { i, v in i.animationDuration = v }
		case .animationImages(let x): return x.apply(instance) { i, v in i.animationImages = v }
		case .animationRepeatCount(let x): return x.apply(instance) { i, v in i.animationRepeatCount = v }
		case .highlightedAnimationImages(let x): return x.apply(instance) { i, v in i.highlightedAnimationImages = v }
		case .highlightedImage: return highlightedImage.apply(instance) { i, v in i.highlightedImage = v }
		case .image: return image.apply(instance) { i, v in i.image = v }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.isHighlighted = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .animating(let x):
			return x.apply(instance) { i, v in
				if v && !i.isAnimating {
					i.startAnimating()
				} else if !v && i.isAnimating {
					i.stopAnimating()
				}
			}
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ImageView.Preparer {
	public typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ImageViewBinding {
	public typealias ImageViewName<V> = BindingName<V, ImageView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ImageView.Binding) -> ImageViewName<V> {
		return ImageViewName<V>(source: source, downcast: Binding.imageViewBinding)
	}
}
public extension BindingName where Binding: ImageViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ImageViewName<$2> { return .name(ImageView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var image: ImageViewName<Dynamic<UIImage?>> { return .name(ImageView.Binding.image) }
	static var highlightedImage: ImageViewName<Dynamic<UIImage?>> { return .name(ImageView.Binding.highlightedImage) }
	static var animationImages: ImageViewName<Dynamic<[UIImage]?>> { return .name(ImageView.Binding.animationImages) }
	static var highlightedAnimationImages: ImageViewName<Dynamic<[UIImage]?>> { return .name(ImageView.Binding.highlightedAnimationImages) }
	static var animationDuration: ImageViewName<Dynamic<TimeInterval>> { return .name(ImageView.Binding.animationDuration) }
	static var animationRepeatCount: ImageViewName<Dynamic<Int>> { return .name(ImageView.Binding.animationRepeatCount) }
	static var isHighlighted: ImageViewName<Dynamic<Bool>> { return .name(ImageView.Binding.isHighlighted) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var animating: ImageViewName<Signal<Bool>> { return .name(ImageView.Binding.animating) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ImageViewConvertible: ViewConvertible {
	func uiImageView() -> ImageView.Instance
}
extension ImageViewConvertible {
	public func uiView() -> View.Instance { return uiImageView() }
}
extension UIImageView: ImageViewConvertible {
	public func uiImageView() -> ImageView.Instance { return self }
}
public extension ImageView {
	func uiImageView() -> ImageView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ImageViewBinding: ViewBinding {
	static func imageViewBinding(_ binding: ImageView.Binding) -> Self
	func asImageViewBinding() -> ImageView.Binding?
}
public extension ImageViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return imageViewBinding(.inheritedBinding(binding))
	}
}
public extension ImageViewBinding where Preparer.Inherited.Binding: ImageViewBinding {
	func asImageViewBinding() -> ImageView.Binding? {
		return asInheritedBinding()?.asImageViewBinding()
	}
}
public extension ImageView.Binding {
	typealias Preparer = ImageView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asImageViewBinding() -> ImageView.Binding? { return self }
	static func imageViewBinding(_ binding: ImageView.Binding) -> ImageView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class Label: Binder, LabelConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Label {
	enum Binding: LabelBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case adjustsFontSizeToFitWidth(Dynamic<Bool>)
		case allowsDefaultTighteningForTruncation(Dynamic<Bool>)
		case attributedText(Dynamic<NSAttributedString?>)
		case baselineAdjustment(Dynamic<UIBaselineAdjustment>)
		case font(Dynamic<UIFont>)
		case highlightedTextColor(Dynamic<UIColor?>)
		case isEnabled(Dynamic<Bool>)
		case isHighlighted(Dynamic<Bool>)
		case lineBreakMode(Dynamic<NSLineBreakMode>)
		case minimumScaleFactor(Dynamic<CGFloat>)
		case numberOfLines(Dynamic<Int>)
		case preferredMaxLayoutWidth(Dynamic<CGFloat>)
		case shadowColor(Dynamic<UIColor?>)
		case shadowOffset(Dynamic<CGSize>)
		case text(Dynamic<String>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case textColor(Dynamic<UIColor>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension Label {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = Label.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UILabel
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Label.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .adjustsFontSizeToFitWidth(let x): return x.apply(instance) { i, v in i.adjustsFontSizeToFitWidth = v }
		case .allowsDefaultTighteningForTruncation(let x): return x.apply(instance) { i, v in i.allowsDefaultTighteningForTruncation = v }
		case .attributedText(let x): return x.apply(instance) { i, v in i.attributedText = v }
		case .baselineAdjustment(let x): return x.apply(instance) { i, v in i.baselineAdjustment = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .highlightedTextColor(let x): return x.apply(instance) { i, v in i.highlightedTextColor = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.isHighlighted = v }
		case .lineBreakMode(let x): return x.apply(instance) { i, v in i.lineBreakMode = v }
		case .minimumScaleFactor(let x): return x.apply(instance) { i, v in i.minimumScaleFactor = v }
		case .numberOfLines(let x): return x.apply(instance) { i, v in i.numberOfLines = v }
		case .preferredMaxLayoutWidth(let x): return x.apply(instance) { i, v in i.preferredMaxLayoutWidth = v }
		case .shadowColor(let x): return x.apply(instance) { i, v in i.shadowColor = v }
		case .shadowOffset(let x): return x.apply(instance) { i, v in i.shadowOffset = v }
		case .text(let x): return x.apply(instance) { i, v in i.text = v }
		case .textAlignment(let x): return x.apply(instance) { i, v in i.textAlignment = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Label.Preparer {
	public typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: LabelBinding {
	public typealias LabelName<V> = BindingName<V, Label.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Label.Binding) -> LabelName<V> {
		return LabelName<V>(source: source, downcast: Binding.windowBinding)
	}
}
public extension BindingName where Binding: LabelBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: LabelName<$2> { return .name(Label.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsFontSizeToFitWidth: LabelName<Dynamic<Bool>> { return .name(Label.Binding.adjustsFontSizeToFitWidth) }
	static var allowsDefaultTighteningForTruncation: LabelName<Dynamic<Bool>> { return .name(Label.Binding.allowsDefaultTighteningForTruncation) }
	static var attributedText: LabelName<Dynamic<NSAttributedString?>> { return .name(Label.Binding.attributedText) }
	static var baselineAdjustment: LabelName<Dynamic<UIBaselineAdjustment>> { return .name(Label.Binding.baselineAdjustment) }
	static var font: LabelName<Dynamic<UIFont>> { return .name(Label.Binding.font) }
	static var highlightedTextColor: LabelName<Dynamic<UIColor?>> { return .name(Label.Binding.highlightedTextColor) }
	static var isEnabled: LabelName<Dynamic<Bool>> { return .name(Label.Binding.isEnabled) }
	static var isHighlighted: LabelName<Dynamic<Bool>> { return .name(Label.Binding.isHighlighted) }
	static var lineBreakMode: LabelName<Dynamic<NSLineBreakMode>> { return .name(Label.Binding.lineBreakMode) }
	static var minimumScaleFactor: LabelName<Dynamic<CGFloat>> { return .name(Label.Binding.minimumScaleFactor) }
	static var numberOfLines: LabelName<Dynamic<Int>> { return .name(Label.Binding.numberOfLines) }
	static var preferredMaxLayoutWidth: LabelName<Dynamic<CGFloat>> { return .name(Label.Binding.preferredMaxLayoutWidth) }
	static var shadowColor: LabelName<Dynamic<UIColor?>> { return .name(Label.Binding.shadowColor) }
	static var shadowOffset: LabelName<Dynamic<CGSize>> { return .name(Label.Binding.shadowOffset) }
	static var text: LabelName<Dynamic<String>> { return .name(Label.Binding.text) }
	static var textAlignment: LabelName<Dynamic<NSTextAlignment>> { return .name(Label.Binding.textAlignment) }
	static var textColor: LabelName<Dynamic<UIColor>> { return .name(Label.Binding.textColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol LabelConvertible: ViewConvertible {
	func uiLabel() -> Label.Instance
}
extension LabelConvertible {
	public func uiView() -> View.Instance { return uiLabel() }
}
extension UILabel: LabelConvertible {
	public func uiLabel() -> Label.Instance { return self }
}
public extension Label {
	func uiLabel() -> Label.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol LabelBinding: ViewBinding {
	static func windowBinding(_ binding: Label.Binding) -> Self
	func asLabelBinding() -> Label.Binding?
}
public extension LabelBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return windowBinding(.inheritedBinding(binding))
	}
}
public extension LabelBinding where Preparer.Inherited.Binding: LabelBinding {
	func asLabelBinding() -> Label.Binding? {
		return asInheritedBinding()?.asLabelBinding()
	}
}
public extension Label.Binding {
	typealias Preparer = Label.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asLabelBinding() -> Label.Binding? { return self }
	static func windowBinding(_ binding: Label.Binding) -> Label.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class LongPressGestureRecognizer: Binder, LongPressGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension LongPressGestureRecognizer {
	enum Binding: LongPressGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowableMovement(Dynamic<CGFloat>)
		case minimumPressDuration(Dynamic<CFTimeInterval>)
		case numberOfTapsRequired(Dynamic<Int>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension LongPressGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = LongPressGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = UILongPressGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension LongPressGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowableMovement(let x): return x.apply(instance) { i, v in i.allowableMovement = v }
		case .minimumPressDuration(let x): return x.apply(instance) { i, v in i.minimumPressDuration = v }
		case .numberOfTapsRequired(let x): return x.apply(instance) { i, v in i.numberOfTapsRequired = v }
		case .numberOfTouchesRequired(let x): return x.apply(instance) { i, v in i.numberOfTouchesRequired = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension LongPressGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: LongPressGestureRecognizerBinding {
	public typealias LongPressGestureRecognizerName<V> = BindingName<V, LongPressGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> LongPressGestureRecognizer.Binding) -> LongPressGestureRecognizerName<V> {
		return LongPressGestureRecognizerName<V>(source: source, downcast: Binding.longPressGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: LongPressGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: LongPressGestureRecognizerName<$2> { return .name(LongPressGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowableMovement: LongPressGestureRecognizerName<Dynamic<CGFloat>> { return .name(LongPressGestureRecognizer.Binding.allowableMovement) }
	static var minimumPressDuration: LongPressGestureRecognizerName<Dynamic<CFTimeInterval>> { return .name(LongPressGestureRecognizer.Binding.minimumPressDuration) }
	static var numberOfTapsRequired: LongPressGestureRecognizerName<Dynamic<Int>> { return .name(LongPressGestureRecognizer.Binding.numberOfTapsRequired) }
	static var numberOfTouchesRequired: LongPressGestureRecognizerName<Dynamic<Int>> { return .name(LongPressGestureRecognizer.Binding.numberOfTouchesRequired) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol LongPressGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance
}
extension LongPressGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiLongPressGestureRecognizer() }
}
extension UILongPressGestureRecognizer: LongPressGestureRecognizerConvertible {
	public func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance { return self }
}
public extension LongPressGestureRecognizer {
	func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol LongPressGestureRecognizerBinding: GestureRecognizerBinding {
	static func longPressGestureRecognizerBinding(_ binding: LongPressGestureRecognizer.Binding) -> Self
	func asLongPressGestureRecognizerBinding() -> LongPressGestureRecognizer.Binding?
}
public extension LongPressGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return longPressGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension LongPressGestureRecognizerBinding where Preparer.Inherited.Binding: LongPressGestureRecognizerBinding {
	func asLongPressGestureRecognizerBinding() -> LongPressGestureRecognizer.Binding? {
		return asInheritedBinding()?.asLongPressGestureRecognizerBinding()
	}
}
public extension LongPressGestureRecognizer.Binding {
	typealias Preparer = LongPressGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asLongPressGestureRecognizerBinding() -> LongPressGestureRecognizer.Binding? { return self }
	static func longPressGestureRecognizerBinding(_ binding: LongPressGestureRecognizer.Binding) -> LongPressGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class NavigationBar: Binder, NavigationBarConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension NavigationBar {
	enum Binding: NavigationBarBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		case backIndicatorImage(Dynamic<UIImage?>)
		case backIndicatorTransitionMaskImage(Dynamic<UIImage?>)
		case barStyle(Dynamic<UIBarStyle>)
		case barTintColor(Dynamic<UIColor?>)
		case isTranslucent(Dynamic<Bool>)
		case items(Dynamic<StackMutation<NavigationItemConvertible>>)
		case shadowImage(Dynamic<UIImage?>)
		case tintColor(Dynamic<UIColor?>)
		case titleTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case titleVerticalPositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, CGFloat>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didPop((UINavigationBar, UINavigationItem) -> Void)
		case didPush((UINavigationBar, UINavigationItem) -> Void)
		case position((UIBarPositioning) -> UIBarPosition)
		case shouldPop((UINavigationBar, UINavigationItem) -> Bool)
		case shouldPush((UINavigationBar, UINavigationItem) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
public extension NavigationBar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = NavigationBar.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UINavigationBar
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension NavigationBar.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding { 
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .didPop(let x): delegate().addMultiHandler2(x, #selector(UINavigationBarDelegate.navigationBar(_:didPop:)))
		case .didPush(let x): delegate().addMultiHandler2(x, #selector(UINavigationBarDelegate.navigationBar(_:didPush:)))
		case .position(let x): delegate().addSingleHandler1(x, #selector(UINavigationBarDelegate.position(for:)))
		case .shouldPop(let x): delegate().addSingleHandler2(x, #selector(UINavigationBarDelegate.navigationBar(_:shouldPop:)))
		case .shouldPush(let x): delegate().addSingleHandler2(x, #selector(UINavigationBarDelegate.navigationBar(_:shouldPush:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, for: scope.barPosition, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, for: scope.barPosition, barMetrics: scope.barMetrics) }
			)
		case .backIndicatorImage(let x): return x.apply(instance) { i, v in i.backIndicatorImage = v }
		case .backIndicatorTransitionMaskImage(let x): return x.apply(instance) { i, v in i.backIndicatorTransitionMaskImage = v }
		case .barStyle(let x): return x.apply(instance) { i, v in i.barStyle = v }
		case .barTintColor(let x): return x.apply(instance) { i, v in i.barTintColor = v }
		case .isTranslucent(let x): return x.apply(instance) { i, v in i.isTranslucent = v }
		case .items(let x):
			return x.apply(instance, storage) { i, s, v in
				switch v {
				case .push(let e):
					i.pushItem(e.uiNavigationItem(), animated: true)
				case .pop:
					i.popItem(animated: true)
				case .popToCount(let c):
					i.setItems(i.items?.dropLast((i.items?.count ?? 0) - c) ?? [], animated: true)
				case .reload(let newStack):
					i.setItems(newStack.map { $0.uiNavigationItem() }, animated: false)
				}
			}
		case .shadowImage(let x): return x.apply(instance) { i, v in i.shadowImage = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
		case .titleTextAttributes(let x): return x.apply(instance) { i, v in i.titleTextAttributes = v }
		case .titleVerticalPositionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setTitleVerticalPositionAdjustment(0, for: scope) },
				applyNew: { i, scope, v in i.setTitleVerticalPositionAdjustment(v, for: scope) }
			)
			
		// 2. Signal bindings are performed on the object after construction.
			
		//	3. Action bindings are triggered by the object after construction.
		case .didPush: return nil
		case .didPop: return nil
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .position: return nil
		case .shouldPop: return nil
		case .shouldPush: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension NavigationBar.Preparer {
	open class Storage: View.Preparer.Storage, UINavigationBarDelegate {}

	open class Delegate: DynamicDelegate, UINavigationBarDelegate {
		open func navigationBar(_ navigationBar: UINavigationBar, shouldPop item: UINavigationItem) -> Bool {
			return singleHandler(navigationBar, item)
		}
		
		open func navigationBar(_ navigationBar: UINavigationBar, shouldPush item: UINavigationItem) -> Bool {
			return singleHandler(navigationBar, item)
		}
		
		open func navigationBar(_ navigationBar: UINavigationBar, didPop item: UINavigationItem) {
			multiHandler(navigationBar, item)
		}
		
		open func navigationBar(_ navigationBar: UINavigationBar, didPush item: UINavigationItem) {
			multiHandler(navigationBar, item)
		}
		
		open func position(for bar: UIBarPositioning) -> UIBarPosition {
			return singleHandler(bar)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: NavigationBarBinding {
	public typealias NavigationBarName<V> = BindingName<V, NavigationBar.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> NavigationBar.Binding) -> NavigationBarName<V> {
		return NavigationBarName<V>(source: source, downcast: Binding.scrollViewBinding)
	}
}
public extension BindingName where Binding: NavigationBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: NavigationBarName<$2> { return .name(NavigationBar.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: NavigationBarName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>> { return .name(NavigationBar.Binding.backgroundImage) }
	static var backIndicatorImage: NavigationBarName<Dynamic<UIImage?>> { return .name(NavigationBar.Binding.backIndicatorImage) }
	static var backIndicatorTransitionMaskImage: NavigationBarName<Dynamic<UIImage?>> { return .name(NavigationBar.Binding.backIndicatorTransitionMaskImage) }
	static var barStyle: NavigationBarName<Dynamic<UIBarStyle>> { return .name(NavigationBar.Binding.barStyle) }
	static var barTintColor: NavigationBarName<Dynamic<UIColor?>> { return .name(NavigationBar.Binding.barTintColor) }
	static var isTranslucent: NavigationBarName<Dynamic<Bool>> { return .name(NavigationBar.Binding.isTranslucent) }
	static var items: NavigationBarName<Dynamic<StackMutation<NavigationItemConvertible>>> { return .name(NavigationBar.Binding.items) }
	static var shadowImage: NavigationBarName<Dynamic<UIImage?>> { return .name(NavigationBar.Binding.shadowImage) }
	static var tintColor: NavigationBarName<Dynamic<UIColor?>> { return .name(NavigationBar.Binding.tintColor) }
	static var titleTextAttributes: NavigationBarName<Dynamic<[NSAttributedString.Key: Any]>> { return .name(NavigationBar.Binding.titleTextAttributes) }
	static var titleVerticalPositionAdjustment: NavigationBarName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>> { return .name(NavigationBar.Binding.titleVerticalPositionAdjustment) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didPop: NavigationBarName<(UINavigationBar, UINavigationItem) -> Void> { return .name(NavigationBar.Binding.didPop) }
	static var didPush: NavigationBarName<(UINavigationBar, UINavigationItem) -> Void> { return .name(NavigationBar.Binding.didPush) }
	static var position: NavigationBarName<(UIBarPositioning) -> UIBarPosition> { return .name(NavigationBar.Binding.position) }
	static var shouldPop: NavigationBarName<(UINavigationBar, UINavigationItem) -> Bool> { return .name(NavigationBar.Binding.shouldPop) }
	static var shouldPush: NavigationBarName<(UINavigationBar, UINavigationItem) -> Bool> { return .name(NavigationBar.Binding.shouldPush) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol NavigationBarConvertible: ViewConvertible {
	func uiNavigationBar() -> NavigationBar.Instance
}
extension NavigationBarConvertible {
	public func uiView() -> View.Instance { return uiNavigationBar() }
}
extension UINavigationBar: NavigationBarConvertible, HasDelegate {
	public func uiNavigationBar() -> NavigationBar.Instance { return self }
}
public extension NavigationBar {
	func uiNavigationBar() -> NavigationBar.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol NavigationBarBinding: ViewBinding {
	static func scrollViewBinding(_ binding: NavigationBar.Binding) -> Self
	func asNavigationBarBinding() -> NavigationBar.Binding?
}
public extension NavigationBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}
public extension NavigationBarBinding where Preparer.Inherited.Binding: NavigationBarBinding {
	func asNavigationBarBinding() -> NavigationBar.Binding? {
		return asInheritedBinding()?.asNavigationBarBinding()
	}
}
public extension NavigationBar.Binding {
	typealias Preparer = NavigationBar.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asNavigationBarBinding() -> NavigationBar.Binding? { return self }
	static func scrollViewBinding(_ binding: NavigationBar.Binding) -> NavigationBar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public struct PositionAndMetrics {
	public let barPosition: UIBarPosition
	public let barMetrics: UIBarMetrics
	public init(position: UIBarPosition = .any, metrics: UIBarMetrics = .default) {
		self.barPosition = position
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == PositionAndMetrics {
	public static func any(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .any, metrics: metrics))
	}
	public static func bottom(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .bottom, metrics: metrics))
	}
	public static func top(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .top, metrics: metrics))
	}
	public static func topAttached(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .topAttached, metrics: metrics))
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class NavigationController: Binder, NavigationControllerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension NavigationController {
	enum Binding: NavigationControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case navigationBar(Constant<NavigationBar>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case hidesBarsOnSwipe(Dynamic<Bool>)
		case hidesBarsOnTap(Dynamic<Bool>)
		case hidesBarsWhenKeyboardAppears(Dynamic<Bool>)
		case hidesBarsWhenVerticallyCompact(Dynamic<Bool>)
		case isNavigationBarHidden(Dynamic<SetOrAnimate<Bool>>)
		case isToolbarHidden(Dynamic<SetOrAnimate<Bool>>)
		case stack(Dynamic<StackMutation<ViewControllerConvertible>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case poppedToCount(SignalInput<Int>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case animationController((_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?)
		case interactionController((_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
		case preferredInterfaceOrientation((_ navigationController: UINavigationController) -> UIInterfaceOrientation)
		case supportedInterfaceOrientations((_ navigationController: UINavigationController) -> UIInterfaceOrientationMask)
		case didShow((_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void)
		case willShow((_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension NavigationController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = NavigationController.Binding
		public typealias Inherited = ViewController.Preparer
		public typealias Instance = UINavigationController
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage(popSignal: popSignal) }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var popSignal: MultiOutput<Int>? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension NavigationController.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance { return type.init(nibName: nil, bundle: nil) }

	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .animationController(let x): delegate().addSingleHandler4(x, #selector(UINavigationControllerDelegate.navigationController(_:animationControllerFor:from:to:)))
		case .interactionController(let x): delegate().addSingleHandler2(x, #selector(UINavigationControllerDelegate.navigationController(_:interactionControllerFor:)))
		case .didShow(let x): delegate().addMultiHandler3(x, #selector(UINavigationControllerDelegate.navigationController(_:willShow:animated:)))
		case .poppedToCount(let x):
			popSignal = popSignal ?? Input().multicast()
			popSignal?.signal.bind(to: x)
		case .preferredInterfaceOrientation(let x): delegate().addSingleHandler1(x, #selector(UINavigationControllerDelegate.navigationControllerPreferredInterfaceOrientationForPresentation(_:)))
		case .supportedInterfaceOrientations(let x): delegate().addSingleHandler1(x, #selector(UINavigationControllerDelegate.navigationControllerSupportedInterfaceOrientations(_:)))
		case .willShow(let x): delegate().addMultiHandler3(x, #selector(UINavigationControllerDelegate.navigationController(_:willShow:animated:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .navigationBar(let x):
			x.value.apply(to: instance.navigationBar)
			return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .hidesBarsOnSwipe(let x): return x.apply(instance) { i, v in i.hidesBarsOnSwipe = v }
		case .hidesBarsOnTap(let x): return x.apply(instance) { i, v in i.hidesBarsOnTap = v }
		case .hidesBarsWhenKeyboardAppears(let x): return x.apply(instance) { i, v in i.hidesBarsWhenKeyboardAppears = v }
		case .hidesBarsWhenVerticallyCompact(let x): return x.apply(instance) { i, v in i.hidesBarsWhenVerticallyCompact = v }
		case .isNavigationBarHidden(let x): return x.apply(instance) { i, v in i.setNavigationBarHidden(v.value, animated: v.isAnimated) }
		case .isToolbarHidden(let x): return x.apply(instance) { i, v in i.setToolbarHidden(v.value, animated: v.isAnimated) }
		case .preferredInterfaceOrientation: return nil
		case .stack(let x):
			return x.apply(instance, storage) { i, s, v in
				switch v {
				case .push(let e):
					s.expectedStackCount += 1
					i.pushViewController(e.uiViewController(), animated: true)
				case .pop:
					s.expectedStackCount -= 1
					i.popViewController(animated: true)
				case .popToCount(let c):
					s.expectedStackCount = c
					i.popToViewController(i.viewControllers[c - 1], animated: true)
				case .reload(let newStack):
					s.expectedStackCount = newStack.count
					i.setViewControllers(newStack.map { $0.uiViewController() }, animated: false)
				}
			}
		case .supportedInterfaceOrientations: return nil
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
		case .didShow: return nil
		case .poppedToCount: return nil
		case .willShow: return nil
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .animationController: return nil
		case .interactionController: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension NavigationController.Preparer {
	open class Storage: ViewController.Preparer.Storage, UINavigationControllerDelegate {
		open var supportedInterfaceOrientations: UIInterfaceOrientationMask = .all
		open var preferredInterfaceOrientation: UIInterfaceOrientation = .portrait
		open var expectedStackCount: Int = 0
		public let popSignal: MultiOutput<Int>?
		weak var collapsedController: UINavigationController?
		
		open override var isInUse: Bool {
			return true
		}
		
		public init(popSignal: MultiOutput<Int>?) {
			self.popSignal = popSignal
			super.init()
		}
		
		open func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
			// Handle pop operations triggered by the back button
			if animated, navigationController.viewControllers.count < expectedStackCount, let ps = popSignal {
				ps.input.send(value: navigationController.viewControllers.count)
			}
			
			// Handle removal of collapsed split view details
			if animated, navigationController.viewControllers.count == expectedStackCount, let collapsed = collapsedController, let splitView = navigationController.splitViewController, let splitViewStorage = splitView.associatedBinderStorage(subclass: SplitViewController.Preparer.Storage.self) {
				collapsedController = nil
				splitViewStorage.collapsedController(collapsed)
			}
			
			// Track when a collapsed split view is added
			if navigationController.viewControllers.count == expectedStackCount + 1, let collapsed = navigationController.viewControllers.last as? UINavigationController {
				collapsedController = collapsed
			}
			
			if let dd = dynamicDelegate, dd.handlesSelector(#selector(UINavigationControllerDelegate.navigationController(_:didShow:animated:))), let d = dd as? UINavigationControllerDelegate {
				d.navigationController?(navigationController, didShow: viewController, animated: animated)
			}
		}
	}

	open class Delegate: DynamicDelegate, UINavigationControllerDelegate {
		open func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {
			return singleHandler(navigationController, viewController, animated)
		}
		
		open func navigationControllerSupportedInterfaceOrientations(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask {
			return singleHandler(navigationController)
		}
		
		open func navigationControllerPreferredInterfaceOrientationForPresentation(_ navigationController: UINavigationController) -> UIInterfaceOrientation {
			return singleHandler(navigationController)
		}
		
		open func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
			return singleHandler(navigationController, operation, fromVC, toVC)
		}
		
		open func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?
		{
			return singleHandler(navigationController, animationController)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: NavigationControllerBinding {
	public typealias NavigationControllerName<V> = BindingName<V, NavigationController.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> NavigationController.Binding) -> NavigationControllerName<V> {
		return NavigationControllerName<V>(source: source, downcast: Binding.navigationControllerBinding)
	}
}
public extension BindingName where Binding: NavigationControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: NavigationControllerName<$2> { return .name(NavigationController.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationBar: NavigationControllerName<Constant<NavigationBar>> { return .name(NavigationController.Binding.navigationBar) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var hidesBarsOnSwipe: NavigationControllerName<Dynamic<Bool>> { return .name(NavigationController.Binding.hidesBarsOnSwipe) }
	static var hidesBarsOnTap: NavigationControllerName<Dynamic<Bool>> { return .name(NavigationController.Binding.hidesBarsOnTap) }
	static var hidesBarsWhenKeyboardAppears: NavigationControllerName<Dynamic<Bool>> { return .name(NavigationController.Binding.hidesBarsWhenKeyboardAppears) }
	static var hidesBarsWhenVerticallyCompact: NavigationControllerName<Dynamic<Bool>> { return .name(NavigationController.Binding.hidesBarsWhenVerticallyCompact) }
	static var isNavigationBarHidden: NavigationControllerName<Dynamic<SetOrAnimate<Bool>>> { return .name(NavigationController.Binding.isNavigationBarHidden) }
	static var isToolbarHidden: NavigationControllerName<Dynamic<SetOrAnimate<Bool>>> { return .name(NavigationController.Binding.isToolbarHidden) }
	static var stack: NavigationControllerName<Dynamic<StackMutation<ViewControllerConvertible>>> { return .name(NavigationController.Binding.stack) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var poppedToCount: NavigationControllerName<SignalInput<Int>> { return .name(NavigationController.Binding.poppedToCount) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var animationController: NavigationControllerName<(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?> { return .name(NavigationController.Binding.animationController) }
	static var interactionController: NavigationControllerName<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?> { return .name(NavigationController.Binding.interactionController) }
	static var preferredInterfaceOrientation: NavigationControllerName<(_ navigationController: UINavigationController) -> UIInterfaceOrientation> { return .name(NavigationController.Binding.preferredInterfaceOrientation) }
	static var supportedInterfaceOrientations: NavigationControllerName<(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask> { return .name(NavigationController.Binding.supportedInterfaceOrientations) }
	static var didShow: NavigationControllerName<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void> { return .name(NavigationController.Binding.didShow) }
	static var willShow: NavigationControllerName<(_ navigationController: UINavigationController, _ viewController: UIViewController, _ animated: Bool) -> Void> { return .name(NavigationController.Binding.willShow) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol NavigationControllerConvertible: ViewControllerConvertible {
	func uiNavigationController() -> NavigationController.Instance
}
extension NavigationControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiNavigationController() }
}
extension UINavigationController: NavigationControllerConvertible, HasDelegate {
	public func uiNavigationController() -> NavigationController.Instance { return self }
}
public extension NavigationController {
	func uiNavigationController() -> NavigationController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol NavigationControllerBinding: ViewControllerBinding {
	static func navigationControllerBinding(_ binding: NavigationController.Binding) -> Self
	func asNavigationControllerBinding() -> NavigationController.Binding?
}
public extension NavigationControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return navigationControllerBinding(.inheritedBinding(binding))
	}
}
public extension NavigationControllerBinding where Preparer.Inherited.Binding: NavigationControllerBinding {
	func asNavigationControllerBinding() -> NavigationController.Binding? {
		return asInheritedBinding()?.asNavigationControllerBinding()
	}
}
public extension NavigationController.Binding {
	typealias Preparer = NavigationController.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asNavigationControllerBinding() -> NavigationController.Binding? { return self }
	static func navigationControllerBinding(_ binding: NavigationController.Binding) -> NavigationController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class NavigationItem: Binder, NavigationItemConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension NavigationItem {
	enum Binding: NavigationItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backBarButtonItem(Dynamic<BarButtonItemConvertible?>)
		case hidesBackButton(Dynamic<SetOrAnimate<Bool>>)
		case leftBarButtonItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case leftItemsSupplementBackButton(Dynamic<Bool>)
		case prompt(Dynamic<String?>)
		case rightBarButtonItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case title(Dynamic<String>)
		case titleView(Dynamic<ViewConvertible?>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension NavigationItem {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = NavigationItem.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = UINavigationItem
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}
		
// MARK: - Binder Part 4: Preparer overrides
public extension NavigationItem.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .backBarButtonItem(let x): return x.apply(instance) { i, v in i.backBarButtonItem = v?.uiBarButtonItem() }
		case .hidesBackButton(let x): return x.apply(instance) { i, v in i.setHidesBackButton(v.value, animated: v.isAnimated) }
		case .leftBarButtonItems(let x): return x.apply(instance) { i, v in i.setLeftBarButtonItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
		case .leftItemsSupplementBackButton(let x): return x.apply(instance) { i, v in i.leftItemsSupplementBackButton = v }
		case .prompt(let x): return x.apply(instance) { i, v in i.prompt = v }
		case .rightBarButtonItems(let x): return x.apply(instance) { i, v in i.setRightBarButtonItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .titleView(let x): return x.apply(instance) { i, v in i.titleView = v?.uiView() }

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension NavigationItem.Preparer {
	public typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: NavigationItemBinding {
	public typealias NavigationItemName<V> = BindingName<V, NavigationItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> NavigationItem.Binding) -> NavigationItemName<V> {
		return NavigationItemName<V>(source: source, downcast: Binding.navigationItemBinding)
	}
}
public extension BindingName where Binding: NavigationItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: NavigationItemName<$2> { return .name(NavigationItem.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backBarButtonItem: NavigationItemName<Dynamic<BarButtonItemConvertible?>> { return .name(NavigationItem.Binding.backBarButtonItem) }
	static var hidesBackButton: NavigationItemName<Dynamic<SetOrAnimate<Bool>>> { return .name(NavigationItem.Binding.hidesBackButton) }
	static var leftBarButtonItems: NavigationItemName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> { return .name(NavigationItem.Binding.leftBarButtonItems) }
	static var leftItemsSupplementBackButton: NavigationItemName<Dynamic<Bool>> { return .name(NavigationItem.Binding.leftItemsSupplementBackButton) }
	static var prompt: NavigationItemName<Dynamic<String?>> { return .name(NavigationItem.Binding.prompt) }
	static var rightBarButtonItems: NavigationItemName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> { return .name(NavigationItem.Binding.rightBarButtonItems) }
	static var title: NavigationItemName<Dynamic<String>> { return .name(NavigationItem.Binding.title) }
	static var titleView: NavigationItemName<Dynamic<ViewConvertible?>> { return .name(NavigationItem.Binding.titleView) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	
	// Composite binding names
	static func leftBarButtonItems(animate: AnimationChoice = .subsequent) -> NavigationItemName<Dynamic<[BarButtonItemConvertible]>> {
		return Binding.compositeName(
			value: { latestArray in 
				switch latestArray {
				case .constant(let b) where animate == .always: return .constant(.animate(b))
				case .constant(let b): return .constant(.set(b))
				case .dynamic(let b): return .dynamic(b.animate(animate))
				}
			},
			binding: NavigationItem.Binding.leftBarButtonItems,
			downcast: Binding.navigationItemBinding
		)
	}
	static func rightBarButtonItems(animate: AnimationChoice = .subsequent) -> NavigationItemName<Dynamic<[BarButtonItemConvertible]>> {
		return Binding.compositeName(
			value: { latestArray in 
				switch latestArray {
				case .constant(let b) where animate == .always: return .constant(.animate(b))
				case .constant(let b): return .constant(.set(b))
				case .dynamic(let b): return .dynamic(b.animate(animate))
				}
			},
			binding: NavigationItem.Binding.rightBarButtonItems,
			downcast: Binding.navigationItemBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol NavigationItemConvertible {
	func uiNavigationItem() -> NavigationItem.Instance
}
extension UINavigationItem: NavigationItemConvertible, DefaultConstructable {
	public func uiNavigationItem() -> NavigationItem.Instance { return self }
}
public extension NavigationItem {
	func uiNavigationItem() -> NavigationItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol NavigationItemBinding: BinderBaseBinding {
	static func navigationItemBinding(_ binding: NavigationItem.Binding) -> Self
	func asNavigationItemBinding() -> NavigationItem.Binding?
}
public extension NavigationItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return navigationItemBinding(.inheritedBinding(binding))
	}
}
public extension NavigationItemBinding where Preparer.Inherited.Binding: NavigationItemBinding {
	func asNavigationItemBinding() -> NavigationItem.Binding? {
		return asInheritedBinding()?.asNavigationItemBinding()
	}
}
public extension NavigationItem.Binding {
	typealias Preparer = NavigationItem.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asNavigationItemBinding() -> NavigationItem.Binding? { return self }
	static func navigationItemBinding(_ binding: NavigationItem.Binding) -> NavigationItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class PageControl: Binder, PageControlConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension PageControl {
	enum Binding: PageControlBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case currentPage(Dynamic<Int>)
		case currentPageIndicatorTintColor(Dynamic<UIColor?>)
		case defersCurrentPageDisplay(Dynamic<Bool>)
		case numberOfPages(Dynamic<Int>)
		case pageIndicatorTintColor(Dynamic<UIColor?>)

		// 2. Signal bindings are performed on the object after construction.
		case updateCurrentPageDisplay(Signal<Void>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension PageControl {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = PageControl.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = UIPageControl
		public typealias Parameters = () /* change if non-default construction required */
		
		public var inherited = Inherited()
		public init() {}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension PageControl.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		case .currentPage(let x): return x.apply(instance) { i, v in i.currentPage = v }
		case .currentPageIndicatorTintColor(let x): return x.apply(instance) { i, v in i.currentPageIndicatorTintColor = v }
		case .defersCurrentPageDisplay(let x): return x.apply(instance) { i, v in i.defersCurrentPageDisplay = v }
		case .numberOfPages(let x): return x.apply(instance) { i, v in i.numberOfPages = v }
		case .pageIndicatorTintColor(let x): return x.apply(instance) { i, v in i.pageIndicatorTintColor = v }
		case .updateCurrentPageDisplay(let x): return x.apply(instance) { i, _ in i.updateCurrentPageDisplay() }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PageControl.Preparer {
	public typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PageControlBinding {
	public typealias PageControlName<V> = BindingName<V, PageControl.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PageControl.Binding) -> PageControlName<V> {
		return PageControlName<V>(source: source, downcast: Binding.pageControlBinding)
	}
}
public extension BindingName where Binding: PageControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PageControlName<$2> { return .name(PageControl.Binding.$1) }

	// 0. Static bindings are applied at construction and are subsequently immutable.

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var currentPage: PageControlName<Dynamic<Int>> { return .name(PageControl.Binding.currentPage) }
	static var currentPageIndicatorTintColor: PageControlName<Dynamic<UIColor?>> { return .name(PageControl.Binding.currentPageIndicatorTintColor) }
	static var defersCurrentPageDisplay: PageControlName<Dynamic<Bool>> { return .name(PageControl.Binding.defersCurrentPageDisplay) }
	static var numberOfPages: PageControlName<Dynamic<Int>> { return .name(PageControl.Binding.numberOfPages) }
	static var pageIndicatorTintColor: PageControlName<Dynamic<UIColor?>> { return .name(PageControl.Binding.pageIndicatorTintColor) }

	// 2. Signal bindings are performed on the object after construction.
	static var updateCurrentPageDisplay: PageControlName<Signal<Void>> { return .name(PageControl.Binding.updateCurrentPageDisplay) }

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol PageControlConvertible: ControlConvertible {
	func uiPageControl() -> PageControl.Instance
}
extension PageControlConvertible {
	public func uiControl() -> Control.Instance { return uiPageControl() }
}
extension UIPageControl: PageControlConvertible {
	public func uiPageControl() -> PageControl.Instance { return self }
}
public extension PageControl {
	func uiPageControl() -> PageControl.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol PageControlBinding: ControlBinding {
	static func pageControlBinding(_ binding: PageControl.Binding) -> Self
	func asPageControlBinding() -> PageControl.Binding?
}
public extension PageControlBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return pageControlBinding(.inheritedBinding(binding))
	}
}
public extension PageControlBinding where Preparer.Inherited.Binding: PageControlBinding {
	func asPageControlBinding() -> PageControl.Binding? {
		return asInheritedBinding()?.asPageControlBinding()
	}
}
public extension PageControl.Binding {
	typealias Preparer = PageControl.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPageControlBinding() -> PageControl.Binding? { return self }
	static func pageControlBinding(_ binding: PageControl.Binding) -> PageControl.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class PageViewController<PageData>: Binder, PageViewControllerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension PageViewController {
	enum Binding: PageViewControllerBinding {
		public typealias PageDataType = PageData
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.
		case navigationOrientation(Constant<UIPageViewController.NavigationOrientation>)
		case pageSpacing(Constant<CGFloat>)
		case spineLocation(Constant<UIPageViewController.SpineLocation>)
		case transitionStyle(Constant<UIPageViewController.TransitionStyle>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case isDoubleSided(Dynamic<Bool>)
		case pageData(Dynamic<Animatable<[PageData], UIPageViewController.NavigationDirection>>)

		// 2. Signal bindings are performed on the object after construction.
		case changeCurrentPage(Signal<Animatable<Int, UIPageViewController.NavigationDirection>>)

		// 3. Action bindings are triggered by the object after construction.
		case pageChanged(SignalInput<(index: Int, data: PageData)>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case constructPage((PageData) -> ViewControllerConvertible)
		case didFinishAnimating((UIPageViewController, Bool, [UIViewController], Bool) -> Void)
		case interfaceOrientationForPresentation((UIPageViewController) -> UIInterfaceOrientation)
		case spineLocationFor((UIPageViewController, UIInterfaceOrientation) -> UIPageViewController.SpineLocation)
		case supportedInterfaceOrientations((UIPageViewController) -> UIInterfaceOrientationMask)
		case willTransitionTo((UIPageViewController, [UIViewController]) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension PageViewController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = PageViewController.Binding
		public typealias Inherited = ViewController.Preparer
		public typealias Instance = UIPageViewController
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage(pageChanged: pageChanged) }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var transitionStyle = UIPageViewController.TransitionStyle.scroll
		var navigationOrientation = UIPageViewController.NavigationOrientation.horizontal
		var spineLocation = UIPageViewController.SpineLocation.min
		var pageSpacing = CGFloat(0)
		var pageConstructor: ((PageData) -> ViewControllerConvertible)?
		var pageChanged: MultiOutput<(index: Int, data: PageData)>?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension PageViewController.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		return type.init(transitionStyle: transitionStyle, navigationOrientation: navigationOrientation, options: [UIPageViewController.OptionsKey.spineLocation: spineLocation.rawValue, UIPageViewController.OptionsKey.interPageSpacing: pageSpacing])
	}
	
	mutating func prepareBinding(_ binding: PageViewController<PageData>.Binding) {
		switch binding {
		case .inheritedBinding(let x): return inherited.prepareBinding(x)
		
		case .constructPage(let x): pageConstructor = x
		case .transitionStyle(let x): transitionStyle = x.value
		case .navigationOrientation(let x): navigationOrientation = x.value
		case .spineLocation(let x): spineLocation = x.value
		case .pageSpacing(let x): pageSpacing = x.value
		case .pageChanged(let x):
			pageChanged = pageChanged ?? Input().multicast()
			pageChanged?.signal.bind(to: x)
		case .willTransitionTo(let x): delegate().addMultiHandler2(x, #selector(UIPageViewControllerDelegate.pageViewController(_:willTransitionTo:)))
		case .didFinishAnimating(let x): delegate().addMultiHandler4(x, #selector(UIPageViewControllerDelegate.pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:)))
		case .spineLocationFor(let x): delegate().addSingleHandler2(x, #selector(UIPageViewControllerDelegate.pageViewController(_:spineLocationFor:)))
		case .supportedInterfaceOrientations(let x): delegate().addSingleHandler1(x, #selector(UIPageViewControllerDelegate.pageViewControllerSupportedInterfaceOrientations(_:)))
		case .interfaceOrientationForPresentation(let x): delegate().addSingleHandler1(x, #selector(UIPageViewControllerDelegate.pageViewControllerPreferredInterfaceOrientationForPresentation(_:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		storage.pageConstructor = pageConstructor
		prepareDelegate(instance: instance, storage: storage)
		instance.dataSource = storage
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.
		case .navigationOrientation: return nil
		case .pageSpacing: return nil
		case .spineLocation: return nil
		case .transitionStyle: return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .isDoubleSided(let x): return x.apply(instance) { i, v in i.isDoubleSided = v }
		case .pageData(let x):
			return x.apply(instance, storage) { i, s, v in
				s.changePageData(v.value, in: i, animation: v.animation)
			}

		// 2. Signal bindings are performed on the object after construction.
		case .changeCurrentPage(let x):
			return x.apply(instance, storage) { i, s, v in
				s.changeCurrentPage(v.value, in: i, animation: v.animation)
			}

		// 3. Action bindings are triggered by the object after construction.
		case .pageChanged: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .constructPage: return nil
		case .didFinishAnimating: return nil
		case .interfaceOrientationForPresentation: return nil
		case .spineLocationFor: return nil
		case .supportedInterfaceOrientations: return nil
		case .willTransitionTo: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PageViewController.Preparer {
	open class Storage: ViewController.Preparer.Storage, UIPageViewControllerDelegate, UIPageViewControllerDataSource {
		open var activeViewControllers: [(Int, Weak<UIViewController>)] = []
		open var pageConstructor: ((PageData) -> ViewControllerConvertible)?
		open var pageData: [PageData] = []
		public let pageChanged: MultiOutput<(index: Int, data: PageData)>?
		
		public init(pageChanged: MultiOutput<(index: Int, data: PageData)>?) {
			self.pageChanged = pageChanged
		}
		
		public func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
			if let i = index(of: viewController) {
				return self.viewController(at: i - 1)
			}
			return nil
		}
		
		public func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
			if let i = index(of: viewController) {
				return self.viewController(at: i + 1)
			}
			return nil
		}

		open func changeCurrentPage(_ index: Int, in pvc: UIPageViewController, animation: UIPageViewController.NavigationDirection?) {
			if let vc = viewController(at: index), !(vc === pvc.viewControllers?.first) {
				pvc.setViewControllers([vc], direction: animation ?? .forward, animated: animation != nil, completion: nil)
			}
		}
		
		open func changePageData(_ newPageData: [PageData], in pvc: UIPageViewController, animation: UIPageViewController.NavigationDirection?) {
			let indexes = pvc.viewControllers?.compactMap { self.index(of: $0) }.sorted() ?? (newPageData.isEmpty ? [] : [0])
			pageData = newPageData
			activeViewControllers.removeAll()
			var newViewControllers = indexes.compactMap { self.viewController(at: $0) }
			if !newPageData.isEmpty && newViewControllers.isEmpty, let vc = viewController(at: 0) {
				newViewControllers.append(vc)
			}
			pvc.setViewControllers(newViewControllers, direction: animation ?? .forward, animated: animation != nil, completion: nil)
		}
		
		open func viewController(at: Int) -> UIViewController? {
			guard let constructor = pageConstructor, pageData.indices.contains(at) else { return nil }
			var i = 0
			var match: UIViewController? = nil
			while i < activeViewControllers.count {
				let tuple = activeViewControllers[i]
				if let vc = tuple.1.value {
					if tuple.0 == at {
						match = vc
					}
					i += 1
				} else {
					activeViewControllers.remove(at: i)
				}
			}
			if let m = match {
				return m
			}
			let vc = constructor(pageData[at]).uiViewController()
			activeViewControllers.append((at, Weak(vc)))
			return vc
		}
		
		open func index(of: UIViewController) -> Int? {
			var i = 0
			var match: Int? = nil
			while i < activeViewControllers.count {
				let tuple = activeViewControllers[i]
				if let vc = tuple.1.value {
					if vc === of {
						match = tuple.0
					}
					i += 1
				} else {
					activeViewControllers.remove(at: i)
				}
			}
			return match
		}
		
		open func presentationCount(for pageViewController: UIPageViewController) -> Int {
			return pageData.count
		}
		
		open func presentationIndex(for pageViewController: UIPageViewController) -> Int {
			guard let vc = pageViewController.viewControllers?.first else { return 0 }
			return index(of: vc) ?? 0
		}

		open func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
			if completed, let input = pageChanged?.input, let vc = pageViewController.children.first, let index = index(of: vc), let data = pageData.at(index) {
				input.send(value: (index, data))
			}
			
			if let dd = dynamicDelegate, dd.handlesSelector(#selector(UIPageViewControllerDelegate.pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:))) {
				(dd as? UIPageViewControllerDelegate)?.pageViewController?(pageViewController, didFinishAnimating: finished, previousViewControllers: previousViewControllers, transitionCompleted: completed)
			}
		}
	}

	open class Delegate: DynamicDelegate, UIPageViewControllerDelegate {
		open func pageViewController(_ pageViewController: UIPageViewController, willTransitionTo pendingViewControllers: [UIViewController]) {
			multiHandler(pageViewController, pendingViewControllers)
		}
		
		open func pageViewController(_ pageViewController: UIPageViewController, spineLocationFor orientation: UIInterfaceOrientation) -> UIPageViewController.SpineLocation {
			return singleHandler(pageViewController, orientation)
		}
		
		open func pageViewControllerSupportedInterfaceOrientations(_ pageViewController: UIPageViewController) -> UIInterfaceOrientationMask {
			return singleHandler(pageViewController)
		}
		
		open func pageViewControllerPreferredInterfaceOrientationForPresentation(_ pageViewController: UIPageViewController) -> UIInterfaceOrientation {
			return singleHandler(pageViewController)
		}
		
		open func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
			multiHandler(pageViewController, finished, previousViewControllers, completed)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PageViewControllerBinding {
	public typealias PageViewControllerName<V> = BindingName<V, PageViewController<Binding.PageDataType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PageViewController<Binding.PageDataType>.Binding) -> PageViewControllerName<V> {
		return PageViewControllerName<V>(source: source, downcast: Binding.pageViewControllerBinding)
	}
}
public extension BindingName where Binding: PageViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PageViewControllerName<$2> { return .name(PageViewController.Binding.$1) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationOrientation: PageViewControllerName<Constant<UIPageViewController.NavigationOrientation>> { return .name(PageViewController.Binding.navigationOrientation) }
	static var pageSpacing: PageViewControllerName<Constant<CGFloat>> { return .name(PageViewController.Binding.pageSpacing) }
	static var spineLocation: PageViewControllerName<Constant<UIPageViewController.SpineLocation>> { return .name(PageViewController.Binding.spineLocation) }
	static var transitionStyle: PageViewControllerName<Constant<UIPageViewController.TransitionStyle>> { return .name(PageViewController.Binding.transitionStyle) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isDoubleSided: PageViewControllerName<Dynamic<Bool>> { return .name(PageViewController.Binding.isDoubleSided) }
	static var pageData: PageViewControllerName<Dynamic<Animatable<[Binding.PageDataType], UIPageViewController.NavigationDirection>>> { return .name(PageViewController.Binding.pageData) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var changeCurrentPage: PageViewControllerName<Signal<Animatable<Int, UIPageViewController.NavigationDirection>>> { return .name(PageViewController.Binding.changeCurrentPage) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var pageChanged: PageViewControllerName<SignalInput<(index: Int, data: Binding.PageDataType)>> { return .name(PageViewController.Binding.pageChanged) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var constructPage: PageViewControllerName<(Binding.PageDataType) -> ViewControllerConvertible> { return .name(PageViewController.Binding.constructPage) }
	static var didFinishAnimating: PageViewControllerName<(UIPageViewController, Bool, [UIViewController], Bool) -> Void> { return .name(PageViewController.Binding.didFinishAnimating) }
	static var interfaceOrientationForPresentation: PageViewControllerName<(UIPageViewController) -> UIInterfaceOrientation> { return .name(PageViewController.Binding.interfaceOrientationForPresentation) }
	static var spineLocationFor: PageViewControllerName<(UIPageViewController, UIInterfaceOrientation) -> UIPageViewController.SpineLocation> { return .name(PageViewController.Binding.spineLocationFor) }
	static var supportedInterfaceOrientations: PageViewControllerName<(UIPageViewController) -> UIInterfaceOrientationMask> { return .name(PageViewController.Binding.supportedInterfaceOrientations) }
	static var willTransitionTo: PageViewControllerName<(UIPageViewController, [UIViewController]) -> Void> { return .name(PageViewController.Binding.willTransitionTo) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol PageViewControllerConvertible: ViewControllerConvertible {
	func uiPageViewController() -> UIPageViewController
}
extension PageViewControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiPageViewController() }
}
extension UIPageViewController: PageViewControllerConvertible, HasDelegate {
	public func uiPageViewController() -> UIPageViewController { return self }
}
public extension PageViewController {
	func uiPageViewController() -> UIPageViewController { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol PageViewControllerBinding: ViewControllerBinding {
	associatedtype PageDataType
	static func pageViewControllerBinding(_ binding: PageViewController<PageDataType>.Binding) -> Self
	func asPageViewControllerBinding() -> PageViewController<PageDataType>.Binding?
}
public extension PageViewControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return pageViewControllerBinding(PageViewController<PageDataType>.Binding.inheritedBinding(binding))
	}
}
public extension PageViewControllerBinding where Preparer.Inherited.Binding: PageViewControllerBinding, Preparer.Inherited.Binding.PageDataType == PageDataType {
	func asPageViewControllerBinding() -> PageViewController<PageDataType>.Binding? {
		return asInheritedBinding()?.asPageViewControllerBinding()
	}
}
public extension PageViewController.Binding {
	typealias Preparer = PageViewController.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPageViewControllerBinding() -> PageViewController.Binding? { return self }
	static func pageViewControllerBinding(_ binding: PageViewController<PageDataType>.Binding) -> PageViewController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class PanGestureRecognizer: Binder, PanGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension PanGestureRecognizer {
	enum Binding: PanGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case maximumNumberOfTouches(Dynamic<Int>)
		case minimumNumberOfTouches(Dynamic<Int>)
		case translation(Dynamic<CGPoint>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension PanGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = PanGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = UIPanGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension PanGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .maximumNumberOfTouches(let x): return x.apply(instance) { i, v in i.maximumNumberOfTouches = v }
		case .minimumNumberOfTouches(let x): return x.apply(instance) { i, v in i.minimumNumberOfTouches = v }
		case .translation(let x): return x.apply(instance) { i, v in i.setTranslation(v, in: nil) }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PanGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PanGestureRecognizerBinding {
	public typealias PanGestureRecognizerName<V> = BindingName<V, PanGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PanGestureRecognizer.Binding) -> PanGestureRecognizerName<V> {
		return PanGestureRecognizerName<V>(source: source, downcast: Binding.panGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: PanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PanGestureRecognizerName<$2> { return .name(PanGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var maximumNumberOfTouches: PanGestureRecognizerName<Dynamic<Int>> { return .name(PanGestureRecognizer.Binding.maximumNumberOfTouches) }
	static var minimumNumberOfTouches: PanGestureRecognizerName<Dynamic<Int>> { return .name(PanGestureRecognizer.Binding.minimumNumberOfTouches) }
	static var translation: PanGestureRecognizerName<Dynamic<CGPoint>> { return .name(PanGestureRecognizer.Binding.translation) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol PanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance
}
extension PanGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiPanGestureRecognizer() }
}
extension UIPanGestureRecognizer: PanGestureRecognizerConvertible {
	public func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance { return self }
}
public extension PanGestureRecognizer {
	func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol PanGestureRecognizerBinding: GestureRecognizerBinding {
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -> Self
	func asPanGestureRecognizerBinding() -> PanGestureRecognizer.Binding?
}
public extension PanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return panGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension PanGestureRecognizerBinding where Preparer.Inherited.Binding: PanGestureRecognizerBinding {
	func asPanGestureRecognizerBinding() -> PanGestureRecognizer.Binding? {
		return asInheritedBinding()?.asPanGestureRecognizerBinding()
	}
}
public extension PanGestureRecognizer.Binding {
	typealias Preparer = PanGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPanGestureRecognizerBinding() -> PanGestureRecognizer.Binding? { return self }
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -> PanGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class PinchGestureRecognizer: Binder, PinchGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension PinchGestureRecognizer {
	enum Binding: PinchGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case scale(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension PinchGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = PinchGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = UIPinchGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension PinchGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .scale(let x): return x.apply(instance) { i, v in i.scale = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PinchGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PinchGestureRecognizerBinding {
	public typealias PinchGestureRecognizerName<V> = BindingName<V, PinchGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PinchGestureRecognizer.Binding) -> PinchGestureRecognizerName<V> {
		return PinchGestureRecognizerName<V>(source: source, downcast: Binding.pinchGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: PinchGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PinchGestureRecognizerName<$2> { return .name(PinchGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var scale: PinchGestureRecognizerName<Dynamic<CGFloat>> { return .name(PinchGestureRecognizer.Binding.scale) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol PinchGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance
}
extension PinchGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiPinchGestureRecognizer() }
}
extension UIPinchGestureRecognizer: PinchGestureRecognizerConvertible {
	public func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance { return self }
}
public extension PinchGestureRecognizer {
	func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol PinchGestureRecognizerBinding: GestureRecognizerBinding {
	static func pinchGestureRecognizerBinding(_ binding: PinchGestureRecognizer.Binding) -> Self
	func asPinchGestureRecognizerBinding() -> PinchGestureRecognizer.Binding?
}
public extension PinchGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return pinchGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension PinchGestureRecognizerBinding where Preparer.Inherited.Binding: PinchGestureRecognizerBinding {
	func asPinchGestureRecognizerBinding() -> PinchGestureRecognizer.Binding? {
		return asInheritedBinding()?.asPinchGestureRecognizerBinding()
	}
}
public extension PinchGestureRecognizer.Binding {
	typealias Preparer = PinchGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPinchGestureRecognizerBinding() -> PinchGestureRecognizer.Binding? { return self }
	static func pinchGestureRecognizerBinding(_ binding: PinchGestureRecognizer.Binding) -> PinchGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class RotationGestureRecognizer: Binder, RotationGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension RotationGestureRecognizer {
	enum Binding: RotationGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rotation(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension RotationGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = RotationGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = UIRotationGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension RotationGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .rotation(let x): return x.apply(instance) { i, v in i.rotation = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension RotationGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: RotationGestureRecognizerBinding {
	public typealias RotationGestureRecognizerName<V> = BindingName<V, RotationGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> RotationGestureRecognizer.Binding) -> RotationGestureRecognizerName<V> {
		return RotationGestureRecognizerName<V>(source: source, downcast: Binding.rotationGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: RotationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: RotationGestureRecognizerName<$2> { return .name(RotationGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var rotation: RotationGestureRecognizerName<Dynamic<CGFloat>> { return .name(RotationGestureRecognizer.Binding.rotation) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol RotationGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance
}
extension RotationGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiRotationGestureRecognizer() }
}
extension UIRotationGestureRecognizer: RotationGestureRecognizerConvertible {
	public func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance { return self }
}
public extension RotationGestureRecognizer {
	func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol RotationGestureRecognizerBinding: GestureRecognizerBinding {
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -> Self
	func asRotationGestureRecognizerBinding() -> RotationGestureRecognizer.Binding?
}
public extension RotationGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return rotationGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension RotationGestureRecognizerBinding where Preparer.Inherited.Binding: RotationGestureRecognizerBinding {
	func asRotationGestureRecognizerBinding() -> RotationGestureRecognizer.Binding? {
		return asInheritedBinding()?.asRotationGestureRecognizerBinding()
	}
}
public extension RotationGestureRecognizer.Binding {
	typealias Preparer = RotationGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asRotationGestureRecognizerBinding() -> RotationGestureRecognizer.Binding? { return self }
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -> RotationGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class ScreenEdgePanGestureRecognizer: Binder, ScreenEdgePanGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ScreenEdgePanGestureRecognizer {
	enum Binding: ScreenEdgePanGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case edges(Dynamic<UIRectEdge>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension ScreenEdgePanGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = ScreenEdgePanGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = UIScreenEdgePanGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ScreenEdgePanGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .edges(let x): return x.apply(instance) { i, v in i.edges = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ScreenEdgePanGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ScreenEdgePanGestureRecognizerBinding {
	public typealias ScreenEdgePanGestureRecognizerName<V> = BindingName<V, ScreenEdgePanGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ScreenEdgePanGestureRecognizer.Binding) -> ScreenEdgePanGestureRecognizerName<V> {
		return ScreenEdgePanGestureRecognizerName<V>(source: source, downcast: Binding.screenEdgePanGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: ScreenEdgePanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ScreenEdgePanGestureRecognizerName<$2> { return .name(ScreenEdgePanGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var edges: ScreenEdgePanGestureRecognizerName<Dynamic<UIRectEdge>> { return .name(ScreenEdgePanGestureRecognizer.Binding.edges) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ScreenEdgePanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance
}
extension ScreenEdgePanGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiScreenEdgePanGestureRecognizer() }
}
extension UIScreenEdgePanGestureRecognizer: ScreenEdgePanGestureRecognizerConvertible {
	public func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance { return self }
}
public extension ScreenEdgePanGestureRecognizer {
	func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ScreenEdgePanGestureRecognizerBinding: GestureRecognizerBinding {
	static func screenEdgePanGestureRecognizerBinding(_ binding: ScreenEdgePanGestureRecognizer.Binding) -> Self
	func asScreenEdgePanGestureRecognizerBinding() -> ScreenEdgePanGestureRecognizer.Binding?
}
public extension ScreenEdgePanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return screenEdgePanGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension ScreenEdgePanGestureRecognizerBinding where Preparer.Inherited.Binding: ScreenEdgePanGestureRecognizerBinding {
	func asScreenEdgePanGestureRecognizerBinding() -> ScreenEdgePanGestureRecognizer.Binding? {
		return asInheritedBinding()?.asScreenEdgePanGestureRecognizerBinding()
	}
}
public extension ScreenEdgePanGestureRecognizer.Binding {
	typealias Preparer = ScreenEdgePanGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asScreenEdgePanGestureRecognizerBinding() -> ScreenEdgePanGestureRecognizer.Binding? { return self }
	static func screenEdgePanGestureRecognizerBinding(_ binding: ScreenEdgePanGestureRecognizer.Binding) -> ScreenEdgePanGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class ScrollView: Binder, ScrollViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ScrollView {
	enum Binding: ScrollViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case panGestureRecognizerStyles(Constant<PanGestureRecognizer>)
		case pinchGestureRecognizerStyles(Constant<PinchGestureRecognizer>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case alwaysBounceHorizontal(Dynamic<Bool>)
		case alwaysBounceVertical(Dynamic<Bool>)
		case bounces(Dynamic<Bool>)
		case bouncesZoom(Dynamic<Bool>)
		case canCancelContentTouches(Dynamic<Bool>)
		case contentInset(Dynamic<UIEdgeInsets>)
		case contentInsetAdjustmentBehavior(Dynamic<UIScrollView.ContentInsetAdjustmentBehavior>)
		case contentOffset(Dynamic<SetOrAnimate<CGPoint>>)
		case contentSize(Dynamic<CGSize>)
		case decelerationRate(Dynamic<UIScrollView.DecelerationRate>)
		case delaysContentTouches(Dynamic<Bool>)
		case indicatorStyle(Dynamic<UIScrollView.IndicatorStyle>)
		case isDirectionalLockEnabled(Dynamic<Bool>)
		case isPagingEnabled(Dynamic<Bool>)
		case isScrollEnabled(Dynamic<Bool>)
		case maximumZoomScale(Dynamic<CGFloat>)
		case minimumZoomScale(Dynamic<CGFloat>)
		case refreshControl(Dynamic<UIRefreshControl?>)
		case scrollIndicatorInsets(Dynamic<UIEdgeInsets>)
		case scrollsToTop(Dynamic<Bool>)
		case showsHorizontalScrollIndicator(Dynamic<Bool>)
		case showsVerticalScrollIndicator(Dynamic<Bool>)
		case zoomScale(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		case flashScrollIndicators(Signal<Void>)
		case scrollRectToVisible(Signal<(rect: CGRect, animated: Bool)>)
		case zoom(Signal<(rect: CGRect, animated: Bool)>)
		
		// 3. Action bindings are triggered by the object after construction.
		case userDidScroll(SignalInput<CGPoint>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didEndDecelerating((UIScrollView) -> Void)
		case didEndDragging((UIScrollView, Bool) -> Void)
		case didEndScrollingAnimation((UIScrollView) -> Void)
		case didEndZooming((UIScrollView, UIView?, CGFloat) -> Void)
		case didScroll((UIScrollView, CGPoint) -> Void)
		case didScrollToTop((UIScrollView) -> Void)
		case didZoom((UIScrollView) -> Void)
		case shouldScrollToTop((_ scrollView: UIScrollView) -> Bool)
		case viewForZooming((_ scrollView: UIScrollView) -> UIView?)
		case willBeginDecelerating((UIScrollView) -> Void)
		case willBeginDragging((UIScrollView) -> Void)
		case willBeginZooming((UIScrollView, UIView?) -> Void)
		case willEndDragging((_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension ScrollView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = ScrollView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UIScrollView
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ScrollView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
			
		case .didEndDecelerating(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:)))
		case .didEndDragging(let x): delegate().addMultiHandler2(x, #selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:)))
		case .didEndScrollingAnimation(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewDidEndScrollingAnimation(_:)))
		case .didEndZooming(let x): delegate().addMultiHandler3(x, #selector(UIScrollViewDelegate.scrollViewDidEndZooming(_:with:atScale:)))
		case .didScroll(let x): delegate().addMultiHandler2(x, #selector(UIScrollViewDelegate.scrollViewDidScroll(_:)))
		case .didScrollToTop(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:)))
		case .didZoom(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewDidZoom(_:)))
		case .shouldScrollToTop(let x): delegate().addSingleHandler1(x, #selector(UIScrollViewDelegate.scrollViewShouldScrollToTop(_:)))
		case .userDidScroll(let x):
			delegate().addMultiHandler1(
				{ (sv: UIScrollView) -> Void in x.send(value: sv.contentOffset) },
				#selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
			)
			delegate().addMultiHandler2(
				{ (sv: UIScrollView, d: Bool) -> Void in if !d { x.send(value: sv.contentOffset) } },
				#selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
			)
			delegate().addMultiHandler1(
				{ (sv: UIScrollView) -> Void in x.send(value: sv.contentOffset) },
				#selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
			)
		case .viewForZooming(let x): delegate().addSingleHandler1(x, #selector(UIScrollViewDelegate.viewForZooming(in:)))
		case .willBeginDecelerating(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewWillBeginDecelerating(_:)))
		case .willBeginDragging(let x): delegate().addMultiHandler1(x, #selector(UIScrollViewDelegate.scrollViewWillBeginDragging(_:)))
		case .willBeginZooming(let x): delegate().addMultiHandler2(x, #selector(UIScrollViewDelegate.scrollViewWillBeginZooming(_:with:)))
		case .willEndDragging(let x): delegate().addMultiHandler3(x, #selector(UIScrollViewDelegate.scrollViewWillEndDragging(_:withVelocity:targetContentOffset:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .panGestureRecognizerStyles(let x):
			x.value.apply(to: instance.panGestureRecognizer)
			return nil
		case .pinchGestureRecognizerStyles(let x):
			if let pgr = instance.pinchGestureRecognizer {
				x.value.apply(to: pgr)
			}
			return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .alwaysBounceHorizontal(let x): return x.apply(instance) { i, v in i.alwaysBounceHorizontal = v }
		case .alwaysBounceVertical(let x): return x.apply(instance) { i, v in i.alwaysBounceVertical = v }
		case .bounces(let x): return x.apply(instance) { i, v in i.bounces = v }
		case .bouncesZoom(let x): return x.apply(instance) { i, v in i.bouncesZoom = v }
		case .canCancelContentTouches(let x): return x.apply(instance) { i, v in i.canCancelContentTouches = v }
		case .contentInset(let x): return x.apply(instance) { i, v in i.contentInset = v }
		case .contentInsetAdjustmentBehavior(let x): return x.apply(instance) { i, v in i.contentInsetAdjustmentBehavior = v }
		case .contentOffset(let x): return x.apply(instance) { i, v in i.setContentOffset(v.value, animated: v.isAnimated) }
		case .contentSize(let x): return x.apply(instance) { i, v in i.contentSize = v }
		case .decelerationRate(let x): return x.apply(instance) { i, v in i.decelerationRate = v }
		case .delaysContentTouches(let x): return x.apply(instance) { i, v in i.delaysContentTouches = v }
		case .indicatorStyle(let x): return x.apply(instance) { i, v in i.indicatorStyle = v }
		case .isDirectionalLockEnabled(let x): return x.apply(instance) { i, v in i.isDirectionalLockEnabled = v }
		case .isPagingEnabled(let x): return x.apply(instance) { i, v in i.isPagingEnabled = v }
		case .isScrollEnabled(let x): return x.apply(instance) { i, v in i.isScrollEnabled = v }
		case .maximumZoomScale(let x): return x.apply(instance) { i, v in i.maximumZoomScale = v }
		case .minimumZoomScale(let x): return x.apply(instance) { i, v in i.minimumZoomScale = v }
		case .refreshControl(let x): return x.apply(instance) { i, v in i.refreshControl = v }
		case .scrollIndicatorInsets(let x): return x.apply(instance) { i, v in i.scrollIndicatorInsets = v }
		case .scrollsToTop(let x): return x.apply(instance) { i, v in i.scrollsToTop = v }
		case .showsHorizontalScrollIndicator(let x): return x.apply(instance) { i, v in i.showsHorizontalScrollIndicator = v }
		case .showsVerticalScrollIndicator(let x): return x.apply(instance) { i, v in i.showsVerticalScrollIndicator = v }
		case .zoomScale(let x): return x.apply(instance) { i, v in i.zoomScale = v }
		
		// 2. Signal bindings are performed on the object after construction.
		case .flashScrollIndicators(let x): return x.apply(instance) { i, v in i.flashScrollIndicators() }
		case .scrollRectToVisible(let x): return x.apply(instance) { i, v in i.scrollRectToVisible(v.rect, animated: v.animated) }
		case .zoom(let x): return x.apply(instance) { i, v in i.zoom(to: v.rect, animated: v.animated) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didEndDecelerating: return nil
		case .didEndDragging: return nil
		case .didEndScrollingAnimation: return nil
		case .didEndZooming: return nil
		case .didScroll: return nil
		case .didScrollToTop: return nil
		case .didZoom: return nil
		case .userDidScroll: return nil
		case .willBeginDecelerating: return nil
		case .willBeginDragging: return nil
		case .willBeginZooming: return nil
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldScrollToTop: return nil
		case .viewForZooming: return nil
		case .willEndDragging: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ScrollView.Preparer {
	open class Storage: View.Preparer.Storage, UIScrollViewDelegate {}
	
	open class Delegate: DynamicDelegate, UIScrollViewDelegate {
		open func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
			multiHandler(scrollView, decelerate)
		}
		
		open func scrollViewDidScrollToTop(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		open func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		open func scrollViewDidScroll(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		open func scrollViewDidZoom(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		open func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		open func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		open func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?) {
			multiHandler(scrollView, view)
		}
		
		open func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat) {
			multiHandler(scrollView, view, scale)
		}
		
		open func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
			multiHandler(scrollView)
		}
		
		open func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
			multiHandler(scrollView, velocity, targetContentOffset)
		}
		
		open func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool {
			return singleHandler(scrollView)
		}
		
		open func viewForZooming(in scrollView: UIScrollView) -> UIView? {
			return singleHandler(scrollView)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ScrollViewBinding {
	public typealias ScrollViewName<V> = BindingName<V, ScrollView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ScrollView.Binding) -> ScrollViewName<V> {
		return ScrollViewName<V>(source: source, downcast: Binding.scrollViewBinding)
	}
}
public extension BindingName where Binding: ScrollViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ScrollViewName<$2> { return .name(ScrollView.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var panGestureRecognizerStyles: ScrollViewName<Constant<PanGestureRecognizer>> { return .name(ScrollView.Binding.panGestureRecognizerStyles) }
	static var pinchGestureRecognizerStyles: ScrollViewName<Constant<PinchGestureRecognizer>> { return .name(ScrollView.Binding.pinchGestureRecognizerStyles) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alwaysBounceHorizontal: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.alwaysBounceHorizontal) }
	static var alwaysBounceVertical: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.alwaysBounceVertical) }
	static var bounces: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.bounces) }
	static var bouncesZoom: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.bouncesZoom) }
	static var canCancelContentTouches: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.canCancelContentTouches) }
	static var contentInset: ScrollViewName<Dynamic<UIEdgeInsets>> { return .name(ScrollView.Binding.contentInset) }
	static var contentInsetAdjustmentBehavior: ScrollViewName<Dynamic<UIScrollView.ContentInsetAdjustmentBehavior>> { return .name(ScrollView.Binding.contentInsetAdjustmentBehavior) }
	static var contentOffset: ScrollViewName<Dynamic<SetOrAnimate<CGPoint>>> { return .name(ScrollView.Binding.contentOffset) }
	static var contentSize: ScrollViewName<Dynamic<CGSize>> { return .name(ScrollView.Binding.contentSize) }
	static var decelerationRate: ScrollViewName<Dynamic<UIScrollView.DecelerationRate>> { return .name(ScrollView.Binding.decelerationRate) }
	static var delaysContentTouches: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.delaysContentTouches) }
	static var indicatorStyle: ScrollViewName<Dynamic<UIScrollView.IndicatorStyle>> { return .name(ScrollView.Binding.indicatorStyle) }
	static var isDirectionalLockEnabled: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.isDirectionalLockEnabled) }
	static var isPagingEnabled: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.isPagingEnabled) }
	static var isScrollEnabled: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.isScrollEnabled) }
	static var maximumZoomScale: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.maximumZoomScale) }
	static var minimumZoomScale: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.minimumZoomScale) }
	static var refreshControl: ScrollViewName<Dynamic<UIRefreshControl?>> { return .name(ScrollView.Binding.refreshControl) }
	static var scrollIndicatorInsets: ScrollViewName<Dynamic<UIEdgeInsets>> { return .name(ScrollView.Binding.scrollIndicatorInsets) }
	static var scrollsToTop: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.scrollsToTop) }
	static var showsHorizontalScrollIndicator: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.showsHorizontalScrollIndicator) }
	static var showsVerticalScrollIndicator: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.showsVerticalScrollIndicator) }
	static var zoomScale: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.zoomScale) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var flashScrollIndicators: ScrollViewName<Signal<Void>> { return .name(ScrollView.Binding.flashScrollIndicators) }
	static var scrollRectToVisible: ScrollViewName<Signal<(rect: CGRect, animated: Bool)>> { return .name(ScrollView.Binding.scrollRectToVisible) }
	static var zoom: ScrollViewName<Signal<(rect: CGRect, animated: Bool)>> { return .name(ScrollView.Binding.zoom) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var userDidScroll: ScrollViewName<SignalInput<CGPoint>> { return .name(ScrollView.Binding.userDidScroll) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didEndDecelerating: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.didEndDecelerating) }
	static var didEndDragging: ScrollViewName<(UIScrollView, Bool) -> Void> { return .name(ScrollView.Binding.didEndDragging) }
	static var didEndScrollingAnimation: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.didEndScrollingAnimation) }
	static var didEndZooming: ScrollViewName<(UIScrollView, UIView?, CGFloat) -> Void> { return .name(ScrollView.Binding.didEndZooming) }
	static var didScroll: ScrollViewName<(UIScrollView, CGPoint) -> Void> { return .name(ScrollView.Binding.didScroll) }
	static var didScrollToTop: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.didScrollToTop) }
	static var didZoom: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.didZoom) }
	static var shouldScrollToTop: ScrollViewName<(_ scrollView: UIScrollView) -> Bool> { return .name(ScrollView.Binding.shouldScrollToTop) }
	static var viewForZooming: ScrollViewName<(_ scrollView: UIScrollView) -> UIView?> { return .name(ScrollView.Binding.viewForZooming) }
	static var willBeginDecelerating: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.willBeginDecelerating) }
	static var willBeginDragging: ScrollViewName<(UIScrollView) -> Void> { return .name(ScrollView.Binding.willBeginDragging) }
	static var willBeginZooming: ScrollViewName<(UIScrollView, UIView?) -> Void> { return .name(ScrollView.Binding.willBeginZooming) }
	static var willEndDragging: ScrollViewName<(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void> { return .name(ScrollView.Binding.willEndDragging) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ScrollViewConvertible: ViewConvertible {
	func uiScrollView() -> ScrollView.Instance
}
extension ScrollViewConvertible {
	public func uiView() -> View.Instance { return uiScrollView() }
}
extension UIScrollView: ScrollViewConvertible, HasDelegate {
	public func uiScrollView() -> ScrollView.Instance { return self }
}
public extension ScrollView {
	func uiScrollView() -> ScrollView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ScrollViewBinding: ViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self
	func asScrollViewBinding() -> ScrollView.Binding?
}
public extension ScrollViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}
public extension ScrollViewBinding where Preparer.Inherited.Binding: ScrollViewBinding {
	func asScrollViewBinding() -> ScrollView.Binding? {
		return asInheritedBinding()?.asScrollViewBinding()
	}
}
public extension ScrollView.Binding {
	typealias Preparer = ScrollView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asScrollViewBinding() -> ScrollView.Binding? { return self }
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> ScrollView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class SearchBar: Binder, SearchBarConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension SearchBar {
	enum Binding: SearchBarBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		case barStyle(Dynamic<UIBarStyle>)
		case image(Dynamic<ScopedValues<IconAndControlState, UIImage?>>)
		case inputAccessoryView(Dynamic<UIView?>)
		case isTranslucent(Dynamic<Bool>)
		case placeholder(Dynamic<String>)
		case positionAdjustment(Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>)
		case prompt(Dynamic<String>)
		case scopeBarButtonBackgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case scopeBarButtonDividerImage(Dynamic<ScopedValues<LeftRightControlState, UIImage?>>)
		case scopeBarButtonTitleTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>)
		case scopeButtonTitles(Dynamic<[String]?>)
		case searchFieldBackgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case searchFieldBackgroundPositionAdjustment(Dynamic<UIOffset>)
		case searchTextPositionAdjustment(Dynamic<UIOffset>)
		case selectedScopeButtonIndex(Dynamic<Int>)
		case showCancelButton(Dynamic<SetOrAnimate<Bool>>)
		case showsBookmarkButton(Dynamic<Bool>)
		case showsScopeBar(Dynamic<Bool>)
		case showsSearchResultsButton(Dynamic<Bool>)
		case text(Dynamic<String>)
		case tintColor(Dynamic<UIColor>)

		// 2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case bookmarkButtonClicked((UISearchBar) -> Void)
		case cancelButtonClicked((UISearchBar) -> Void)
		case textDidBeginEditing((UISearchBar) -> Void)
		case textDidChange((UISearchBar, String) -> Void)
		case textDidEndEditing((UISearchBar) -> Void)
		case position((UIBarPositioning) -> UIBarPosition)
		case resultsListButtonClicked((UISearchBar) -> Void)
		case searchButtonClicked((UISearchBar) -> Void)
		case selectedScopeButtonIndexDidChange((UISearchBar, Int) -> Void)
		case shouldBeginEditing((UISearchBar) -> Bool)
		case shouldChangeText((UISearchBar, NSRange, String) -> Bool)
		case shouldEndEditing((UISearchBar) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
public extension SearchBar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = SearchBar.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UISearchBar
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension SearchBar.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .bookmarkButtonClicked(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarBookmarkButtonClicked(_:)))
		case .cancelButtonClicked(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarCancelButtonClicked(_:)))
		case .textDidBeginEditing(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarTextDidBeginEditing(_:)))
		case .textDidChange(let x): delegate().addMultiHandler2(x, #selector(UISearchBarDelegate.searchBar(_:textDidChange:)))
		case .textDidEndEditing(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarTextDidEndEditing(_:)))
		case .position(let x): delegate().addSingleHandler1(x, #selector(UISearchBarDelegate.position(for:)))
		case .resultsListButtonClicked(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarResultsListButtonClicked(_:)))
		case .searchButtonClicked(let x): delegate().addMultiHandler1(x, #selector(UISearchBarDelegate.searchBarSearchButtonClicked(_:)))
		case .selectedScopeButtonIndexDidChange(let x): delegate().addMultiHandler2(x, #selector(UISearchBarDelegate.searchBar(_:selectedScopeButtonIndexDidChange:)))
		case .shouldBeginEditing(let x): delegate().addSingleHandler1(x, #selector(UISearchBarDelegate.searchBarShouldBeginEditing(_:)))
		case .shouldChangeText(let x): delegate().addSingleHandler3(x, #selector(UISearchBarDelegate.searchBar(_:shouldChangeTextIn:replacementText:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler1(x, #selector(UISearchBarDelegate.searchBarShouldEndEditing(_:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .textInputTraits(let x): return x.value.apply(to: instance)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, for: scope.barPosition, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, for: scope.barPosition, barMetrics: scope.barMetrics) }
			)
		case .barStyle(let x): return x.apply(instance) { i, v in i.barStyle = v }
		case .image(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setImage(nil, for: scope.icon, state: scope.controlState) },
				applyNew: { i, scope, v in i.setImage(v, for: scope.icon, state: scope.controlState) }
			)
		case .inputAccessoryView(let x): return x.apply(instance) { i, v in i.inputAccessoryView = v }
		case .isTranslucent(let x): return x.apply(instance) { i, v in i.isTranslucent = v }
		case .placeholder(let x): return x.apply(instance) { i, v in i.placeholder = v }
		case .positionAdjustment(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setPositionAdjustment(UIOffset(), for: scope) },
				applyNew: { i, scope, v in i.setPositionAdjustment(v, for: scope) }
			)
		case .prompt(let x): return x.apply(instance) { i, v in i.prompt = v }
		case .scopeBarButtonBackgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setScopeBarButtonBackgroundImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setScopeBarButtonBackgroundImage(v, for: scope) }
			)
		case .scopeBarButtonDividerImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setScopeBarButtonDividerImage(nil, forLeftSegmentState: scope.left, rightSegmentState: scope.right) },
				applyNew: { i, scope, v in i.setScopeBarButtonDividerImage(v, forLeftSegmentState: scope.left, rightSegmentState: scope.right) }
			)
		case .scopeBarButtonTitleTextAttributes(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setScopeBarButtonTitleTextAttributes(nil, for: scope) },
				applyNew: { i, scope, v in i.setScopeBarButtonTitleTextAttributes(v, for: scope) }
			)
		case .scopeButtonTitles(let x): return x.apply(instance) { i, v in i.scopeButtonTitles = v }
		case .searchFieldBackgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setScopeBarButtonBackgroundImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setScopeBarButtonBackgroundImage(v, for: scope) }
			)
		case .searchFieldBackgroundPositionAdjustment(let x): return x.apply(instance) { i, v in i.searchFieldBackgroundPositionAdjustment = v }
		case .searchTextPositionAdjustment(let x): return x.apply(instance) { i, v in i.searchTextPositionAdjustment = v }
		case .selectedScopeButtonIndex(let x): return x.apply(instance) { i, v in i.selectedScopeButtonIndex = v }
		case .showCancelButton(let x): return x.apply(instance) { i, v in i.setShowsCancelButton(v.value, animated: v.isAnimated) }
		case .showsBookmarkButton(let x): return x.apply(instance) { i, v in i.showsBookmarkButton = v }
		case .showsScopeBar(let x): return x.apply(instance) { i, v in i.showsScopeBar = v }
		case .showsSearchResultsButton(let x): return x.apply(instance) { i, v in i.showsSearchResultsButton = v }
		case .text(let x): return x.apply(instance) { i, v in i.text = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }

		// 2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case .textDidChange: return nil
		case .textDidBeginEditing: return nil
		case .textDidEndEditing: return nil
		case .bookmarkButtonClicked: return nil
		case .cancelButtonClicked: return nil
		case .searchButtonClicked: return nil
		case .resultsListButtonClicked: return nil
		case .selectedScopeButtonIndexDidChange: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .position: return nil
		case .shouldChangeText: return nil
		case .shouldBeginEditing: return nil
		case .shouldEndEditing: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SearchBar.Preparer {
	open class Storage: View.Preparer.Storage, UISearchBarDelegate {}
	
	open class Delegate: DynamicDelegate, UISearchBarDelegate {
		open func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
			multiHandler(searchBar, searchText)
		}
		
		open func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		open func searchBarTextDidEndEditing(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		open func searchBarBookmarkButtonClicked(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		open func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		open func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		open func searchBarResultsListButtonClicked(_ searchBar: UISearchBar) {
			multiHandler(searchBar)
		}
		
		open func searchBarSelectedScopeButtonIndexDidChange(_ searchBar: UISearchBar, selectedScopeButtonIndexDidChange selectedScope: Int) {
			multiHandler(searchBar, selectedScope)
		}
		
		open func searchBarShouldBeginEditing(_ searchBar: UISearchBar) -> Bool {
			return singleHandler(searchBar)
		}
		
		open func searchBarShouldEndEditing(_ searchBar: UISearchBar) -> Bool {
			return singleHandler(searchBar)
		}
		
		open func searchBar(_ searchBar: UISearchBar, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return singleHandler(searchBar, range, text)
		}
		
		open func position(for bar: UIBarPositioning) -> UIBarPosition {
			return singleHandler(bar)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SearchBarBinding {
	public typealias SearchBarName<V> = BindingName<V, SearchBar.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> SearchBar.Binding) -> SearchBarName<V> {
		return SearchBarName<V>(source: source, downcast: Binding.searchBarBinding)
	}
}
public extension BindingName where Binding: SearchBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SearchBarName<$2> { return .name(SearchBar.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: SearchBarName<Constant<TextInputTraits>> { return .name(SearchBar.Binding.textInputTraits) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: SearchBarName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>> { return .name(SearchBar.Binding.backgroundImage) }
	static var barStyle: SearchBarName<Dynamic<UIBarStyle>> { return .name(SearchBar.Binding.barStyle) }
	static var image: SearchBarName<Dynamic<ScopedValues<IconAndControlState, UIImage?>>> { return .name(SearchBar.Binding.image) }
	static var inputAccessoryView: SearchBarName<Dynamic<UIView?>> { return .name(SearchBar.Binding.inputAccessoryView) }
	static var isTranslucent: SearchBarName<Dynamic<Bool>> { return .name(SearchBar.Binding.isTranslucent) }
	static var placeholder: SearchBarName<Dynamic<String>> { return .name(SearchBar.Binding.placeholder) }
	static var positionAdjustment: SearchBarName<Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>> { return .name(SearchBar.Binding.positionAdjustment) }
	static var prompt: SearchBarName<Dynamic<String>> { return .name(SearchBar.Binding.prompt) }
	static var scopeBarButtonBackgroundImage: SearchBarName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(SearchBar.Binding.scopeBarButtonBackgroundImage) }
	static var scopeBarButtonDividerImage: SearchBarName<Dynamic<ScopedValues<LeftRightControlState, UIImage?>>> { return .name(SearchBar.Binding.scopeBarButtonDividerImage) }
	static var scopeBarButtonTitleTextAttributes: SearchBarName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>> { return .name(SearchBar.Binding.scopeBarButtonTitleTextAttributes) }
	static var scopeButtonTitles: SearchBarName<Dynamic<[String]?>> { return .name(SearchBar.Binding.scopeButtonTitles) }
	static var searchFieldBackgroundImage: SearchBarName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(SearchBar.Binding.searchFieldBackgroundImage) }
	static var searchFieldBackgroundPositionAdjustment: SearchBarName<Dynamic<UIOffset>> { return .name(SearchBar.Binding.searchFieldBackgroundPositionAdjustment) }
	static var searchTextPositionAdjustment: SearchBarName<Dynamic<UIOffset>> { return .name(SearchBar.Binding.searchTextPositionAdjustment) }
	static var selectedScopeButtonIndex: SearchBarName<Dynamic<Int>> { return .name(SearchBar.Binding.selectedScopeButtonIndex) }
	static var showCancelButton: SearchBarName<Dynamic<SetOrAnimate<Bool>>> { return .name(SearchBar.Binding.showCancelButton) }
	static var showsBookmarkButton: SearchBarName<Dynamic<Bool>> { return .name(SearchBar.Binding.showsBookmarkButton) }
	static var showsScopeBar: SearchBarName<Dynamic<Bool>> { return .name(SearchBar.Binding.showsScopeBar) }
	static var showsSearchResultsButton: SearchBarName<Dynamic<Bool>> { return .name(SearchBar.Binding.showsSearchResultsButton) }
	static var text: SearchBarName<Dynamic<String>> { return .name(SearchBar.Binding.text) }
	static var tintColor: SearchBarName<Dynamic<UIColor>> { return .name(SearchBar.Binding.tintColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var bookmarkButtonClicked: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.bookmarkButtonClicked) }
	static var cancelButtonClicked: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.cancelButtonClicked) }
	static var textDidBeginEditing: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.textDidBeginEditing) }
	static var textDidChange: SearchBarName<(UISearchBar, String) -> Void> { return .name(SearchBar.Binding.textDidChange) }
	static var textDidEndEditing: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.textDidEndEditing) }
	static var position: SearchBarName<(UIBarPositioning) -> UIBarPosition> { return .name(SearchBar.Binding.position) }
	static var resultsListButtonClicked: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.resultsListButtonClicked) }
	static var searchButtonClicked: SearchBarName<(UISearchBar) -> Void> { return .name(SearchBar.Binding.searchButtonClicked) }
	static var selectedScopeButtonIndexDidChange: SearchBarName<(UISearchBar, Int) -> Void> { return .name(SearchBar.Binding.selectedScopeButtonIndexDidChange) }
	static var shouldBeginEditing: SearchBarName<(UISearchBar) -> Bool> { return .name(SearchBar.Binding.shouldBeginEditing) }
	static var shouldChangeText: SearchBarName<(UISearchBar, NSRange, String) -> Bool> { return .name(SearchBar.Binding.shouldChangeText) }
	static var shouldEndEditing: SearchBarName<(UISearchBar) -> Bool> { return .name(SearchBar.Binding.shouldEndEditing) }
	
	// Composite binding names
	static func textChanged(_ void: Void = ()) -> SearchBarName<SignalInput<String>> {
		return Binding.compositeName(
			value: { input in { (searchBar, text) in input.send(value: text) } },
			binding: SearchBar.Binding.textDidChange,
			downcast: Binding.searchBarBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol SearchBarConvertible: ViewConvertible {
	func uiSearchBar() -> SearchBar.Instance
}
extension SearchBarConvertible {
	public func uiView() -> View.Instance { return uiSearchBar() }
}
extension UISearchBar: SearchBarConvertible, HasDelegate {
	public func uiSearchBar() -> SearchBar.Instance { return self }
}
public extension SearchBar {
	func uiSearchBar() -> SearchBar.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol SearchBarBinding: ViewBinding {
	static func searchBarBinding(_ binding: SearchBar.Binding) -> Self
	func asSearchBarBinding() -> SearchBar.Binding?
}
public extension SearchBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return searchBarBinding(.inheritedBinding(binding))
	}
}
public extension SearchBarBinding where Preparer.Inherited.Binding: SearchBarBinding {
	func asSearchBarBinding() -> SearchBar.Binding? {
		return asInheritedBinding()?.asSearchBarBinding()
	}
}
public extension SearchBar.Binding {
	typealias Preparer = SearchBar.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSearchBarBinding() -> SearchBar.Binding? { return self }
	static func searchBarBinding(_ binding: SearchBar.Binding) -> SearchBar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public struct LeftRightControlState {
	public let left: UIControl.State
	public let right: UIControl.State
	public init(left: UIControl.State = .normal, right: UIControl.State = .normal) {
		self.left = left
		self.right = right
	}
}

public struct IconAndControlState {
	public let icon: UISearchBar.Icon
	public let controlState: UIControl.State
	public init(icon: UISearchBar.Icon = .search, state: UIControl.State = .normal) {
		self.icon = icon
		self.controlState = state
	}
}

extension ScopedValues where Scope == LeftRightControlState {
	public static func normal(right: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .normal, right: right))
	}
	public static func highlighted(right: UIControl.State = .highlighted, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .highlighted, right: right))
	}
	public static func disabled(right: UIControl.State = .disabled, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .disabled, right: right))
	}
	public static func selected(right: UIControl.State = .selected, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .selected, right: right))
	}
	public static func focused(right: UIControl.State = .focused, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .focused, right: right))
	}
	public static func application(right: UIControl.State = .application, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .application, right: right))
	}
	public static func reserved(right: UIControl.State = .reserved, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .reserved, right: right))
	}
}

extension ScopedValues where Scope == IconAndControlState {
	public static func search(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .search, state: state))
	}
	public static func clear(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .clear, state: state))
	}
	public static func bookmark(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .bookmark, state: state))
	}
	public static func resultsList(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .resultsList, state: state))
	}
}

extension ScopedValues where Scope == UISearchBar.Icon {
	public static func search(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .search)
	}
	public static func clear(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .clear)
	}
	public static func bookmark(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .bookmark)
	}
	public static func resultsList(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .resultsList)
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class Slider: Binder, SliderConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Slider {
	enum Binding: SliderBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isContinuous(Dynamic<Bool>)
		case maximumTrackImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case maximumTrackTintColor(Dynamic<UIColor?>)
		case maximumValue(Dynamic<Float>)
		case maximumValueImage(Dynamic<UIImage?>)
		case minimumTrackImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case minimumTrackTintColor(Dynamic<UIColor?>)
		case minimumValue(Dynamic<Float>)
		case minimumValueImage(Dynamic<UIImage?>)
		case thumbImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case thumbTintColor(Dynamic<UIColor?>)
		case value(Dynamic<SetOrAnimate<Float>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension Slider {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = Slider.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = UISlider
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Slider.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		case .isContinuous(let x): return x.apply(instance) { i, v in i.isContinuous = v }
		case .maximumTrackImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setMaximumTrackImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setMaximumTrackImage(v, for: scope) }
			)
		case .maximumTrackTintColor(let x): return x.apply(instance) { i, v in i.maximumTrackTintColor = v }
		case .maximumValue(let x): return x.apply(instance) { i, v in i.maximumValue = v }
		case .maximumValueImage(let x): return x.apply(instance) { i, v in i.maximumValueImage = v }
		case .minimumTrackImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setMinimumTrackImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setMinimumTrackImage(v, for: scope) }
			)
		case .minimumTrackTintColor(let x): return x.apply(instance) { i, v in i.minimumTrackTintColor = v }
		case .minimumValue(let x): return x.apply(instance) { i, v in i.minimumValue = v }
		case .minimumValueImage(let x): return x.apply(instance) { i, v in i.minimumValueImage = v }
		case .thumbImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setThumbImage(nil, for: scope) },
				applyNew: { i, scope, v in i.setThumbImage(v, for: scope) }
			)
		case .thumbTintColor(let x): return x.apply(instance) { i, v in i.thumbTintColor = v }
		case .value(let x): return x.apply(instance) { i, v in i.setValue(v.value, animated: v.isAnimated) }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Slider.Preparer {
	public typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SliderBinding {
	public typealias SliderName<V> = BindingName<V, Slider.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Slider.Binding) -> SliderName<V> {
		return SliderName<V>(source: source, downcast: Binding.sliderBinding)
	}
}
public extension BindingName where Binding: SliderBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SliderName<$2> { return .name(Slider.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isContinuous: SliderName<Dynamic<Bool>> { return .name(Slider.Binding.isContinuous) }
	static var maximumTrackImage: SliderName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Slider.Binding.maximumTrackImage) }
	static var maximumTrackTintColor: SliderName<Dynamic<UIColor?>> { return .name(Slider.Binding.maximumTrackTintColor) }
	static var maximumValue: SliderName<Dynamic<Float>> { return .name(Slider.Binding.maximumValue) }
	static var maximumValueImage: SliderName<Dynamic<UIImage?>> { return .name(Slider.Binding.maximumValueImage) }
	static var minimumTrackImage: SliderName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Slider.Binding.minimumTrackImage) }
	static var minimumTrackTintColor: SliderName<Dynamic<UIColor?>> { return .name(Slider.Binding.minimumTrackTintColor) }
	static var minimumValue: SliderName<Dynamic<Float>> { return .name(Slider.Binding.minimumValue) }
	static var minimumValueImage: SliderName<Dynamic<UIImage?>> { return .name(Slider.Binding.minimumValueImage) }
	static var thumbImage: SliderName<Dynamic<ScopedValues<UIControl.State, UIImage?>>> { return .name(Slider.Binding.thumbImage) }
	static var thumbTintColor: SliderName<Dynamic<UIColor?>> { return .name(Slider.Binding.thumbTintColor) }
	static var value: SliderName<Dynamic<SetOrAnimate<Float>>> { return .name(Slider.Binding.value) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol SliderConvertible: ControlConvertible {
	func uiSlider() -> Slider.Instance
}
extension SliderConvertible {
	public func uiControl() -> Control.Instance { return uiSlider() }
}
extension UISlider: SliderConvertible {
	public func uiSlider() -> Slider.Instance { return self }
}
public extension Slider {
	func uiSlider() -> Slider.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol SliderBinding: ControlBinding {
	static func sliderBinding(_ binding: Slider.Binding) -> Self
	func asSliderBinding() -> Slider.Binding?
}
public extension SliderBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return sliderBinding(.inheritedBinding(binding))
	}
}
public extension SliderBinding where Preparer.Inherited.Binding: SliderBinding {
	func asSliderBinding() -> Slider.Binding? {
		return asInheritedBinding()?.asSliderBinding()
	}
}
public extension Slider.Binding {
	typealias Preparer = Slider.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSliderBinding() -> Slider.Binding? { return self }
	static func sliderBinding(_ binding: Slider.Binding) -> Slider.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class SplitViewController: Binder, SplitViewControllerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension SplitViewController {
	enum Binding: SplitViewControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case backgroundView(Constant<View>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case maximumPrimaryColumnWidth(Dynamic<CGFloat>)
		case minimumPrimaryColumnWidth(Dynamic<CGFloat>)
		case preferredDisplayMode(Dynamic<UISplitViewController.DisplayMode>)
		case preferredPrimaryColumnWidthFraction(Dynamic<CGFloat>)
		case presentsWithGesture(Dynamic<Bool>)
		case primaryViewController(Dynamic<ViewControllerConvertible>)
		case secondaryViewController(Dynamic<ViewControllerConvertible>)
		case shouldShowSecondary(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case dismissedSecondary(SignalInput<Void>)
		case displayModeButton(SignalInput<BarButtonItemConvertible?>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case collapseSecondary((UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool)
		case preferredInterfaceOrientation((UISplitViewController) -> UIInterfaceOrientation)
		case primaryViewControllerForCollapsing((UISplitViewController) -> UIViewController?)
		case primaryViewControllerForExpanding((UISplitViewController) -> UIViewController?)
		case separateSecondary((UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?)
		case showPrimaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
		case showSecondaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
		case supportedInterfaceOrientations((UISplitViewController) -> UIInterfaceOrientationMask)
		case targetDisplayModeForAction((UISplitViewController) -> UISplitViewController.DisplayMode)
		case willChangeDisplayMode((UISplitViewController, UISplitViewController.DisplayMode) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension SplitViewController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = SplitViewController.Binding
		public typealias Inherited = ViewController.Preparer
		public typealias Instance = UISplitViewController
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage(displayModeButton: displayModeButton, dismissedSecondary: dismissedSecondary) }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		public var primary = InitialSubsequent<ViewControllerConvertible>()
		public var secondary = InitialSubsequent<ViewControllerConvertible>()
		public var displayModeButton: MultiOutput<BarButtonItemConvertible?>?
		public var dismissedSecondary: MultiOutput<Void>?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension SplitViewController.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance { return type.init(nibName: nil, bundle: nil) }

	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .collapseSecondary(let x): delegate().addSingleHandler3(x, #selector(UISplitViewControllerDelegate.splitViewController(_:collapseSecondary:onto:)))
		case .preferredInterfaceOrientation(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.splitViewControllerPreferredInterfaceOrientationForPresentation(_:)))
		case .primaryViewController(let x): primary = x.initialSubsequent()
		case .primaryViewControllerForCollapsing(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.primaryViewController(forCollapsing:)))
		case .primaryViewControllerForExpanding(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.primaryViewController(forExpanding:)))
		case .secondaryViewController(let x): secondary = x.initialSubsequent()
		case .separateSecondary(let x): delegate().addSingleHandler2(x, #selector(UISplitViewControllerDelegate.splitViewController(_:separateSecondaryFrom:)))
		case .showPrimaryViewController(let x): delegate().addSingleHandler3(x, #selector(UISplitViewControllerDelegate.splitViewController(_:show:sender:)))
		case .showSecondaryViewController(let x): delegate().addSingleHandler3(x, #selector(UISplitViewControllerDelegate.splitViewController(_:showDetail:sender:)))
		case .supportedInterfaceOrientations(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.splitViewControllerSupportedInterfaceOrientations(_:)))
		case .targetDisplayModeForAction(let x): delegate().addSingleHandler1(x, #selector(UISplitViewControllerDelegate.targetDisplayModeForAction(in:)))
		case .willChangeDisplayMode(let x): delegate().addMultiHandler2(x, #selector(UISplitViewControllerDelegate.splitViewController(_:willChangeTo:)))
		case .dismissedSecondary(let x):
			dismissedSecondary = dismissedSecondary ?? Input().multicast()
			dismissedSecondary?.signal.bind(to: x)
		case .displayModeButton(let x):
			displayModeButton = displayModeButton ?? Input().multicast()
			displayModeButton?.signal.bind(to: x)
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		storage.secondaryViewController = secondary.initial?.uiViewController()
		instance.viewControllers = [primary.initial?.uiViewController() ?? UIViewController()]
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .backgroundView(let v):
			v.value.apply(to: instance.view)
			return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .maximumPrimaryColumnWidth(let x): return x.apply(instance) { i, v in i.maximumPrimaryColumnWidth = v }
		case .minimumPrimaryColumnWidth(let x): return x.apply(instance) { i, v in i.minimumPrimaryColumnWidth = v }
		case .preferredDisplayMode(let x): return x.apply(instance) { i, v in i.preferredDisplayMode = v }
		case .preferredPrimaryColumnWidthFraction(let x): return x.apply(instance) { i, v in i.preferredPrimaryColumnWidthFraction = v }
		case .presentsWithGesture(let x): return x.apply(instance) { i, v in i.presentsWithGesture = v }
		case .primaryViewController: return primary.resume()?.apply(instance) { i, v in i.show(v.uiViewController(), sender: nil) }
		case .secondaryViewController:
			return secondary.resume()?.apply(instance, storage) { i, s, v in
				let vc = v.uiViewController()
				s.secondaryViewController = vc
				i.showDetailViewController(vc, sender: nil)
			}
		case .shouldShowSecondary(let x):
			return x.apply(instance, storage) { i, s, v in
				if v == true && s.shouldShowSecondary == false, let svc = s.secondaryViewController {
					i.showDetailViewController(svc, sender: nil)
				}
				s.shouldShowSecondary = v
			}

		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
		case .dismissedSecondary: return nil
		case .displayModeButton: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .collapseSecondary: return nil
		case .preferredInterfaceOrientation: return nil
		case .primaryViewControllerForCollapsing: return nil
		case .primaryViewControllerForExpanding: return nil
		case .separateSecondary: return nil
		case .showPrimaryViewController: return nil
		case .showSecondaryViewController: return nil
		case .supportedInterfaceOrientations: return nil
		case .targetDisplayModeForAction: return nil
		case .willChangeDisplayMode: return nil
		}
	}

	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		if !instance.isCollapsed {
			storage.displayModeButton?.input.send(value: instance.displayModeButtonItem)
		}
		if let secondary = storage.secondaryViewController {
			instance.viewControllers.append(secondary)
		}
		
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SplitViewController.Preparer {
	open class Storage: ViewController.Preparer.Storage, UISplitViewControllerDelegate {
		open var secondaryViewController: UIViewController? = nil
		open var shouldShowSecondary: Bool = true
		public let dismissedSecondary: MultiOutput<Void>?
		public let displayModeButton: MultiOutput<BarButtonItemConvertible?>?
		
		public init(displayModeButton: MultiOutput<BarButtonItemConvertible?>?, dismissedSecondary: MultiOutput<Void>?) {
			self.dismissedSecondary = dismissedSecondary
			self.displayModeButton = displayModeButton
			super.init()
		}
		
		open override var isInUse: Bool {
			return true
		}
		
		open func collapsedController(_ controller: UINavigationController) {
			if let svc = secondaryViewController, svc === controller {
				dismissedSecondary?.input.send(value: ())
			}
		}

		open func splitViewController(_ splitViewController: UISplitViewController, collapseSecondary secondaryViewController: UIViewController, onto primaryViewController: UIViewController) -> Bool {
			displayModeButton?.input.send(value: nil)

			if let dd = dynamicDelegate, dd.handlesSelector(#selector(UISplitViewControllerDelegate.splitViewController(_:collapseSecondary:onto:))) {
				return ((dd as? UISplitViewControllerDelegate)?.splitViewController?(splitViewController, collapseSecondary: secondaryViewController, onto: primaryViewController) ?? false) || !shouldShowSecondary
			}
			return !shouldShowSecondary
		}
		
		open func splitViewController(_ splitViewController: UISplitViewController, separateSecondaryFrom primaryViewController: UIViewController) -> UIViewController? {
			displayModeButton?.input.send(value: splitViewController.displayModeButtonItem)

			if let dd = dynamicDelegate, dd.handlesSelector(#selector(UISplitViewControllerDelegate.splitViewController(_:separateSecondaryFrom:))) {
				return (dd as? UISplitViewControllerDelegate)?.splitViewController?(splitViewController, separateSecondaryFrom: primaryViewController)
			}
			return nil
		}
	}

	open class Delegate: DynamicDelegate, UISplitViewControllerDelegate {
		public func splitViewController(_ svc: UISplitViewController, willChangeTo displayMode: UISplitViewController.DisplayMode) {
			multiHandler(svc, displayMode)
		}
		
		public func targetDisplayModeForAction(in svc: UISplitViewController) -> UISplitViewController.DisplayMode {
			return singleHandler(svc)
		}
		
		public func splitViewControllerPreferredInterfaceOrientationForPresentation(_ splitViewController: UISplitViewController) -> UIInterfaceOrientation {
			return singleHandler(splitViewController)
		}
		
		public func splitViewControllerSupportedInterfaceOrientations(_ splitViewController: UISplitViewController) -> UIInterfaceOrientationMask {
			return singleHandler(splitViewController)
		}
		
		public func primaryViewController(forCollapsing splitViewController: UISplitViewController) -> UIViewController? {
			return singleHandler(splitViewController)
		}
		
		public func primaryViewController(forExpanding splitViewController: UISplitViewController) -> UIViewController? {
			return singleHandler(splitViewController)
		}
		
		public func splitViewController(_ splitViewController: UISplitViewController, show vc: UIViewController, sender: Any?) -> Bool {
			return singleHandler(splitViewController, vc, sender)
		}
		
		public func splitViewController(_ splitViewController: UISplitViewController, showDetail vc: UIViewController, sender: Any?) -> Bool {
			return singleHandler(splitViewController, vc, sender)
		}

		public func splitViewController(_ splitViewController: UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool {
			return singleHandler(splitViewController, secondaryViewController, ontoPrimaryViewController)
		}
		
		public func splitViewController(_ splitViewController: UISplitViewController, separateSecondaryFrom primaryViewController: UIViewController) -> UIViewController? {
			return singleHandler(splitViewController, primaryViewController)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SplitViewControllerBinding {
	public typealias SplitViewControllerName<V> = BindingName<V, SplitViewController.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> SplitViewController.Binding) -> SplitViewControllerName<V> {
		return SplitViewControllerName<V>(source: source, downcast: Binding.splitViewControllerBinding)
	}
}
public extension BindingName where Binding: SplitViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SplitViewControllerName<$2> { return .name(SplitViewController.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var backgroundView: SplitViewControllerName<Constant<View>> { return .name(SplitViewController.Binding.backgroundView) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var maximumPrimaryColumnWidth: SplitViewControllerName<Dynamic<CGFloat>> { return .name(SplitViewController.Binding.maximumPrimaryColumnWidth) }
	static var minimumPrimaryColumnWidth: SplitViewControllerName<Dynamic<CGFloat>> { return .name(SplitViewController.Binding.minimumPrimaryColumnWidth) }
	static var preferredDisplayMode: SplitViewControllerName<Dynamic<UISplitViewController.DisplayMode>> { return .name(SplitViewController.Binding.preferredDisplayMode) }
	static var preferredPrimaryColumnWidthFraction: SplitViewControllerName<Dynamic<CGFloat>> { return .name(SplitViewController.Binding.preferredPrimaryColumnWidthFraction) }
	static var presentsWithGesture: SplitViewControllerName<Dynamic<Bool>> { return .name(SplitViewController.Binding.presentsWithGesture) }
	static var primaryViewController: SplitViewControllerName<Dynamic<ViewControllerConvertible>> { return .name(SplitViewController.Binding.primaryViewController) }
	static var secondaryViewController: SplitViewControllerName<Dynamic<ViewControllerConvertible>> { return .name(SplitViewController.Binding.secondaryViewController) }
	static var shouldShowSecondary: SplitViewControllerName<Dynamic<Bool>> { return .name(SplitViewController.Binding.shouldShowSecondary) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var dismissedSecondary: SplitViewControllerName<SignalInput<Void>> { return .name(SplitViewController.Binding.dismissedSecondary) }
	static var displayModeButton: SplitViewControllerName<SignalInput<BarButtonItemConvertible?>> { return .name(SplitViewController.Binding.displayModeButton) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var collapseSecondary: SplitViewControllerName<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool> { return .name(SplitViewController.Binding.collapseSecondary) }
	static var preferredInterfaceOrientation: SplitViewControllerName<(UISplitViewController) -> UIInterfaceOrientation> { return .name(SplitViewController.Binding.preferredInterfaceOrientation) }
	static var primaryViewControllerForCollapsing: SplitViewControllerName<(UISplitViewController) -> UIViewController?> { return .name(SplitViewController.Binding.primaryViewControllerForCollapsing) }
	static var primaryViewControllerForExpanding: SplitViewControllerName<(UISplitViewController) -> UIViewController?> { return .name(SplitViewController.Binding.primaryViewControllerForExpanding) }
	static var separateSecondary: SplitViewControllerName<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?> { return .name(SplitViewController.Binding.separateSecondary) }
	static var showPrimaryViewController: SplitViewControllerName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool> { return .name(SplitViewController.Binding.showPrimaryViewController) }
	static var showSecondaryViewController: SplitViewControllerName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool> { return .name(SplitViewController.Binding.showSecondaryViewController) }
	static var supportedInterfaceOrientations: SplitViewControllerName<(UISplitViewController) -> UIInterfaceOrientationMask> { return .name(SplitViewController.Binding.supportedInterfaceOrientations) }
	static var targetDisplayModeForAction: SplitViewControllerName<(UISplitViewController) -> UISplitViewController.DisplayMode> { return .name(SplitViewController.Binding.targetDisplayModeForAction) }
	static var willChangeDisplayMode: SplitViewControllerName<(UISplitViewController, UISplitViewController.DisplayMode) -> Void> { return .name(SplitViewController.Binding.willChangeDisplayMode) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol SplitViewControllerConvertible: ViewControllerConvertible {
	func uiSplitViewController() -> SplitViewController.Instance
}
extension SplitViewControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiSplitViewController() }
}
extension UISplitViewController: SplitViewControllerConvertible, HasDelegate {
	public func uiSplitViewController() -> SplitViewController.Instance { return self }
}
public extension SplitViewController {
	func uiSplitViewController() -> SplitViewController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol SplitViewControllerBinding: ViewControllerBinding {
	static func splitViewControllerBinding(_ binding: SplitViewController.Binding) -> Self
	func asSplitViewControllerBinding() -> SplitViewController.Binding?
}
public extension SplitViewControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return splitViewControllerBinding(.inheritedBinding(binding))
	}
}
public extension SplitViewControllerBinding where Preparer.Inherited.Binding: SplitViewControllerBinding {
	func asSplitViewControllerBinding() -> SplitViewController.Binding? {
		return asInheritedBinding()?.asSplitViewControllerBinding()
	}
}
public extension SplitViewController.Binding {
	typealias Preparer = SplitViewController.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSplitViewControllerBinding() -> SplitViewController.Binding? { return self }
	static func splitViewControllerBinding(_ binding: SplitViewController.Binding) -> SplitViewController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class SwipeGestureRecognizer: Binder, SwipeGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension SwipeGestureRecognizer {
	enum Binding: SwipeGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case direction(Dynamic<UISwipeGestureRecognizer.Direction>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension SwipeGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = SwipeGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = UISwipeGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension SwipeGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .direction(let x): return x.apply(instance) { i, v in i.direction = v }
		case .numberOfTouchesRequired(let x): return x.apply(instance) { i, v in i.numberOfTouchesRequired = v }
			
		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SwipeGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SwipeGestureRecognizerBinding {
	public typealias SwipeGestureRecognizerName<V> = BindingName<V, SwipeGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> SwipeGestureRecognizer.Binding) -> SwipeGestureRecognizerName<V> {
		return SwipeGestureRecognizerName<V>(source: source, downcast: Binding.swipeGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: SwipeGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SwipeGestureRecognizerName<$2> { return .name(SwipeGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var direction: SwipeGestureRecognizerName<Dynamic<UISwipeGestureRecognizer.Direction>> { return .name(SwipeGestureRecognizer.Binding.direction) }
	static var numberOfTouchesRequired: SwipeGestureRecognizerName<Dynamic<Int>> { return .name(SwipeGestureRecognizer.Binding.numberOfTouchesRequired) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol SwipeGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance
}
extension SwipeGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiSwipeGestureRecognizer() }
}
extension UISwipeGestureRecognizer: SwipeGestureRecognizerConvertible {
	public func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance { return self }
}
public extension SwipeGestureRecognizer {
	func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol SwipeGestureRecognizerBinding: GestureRecognizerBinding {
	static func swipeGestureRecognizerBinding(_ binding: SwipeGestureRecognizer.Binding) -> Self
	func asSwipeGestureRecognizerBinding() -> SwipeGestureRecognizer.Binding?
}
public extension SwipeGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return swipeGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension SwipeGestureRecognizerBinding where Preparer.Inherited.Binding: SwipeGestureRecognizerBinding {
	func asSwipeGestureRecognizerBinding() -> SwipeGestureRecognizer.Binding? {
		return asInheritedBinding()?.asSwipeGestureRecognizerBinding()
	}
}
public extension SwipeGestureRecognizer.Binding {
	typealias Preparer = SwipeGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSwipeGestureRecognizerBinding() -> SwipeGestureRecognizer.Binding? { return self }
	static func swipeGestureRecognizerBinding(_ binding: SwipeGestureRecognizer.Binding) -> SwipeGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class Switch: Binder, SwitchConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Switch {
	enum Binding: SwitchBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isOn(Dynamic<SetOrAnimate<Bool>>)
		case offImage(Dynamic<UIImage?>)
		case onImage(Dynamic<UIImage?>)
		case onTintColor(Dynamic<UIColor>)
		case thumbTintColor(Dynamic<UIColor>)
		case tintColor(Dynamic<UIColor>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension Switch {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = Switch.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = UISwitch
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Switch.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .isOn(let x): return x.apply(instance) { i, v in i.setOn(v.value, animated: v.isAnimated) }
		case .offImage(let x): return x.apply(instance) { i, v in i.offImage = v }
		case .onImage(let x): return x.apply(instance) { i, v in i.onImage = v }
		case .onTintColor(let x): return x.apply(instance) { i, v in i.onTintColor = v }
		case .thumbTintColor(let x): return x.apply(instance) { i, v in i.thumbTintColor = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Switch.Preparer {
	public typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SwitchBinding {
	public typealias SwitchName<V> = BindingName<V, Switch.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Switch.Binding) -> SwitchName<V> {
		return SwitchName<V>(source: source, downcast: Binding.switchBinding)
	}
}
public extension BindingName where Binding: SwitchBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SwitchName<$2> { return .name(Switch.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isOn: SwitchName<Dynamic<SetOrAnimate<Bool>>> { return .name(Switch.Binding.isOn) }
	static var offImage: SwitchName<Dynamic<UIImage?>> { return .name(Switch.Binding.offImage) }
	static var onImage: SwitchName<Dynamic<UIImage?>> { return .name(Switch.Binding.onImage) }
	static var onTintColor: SwitchName<Dynamic<UIColor>> { return .name(Switch.Binding.onTintColor) }
	static var thumbTintColor: SwitchName<Dynamic<UIColor>> { return .name(Switch.Binding.thumbTintColor) }
	static var tintColor: SwitchName<Dynamic<UIColor>> { return .name(Switch.Binding.tintColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol SwitchConvertible: ControlConvertible {
	func uiSwitch() -> Switch.Instance
}
extension SwitchConvertible {
	public func uiControl() -> Control.Instance { return uiSwitch() }
}
extension UISwitch: SwitchConvertible {
	public func uiSwitch() -> Switch.Instance { return self }
}
public extension Switch {
	func uiSwitch() -> Switch.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol SwitchBinding: ControlBinding {
	static func switchBinding(_ binding: Switch.Binding) -> Self
	func asSwitchBinding() -> Switch.Binding?
}
public extension SwitchBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return switchBinding(.inheritedBinding(binding))
	}
}
public extension SwitchBinding where Preparer.Inherited.Binding: SwitchBinding {
	func asSwitchBinding() -> Switch.Binding? {
		return asInheritedBinding()?.asSwitchBinding()
	}
}
public extension Switch.Binding {
	typealias Preparer = Switch.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSwitchBinding() -> Switch.Binding? { return self }
	static func switchBinding(_ binding: Switch.Binding) -> Switch.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class TabBarController<ItemIdentifier: Hashable>: Binder, TabBarControllerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TabBarController {
	enum Binding: TabBarControllerBinding {
		public typealias ItemIdentifierType = ItemIdentifier
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case tabBar(Constant<TabBar<ItemIdentifier>>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case customizableItems(Dynamic<Set<ItemIdentifier>>)
		case items(Dynamic<SetOrAnimate<[ItemIdentifier]>>)

		// 2. Signal bindings are performed on the object after construction.
		case selectItem(Signal<ItemIdentifier>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case animationControllerForTransition((UITabBarController, UIViewController, ItemIdentifier, UIViewController, ItemIdentifier) -> UIViewControllerAnimatedTransitioning?)
		case didEndCustomizing((UITabBarController, [UIViewController], [ItemIdentifier], Bool) -> Void)
		case didSelect((UITabBarController, UIViewController, ItemIdentifier) -> Void)
		case interactionControllerForAnimation((UITabBarController, UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
		case preferredInterfaceOrientationForPresentation((UITabBarController) -> UIInterfaceOrientation)
		case shouldSelect((UITabBarController, UIViewController, ItemIdentifier) -> Bool)
		case supportedInterfaceOrientations((UITabBarController) -> UIInterfaceOrientationMask)
		case tabConstructor((ItemIdentifier) -> ViewControllerConvertible)
		case willBeginCustomizing((UITabBarController, [UIViewController], [ItemIdentifier]) -> Void)
		case willEndCustomizing((UITabBarController, [UIViewController], [ItemIdentifier], Bool) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension TabBarController {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = TabBarController.Binding
		public typealias Inherited = ViewController.Preparer
		public typealias Instance = UITabBarController
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var tabConstructor: ((ItemIdentifier) -> ViewControllerConvertible)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TabBarController.Preparer {
	var delegateIsRequired: Bool { return true }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .animationControllerForTransition(let x): delegate().addSingleHandler5(x, #selector(UITabBarControllerDelegate.tabBarController(_:animationControllerForTransitionFrom:to:)))
		case .didEndCustomizing(let x): delegate().addMultiHandler4(x, #selector(UITabBarControllerDelegate.tabBarController(_:didEndCustomizing:changed:)))
		case .didSelect(let x): delegate().addMultiHandler3(x, #selector(UITabBarControllerDelegate.tabBarController(_:didSelect:)))
		case .interactionControllerForAnimation(let x): delegate().addSingleHandler2(x, #selector(UITabBarControllerDelegate.tabBarController(_:interactionControllerFor:)))
		case .preferredInterfaceOrientationForPresentation(let x): delegate().addSingleHandler1(x, #selector(UITabBarControllerDelegate.tabBarControllerPreferredInterfaceOrientationForPresentation(_:)))
		case .shouldSelect(let x): delegate().addSingleHandler3(x, #selector(UITabBarControllerDelegate.tabBarController(_:shouldSelect:)))
		case .supportedInterfaceOrientations(let x): delegate().addSingleHandler1(x, #selector(UITabBarControllerDelegate.tabBarControllerSupportedInterfaceOrientations(_:)))
		case .tabConstructor(let x): tabConstructor = x
		case .willBeginCustomizing(let x): delegate().addMultiHandler3(x, #selector(UITabBarControllerDelegate.tabBarController(_:willBeginCustomizing:)))
		case .willEndCustomizing(let x): delegate().addMultiHandler4(x, #selector(UITabBarControllerDelegate.tabBarController(_:willEndCustomizing:changed:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		storage.tabConstructor = tabConstructor
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .tabBar(let x):
			x.value.apply(to: instance.tabBar)
			return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .customizableItems(let x):
			return x.apply(instance, storage) { i, s, v in
				i.customizableViewControllers = v.compactMap { s.viewController(for: $0) }
			}
		case .items(let x):
			return x.apply(instance, storage) { i, s, v in
				let items = v.value.compactMap { s.viewController(for: $0) }
				i.setViewControllers(items, animated: v.isAnimated)
			}

		// 2. Signal bindings are performed on the object after construction.
		case .selectItem(let x):
			return x.apply(instance, storage) { i, s, v in
				if let vc = s.viewController(for: v), let index = i.viewControllers?.firstIndex(of: vc) {
					i.selectedIndex = index
				}
			}

		// 3. Action bindings are triggered by the object after construction.
		case .didEndCustomizing: return nil
		case .didSelect: return nil
		case .willBeginCustomizing: return nil
		case .willEndCustomizing: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .animationControllerForTransition: return nil
		case .interactionControllerForAnimation: return nil
		case .preferredInterfaceOrientationForPresentation: return nil
		case .shouldSelect: return nil
		case .supportedInterfaceOrientations: return nil
		case .tabConstructor: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabBarController.Preparer {
	open class Storage: ViewController.Preparer.Storage, UITabBarControllerDelegate {
		open var tabConstructor: ((ItemIdentifier) -> ViewControllerConvertible)?
		open var allItems: [ItemIdentifier: ViewControllerConvertible] = [:]
		
		open override var isInUse: Bool { return true }
		
		open func identifier(for viewController: UIViewController) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.uiViewController() === viewController
			})?.key
		}
		open func viewController(for identifier: ItemIdentifier) -> UIViewController? {
			if let existing = allItems[identifier] {
				return existing.uiViewController()
			}
			if let binding = tabConstructor {
				let new = binding(identifier)
				allItems[identifier] = new
				return new.uiViewController()
			}
			return nil
		}
	}
	
	open class Delegate: DynamicDelegate, UITabBarControllerDelegate {
		open func tabBarController(_ tabBarController: UITabBarController, didSelect viewController: UIViewController) {
			guard let identifier = (tabBarController.delegate as? Storage)?.identifier(for: viewController) else { return }
			multiHandler(tabBarController, viewController, identifier)
		}

		open func tabBarController(_ tabBarController: UITabBarController, willBeginCustomizing viewControllers: [UIViewController]) {
			guard let storage = tabBarController.delegate as? Storage else { return }
			let identifiers = viewControllers.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBarController, viewControllers, identifiers)
		}

		open func tabBarController(_ tabBarController: UITabBarController, didBeginCustomizing viewControllers: [UIViewController]) {
			guard let storage = tabBarController.delegate as? Storage else { return }
			let identifiers = viewControllers.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBarController, viewControllers, identifiers)
		}

		open func tabBarController(_ tabBarController: UITabBarController, willEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			guard let storage = tabBarController.delegate as? Storage else { return }
			let identifiers = viewControllers.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBarController, viewControllers, identifiers, changed)
		}

		open func tabBarController(_ tabBarController: UITabBarController, didEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			guard let storage = tabBarController.delegate as? Storage else { return }
			let identifiers = viewControllers.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBarController, viewControllers, identifiers, changed)
		}
		
		open func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -> Bool {
			guard let storage = tabBarController.delegate as? Storage, let identifier = storage.identifier(for: viewController) else { return false }
			return singleHandler(tabBarController, viewController, identifier)
		}
		
		open func tabBarControllerSupportedInterfaceOrientations(_ tabBarController: UITabBarController) -> UIInterfaceOrientationMask {
			return singleHandler(tabBarController)
		}
		
		open func tabBarControllerPreferredInterfaceOrientationForPresentation(_ tabBarController: UITabBarController) -> UIInterfaceOrientation {
			return singleHandler(tabBarController)
		}
		
		open func tabBarController(_ tabBarController: UITabBarController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
			return singleHandler(tabBarController, animationController)
		}
		
		open func tabBarController(_ tabBarController: UITabBarController, animationControllerForTransitionFrom fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
			guard let identifierFrom = (tabBarController.delegate as? Storage)?.identifier(for: fromVC) else { return nil }
			guard let identifierTo = (tabBarController.delegate as? Storage)?.identifier(for: toVC) else { return nil }
			return singleHandler(tabBarController, fromVC, identifierFrom, toVC, identifierTo)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabBarControllerBinding {
	public typealias TabBarControllerName<V> = BindingName<V, TabBarController<Binding.ItemIdentifierType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TabBarController<Binding.ItemIdentifierType>.Binding) -> TabBarControllerName<V> {
		return TabBarControllerName<V>(source: source, downcast: Binding.tabBarControllerBinding)
	}
}
public extension BindingName where Binding: TabBarControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabBarControllerName<$2> { return .name(TabBarController.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tabBar: TabBarControllerName<Constant<TabBar<Binding.ItemIdentifierType>>> { return .name(TabBarController.Binding.tabBar) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var customizableItems: TabBarControllerName<Dynamic<Set<Binding.ItemIdentifierType>>> { return .name(TabBarController.Binding.customizableItems) }
	static var items: TabBarControllerName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>> { return .name(TabBarController.Binding.items) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectItem: TabBarControllerName<Signal<Binding.ItemIdentifierType>> { return .name(TabBarController.Binding.selectItem) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var animationControllerForTransition: TabBarControllerName<(UITabBarController, UIViewController, Binding.ItemIdentifierType, UIViewController, Binding.ItemIdentifierType) -> UIViewControllerAnimatedTransitioning?> { return .name(TabBarController.Binding.animationControllerForTransition) }
	static var didEndCustomizing: TabBarControllerName<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void> { return .name(TabBarController.Binding.didEndCustomizing) }
	static var didSelect: TabBarControllerName<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Void> { return .name(TabBarController.Binding.didSelect) }
	static var interactionControllerForAnimation: TabBarControllerName<(UITabBarController, UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?> { return .name(TabBarController.Binding.interactionControllerForAnimation) }
	static var preferredInterfaceOrientationForPresentation: TabBarControllerName<(UITabBarController) -> UIInterfaceOrientation> { return .name(TabBarController.Binding.preferredInterfaceOrientationForPresentation) }
	static var shouldSelect: TabBarControllerName<(UITabBarController, UIViewController, Binding.ItemIdentifierType) -> Bool> { return .name(TabBarController.Binding.shouldSelect) }
	static var supportedInterfaceOrientations: TabBarControllerName<(UITabBarController) -> UIInterfaceOrientationMask> { return .name(TabBarController.Binding.supportedInterfaceOrientations) }
	static var tabConstructor: TabBarControllerName<(Binding.ItemIdentifierType) -> ViewControllerConvertible> { return .name(TabBarController.Binding.tabConstructor) }
	static var willBeginCustomizing: TabBarControllerName<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType]) -> Void> { return .name(TabBarController.Binding.willBeginCustomizing) }
	static var willEndCustomizing: TabBarControllerName<(UITabBarController, [UIViewController], [Binding.ItemIdentifierType], Bool) -> Void> { return .name(TabBarController.Binding.willEndCustomizing) }
	
	// Composite binding names
	static func tabSelected(_ void: Void = ()) -> TabBarControllerName<SignalInput<Binding.ItemIdentifierType>> {
		return Binding.compositeName(
			value: { input in { tabBarcontroller, vc, i -> Void in input.send(value: i) } },
			binding: TabBarController.Binding.didSelect,
			downcast: Binding.tabBarControllerBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TabBarControllerConvertible: ViewControllerConvertible {
	func uiTabBarController() -> UITabBarController
}
extension TabBarControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiTabBarController() }
}
extension UITabBarController: TabBarControllerConvertible, HasDelegate {
	public func uiTabBarController() -> UITabBarController { return self }
}
public extension TabBarController {
	func uiTabBarController() -> UITabBarController { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TabBarControllerBinding: ViewControllerBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarControllerBinding(_ binding: TabBarController<ItemIdentifierType>.Binding) -> Self
	func asTabBarControllerBinding() -> TabBarController<ItemIdentifierType>.Binding?
}
public extension TabBarControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return tabBarControllerBinding(TabBarController<ItemIdentifierType>.Binding.inheritedBinding(binding))
	}
}
public extension TabBarControllerBinding where Preparer.Inherited.Binding: TabBarControllerBinding, Preparer.Inherited.Binding.ItemIdentifierType == ItemIdentifierType {
	func asTabBarControllerBinding() -> TabBarController<ItemIdentifierType>.Binding? {
		return asInheritedBinding()?.asTabBarControllerBinding()
	}
}
public extension TabBarController.Binding {
	typealias Preparer = TabBarController.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTabBarControllerBinding() -> TabBarController.Binding? { return self }
	static func tabBarControllerBinding(_ binding: TabBarController<ItemIdentifierType>.Binding) -> TabBarController<ItemIdentifierType>.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class TabBarItem: Binder, TabBarItemConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TabBarItem {
	enum Binding: TabBarItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case systemItem(Constant<UITabBarItem.SystemItem?>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case badgeColor(Dynamic<UIColor?>)
		case badgeTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>)
		case badgeValue(Dynamic<String?>)
		case selectedImage(Dynamic<UIImage?>)
		case titlePositionAdjustment(Dynamic<UIOffset>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension TabBarItem {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = TabBarItem.Binding
		public typealias Inherited = BarItem.Preparer
		public typealias Instance = UITabBarItem
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		public var systemItem: UITabBarItem.SystemItem?
		public var title = InitialSubsequent<String>()
		public var image = InitialSubsequent<UIImage?>()
		public var selectedImage = InitialSubsequent<UIImage?>()
		public var tag = InitialSubsequent<Int>()
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TabBarItem.Preparer {
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		let x: UITabBarItem
		if let si = systemItem {
			x = type.init(tabBarSystemItem: si, tag: tag.initial ?? 0)
		} else if let si = selectedImage.initial {
			x = type.init(title: title.initial ?? nil, image: image.initial ?? nil, selectedImage: si)
		} else {
			x = type.init(title: title.initial ?? nil, image: image.initial ?? nil, tag: tag.initial ?? 0)
		}
		return x
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.image(let x)): image = x.initialSubsequent()
		case .inheritedBinding(.tag(let x)): tag = x.initialSubsequent()
		case .inheritedBinding(.title(let x)): title = x.initialSubsequent()
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .selectedImage(let x): selectedImage = x.initialSubsequent()
		case .systemItem(let x): systemItem = x.value
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(.tag): return tag.resume()?.apply(instance) { i, v in i.tag = v }
		case .inheritedBinding(.image): return image.resume()?.apply(instance) { i, v in i.image = v }
		case .inheritedBinding(.title): return title.resume()?.apply(instance) { i, v in i.title = v }
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		case .systemItem: return nil
		
		case .badgeValue(let x): return x.apply(instance) { i, v in i.badgeValue = v }
		case .selectedImage: return selectedImage.resume()?.apply(instance) { i, v in i.selectedImage = v }
		case .titlePositionAdjustment(let x): return x.apply(instance) { i, v in i.titlePositionAdjustment = v }
		
		case .badgeColor(let x): return x.apply(instance) { i, v in i.badgeColor = v }
		case .badgeTextAttributes(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBadgeTextAttributes(nil, for: scope) },
				applyNew: { i, scope, v in i.setBadgeTextAttributes(v, for: scope) }
			)
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabBarItem.Preparer {
	public typealias Storage = BarItem.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabBarItemBinding {
	public typealias TabBarItemName<V> = BindingName<V, TabBarItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TabBarItem.Binding) -> TabBarItemName<V> {
		return TabBarItemName<V>(source: source, downcast: Binding.tabBarItemBinding)
	}
}
public extension BindingName where Binding: TabBarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabBarItemName<$2> { return .name(TabBarItem.Binding.$1) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TabBarItemConvertible: BarItemConvertible {
	func uiTabBarItem() -> TabBarItem.Instance
}
extension TabBarItemConvertible {
	public func uiBarItem() -> BarItem.Instance { return uiTabBarItem() }
}
extension UITabBarItem: TabBarItemConvertible {
	public func uiTabBarItem() -> TabBarItem.Instance { return self }
}
public extension TabBarItem {
	func uiTabBarItem() -> TabBarItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TabBarItemBinding: BarItemBinding {
	static func tabBarItemBinding(_ binding: TabBarItem.Binding) -> Self
	func asTabBarItemBinding() -> TabBarItem.Binding?
}
public extension TabBarItemBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return tabBarItemBinding(.inheritedBinding(binding))
	}
}
public extension TabBarItemBinding where Preparer.Inherited.Binding: TabBarItemBinding {
	func asTabBarItemBinding() -> TabBarItem.Binding? {
		return asInheritedBinding()?.asTabBarItemBinding()
	}
}
public extension TabBarItem.Binding {
	typealias Preparer = TabBarItem.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTabBarItemBinding() -> TabBarItem.Binding? { return self }
	static func tabBarItemBinding(_ binding: TabBarItem.Binding) -> TabBarItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class TabBar<ItemIdentifier: Hashable>: Binder, TabBarConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TabBar {
	enum Binding: TabBarBinding {
		public typealias ItemIdentifierType = ItemIdentifier
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundImage(Dynamic<UIImage?>)
		case barStyle(Dynamic<UIBarStyle>)
		case barTintColor(Dynamic<UIColor>)
		case isTranslucent(Dynamic<Bool>)
		case itemPositioning(Dynamic<UITabBar.ItemPositioning>)
		case items(Dynamic<SetOrAnimate<[ItemIdentifier]>>)
		case itemSpacing(Dynamic<CGFloat>)
		case itemWidth(Dynamic<CGFloat>)
		case selectionIndicatorImage(Dynamic<UIImage?>)
		case shadowImage(Dynamic<UIImage?>)
		case tintColor(Dynamic<UIColor>)
		case unselectedItemTintColor(Dynamic<UIColor>)

		// 2. Signal bindings are performed on the object after construction.
		case customizingItems(Signal<SetOrAnimate<[ItemIdentifier]?>>)
		case selectItem(Signal<ItemIdentifier>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didBeginCustomizing((UITabBar, [UITabBarItem], [ItemIdentifier]) -> Void)
		case didEndCustomizing((UITabBar, [UITabBarItem], [ItemIdentifier], Bool) -> Void)
		case didSelectItem((UITabBar, UITabBarItem, ItemIdentifier) -> Void)
		case itemConstructor((ItemIdentifier) -> TabBarItemConvertible)
		case willBeginCustomizing((UITabBar, [UITabBarItem], [ItemIdentifier]) -> Void)
		case willEndCustomizing((UITabBar, [UITabBarItem], [ItemIdentifier], Bool) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension TabBar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = TabBar.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UITabBar
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemConvertible)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TabBar.Preparer {
	var delegateIsRequired: Bool { return true }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)

		case .didBeginCustomizing(let x): delegate().addMultiHandler3(x, #selector(UITabBarDelegate.tabBar(_:didBeginCustomizing:)))
		case .didEndCustomizing(let x): delegate().addMultiHandler4(x, #selector(UITabBarDelegate.tabBar(_:didEndCustomizing:changed:)))
		case .didSelectItem(let x): delegate().addMultiHandler3(x, #selector(UITabBarDelegate.tabBar(_:didSelect:)))
		case .itemConstructor(let x): tabBarItemConstructor = x
		case .willBeginCustomizing(let x): delegate().addMultiHandler3(x, #selector(UITabBarDelegate.tabBar(_:willBeginCustomizing:)))
		case .willEndCustomizing(let x): delegate().addMultiHandler4(x, #selector(UITabBarDelegate.tabBar(_:willEndCustomizing:changed:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		storage.tabBarItemConstructor = tabBarItemConstructor
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		// 0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundImage(let x): return x.apply(instance) { i, v in i.backgroundImage = v }
		case .barStyle(let x): return x.apply(instance) { i, v in i.barStyle = v }
		case .barTintColor(let x): return x.apply(instance) { i, v in i.barTintColor = v }
		case .isTranslucent(let x): return x.apply(instance) { i, v in i.isTranslucent = v }
		case .itemPositioning(let x): return x.apply(instance) { i, v in i.itemPositioning = v }
		case .items(let x):
			return x.apply(instance, storage) { i, s, v in
				let items = v.value.compactMap { s.tabBarItem(for: $0) }
				i.setItems(items, animated: v.isAnimated)
			}
		case .itemSpacing(let x): return x.apply(instance) { i, v in i.itemSpacing = v }
		case .itemWidth(let x): return x.apply(instance) { i, v in i.itemWidth = v }
		case .selectionIndicatorImage(let x): return x.apply(instance) { i, v in i.selectionIndicatorImage = v }
		case .shadowImage(let x): return x.apply(instance) { i, v in i.shadowImage = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }

		case .unselectedItemTintColor(let x): return x.apply(instance) { i, v in i.unselectedItemTintColor = v }

		// 2. Signal bindings are performed on the object after construction.
		case .customizingItems(let x): return x.apply(instance, storage) { i, s, v in
			if let v = v.value {
				let items = v.compactMap { s.tabBarItem(for: $0) }
				i.beginCustomizingItems(items)
			} else {
				i.endCustomizing(animated: v.isAnimated)
			}
		}
		case .selectItem(let x): return x.apply(instance, storage) { i, s, v in i.selectedItem = s.tabBarItem(for: v) }

		// 3. Action bindings are triggered by the object after construction.
		case .didBeginCustomizing: return nil
		case .didEndCustomizing: return nil
		case .didSelectItem: return nil
		case .willBeginCustomizing: return nil
		case .willEndCustomizing: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .itemConstructor: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabBar.Preparer {
	open class Storage: View.Preparer.Storage, UITabBarDelegate {
		open var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemConvertible)?
		open var allItems: [ItemIdentifier: TabBarItemConvertible] = [:]
		
		open override var isInUse: Bool { return true }
		
		open func identifier(for tabBarItem: UITabBarItem) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.uiTabBarItem() === tabBarItem
			})?.key
		}
		open func tabBarItem(for identifier: ItemIdentifier) -> UITabBarItem? {
			if let existing = allItems[identifier] {
				return existing.uiTabBarItem()
			}
			if let binding = tabBarItemConstructor {
				let new = binding(identifier)
				allItems[identifier] = new
				return new.uiTabBarItem()
			}
			return nil
		}
	}
	
	open class Delegate: DynamicDelegate, UITabBarDelegate {
		open func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
			guard let identifier = (tabBar.delegate as? Storage)?.identifier(for: item) else { return }
			multiHandler(tabBar, item, identifier)
		}

		open func tabBar(_ tabBar: UITabBar, willBeginCustomizing items: [UITabBarItem]) {
			guard let storage = tabBar.delegate as? Storage else { return }
			let identifiers = items.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBar, items, identifiers)
		}

		open func tabBar(_ tabBar: UITabBar, didBeginCustomizing items: [UITabBarItem]) {
			guard let storage = tabBar.delegate as? Storage else { return }
			let identifiers = items.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBar, items, identifiers)
		}

		open func tabBar(_ tabBar: UITabBar, willEndCustomizing items: [UITabBarItem], changed: Bool) {
			guard let storage = tabBar.delegate as? Storage else { return }
			let identifiers = items.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBar, items, identifiers, changed)
		}

		open func tabBar(_ tabBar: UITabBar, didEndCustomizing items: [UITabBarItem], changed: Bool) {
			guard let storage = tabBar.delegate as? Storage else { return }
			let identifiers = items.compactMap { storage.identifier(for: $0) }
			multiHandler(tabBar, items, identifiers, changed)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabBarBinding {
	public typealias TabBarName<V> = BindingName<V, TabBar<Binding.ItemIdentifierType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TabBar<Binding.ItemIdentifierType>.Binding) -> TabBarName<V> {
		return TabBarName<V>(source: source, downcast: Binding.tabBarBinding)
	}
}
public extension BindingName where Binding: TabBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabBarName<$2> { return .name(TabBar.Binding.$1) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: TabBarName<Dynamic<UIImage?>> { return .name(TabBar.Binding.backgroundImage) }
	static var barStyle: TabBarName<Dynamic<UIBarStyle>> { return .name(TabBar.Binding.barStyle) }
	static var barTintColor: TabBarName<Dynamic<UIColor>> { return .name(TabBar.Binding.barTintColor) }
	static var isTranslucent: TabBarName<Dynamic<Bool>> { return .name(TabBar.Binding.isTranslucent) }
	static var itemPositioning: TabBarName<Dynamic<UITabBar.ItemPositioning>> { return .name(TabBar.Binding.itemPositioning) }
	static var items: TabBarName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>> { return .name(TabBar.Binding.items) }
	static var itemSpacing: TabBarName<Dynamic<CGFloat>> { return .name(TabBar.Binding.itemSpacing) }
	static var itemWidth: TabBarName<Dynamic<CGFloat>> { return .name(TabBar.Binding.itemWidth) }
	static var selectionIndicatorImage: TabBarName<Dynamic<UIImage?>> { return .name(TabBar.Binding.selectionIndicatorImage) }
	static var shadowImage: TabBarName<Dynamic<UIImage?>> { return .name(TabBar.Binding.shadowImage) }
	static var tintColor: TabBarName<Dynamic<UIColor>> { return .name(TabBar.Binding.tintColor) }
	static var unselectedItemTintColor: TabBarName<Dynamic<UIColor>> { return .name(TabBar.Binding.unselectedItemTintColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var customizingItems: TabBarName<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>> { return .name(TabBar.Binding.customizingItems) }
	static var selectItem: TabBarName<Signal<Binding.ItemIdentifierType>> { return .name(TabBar.Binding.selectItem) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginCustomizing: TabBarName<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void> { return .name(TabBar.Binding.didBeginCustomizing) }
	static var didEndCustomizing: TabBarName<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void> { return .name(TabBar.Binding.didEndCustomizing) }
	static var didSelectItem: TabBarName<(UITabBar, UITabBarItem, Binding.ItemIdentifierType) -> Void> { return .name(TabBar.Binding.didSelectItem) }
	static var itemConstructor: TabBarName<(Binding.ItemIdentifierType) -> TabBarItemConvertible> { return .name(TabBar.Binding.itemConstructor) }
	static var willBeginCustomizing: TabBarName<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType]) -> Void> { return .name(TabBar.Binding.willBeginCustomizing) }
	static var willEndCustomizing: TabBarName<(UITabBar, [UITabBarItem], [Binding.ItemIdentifierType], Bool) -> Void> { return .name(TabBar.Binding.willEndCustomizing) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TabBarConvertible: ViewConvertible {
	func uiTabBar() -> UITabBar
}
extension TabBarConvertible {
	public func uiView() -> View.Instance { return uiTabBar() }
}
extension UITabBar: TabBarConvertible, HasDelegate {
	public func uiTabBar() -> UITabBar { return self }
}
public extension TabBar {
	func uiTabBar() -> UITabBar { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TabBarBinding: ViewBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarBinding(_ binding: TabBar<ItemIdentifierType>.Binding) -> Self
	func asTabBarBinding() -> TabBar<ItemIdentifierType>.Binding?
}
public extension TabBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tabBarBinding(TabBar<ItemIdentifierType>.Binding.inheritedBinding(binding))
	}
}
public extension TabBarBinding where Preparer.Inherited.Binding: TabBarBinding, Preparer.Inherited.Binding.ItemIdentifierType == ItemIdentifierType {
	func asTabBarBinding() -> TabBar<ItemIdentifierType>.Binding? {
		return asInheritedBinding()?.asTabBarBinding()
	}
}
public extension TabBar.Binding {
	typealias Preparer = TabBar.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTabBarBinding() -> TabBar.Binding? { return self }
	static func tabBarBinding(_ binding: TabBar<ItemIdentifierType>.Binding) -> TabBar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class TableViewCell: Binder, TableViewCellConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}
extension Binder where Preparer.Binding: TableViewCellBinding, Preparer.Parameters == String? {
	public init(type: Preparer.Instance.Type = Preparer.Instance.self, reuseIdentifier: String? = nil, _ bindings: Preparer.Binding...) {
		self.init(type: type, parameters: reuseIdentifier, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TableViewCell {
	enum Binding: TableViewCellBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case cellStyle(Constant<UITableViewCell.CellStyle>)
		case contentView(Constant<View>)
		case detailLabel(Constant<Label>)
		case imageView(Constant<ImageView>)
		case textLabel(Constant<Label>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case accessoryType(Dynamic<UITableViewCell.AccessoryType>)
		case accessoryView(Dynamic<ViewConvertible>)
		case backgroundView(Dynamic<ViewConvertible?>)
		case editingAccessoryType(Dynamic<UITableViewCell.AccessoryType>)
		case editingAccessoryView(Dynamic<ViewConvertible>)
		case focusStyle(Dynamic<UITableViewCell.FocusStyle>)
		case indentationLevel(Dynamic<Int>)
		case indentationWidth(Dynamic<CGFloat>)
		case isEditing(Dynamic<SetOrAnimate<Bool>>)
		case isHighlighted(Dynamic<SetOrAnimate<Bool>>)
		case isSelected(Dynamic<SetOrAnimate<Bool>>)
		case multipleSelectionBackgroundView(Dynamic<ViewConvertible?>)
		case selectedBackgroundView(Dynamic<ViewConvertible?>)
		case separatorInset(Dynamic<UIEdgeInsets>)
		case shouldIndentWhileEditing(Dynamic<Bool>)
		case showsReorderControl(Dynamic<Bool>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension TableViewCell {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = TableViewCell.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UITableViewCell
		public typealias Parameters = String?
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var cellStyle: UITableViewCell.CellStyle = .default
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TableViewCell.Preparer {
	func constructInstance(type: Instance.Type, parameters: String?) -> Instance {
		return type.init(style: cellStyle, reuseIdentifier: parameters)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .cellStyle(let x): cellStyle = x.value
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .cellStyle: return nil
		case .contentView(let x):
			x.value.apply(to: instance.contentView)
			return nil
		case .detailLabel(let x):
			if let l = instance.detailTextLabel {
				x.value.apply(to: l)
			}
			return nil
		case .imageView(let x):
			if let l = instance.imageView {
				x.value.apply(to: l)
			}
			return nil
		case .textLabel(let x):
			if let l = instance.textLabel {
				x.value.apply(to: l)
			}
			return nil
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .accessoryType(let x): return x.apply(instance) { i, v in i.accessoryType = v }
		case .accessoryView(let x): return x.apply(instance) { i, v in i.accessoryView = v.uiView() }
		case .backgroundView(let x): return x.apply(instance) { i, v in i.backgroundView = v?.uiView() }
		case .editingAccessoryType(let x): return x.apply(instance) { i, v in i.editingAccessoryType = v }
		case .editingAccessoryView(let x): return x.apply(instance) { i, v in i.editingAccessoryView = v.uiView() }
		case .focusStyle(let x): return x.apply(instance) { i, v in i.focusStyle = v }
		case .indentationLevel(let x): return x.apply(instance) { i, v in i.indentationLevel = v }
		case .indentationWidth(let x): return x.apply(instance) { i, v in i.indentationWidth = v }
		case .isEditing(let x): return x.apply(instance) { i, v in i.setEditing(v.value, animated: v.isAnimated) }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.setHighlighted(v.value, animated: v.isAnimated) }
		case .isSelected(let x): return x.apply(instance) { i, v in i.setSelected(v.value, animated: v.isAnimated) }
		case .multipleSelectionBackgroundView(let x): return x.apply(instance) { i, v in i.multipleSelectionBackgroundView = v?.uiView() }
		case .selectedBackgroundView(let x): return x.apply(instance) { i, v in i.selectedBackgroundView = v?.uiView() }
		case .separatorInset(let x): return x.apply(instance) { i, v in i.separatorInset = v }
		case .shouldIndentWhileEditing(let x): return x.apply(instance) { i, v in i.shouldIndentWhileEditing = v }
		case .showsReorderControl(let x): return x.apply(instance) { i, v in i.showsReorderControl = v }
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableViewCell.Preparer {
	public typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableViewCellBinding {
	public typealias TableViewCellName<V> = BindingName<V, TableViewCell.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TableViewCell.Binding) -> TableViewCellName<V> {
		return TableViewCellName<V>(source: source, downcast: Binding.tableViewCellBinding)
	}
}
public extension BindingName where Binding: TableViewCellBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableViewCellName<$2> { return .name(TableViewCell.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var cellStyle: TableViewCellName<Constant<UITableViewCell.CellStyle>> { return .name(TableViewCell.Binding.cellStyle) }
	static var contentView: TableViewCellName<Constant<View>> { return .name(TableViewCell.Binding.contentView) }
	static var detailLabel: TableViewCellName<Constant<Label>> { return .name(TableViewCell.Binding.detailLabel) }
	static var imageView: TableViewCellName<Constant<ImageView>> { return .name(TableViewCell.Binding.imageView) }
	static var textLabel: TableViewCellName<Constant<Label>> { return .name(TableViewCell.Binding.textLabel) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var accessoryType: TableViewCellName<Dynamic<UITableViewCell.AccessoryType>> { return .name(TableViewCell.Binding.accessoryType) }
	static var accessoryView: TableViewCellName<Dynamic<ViewConvertible>> { return .name(TableViewCell.Binding.accessoryView) }
	static var backgroundView: TableViewCellName<Dynamic<ViewConvertible?>> { return .name(TableViewCell.Binding.backgroundView) }
	static var editingAccessoryType: TableViewCellName<Dynamic<UITableViewCell.AccessoryType>> { return .name(TableViewCell.Binding.editingAccessoryType) }
	static var editingAccessoryView: TableViewCellName<Dynamic<ViewConvertible>> { return .name(TableViewCell.Binding.editingAccessoryView) }
	static var focusStyle: TableViewCellName<Dynamic<UITableViewCell.FocusStyle>> { return .name(TableViewCell.Binding.focusStyle) }
	static var indentationLevel: TableViewCellName<Dynamic<Int>> { return .name(TableViewCell.Binding.indentationLevel) }
	static var indentationWidth: TableViewCellName<Dynamic<CGFloat>> { return .name(TableViewCell.Binding.indentationWidth) }
	static var isEditing: TableViewCellName<Dynamic<SetOrAnimate<Bool>>> { return .name(TableViewCell.Binding.isEditing) }
	static var isHighlighted: TableViewCellName<Dynamic<SetOrAnimate<Bool>>> { return .name(TableViewCell.Binding.isHighlighted) }
	static var isSelected: TableViewCellName<Dynamic<SetOrAnimate<Bool>>> { return .name(TableViewCell.Binding.isSelected) }
	static var multipleSelectionBackgroundView: TableViewCellName<Dynamic<ViewConvertible?>> { return .name(TableViewCell.Binding.multipleSelectionBackgroundView) }
	static var selectedBackgroundView: TableViewCellName<Dynamic<ViewConvertible?>> { return .name(TableViewCell.Binding.selectedBackgroundView) }
	static var separatorInset: TableViewCellName<Dynamic<UIEdgeInsets>> { return .name(TableViewCell.Binding.separatorInset) }
	static var shouldIndentWhileEditing: TableViewCellName<Dynamic<Bool>> { return .name(TableViewCell.Binding.shouldIndentWhileEditing) }
	static var showsReorderControl: TableViewCellName<Dynamic<Bool>> { return .name(TableViewCell.Binding.showsReorderControl) }
	
	//	2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TableViewCellConvertible: ViewConvertible {
	func uiTableViewCell(reuseIdentifier: String?) -> TableViewCell.Instance
}
extension TableViewCellConvertible {
	public func uiTableViewCell() -> TableViewCell.Instance { return uiTableViewCell(reuseIdentifier: nil) }
	public func uiView() -> View.Instance { return uiTableViewCell() }
}
extension UITableViewCell: TableViewCellConvertible {
	public func uiTableViewCell(reuseIdentifier: String?) -> TableViewCell.Instance { return self }
}
public extension TableViewCell {
	func uiTableViewCell(reuseIdentifier: String?) -> TableViewCell.Instance { return instance(parameters: reuseIdentifier) }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TableViewCellBinding: ViewBinding {
	static func tableViewCellBinding(_ binding: TableViewCell.Binding) -> Self
	func asTableViewCellBinding() -> TableViewCell.Binding?
}
public extension TableViewCellBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tableViewCellBinding(.inheritedBinding(binding))
	}
}
public extension TableViewCellBinding where Preparer.Inherited.Binding: TableViewCellBinding {
	func asTableViewCellBinding() -> TableViewCell.Binding? {
		return asInheritedBinding()?.asTableViewCellBinding()
	}
}
public extension TableViewCell.Binding {
	typealias Preparer = TableViewCell.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableViewCellBinding() -> TableViewCell.Binding? { return self }
	static func tableViewCellBinding(_ binding: TableViewCell.Binding) -> TableViewCell.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
private var associatedInputKey = NSObject()
public extension UITableViewCell {
	func associatedRowInput<B>(valueType: B.Type) -> 
		SignalInput<B>? {
			return objc_getAssociatedObject(self, &associatedInputKey) as? SignalInput<B>
	}
	
	func setAssociatedRowInput<B>(to input: SignalInput<B>) {
		objc_setAssociatedObject(self, &associatedInputKey, input, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class TableView<RowData>: Binder, TableViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TableView {
	enum Binding: TableViewBinding {
		public typealias RowDataType = RowData
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case tableViewStyle(Constant<UITableView.Style>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsMultipleSelection(Dynamic<Bool>)
		case allowsMultipleSelectionDuringEditing(Dynamic<Bool>)
		case allowsSelection(Dynamic<Bool>)
		case allowsSelectionDuringEditing(Dynamic<Bool>)
		case backgroundView(Dynamic<ViewConvertible?>)
		case cellLayoutMarginsFollowReadableWidth(Dynamic<Bool>)
		case estimatedRowHeight(Dynamic<CGFloat>)
		case estimatedSectionFooterHeight(Dynamic<CGFloat>)
		case estimatedSectionHeaderHeight(Dynamic<CGFloat>)
		case isEditing(Signal<SetOrAnimate<Bool>>)
		case remembersLastFocusedIndexPath(Dynamic<Bool>)
		case rowHeight(Dynamic<CGFloat>)
		case sectionFooterHeight(Dynamic<CGFloat>)
		case sectionHeaderHeight(Dynamic<CGFloat>)
		case sectionIndexBackgroundColor(Dynamic<UIColor?>)
		case sectionIndexColor(Dynamic<UIColor?>)
		case sectionIndexMinimumDisplayRowCount(Dynamic<Int>)
		case sectionIndexTitles(Dynamic<[String]?>)
		case sectionIndexTrackingBackgroundColor(Dynamic<UIColor?>)
		case separatorColor(Dynamic<UIColor?>)
		case separatorEffect(Dynamic<UIVisualEffect?>)
		case separatorInset(Dynamic<UIEdgeInsets>)
		case separatorInsetReference(Dynamic<UITableView.SeparatorInsetReference>)
		case separatorStyle(Dynamic<UITableViewCell.SeparatorStyle>)
		case tableData(Dynamic<TableSectionAnimatable<RowData>>)
		case tableFooterView(Dynamic<ViewConvertible?>)
		case tableHeaderView(Dynamic<ViewConvertible?>)
		
		//	2. Signal bindings are performed on the object after construction.
		case deselectRow(Signal<SetOrAnimate<IndexPath>>)
		case scrollToNearestSelectedRow(Signal<SetOrAnimate<UITableView.ScrollPosition>>)
		case scrollToRow(Signal<SetOrAnimate<TableScrollPosition>>)
		case selectRow(Signal<SetOrAnimate<TableScrollPosition?>>)
		
		//	3. Action bindings are triggered by the object after construction.
		case selectionDidChange(SignalInput<[TableRow<RowData>]?>)
		case userDidScrollToRow(SignalInput<TableRow<RowData>>)
		case visibleRowsChanged(SignalInput<[TableRow<RowData>]>)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case accessoryButtonTapped((UITableView, TableRow<RowData>) -> Void)
		case canEditRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case canFocusRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case canMoveRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case canPerformAction((_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<RowData>, _ sender: Any?) -> Bool)
		case cellConstructor((_ identifier: String?, _ rowSignal: SignalMulti<RowData>) -> TableViewCellConvertible)
		case cellIdentifier((TableRow<RowData>) -> String?)
		case commit((UITableView, UITableViewCell.EditingStyle, TableRow<RowData>) -> Void)
		case dataMissingCell((IndexPath) -> TableViewCellConvertible)
		case didDeselectRow((UITableView, TableRow<RowData>) -> Void)
		case didEndDisplayingCell((UITableView, UITableViewCell, TableRow<RowData>) -> Void)
		case didEndDisplayingFooter((UITableView, UIView, Int) -> Void)
		case didEndDisplayingHeader((UITableView, UIView, Int) -> Void)
		case didEndEditingRow((UITableView, TableRow<RowData>?) -> Void)
		case didHightlightRow((UITableView, TableRow<RowData>) -> Void)
		case didSelectRow((UITableView, TableRow<RowData>) -> Void)
		case didUnhighlightRow((UITableView, TableRow<RowData>) -> Void)
		case didUpdateFocus((UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void)
		case editActionsForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> [UITableViewRowAction]?)
		case editingStyleForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> UITableViewCell.EditingStyle)
		case estimatedHeightForFooter((_ tableView: UITableView, _ section: Int) -> CGFloat)
		case estimatedHeightForHeader((_ tableView: UITableView, _ section: Int) -> CGFloat)
		case estimatedHeightForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> CGFloat)
		case footerHeight((_ tableView: UITableView, _ section: Int) -> CGFloat)
		case footerView((_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?)
		case headerHeight((_ tableView: UITableView, _ section: Int) -> CGFloat)
		case headerView((_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?)
		case heightForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> CGFloat)
		case indentationLevelForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Int)
		case indexPathForPreferredFocusedView((UITableView) -> IndexPath)
		case moveRow((UITableView, TableRow<RowData>, IndexPath) -> Void)
		case shouldHighlightRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case shouldIndentWhileEditingRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case shouldShowMenuForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Bool)
		case shouldUpdateFocus((UITableView, UITableViewFocusUpdateContext) -> Bool)
		case targetIndexPathForMoveFromRow((_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath)
		case titleForDeleteConfirmationButtonForRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> String?)
		case willBeginEditingRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Void)
		case willDeselectRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)
		case willDisplayFooter((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)
		case willDisplayHeader((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)
		case willDisplayRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>, _ cell: UITableViewCell) -> Void)
		case willSelectRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)
	}
}

// MARK: - Binder Part 3: Preparer
public extension TableView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = TableView.Binding
		public typealias Inherited = ScrollView.Preparer
		public typealias Instance = UITableView
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage(rowsChanged: rowsChanged, cellIdentifier: cellIdentifier) }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var cellIdentifier: (TableRow<RowData>) -> String? = { _ in nil }
		var rowsChanged: MultiOutput<[TableRow<RowData>]>? = nil
		var tableViewStyle: UITableView.Style = .plain
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TableView.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		return type.init(frame: CGRect.zero, style: tableViewStyle)
	}
	
	private static func tableRowData(at indexPath: IndexPath, in tableView: UITableView) -> TableRow<RowData> {
		return TableRow<RowData>(indexPath: indexPath, data: (tableView.delegate as? TableView<RowData>.Preparer.Storage)?.sections.values?.at(indexPath.section)?.values?.at(indexPath.row))
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .tableViewStyle(let x): tableViewStyle = x.value
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case .userDidScrollToRow(let x):
			delegate().addMultiHandler1(
				{ (sv: UIScrollView) -> Void in
					guard let tableView = sv as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.first else { return }
					_ = x.send(value: TableView.Preparer.tableRowData(at: topVisibleRow, in: tableView))
				},
				#selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
			)
			delegate().addMultiHandler2(
				{ (sv: UIScrollView, d: Bool) -> Void in
					guard !d, let tableView = sv as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.first else { return }
					_ = x.send(value: TableView.Preparer.tableRowData(at: topVisibleRow, in: tableView))
				},
				#selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
			)
			delegate().addMultiHandler1(
				{ (sv: UIScrollView) -> Void in
					guard let tableView = sv as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.first else { return }
					_ = x.send(value: TableView.Preparer.tableRowData(at: topVisibleRow, in: tableView))
				},
				#selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
			)
		case .visibleRowsChanged(let x):
			rowsChanged = rowsChanged ?? Input().multicast()
			rowsChanged?.signal.bind(to: x)
			delegate().addMultiHandler3(
				{ (tv: UITableView, _: IndexPath, _: UITableViewCell) -> Void in
					_ = (tv.delegate as? Storage)?.notifyVisibleRowsChanged(in: tv)
				},
				#selector(UITableViewDelegate.tableView(_:willDisplay:forRowAt:))
			)
			delegate().addMultiHandler3(
				{ (tv: UITableView, _: IndexPath, _: UITableViewCell) -> Void in
					_ = (tv.delegate as? Storage)?.notifyVisibleRowsChanged(in: tv)
				},
				#selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:))
			)
			
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .accessoryButtonTapped(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:accessoryButtonTappedForRowWith:)))
		case .commit(let x): delegate().addMultiHandler3(x, #selector(UITableViewDataSource.tableView(_:commit:forRowAt:)))
		case .didDeselectRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didDeselectRowAt:)))
		case .didEndDisplayingFooter(let x): delegate().addMultiHandler3(x, #selector(UITableViewDelegate.tableView(_:didEndDisplayingFooterView:forSection:)))
		case .didEndDisplayingHeader(let x): delegate().addMultiHandler3(x, #selector(UITableViewDelegate.tableView(_:didEndDisplayingHeaderView:forSection:)))
		case .didEndDisplayingCell(let x): delegate().addMultiHandler3(x, #selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:)))
		case .didEndEditingRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didEndEditingRowAt:)))
		case .didHightlightRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didHighlightRowAt:)))
		case .didSelectRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didSelectRowAt:)))
		case .didUnhighlightRow(let x): delegate().addMultiHandler2(x, #selector(UITableViewDelegate.tableView(_:didUnhighlightRowAt:)))
		case .moveRow(let x): delegate().addMultiHandler3(x, #selector(UITableViewDataSource.tableView(_:moveRowAt:to:)))
		case .canEditRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDataSource.tableView(_:canEditRowAt:)))
		case .canFocusRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:canFocusRowAt:)))
		case .canMoveRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDataSource.tableView(_:canMoveRowAt:)))
		case .canPerformAction(let x): delegate().addSingleHandler4(x, #selector(UITableViewDelegate.tableView(_:canPerformAction:forRowAt:withSender:)))
		case .cellIdentifier(let x): cellIdentifier = x
		case .didUpdateFocus(let x): delegate().addMultiHandler3(x, #selector(UITableViewDelegate.tableView(_:didUpdateFocusIn:with:)))
		case .editActionsForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:editActionsForRowAt:)))
		case .editingStyleForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:editingStyleForRowAt:)))
		case .estimatedHeightForFooter(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:estimatedHeightForFooterInSection:)))
		case .estimatedHeightForHeader(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:estimatedHeightForHeaderInSection:)))
		case .estimatedHeightForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:estimatedHeightForRowAt:)))
		case .footerHeight(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:heightForFooterInSection:)))
		case .footerView(let x): delegate().addSingleHandler3(x, #selector(UITableViewDelegate.tableView(_:viewForFooterInSection:)))
		case .headerHeight(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:heightForHeaderInSection:)))
		case .headerView(let x): delegate().addSingleHandler3(x, #selector(UITableViewDelegate.tableView(_:viewForHeaderInSection:)))
		case .heightForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:heightForRowAt:)))
		case .indentationLevelForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:indentationLevelForRowAt:)))
		case .indexPathForPreferredFocusedView(let x): delegate().addSingleHandler1(x, #selector(UITableViewDelegate.indexPathForPreferredFocusedView(in:)))
		case .shouldHighlightRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:shouldHighlightRowAt:)))
		case .shouldIndentWhileEditingRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:shouldIndentWhileEditingRowAt:)))
		case .shouldShowMenuForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:shouldShowMenuForRowAt:)))
		case .shouldUpdateFocus(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:shouldUpdateFocusIn:)))
		case .targetIndexPathForMoveFromRow(let x): delegate().addSingleHandler3(x, #selector(UITableViewDelegate.tableView(_:targetIndexPathForMoveFromRowAt:toProposedIndexPath:)))
		case .titleForDeleteConfirmationButtonForRow(let x): delegate().addSingleHandler2(x, #selector(UITableViewDelegate.tableView(_:titleForDeleteConfirmationButtonForRowAt:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)

		prepareDelegate(instance: instance, storage: storage)
		instance.dataSource = storage
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .tableViewStyle: return nil
		
		case .allowsMultipleSelection(let x): return x.apply(instance) { i, v in i.allowsMultipleSelection = v }
		case .allowsMultipleSelectionDuringEditing(let x): return x.apply(instance) { i, v in i.allowsMultipleSelectionDuringEditing = v }
		case .allowsSelection(let x): return x.apply(instance) { i, v in i.allowsSelection = v }
		case .allowsSelectionDuringEditing(let x): return x.apply(instance) { i, v in i.allowsSelectionDuringEditing = v }
		case .backgroundView(let x): return x.apply(instance) { i, v in i.backgroundView = v?.uiView() }
		case .cellLayoutMarginsFollowReadableWidth(let x): return x.apply(instance) { i, v in i.cellLayoutMarginsFollowReadableWidth = v }
		case .isEditing(let x): return x.apply(instance) { i, v in i.setEditing(v.value, animated: v.isAnimated) }
		case .estimatedRowHeight(let x): return x.apply(instance) { i, v in i.estimatedRowHeight = v }
		case .estimatedSectionFooterHeight(let x): return x.apply(instance) { i, v in i.estimatedSectionFooterHeight = v }
		case .estimatedSectionHeaderHeight(let x): return x.apply(instance) { i, v in i.estimatedSectionHeaderHeight = v }
		case .remembersLastFocusedIndexPath(let x): return x.apply(instance) { i, v in i.remembersLastFocusedIndexPath = v }
		case .rowHeight(let x): return x.apply(instance) { i, v in i.rowHeight = v }
		case .sectionFooterHeight(let x): return x.apply(instance) { i, v in i.sectionFooterHeight = v }
		case .sectionHeaderHeight(let x): return x.apply(instance) { i, v in i.sectionHeaderHeight = v }
		case .sectionIndexBackgroundColor(let x): return x.apply(instance) { i, v in i.sectionIndexBackgroundColor = v }
		case .sectionIndexColor(let x): return x.apply(instance) { i, v in i.sectionIndexColor = v }
		case .sectionIndexMinimumDisplayRowCount(let x): return x.apply(instance) { i, v in i.sectionIndexMinimumDisplayRowCount = v }
		case .sectionIndexTrackingBackgroundColor(let x): return x.apply(instance) { i, v in i.sectionIndexTrackingBackgroundColor = v }
		case .separatorColor(let x): return x.apply(instance) { i, v in i.separatorColor = v }
		case .separatorEffect(let x): return x.apply(instance) { i, v in i.separatorEffect = v }
		case .separatorInset(let x): return x.apply(instance) { i, v in i.separatorInset = v }
		case .separatorInsetReference(let x): return x.apply(instance) { i, v in i.separatorInsetReference = v }
		case .separatorStyle(let x): return x.apply(instance) { i, v in i.separatorStyle = v }
		case .tableFooterView(let x): return x.apply(instance) { i, v	in i.tableFooterView = v?.uiView() }
		case .tableHeaderView(let x): return x.apply(instance) { i, v in i.tableHeaderView = v?.uiView() }
		
		//	2. Signal bindings are performed on the object after construction.
		case .deselectRow(let x): return x.apply(instance) { i, v in i.deselectRow(at: v.value, animated: v.isAnimated) }
		case .scrollToNearestSelectedRow(let x): return x.apply(instance) { i, v in i.scrollToNearestSelectedRow(at: v.value, animated: v.isAnimated) }
		case .scrollToRow(let x):
			// You can't scroll a table view until *after* the number of sections and rows has been read from the data source.
			// This occurs on didAddToWindow but the easiest way to track it is by waiting for the contentSize to be set (which is set for the first time immediately after the row count is read). This makes assumptions about internal logic of UITableView â if this logic changes in future, scrolls set on load might be lost (not a catastrophic problem).
			// Capture the scroll signal to stall it
			let capture = x.capture()
			
			// Create a signal pair that will join the capture to the destination *after* the first `contentSize` change is observed
			let pair = Signal<SetOrAnimate<TableScrollPosition>>.create()
			var kvo: NSKeyValueObservation? = instance.observe(\.contentSize) { (i, change) in
				_ = try? capture.bind(to: pair.input, resend: .all)
			}
			
			// Use the output of the pair to apply the effects as normal
			return pair.signal.apply(instance) { i, v in
				// Remove the key value observing after the first value is received.
				if let k = kvo {
					k.invalidate()
					kvo = nil
				}
				
				// Clamp to the number of actual sections and rows
				var indexPath = v.value.indexPath
				if indexPath.section >= i.numberOfSections {
					indexPath.section = i.numberOfSections - 1
				}
				if indexPath.section < 0 {
					return
				}
				if indexPath.row >= i.numberOfRows(inSection: indexPath.section) {
					indexPath.row = i.numberOfRows(inSection: indexPath.section) - 1
				}
				if indexPath.row < 0 {
					return
				}
				
				// Finally, perform the scroll
				i.scrollToRow(at: indexPath, at: v.value.position, animated: v.isAnimated)
			}
		case .selectRow(let x):
			return x.apply(instance) { i, v in
				i.selectRow(at: v.value?.indexPath, animated: v.isAnimated, scrollPosition: v.value?.position ?? .none)
			}
			
		//	3. Action bindings are triggered by the object after construction.
		case .accessoryButtonTapped: return nil
		case .commit: return nil
		case .didDeselectRow: return nil
		case .didEndDisplayingFooter: return nil
		case .didEndDisplayingHeader: return nil
		case .didEndDisplayingCell: return nil
		case .didEndEditingRow: return nil
		case .didHightlightRow: return nil
		case .didSelectRow: return nil
		case .didUnhighlightRow: return nil
		case .moveRow: return nil
		case .selectionDidChange(let x):
			return Signal.notifications(name: UITableView.selectionDidChangeNotification, object: instance).map { n -> ([TableRow<RowData>])? in
				if let tableView = n.object as? UITableView, let selection = tableView.indexPathsForSelectedRows {
					if let sections = (tableView.delegate as? Storage)?.sections.values {
						return selection.compactMap { indexPath in
							return TableRow<RowData>(indexPath: indexPath, data: sections.at(indexPath.section)?.values?.at(indexPath.row))
						}
					} else {
						return selection.map { indexPath in TableRow<RowData>(indexPath: indexPath, data: nil) }
					}
				} else {
					return nil
				}
			}.cancellableBind(to: x)
		case .userDidScrollToRow: return nil
		case .visibleRowsChanged: return nil
			
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .canEditRow: return nil
		case .canFocusRow: return nil
		case .canMoveRow: return nil
		case .canPerformAction: return nil
		case .cellConstructor(let x):
			storage.cellConstructor = x
			return nil
		case .cellIdentifier: return nil
		case .dataMissingCell(let x):
			storage.dataMissingCell = x
			return nil
		case .didUpdateFocus: return nil
		case .editActionsForRow: return nil
		case .editingStyleForRow: return nil
		case .estimatedHeightForFooter: return nil
		case .estimatedHeightForHeader: return nil
		case .estimatedHeightForRow: return nil
		case .footerHeight: return nil
		case .footerView: return nil
		case .headerHeight: return nil
		case .headerView: return nil
		case .heightForRow: return nil
		case .indentationLevelForRow: return nil
		case .indexPathForPreferredFocusedView: return nil
		case .sectionIndexTitles(let x):
			return x.apply(instance, storage) { i, s, v in
				s.indexTitles = v
				i.reloadSectionIndexTitles()
			}
		case .shouldHighlightRow: return nil
		case .shouldIndentWhileEditingRow: return nil
		case .shouldShowMenuForRow: return nil
		case .shouldUpdateFocus: return nil
		case .tableData(let x): return x.apply(instance, storage) { i, s, v in s.applySectionAnimation(v, to: i) }
		case .targetIndexPathForMoveFromRow: return nil
		case .titleForDeleteConfirmationButtonForRow: return nil
		case .willBeginEditingRow: return nil
		case .willDeselectRow: return nil
		case .willDisplayFooter: return nil
		case .willDisplayHeader: return nil
		case .willDisplayRow: return nil
		case .willSelectRow: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableView.Preparer {
	open class Storage: ScrollView.Preparer.Storage, UITableViewDelegate, UITableViewDataSource {
		open override var isInUse: Bool { return true }
		
		open var sections = TableSectionState<RowData>()
		open var indexTitles: [String]? = nil
		open var scrollJunction: (SignalCapture<SetOrAnimate<(IndexPath, UITableView.ScrollPosition)>>, SignalInput<SetOrAnimate<(IndexPath, UITableView.ScrollPosition)>>)? = nil
		open var cellIdentifier: (TableRow<RowData>) -> String?
		open var cellConstructor: ((_ identifier: String?, _ rowSignal: SignalMulti<RowData>) -> TableViewCellConvertible)?
		open var dataMissingCell: (IndexPath) -> TableViewCellConvertible = { _ in return TableViewCell() }
		public let rowsChanged: MultiOutput<[TableRow<RowData>]>?
		
		public init(rowsChanged: MultiOutput<[TableRow<RowData>]>?, cellIdentifier: @escaping (TableRow<RowData>) -> String?) {
			self.rowsChanged = rowsChanged
			self.cellIdentifier = cellIdentifier
			super.init()
		}
		
		open func numberOfSections(in tableView: UITableView) -> Int {
			return sections.globalCount
		}
		
		open func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
			return sections.values?.at(section)?.globalCount ?? 0
		}
		
		open func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
			let data = sections.values?.at(indexPath.section).flatMap { section in section.values?.at(indexPath.row - section.localOffset) }
			let identifier = cellIdentifier(TableRow(indexPath: indexPath, data: data))
			
			let cellView: UITableViewCell
			let cellInput: SignalInput<RowData>?
			if let i = identifier, let reusedView = tableView.dequeueReusableCell(withIdentifier: i) {
				cellView = reusedView
				cellInput = reusedView.associatedRowInput(valueType: RowData.self)
			} else if let cc = cellConstructor {
				let dataTuple = Input<RowData>().multicast()
				let constructed = cc(identifier, dataTuple.signal).uiTableViewCell(reuseIdentifier: identifier)
				cellView = constructed
				cellInput = dataTuple.input
				constructed.setAssociatedRowInput(to: dataTuple.input)
			} else {
				return dataMissingCell(indexPath).uiTableViewCell(reuseIdentifier: nil)
			}
			
			if let d = data {
				_ = cellInput?.send(value: d)
			}
			
			return cellView
		}
		
		open func tableView(_ tableView: UITableView, titleForHeaderInSection: Int) -> String? {
			return sections.values?.at(titleForHeaderInSection)?.leaf?.header
		}
		
		open func tableView(_ tableView: UITableView, titleForFooterInSection: Int) -> String? {
			return sections.values?.at(titleForFooterInSection)?.leaf?.footer
		}
		
		open func sectionIndexTitles(for tableView: UITableView) -> [String]? {
			return indexTitles
		}
		
		open func notifyVisibleRowsChanged(in tableView: UITableView) {
			guard let rowsChanged = rowsChanged else { return }
			DispatchQueue.main.async { [rowsChanged] in
				if let indexPaths = tableView.indexPathsForVisibleRows, indexPaths.count > 0 {
					rowsChanged.input.send(value: indexPaths.map { indexPath in TableRow<RowData>(indexPath: indexPath, data: self.sections.values?.at(indexPath.section)?.values?.at(indexPath.row)) })
				} else {
					rowsChanged.input.send(value: [])
				}
			}
		}
		
		open func applySectionAnimation(_ sectionAnimatable: TableSectionAnimatable<RowData>, to i: UITableView) {
			let sectionMutation = sectionAnimatable.value
			
			if case .update = sectionMutation.kind {
				for (mutationIndex, rowIndex) in sectionMutation.indexSet.enumerated() {
					sectionMutation.values[mutationIndex].mapMetadata { _ in () }.apply(to: &sections.values![rowIndex].values!)
					sectionMutation.values[mutationIndex].updateMetadata(&sections.values![rowIndex])
				}
			} else {
				sectionMutation.mapValues { rowMutation -> TableRowState<RowData> in
					var rowState = TableRowState<RowData>()
					rowMutation.apply(toSubrange: &rowState)
					return rowState
				}.apply(toSubrange: &sections)
			}
			sectionMutation.updateMetadata(&sections)
			
			let animation = sectionAnimatable.animation ?? .none
			switch sectionMutation.kind {
			case .delete:
				i.deleteSections(sectionMutation.indexSet.offset(by: sections.localOffset), with: animation)
			case .move(let destination):
				i.performBatchUpdates({
					for (count, index) in sectionMutation.indexSet.offset(by: sections.localOffset).enumerated() {
						i.moveSection(index, toSection: destination + count)
					}
				}, completion: nil)
			case .insert:
				i.insertSections(sectionMutation.indexSet.offset(by: sections.localOffset), with: animation)
			case .scroll:
				i.reloadSections(sectionMutation.indexSet.offset(by: sections.localOffset), with: animation)
			case .update:
				i.performBatchUpdates({
					for (sectionIndex, change) in zip(sectionMutation.indexSet.offset(by: sections.localOffset), sectionMutation.values) {
						if change.metadata?.leaf != nil {
							i.reloadSections([sectionIndex], with: animation)
						} else {
							let indexPaths = change.indexSet.map { rowIndex in IndexPath(row: rowIndex, section: sectionIndex) }
							switch change.kind {
							case .delete: i.deleteRows(at: indexPaths, with: animation)
							case .move(let destination):
								for (count, index) in indexPaths.enumerated() {
									i.moveRow(at: index, to: IndexPath(row: destination + count, section: sectionIndex))
								}
							case .insert: i.insertRows(at: indexPaths, with: animation)
							case .scroll:
								i.reloadRows(at: indexPaths, with: animation)
							case .update:
								guard let section = sections.values?.at(sectionIndex - sections.localOffset) else { continue }
								for indexPath in indexPaths {
									guard let cell = i.cellForRow(at: indexPath), let value = section.values?.at(indexPath.row - sections.localOffset) else { continue }
									cell.associatedRowInput(valueType: RowData.self)?.send(value: value)
								}
								notifyVisibleRowsChanged(in: i)
							case .reload:
								i.reloadSections([sectionIndex], with: animation)
							}
						}
					}
				}, completion: nil)
			case .reload:
				i.reloadData()
			}

		}
	}

	open class Delegate: ScrollView.Preparer.Delegate, UITableViewDataSource, UITableViewDelegate {
		private func tableRowData(at indexPath: IndexPath, in tableView: UITableView) -> TableRow<RowData> {
			return TableRow<RowData>(indexPath: indexPath, data: (tableView.delegate as? TableView<RowData>.Preparer.Storage)?.sections.values?.at(indexPath.section)?.values?.at(indexPath.row))
		}
		
		private func metadata(section: Int, in tableView: UITableView) -> TableSectionMetadata? {
			return (tableView.delegate as? TableView<RowData>.Preparer.Storage)?.sections.values?.at(section)?.leaf
		}
		
		open func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
			// This is a required method of UITableViewDataSource but is implemented by the storage
			return 0
		}
		
		open func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
			// This is a required method of UITableViewDelegate but is implemented by the storage
			return UITableViewCell()
		}
		
		open func tableView(_ tableView: UITableView, accessoryButtonTappedForRowWith indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, canFocusRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, canPerformAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?) -> Bool {
			return singleHandler(tableView, action, tableRowData(at: indexPath, in: tableView), sender)
		}
		
		open func tableView(_ tableView: UITableView, didDeselectRowAt indexPath: IndexPath) {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, didEndDisplayingHeaderView view: UIView, forSection section: Int) {
			multiHandler(tableView, view, section)
		}
		
		open func tableView(_ tableView: UITableView, didEndDisplayingFooterView view: UIView, forSection section: Int) {
			multiHandler(tableView, view, section)
		}
		
		open func tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) {
			multiHandler(tableView, cell, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, didEndEditingRowAt indexPath: IndexPath?) {
			multiHandler(tableView, indexPath.map { tableRowData(at: $0, in: tableView) })
		}
		
		open func tableView(_ tableView: UITableView, didHighlightRowAt indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, didUnhighlightRowAt indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, didUpdateFocusIn context: UITableViewFocusUpdateContext, with coordinator: UIFocusAnimationCoordinator) {
			return singleHandler(tableView, context, coordinator)
		}
		
		open func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -> UITableViewCell.EditingStyle {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -> CGFloat {
			return singleHandler(tableView, section)
		}
		
		open func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {
			return singleHandler(tableView, section)
		}
		
		open func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
			return singleHandler(tableView, section)
		}
		
		open func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {
			return (singleHandler(tableView, section, metadata(section: section, in: tableView)?.footer) as ViewConvertible?)?.uiView()
		}
		
		open func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
			return singleHandler(tableView, section)
		}
		
		open func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
			return (singleHandler(tableView, section, metadata(section: section, in: tableView)?.header) as ViewConvertible?)?.uiView()
		}
		
		open func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, indentationLevelForRowAt indexPath: IndexPath) -> Int {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func indexPathForPreferredFocusedView(in tableView: UITableView) -> IndexPath? {
			return singleHandler(tableView)
		}
		
		open func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: sourceIndexPath, in: tableView), destinationIndexPath)
		}
		
		open func tableView(_ tableView: UITableView, shouldHighlightRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, shouldIndentWhileEditingRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, shouldShowMenuForRowAt indexPath: IndexPath) -> Bool {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, shouldUpdateFocusIn context: UITableViewFocusUpdateContext) -> Bool {
			return singleHandler(tableView, context)
		}
		
		open func tableView(_ tableView: UITableView, targetIndexPathForMoveFromRowAt sourceIndexPath: IndexPath, toProposedIndexPath proposedDestinationIndexPath: IndexPath) -> IndexPath {
			return singleHandler(tableView, sourceIndexPath, proposedDestinationIndexPath)
		}
		
		open func tableView(_ tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath) -> String? {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath) {
			multiHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, willDeselectRowAt indexPath: IndexPath) -> IndexPath? {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) {
			multiHandler(tableView, section, view)
		}
		
		open func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) {
			multiHandler(tableView, section, view)
		}
		
		open func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
			multiHandler(tableView, indexPath, cell)
		}
		
		open func tableView(_ tableView: UITableView, willSelectRowAt indexPath: IndexPath) -> IndexPath? {
			return singleHandler(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
			multiHandler(tableView, editingStyle, tableRowData(at: indexPath, in: tableView))
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableViewBinding {
	public typealias TableViewName<V> = BindingName<V, TableView<Binding.RowDataType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TableView<Binding.RowDataType>.Binding) -> TableViewName<V> {
		return TableViewName<V>(source: source, downcast: Binding.tableViewBinding)
	}
}
public extension BindingName where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableViewName<$2> { return .name(TableView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tableViewStyle: TableViewName<Constant<UITableView.Style>> { return .name(TableView.Binding.tableViewStyle) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMultipleSelection: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsMultipleSelection) }
	static var allowsMultipleSelectionDuringEditing: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsMultipleSelectionDuringEditing) }
	static var allowsSelection: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsSelection) }
	static var allowsSelectionDuringEditing: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsSelectionDuringEditing) }
	static var backgroundView: TableViewName<Dynamic<ViewConvertible?>> { return .name(TableView.Binding.backgroundView) }
	static var cellLayoutMarginsFollowReadableWidth: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.cellLayoutMarginsFollowReadableWidth) }
	static var estimatedRowHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.estimatedRowHeight) }
	static var estimatedSectionFooterHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.estimatedSectionFooterHeight) }
	static var estimatedSectionHeaderHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.estimatedSectionHeaderHeight) }
	static var isEditing: TableViewName<Signal<SetOrAnimate<Bool>>> { return .name(TableView.Binding.isEditing) }
	static var remembersLastFocusedIndexPath: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.remembersLastFocusedIndexPath) }
	static var rowHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.rowHeight) }
	static var sectionFooterHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.sectionFooterHeight) }
	static var sectionHeaderHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.sectionHeaderHeight) }
	static var sectionIndexBackgroundColor: TableViewName<Dynamic<UIColor?>> { return .name(TableView.Binding.sectionIndexBackgroundColor) }
	static var sectionIndexColor: TableViewName<Dynamic<UIColor?>> { return .name(TableView.Binding.sectionIndexColor) }
	static var sectionIndexMinimumDisplayRowCount: TableViewName<Dynamic<Int>> { return .name(TableView.Binding.sectionIndexMinimumDisplayRowCount) }
	static var sectionIndexTitles: TableViewName<Dynamic<[String]?>> { return .name(TableView.Binding.sectionIndexTitles) }
	static var sectionIndexTrackingBackgroundColor: TableViewName<Dynamic<UIColor?>> { return .name(TableView.Binding.sectionIndexTrackingBackgroundColor) }
	static var separatorColor: TableViewName<Dynamic<UIColor?>> { return .name(TableView.Binding.separatorColor) }
	static var separatorEffect: TableViewName<Dynamic<UIVisualEffect?>> { return .name(TableView.Binding.separatorEffect) }
	static var separatorInset: TableViewName<Dynamic<UIEdgeInsets>> { return .name(TableView.Binding.separatorInset) }
	static var separatorInsetReference: TableViewName<Dynamic<UITableView.SeparatorInsetReference>> { return .name(TableView.Binding.separatorInsetReference) }
	static var separatorStyle: TableViewName<Dynamic<UITableViewCell.SeparatorStyle>> { return .name(TableView.Binding.separatorStyle) }
	static var tableData: TableViewName<Dynamic<TableSectionAnimatable<Binding.RowDataType>>> { return .name(TableView.Binding.tableData) }
	static var tableFooterView: TableViewName<Dynamic<ViewConvertible?>> { return .name(TableView.Binding.tableFooterView) }
	static var tableHeaderView: TableViewName<Dynamic<ViewConvertible?>> { return .name(TableView.Binding.tableHeaderView) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var deselectRow: TableViewName<Signal<SetOrAnimate<IndexPath>>> { return .name(TableView.Binding.deselectRow) }
	static var scrollToNearestSelectedRow: TableViewName<Signal<SetOrAnimate<UITableView.ScrollPosition>>> { return .name(TableView.Binding.scrollToNearestSelectedRow) }
	static var scrollToRow: TableViewName<Signal<SetOrAnimate<TableScrollPosition>>> { return .name(TableView.Binding.scrollToRow) }
	static var selectRow: TableViewName<Signal<SetOrAnimate<TableScrollPosition?>>> { return .name(TableView.Binding.selectRow) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var selectionDidChange: TableViewName<SignalInput<[TableRow<Binding.RowDataType>]?>> { return .name(TableView.Binding.selectionDidChange) }
	static var userDidScrollToRow: TableViewName<SignalInput<TableRow<Binding.RowDataType>>> { return .name(TableView.Binding.userDidScrollToRow) }
	static var visibleRowsChanged: TableViewName<SignalInput<[TableRow<Binding.RowDataType>]>> { return .name(TableView.Binding.visibleRowsChanged) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var accessoryButtonTapped: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.accessoryButtonTapped) }
	static var canEditRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.canEditRow) }
	static var canFocusRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.canFocusRow) }
	static var canMoveRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.canMoveRow) }
	static var canPerformAction: TableViewName<(_ tableView: UITableView, _ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool> { return .name(TableView.Binding.canPerformAction) }
	static var cellConstructor: TableViewName<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible> { return .name(TableView.Binding.cellConstructor) }
	static var cellIdentifier: TableViewName<(TableRow<Binding.RowDataType>) -> String?> { return .name(TableView.Binding.cellIdentifier) }
	static var commit: TableViewName<(UITableView, UITableViewCell.EditingStyle, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.commit) }
	static var dataMissingCell: TableViewName<(IndexPath) -> TableViewCellConvertible> { return .name(TableView.Binding.dataMissingCell) }
	static var didDeselectRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didDeselectRow) }
	static var didEndDisplayingCell: TableViewName<(UITableView, UITableViewCell, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didEndDisplayingCell) }
	static var didEndDisplayingFooter: TableViewName<(UITableView, UIView, Int) -> Void> { return .name(TableView.Binding.didEndDisplayingFooter) }
	static var didEndDisplayingHeader: TableViewName<(UITableView, UIView, Int) -> Void> { return .name(TableView.Binding.didEndDisplayingHeader) }
	static var didEndEditingRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>?) -> Void> { return .name(TableView.Binding.didEndEditingRow) }
	static var didHightlightRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didHightlightRow) }
	static var didSelectRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didSelectRow) }
	static var didUnhighlightRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.didUnhighlightRow) }
	static var didUpdateFocus: TableViewName<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void> { return .name(TableView.Binding.didUpdateFocus) }
	static var editActionsForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?> { return .name(TableView.Binding.editActionsForRow) }
	static var editingStyleForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle> { return .name(TableView.Binding.editingStyleForRow) }
	static var estimatedHeightForFooter: TableViewName<(_ tableView: UITableView, _ section: Int) -> CGFloat> { return .name(TableView.Binding.estimatedHeightForFooter) }
	static var estimatedHeightForHeader: TableViewName<(_ tableView: UITableView, _ section: Int) -> CGFloat> { return .name(TableView.Binding.estimatedHeightForHeader) }
	static var estimatedHeightForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> { return .name(TableView.Binding.estimatedHeightForRow) }
	static var footerHeight: TableViewName<(_ tableView: UITableView, _ section: Int) -> CGFloat> { return .name(TableView.Binding.footerHeight) }
	static var footerView: TableViewName<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?> { return .name(TableView.Binding.footerView) }
	static var headerHeight: TableViewName<(_ tableView: UITableView, _ section: Int) -> CGFloat> { return .name(TableView.Binding.headerHeight) }
	static var headerView: TableViewName<(_ tableView: UITableView, _ section: Int, _ title: String?) -> ViewConvertible?> { return .name(TableView.Binding.headerView) }
	static var heightForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> { return .name(TableView.Binding.heightForRow) }
	static var indentationLevelForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Int> { return .name(TableView.Binding.indentationLevelForRow) }
	static var indexPathForPreferredFocusedView: TableViewName<(UITableView) -> IndexPath> { return .name(TableView.Binding.indexPathForPreferredFocusedView) }
	static var moveRow: TableViewName<(UITableView, TableRow<Binding.RowDataType>, IndexPath) -> Void> { return .name(TableView.Binding.moveRow) }
	static var shouldHighlightRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.shouldHighlightRow) }
	static var shouldIndentWhileEditingRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.shouldIndentWhileEditingRow) }
	static var shouldShowMenuForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Bool> { return .name(TableView.Binding.shouldShowMenuForRow) }
	static var shouldUpdateFocus: TableViewName<(UITableView, UITableViewFocusUpdateContext) -> Bool> { return .name(TableView.Binding.shouldUpdateFocus) }
	static var targetIndexPathForMoveFromRow: TableViewName<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath> { return .name(TableView.Binding.targetIndexPathForMoveFromRow) }
	static var titleForDeleteConfirmationButtonForRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> String?> { return .name(TableView.Binding.titleForDeleteConfirmationButtonForRow) }
	static var willBeginEditingRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void> { return .name(TableView.Binding.willBeginEditingRow) }
	static var willDeselectRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> { return .name(TableView.Binding.willDeselectRow) }
	static var willDisplayFooter: TableViewName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> { return .name(TableView.Binding.willDisplayFooter) }
	static var willDisplayHeader: TableViewName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> { return .name(TableView.Binding.willDisplayHeader) }
	static var willDisplayRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void> { return .name(TableView.Binding.willDisplayRow) }
	static var willSelectRow: TableViewName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> { return .name(TableView.Binding.willSelectRow) }
	
	// Composite binding names
	static func rowSelected<Value>(_ keyPath: KeyPath<TableRow<Binding.RowDataType>, Value>) -> TableViewName<SignalInput<Value>> {
		return Binding.compositeName(
			value: { input in { tableView, tableRow -> Void in input.send(value: tableRow[keyPath: keyPath]) } },
			binding: TableView.Binding.didSelectRow,
			downcast: Binding.tableViewBinding
		)
	}
	static func rowSelected(_ void: Void = ()) -> TableViewName<SignalInput<TableRow<Binding.RowDataType>>> {
		return Binding.compositeName(
			value: { input in { tableView, tableRow -> Void in input.send(value: tableRow) } },
			binding: TableView.Binding.didSelectRow,
			downcast: Binding.tableViewBinding
		)
	}
	static func commit<Value>(_ keyPath: KeyPath<TableRowCommit<Binding.RowDataType>, Value>) -> TableViewName<SignalInput<Value>> {
		return Binding.compositeName(
			value: { input in { tableView, editingStyle, tableRow -> Void in input.send(value: TableRowCommit(style: editingStyle, tableRow: tableRow)[keyPath: keyPath]) } },
			binding: TableView.Binding.commit,
			downcast: Binding.tableViewBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TableViewConvertible: ScrollViewConvertible {
	func uiTableView() -> UITableView
}
extension TableViewConvertible {
	public func uiScrollView() -> ScrollView.Instance { return uiTableView() }
}
extension UITableView: TableViewConvertible {
	public func uiTableView() -> UITableView { return self }
}
public extension TableView {
	func uiTableView() -> UITableView { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TableViewBinding: ScrollViewBinding {
	associatedtype RowDataType
	static func tableViewBinding(_ binding: TableView<RowDataType>.Binding) -> Self
	func asTableViewBinding() -> TableView<RowDataType>.Binding?
}
public extension TableViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self {
		return tableViewBinding(.inheritedBinding(binding))
	}
}
public extension TableViewBinding where Preparer.Inherited.Binding: TableViewBinding, Preparer.Inherited.Binding.RowDataType == RowDataType {
	func asTableViewBinding() -> TableView<RowDataType>.Binding? {
		return asInheritedBinding()?.asTableViewBinding()
	}
}
public extension TableView.Binding {
	typealias Preparer = TableView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableViewBinding() -> TableView.Binding? { return self }
	static func tableViewBinding(_ binding: TableView<RowDataType>.Binding) -> TableView<RowDataType>.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public struct TableSectionMetadata {
	public let header: String?
	public let footer: String?
	public init(header: String? = nil, footer: String? = nil) {
		(self.header, self.footer) = (header, footer)
	}
}

public typealias TableRowMutation<Element> = SubrangeMutation<Element, TableSectionMetadata>
public typealias TableRowAnimatable<Element> = Animatable<TableRowMutation<Element>, UITableView.RowAnimation>
public typealias TableSectionMutation<Element> = SubrangeMutation<TableRowMutation<Element>, ()>
public typealias TableSectionAnimatable<Element> = Animatable<TableSectionMutation<Element>, UITableView.RowAnimation>

public typealias TableRowState<Element> = SubrangeState<Element, TableSectionMetadata>
public typealias TableSectionState<Element> = SubrangeState<TableRowState<Element>, ()>

public extension IndexedMutation where Metadata == Subrange<Void> {
	func apply<RowData>(to sections: inout TableSectionState<RowData>) where Element == TableRowMutation<RowData> {
		if case .update = kind {
			for (mutationIndex, rowIndex) in indexSet.enumerated() {
				values[mutationIndex].mapMetadata { _ in () }.apply(to: &sections.values![rowIndex].values!)
				values[mutationIndex].updateMetadata(&sections.values![rowIndex])
			}
		} else {
			self.mapValues { rowMutation -> TableRowState<RowData> in
				var rowState = TableRowState<RowData>()
				rowMutation.apply(toSubrange: &rowState)
				return rowState
				}.apply(toSubrange: &sections)
		}
		self.updateMetadata(&sections)
	}
}

public struct TableScrollPosition {
	public let indexPath: IndexPath
	public let position: UITableView.ScrollPosition
	public init(indexPath: IndexPath, position: UITableView.ScrollPosition = .none) {
		self.indexPath = indexPath
		self.position = position
	}
	
	public static func none(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .none)
	}
	
	public static func top(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .top)
	}
	
	public static func middle(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .middle)
	}
	
	public static func bottom(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .bottom)
	}
}

public struct TableRowCommit<RowData> {
	public let style: UITableViewCell.EditingStyle
	public let tableRow: TableRow<RowData>

	public init(style: UITableViewCell.EditingStyle, tableRow: TableRow<RowData>) {
		self.style = style
		self.tableRow = tableRow
	}
}

public struct TableRow<RowData> {
	public let indexPath: IndexPath
	public let data: RowData?
	
	public init(indexPath: IndexPath, data: RowData?) {
		self.indexPath = indexPath
		self.data = data
	}
}

public extension Sequence {
	func tableData() -> TableSectionAnimatable<Element> {
		return .set(.reload([.reload(Array(self))]))
	}
}

public extension Signal {
	func tableData<RowData>(_ choice: AnimationChoice = .subsequent) -> Signal<TableSectionAnimatable<RowData>> where TableRowMutation<RowData> == OutputValue {
		return map(initialState: false) { (alreadyReceived: inout Bool, rowMutation: OutputValue) -> TableSectionAnimatable<RowData> in
			if alreadyReceived || choice == .always {
				return .animate(.updated(rowMutation, at: 0), animation: .automatic)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(.reload([rowMutation]))
			}
		}
	}
}

public extension Adapter where State == VarState<IndexPath?> {
	func updateFirstRow<RowData>() -> SignalInput<[TableRow<RowData>]> {
		return Input().map { $0.first?.indexPath }.bind(to: update())
	}
}

extension SignalInterface where OutputValue == IndexPath? {
	public func restoreFirstRow() -> Signal<SetOrAnimate<TableScrollPosition>> {
		return compactMap { $0.map { .top($0) } }.animate(.never)
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class TapGestureRecognizer: Binder, TapGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TapGestureRecognizer {
	enum Binding: TapGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case numberOfTapsRequired(Dynamic<Int>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension TapGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = TapGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = UITapGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TapGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
			//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .numberOfTapsRequired(let x): return x.apply(instance) { i, v in i.numberOfTapsRequired = v }
		case .numberOfTouchesRequired(let x): return x.apply(instance) { i, v in i.numberOfTouchesRequired = v }
			
			// 2. Signal bindings are performed on the object after construction.
			
			// 3. Action bindings are triggered by the object after construction.
			
			// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TapGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TapGestureRecognizerBinding {
	public typealias TapGestureRecognizerName<V> = BindingName<V, TapGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TapGestureRecognizer.Binding) -> TapGestureRecognizerName<V> {
		return TapGestureRecognizerName<V>(source: source, downcast: Binding.tapGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: TapGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TapGestureRecognizerName<$2> { return .name(TapGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var numberOfTapsRequired: TapGestureRecognizerName<Dynamic<Int>> { return .name(TapGestureRecognizer.Binding.numberOfTapsRequired) }
	static var numberOfTouchesRequired: TapGestureRecognizerName<Dynamic<Int>> { return .name(TapGestureRecognizer.Binding.numberOfTouchesRequired) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TapGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance
}
extension TapGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiTapGestureRecognizer() }
}
extension UITapGestureRecognizer: TapGestureRecognizerConvertible {
	public func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance { return self }
}
public extension TapGestureRecognizer {
	func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TapGestureRecognizerBinding: GestureRecognizerBinding {
	static func tapGestureRecognizerBinding(_ binding: TapGestureRecognizer.Binding) -> Self
	func asTapGestureRecognizerBinding() -> TapGestureRecognizer.Binding?
}
public extension TapGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return tapGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension TapGestureRecognizerBinding where Preparer.Inherited.Binding: TapGestureRecognizerBinding {
	func asTapGestureRecognizerBinding() -> TapGestureRecognizer.Binding? {
		return asInheritedBinding()?.asTapGestureRecognizerBinding()
	}
}
public extension TapGestureRecognizer.Binding {
	typealias Preparer = TapGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTapGestureRecognizerBinding() -> TapGestureRecognizer.Binding? { return self }
	static func tapGestureRecognizerBinding(_ binding: TapGestureRecognizer.Binding) -> TapGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class TextField: Binder, TextFieldConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TextField {
	enum Binding: TextFieldBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case adjustsFontSizeToFitWidth(Dynamic<Bool>)
		case allowsEditingTextAttributes(Dynamic<Bool>)
		case attributedPlaceholder(Dynamic<NSAttributedString?>)
		case attributedText(Dynamic<NSAttributedString?>)
		case background(Dynamic<UIImage?>)
		case borderStyle(Dynamic<UITextField.BorderStyle>)
		case clearButtonMode(Dynamic<UITextField.ViewMode>)
		case clearsOnBeginEditing(Dynamic<Bool>)
		case clearsOnInsertion(Dynamic<Bool>)
		case defaultTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case disabledBackground(Dynamic<UIImage?>)
		case font(Dynamic<UIFont?>)
		case inputAccessoryView(Dynamic<ViewConvertible?>)
		case inputView(Dynamic<ViewConvertible?>)
		case leftView(Dynamic<ViewConvertible?>)
		case leftViewMode(Dynamic<UITextField.ViewMode>)
		case minimumFontSize(Dynamic<CGFloat>)
		case placeholder(Dynamic<String?>)
		case rightView(Dynamic<ViewConvertible?>)
		case rightViewMode(Dynamic<UITextField.ViewMode>)
		case text(Dynamic<String>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case textColor(Dynamic<UIColor?>)
		case typingAttributes(Dynamic<[NSAttributedString.Key: Any]?>)
		
		//	2. Signal bindings are performed on the object after construction.
		case resignFirstResponder(Signal<Void>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case didBeginEditing((_ textField: UITextField) -> Void)
		case didChange((_ textField: UITextField) -> Void)
		case didEndEditing((_ textField: UITextField) -> Void)
		case didEndEditingWithReason((_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void)
		case shouldBeginEditing((_ textField: UITextField) -> Bool)
		case shouldChangeCharacters((_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool)
		case shouldClear((_ textField: UITextField) -> Bool)
		case shouldEndEditing((_ textField: UITextField) -> Bool)
		case shouldReturn((_ textField: UITextField) -> Bool)
	}
}
	
// MARK: - Binder Part 3: Preparer
public extension TextField {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = TextField.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = UITextField
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TextField.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .didEndEditingWithReason(let x): delegate().addMultiHandler2(x, #selector(UITextFieldDelegate.textFieldDidEndEditing(_:reason:)))
		case .shouldBeginEditing(let x): delegate().addSingleHandler1(x, #selector(UITextFieldDelegate.textFieldShouldBeginEditing(_:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler1(x, #selector(UITextFieldDelegate.textFieldShouldEndEditing(_:)))
		case .shouldChangeCharacters(let x): delegate().addSingleHandler3(x, #selector(UITextFieldDelegate.textField(_:shouldChangeCharactersIn:replacementString:)))
		case .shouldClear(let x): delegate().addSingleHandler1(x, #selector(UITextFieldDelegate.textFieldShouldClear(_:)))
		case .shouldReturn(let x): delegate().addSingleHandler1(x, #selector(UITextFieldDelegate.textFieldShouldReturn(_:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .textInputTraits(let x): return x.value.apply(to: instance)
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .adjustsFontSizeToFitWidth(let x): return x.apply(instance) { i, v in i.adjustsFontSizeToFitWidth = v }
		case .allowsEditingTextAttributes(let x): return x.apply(instance) { i, v in i.allowsEditingTextAttributes = v }
		case .attributedPlaceholder(let x): return x.apply(instance) { i, v in i.attributedPlaceholder = v }
		case .attributedText(let x): return x.apply(instance) { i, v in i.attributedText = v }
		case .background(let x): return x.apply(instance) { i, v in i.background = v }
		case .borderStyle(let x): return x.apply(instance) { i, v in i.borderStyle = v }
		case .clearButtonMode(let x): return x.apply(instance) { i, v in i.clearButtonMode = v }
		case .clearsOnBeginEditing(let x): return x.apply(instance) { i, v in i.clearsOnBeginEditing = v }
		case .clearsOnInsertion(let x): return x.apply(instance) { i, v in i.clearsOnInsertion = v }
		case .defaultTextAttributes(let x): return x.apply(instance) { i, v in i.defaultTextAttributes = v }
		case .disabledBackground(let x): return x.apply(instance) { i, v in i.disabledBackground = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .inputAccessoryView(let x): return x.apply(instance) { i, v in i.inputAccessoryView = v?.uiView() }
		case .inputView(let x): return x.apply(instance) { i, v in i.inputView = v?.uiView() }
		case .leftView(let x): return x.apply(instance) { i, v in i.leftView = v?.uiView() }
		case .leftViewMode(let x): return x.apply(instance) { i, v in i.leftViewMode = v }
		case .minimumFontSize(let x): return x.apply(instance) { i, v in i.minimumFontSize = v }
		case .placeholder(let x): return x.apply(instance) { i, v in i.placeholder = v }
		case .rightView(let x): return x.apply(instance) { i, v in i.rightView = v?.uiView() }
		case .rightViewMode(let x): return x.apply(instance) { i, v in i.rightViewMode = v }
		case .text(let x): return x.apply(instance) { i, v in i.text = v }
		case .textAlignment(let x): return x.apply(instance) { i, v in i.textAlignment = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		case .typingAttributes(let x): return x.apply(instance) { i, v in i.typingAttributes = v }
		
		//	2. Signal bindings are performed on the object after construction.
		case .resignFirstResponder(let x): return x.apply(instance) { i, v in i.resignFirstResponder() }
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .didBeginEditing(let x): return Signal.notifications(name: UITextField.textDidBeginEditingNotification, object: instance).compactMap { notification in return notification.object as? UITextField }.subscribeValues { field in x(field) }
		case .didChange(let x): return Signal.notifications(name: UITextField.textDidChangeNotification, object: instance).compactMap { notification in return notification.object as? UITextField }.subscribeValues { field in x(field) }
		case .didEndEditing(let x): return Signal.notifications(name: UITextField.textDidEndEditingNotification, object: instance).compactMap { notification in return notification.object as? UITextField }.subscribeValues { field in x(field) }
		case .shouldBeginEditing: return nil
		case .shouldChangeCharacters: return nil
		case .shouldClear: return nil
		case .shouldEndEditing: return nil
		case .shouldReturn: return nil

		case .didEndEditingWithReason: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TextField.Preparer {
	open class Storage: Control.Preparer.Storage, UITextFieldDelegate {}
	
	open class Delegate: DynamicDelegate, UITextFieldDelegate {
		open func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
			return singleHandler(textField)
		}
		
		open func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
			return singleHandler(textField)
		}
		
		open func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
			return singleHandler(textField, range, string)
		}
		
		open func textFieldShouldClear(_ textField: UITextField) -> Bool {
			return singleHandler(textField)
		}
		
		open func textFieldShouldReturn(_ textField: UITextField) -> Bool {
			return singleHandler(textField)
		}
		
		open func textFieldDidEndEditing(_ textField: UITextField, reason: UITextField.DidEndEditingReason) {
			multiHandler(textField, reason)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TextFieldBinding {
	public typealias TextFieldName<V> = BindingName<V, TextField.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TextField.Binding) -> TextFieldName<V> {
		return TextFieldName<V>(source: source, downcast: Binding.textFieldBinding)
	}
}
public extension BindingName where Binding: TextFieldBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TextFieldName<$2> { return .name(TextField.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: TextFieldName<Constant<TextInputTraits>> { return .name(TextField.Binding.textInputTraits) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var adjustsFontSizeToFitWidth: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.adjustsFontSizeToFitWidth) }
	static var allowsEditingTextAttributes: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.allowsEditingTextAttributes) }
	static var attributedPlaceholder: TextFieldName<Dynamic<NSAttributedString?>> { return .name(TextField.Binding.attributedPlaceholder) }
	static var attributedText: TextFieldName<Dynamic<NSAttributedString?>> { return .name(TextField.Binding.attributedText) }
	static var background: TextFieldName<Dynamic<UIImage?>> { return .name(TextField.Binding.background) }
	static var borderStyle: TextFieldName<Dynamic<UITextField.BorderStyle>> { return .name(TextField.Binding.borderStyle) }
	static var clearButtonMode: TextFieldName<Dynamic<UITextField.ViewMode>> { return .name(TextField.Binding.clearButtonMode) }
	static var clearsOnBeginEditing: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.clearsOnBeginEditing) }
	static var clearsOnInsertion: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.clearsOnInsertion) }
	static var defaultTextAttributes: TextFieldName<Dynamic<[NSAttributedString.Key: Any]>> { return .name(TextField.Binding.defaultTextAttributes) }
	static var disabledBackground: TextFieldName<Dynamic<UIImage?>> { return .name(TextField.Binding.disabledBackground) }
	static var font: TextFieldName<Dynamic<UIFont?>> { return .name(TextField.Binding.font) }
	static var inputAccessoryView: TextFieldName<Dynamic<ViewConvertible?>> { return .name(TextField.Binding.inputAccessoryView) }
	static var inputView: TextFieldName<Dynamic<ViewConvertible?>> { return .name(TextField.Binding.inputView) }
	static var leftView: TextFieldName<Dynamic<ViewConvertible?>> { return .name(TextField.Binding.leftView) }
	static var leftViewMode: TextFieldName<Dynamic<UITextField.ViewMode>> { return .name(TextField.Binding.leftViewMode) }
	static var minimumFontSize: TextFieldName<Dynamic<CGFloat>> { return .name(TextField.Binding.minimumFontSize) }
	static var placeholder: TextFieldName<Dynamic<String?>> { return .name(TextField.Binding.placeholder) }
	static var rightView: TextFieldName<Dynamic<ViewConvertible?>> { return .name(TextField.Binding.rightView) }
	static var rightViewMode: TextFieldName<Dynamic<UITextField.ViewMode>> { return .name(TextField.Binding.rightViewMode) }
	static var text: TextFieldName<Dynamic<String>> { return .name(TextField.Binding.text) }
	static var textAlignment: TextFieldName<Dynamic<NSTextAlignment>> { return .name(TextField.Binding.textAlignment) }
	static var textColor: TextFieldName<Dynamic<UIColor?>> { return .name(TextField.Binding.textColor) }
	static var typingAttributes: TextFieldName<Dynamic<[NSAttributedString.Key: Any]?>> { return .name(TextField.Binding.typingAttributes) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var resignFirstResponder: TextFieldName<Signal<Void>> { return .name(TextField.Binding.resignFirstResponder) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginEditing: TextFieldName<(_ textField: UITextField) -> Void> { return .name(TextField.Binding.didBeginEditing) }
	static var didChange: TextFieldName<(_ textField: UITextField) -> Void> { return .name(TextField.Binding.didChange) }
	static var didEndEditing: TextFieldName<(_ textField: UITextField) -> Void> { return .name(TextField.Binding.didEndEditing) }
	static var didEndEditingWithReason: TextFieldName<(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void> { return .name(TextField.Binding.didEndEditingWithReason) }
	static var shouldBeginEditing: TextFieldName<(_ textField: UITextField) -> Bool> { return .name(TextField.Binding.shouldBeginEditing) }
	static var shouldChangeCharacters: TextFieldName<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool> { return .name(TextField.Binding.shouldChangeCharacters) }
	static var shouldClear: TextFieldName<(_ textField: UITextField) -> Bool> { return .name(TextField.Binding.shouldClear) }
	static var shouldEndEditing: TextFieldName<(_ textField: UITextField) -> Bool> { return .name(TextField.Binding.shouldEndEditing) }
	static var shouldReturn: TextFieldName<(_ textField: UITextField) -> Bool> { return .name(TextField.Binding.shouldReturn) }
	
	// Composite binding names
	static func textChanged(_ void: Void = ()) -> TextFieldName<SignalInput<String>> {
		return Binding.compositeName(
			value: { input in { textField in textField.text.map { _ = input.send(value: $0) } } },
			binding: TextField.Binding.didChange,
			downcast: Binding.textFieldBinding
		)
	}
	static func attributedTextChanged(_ void: Void = ()) -> TextFieldName<SignalInput<NSAttributedString>> {
		return Binding.compositeName(
			value: { input in { textField in textField.attributedText.map { _ = input.send(value: $0) } } },
			binding: TextField.Binding.didChange,
			downcast: Binding.textFieldBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TextFieldConvertible: ControlConvertible {
	func uiTextField() -> TextField.Instance
}
extension TextFieldConvertible {
	public func uiControl() -> Control.Instance { return uiTextField() }
}
extension UITextField: TextFieldConvertible, HasDelegate {
	public func uiTextField() -> TextField.Instance { return self }
}
public extension TextField {
	func uiTextField() -> TextField.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TextFieldBinding: ControlBinding {
	static func textFieldBinding(_ binding: TextField.Binding) -> Self
	func asTextFieldBinding() -> TextField.Binding?
}
public extension TextFieldBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return textFieldBinding(.inheritedBinding(binding))
	}
}
public extension TextFieldBinding where Preparer.Inherited.Binding: TextFieldBinding {
	func asTextFieldBinding() -> TextField.Binding? {
		return asInheritedBinding()?.asTextFieldBinding()
	}
}
public extension TextField.Binding {
	typealias Preparer = TextField.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTextFieldBinding() -> TextField.Binding? { return self }
	static func textFieldBinding(_ binding: TextField.Binding) -> TextField.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public func textFieldResignOnReturn(condition: @escaping (UITextField) -> Bool = { _ in return true }) -> (UITextField) -> Bool {
	return { tf in
		if condition(tf) {
			tf.resignFirstResponder()
			return false
		}
		return true
	}
}

#endif

#if os(iOS)

/// A type that hold an array of UITextInputTraits in a binding-like manner so they can be constructed using BindingName syntax.
/// This type is not implemented as a binder because it does not construct an instance or binder storage. It is a helper-type used by other binders that conform to the UITextInputTraits protocol.
public struct TextInputTraits {
	let bindings: [Binding]
	public init(bindings: [Binding]) {
		self.bindings = bindings
	}
	public init(_ bindings: Binding...) {
		self.init(bindings: bindings)
	}
	
	public enum Binding {
		case autocapitalizationType(Dynamic<UITextAutocapitalizationType>)
		case autocorrectionType(Dynamic<UITextAutocorrectionType>)
		case enablesReturnKeyAutomatically(Dynamic<Bool>)
		case isSecureTextEntry(Dynamic<Bool>)
		case keyboardAppearance(Dynamic<UIKeyboardAppearance>)
		case keyboardType(Dynamic<UIKeyboardType>)
		case returnKeyType(Dynamic<UIReturnKeyType>)
		case smartDashesType(Dynamic<UITextSmartDashesType>)
		case smartInsertDeleteType(Dynamic<UITextSmartInsertDeleteType>)
		case smartQuotesType(Dynamic<UITextSmartQuotesType>)
		case spellCheckingType(Dynamic<UITextSpellCheckingType>)
		case textContentType(Dynamic<UITextContentType>)
	}
	
	// No, you're not seeing things, this is one method, copy and pasted three times with a different instance parameter type.
	// Unfortunately, Objective-C protocols with optional, settable vars â as used in the UITextInputTraits protocol â don't work in Swift 5, so everything must be done manually, instead.
	public func apply(to instance: UISearchBar) -> Lifetime? {
		return bindings.isEmpty ? nil : AggregateLifetime(lifetimes: bindings.compactMap { trait in
			switch trait {
			case .autocapitalizationType(let x): return x.apply(instance) { i, v in i.autocapitalizationType = v }
			case .autocorrectionType(let x): return x.apply(instance) { i, v in i.autocorrectionType = v }
			case .enablesReturnKeyAutomatically(let x): return x.apply(instance) { i, v in i.enablesReturnKeyAutomatically = v }
			case .isSecureTextEntry(let x): return x.apply(instance) { i, v in i.isSecureTextEntry = v }
			case .keyboardAppearance(let x): return x.apply(instance) { i, v in i.keyboardAppearance = v }
			case .keyboardType(let x): return x.apply(instance) { i, v in i.keyboardType = v }
			case .returnKeyType(let x): return x.apply(instance) { i, v in i.returnKeyType = v }
			case .smartDashesType(let x): return x.apply(instance) { i, v in i.smartDashesType = v }
			case .smartInsertDeleteType(let x): return x.apply(instance) { i, v in i.smartInsertDeleteType = v }
			case .smartQuotesType(let x): return x.apply(instance) { i, v in i.smartQuotesType = v }
			case .spellCheckingType(let x): return x.apply(instance) { i, v in i.spellCheckingType = v }
			case .textContentType(let x): return x.apply(instance) { i, v in i.textContentType = v }
			}
		})
	}
	
	// No, you're not seeing things, this is one method, copy and pasted three times with a different instance parameter type.
	// Unfortunately, Objective-C protocols with optional, settable vars â as used in the UITextInputTraits protocol â don't work in Swift 5, so everything must be done manually, instead.
	public func apply(to instance: UITextField) -> Lifetime? {
		return bindings.isEmpty ? nil : AggregateLifetime(lifetimes: bindings.compactMap { trait in
			switch trait {
			case .autocapitalizationType(let x): return x.apply(instance) { i, v in i.autocapitalizationType = v }
			case .autocorrectionType(let x): return x.apply(instance) { i, v in i.autocorrectionType = v }
			case .enablesReturnKeyAutomatically(let x): return x.apply(instance) { i, v in i.enablesReturnKeyAutomatically = v }
			case .isSecureTextEntry(let x): return x.apply(instance) { i, v in i.isSecureTextEntry = v }
			case .keyboardAppearance(let x): return x.apply(instance) { i, v in i.keyboardAppearance = v }
			case .keyboardType(let x): return x.apply(instance) { i, v in i.keyboardType = v }
			case .returnKeyType(let x): return x.apply(instance) { i, v in i.returnKeyType = v }
			case .smartDashesType(let x): return x.apply(instance) { i, v in i.smartDashesType = v }
			case .smartInsertDeleteType(let x): return x.apply(instance) { i, v in i.smartInsertDeleteType = v }
			case .smartQuotesType(let x): return x.apply(instance) { i, v in i.smartQuotesType = v }
			case .spellCheckingType(let x): return x.apply(instance) { i, v in i.spellCheckingType = v }
			case .textContentType(let x): return x.apply(instance) { i, v in i.textContentType = v }
			}
		})
	}
	
	// No, you're not seeing things, this is one method, copy and pasted three times with a different instance parameter type.
	// Unfortunately, Objective-C protocols with optional, settable vars â as used in the UITextInputTraits protocol â don't work in Swift 5, so everything must be done manually, instead.
	public func apply(to instance: UITextView) -> Lifetime? {
		return bindings.isEmpty ? nil : AggregateLifetime(lifetimes: bindings.compactMap { trait in
			switch trait {
			case .autocapitalizationType(let x): return x.apply(instance) { i, v in i.autocapitalizationType = v }
			case .autocorrectionType(let x): return x.apply(instance) { i, v in i.autocorrectionType = v }
			case .enablesReturnKeyAutomatically(let x): return x.apply(instance) { i, v in i.enablesReturnKeyAutomatically = v }
			case .isSecureTextEntry(let x): return x.apply(instance) { i, v in i.isSecureTextEntry = v }
			case .keyboardAppearance(let x): return x.apply(instance) { i, v in i.keyboardAppearance = v }
			case .keyboardType(let x): return x.apply(instance) { i, v in i.keyboardType = v }
			case .returnKeyType(let x): return x.apply(instance) { i, v in i.returnKeyType = v }
			case .smartDashesType(let x): return x.apply(instance) { i, v in i.smartDashesType = v }
			case .smartInsertDeleteType(let x): return x.apply(instance) { i, v in i.smartInsertDeleteType = v }
			case .smartQuotesType(let x): return x.apply(instance) { i, v in i.smartQuotesType = v }
			case .spellCheckingType(let x): return x.apply(instance) { i, v in i.spellCheckingType = v }
			case .textContentType(let x): return x.apply(instance) { i, v in i.textContentType = v }
			}
		})
	}
}

extension BindingName where Source == Binding, Binding == TextInputTraits.Binding {
	// NOTE: for some reason, any attempt at a TextInputTraitsName typealias led to a compiler crash so the explicit BindingName<V, TextInputTraits.Binding, TextInputTraits.Binding> must be used instead.
	private static func name<V>(_ source: @escaping (V) -> TextInputTraits.Binding) -> BindingName<V, TextInputTraits.Binding, TextInputTraits.Binding> {
		return BindingName<V, TextInputTraits.Binding, TextInputTraits.Binding>(source: source, downcast: { b in b})
	}
}
public extension BindingName where Source == Binding, Binding == TextInputTraits.Binding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2> { return .name(TextInputTraits.Binding.$1) }
	static var autocapitalizationType: BindingName<Dynamic<UITextAutocapitalizationType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.autocapitalizationType) }
	static var autocorrectionType: BindingName<Dynamic<UITextAutocorrectionType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.autocorrectionType) }
	static var enablesReturnKeyAutomatically: BindingName<Dynamic<Bool>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.enablesReturnKeyAutomatically) }
	static var isSecureTextEntry: BindingName<Dynamic<Bool>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.isSecureTextEntry) }
	static var keyboardAppearance: BindingName<Dynamic<UIKeyboardAppearance>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.keyboardAppearance) }
	static var keyboardType: BindingName<Dynamic<UIKeyboardType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.keyboardType) }
	static var returnKeyType: BindingName<Dynamic<UIReturnKeyType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.returnKeyType) }
	static var smartDashesType: BindingName<Dynamic<UITextSmartDashesType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.smartDashesType) }
	static var smartInsertDeleteType: BindingName<Dynamic<UITextSmartInsertDeleteType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.smartInsertDeleteType) }
	static var smartQuotesType: BindingName<Dynamic<UITextSmartQuotesType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.smartQuotesType) }
	static var spellCheckingType: BindingName<Dynamic<UITextSpellCheckingType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.spellCheckingType) }
	static var textContentType: BindingName<Dynamic<UITextContentType>, TextInputTraits.Binding, TextInputTraits.Binding> { return .name(TextInputTraits.Binding.textContentType) }
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class TextView: Binder, TextViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TextView {
	enum Binding: TextViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsEditingTextAttributes(Dynamic<Bool>)
		case attributedText(Dynamic<NSAttributedString>)
		case clearsOnInsertion(Dynamic<Bool>)
		case dataDetectorTypes(Dynamic<UIDataDetectorTypes>)
		case font(Dynamic<UIFont?>)
		case inputAccessoryView(Dynamic<ViewConvertible?>)
		case inputView(Dynamic<ViewConvertible?>)
		case isEditable(Dynamic<Bool>)
		case isSelectable(Dynamic<Bool>)
		case linkTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case selectedRange(Dynamic<NSRange>)
		case text(Dynamic<String>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case textColor(Dynamic<UIColor?>)
		case textContainerInset(Dynamic<UIEdgeInsets>)
		case typingAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		
		// 2. Signal bindings are performed on the object after construction.
		case scrollRangeToVisible(Signal<NSRange>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didBeginEditing((UITextView) -> Void)
		case didChange((UITextView) -> Void)
		case didChangeSelection((UITextView) -> Void)
		case didEndEditing((UITextView) -> Void)
		case shouldBeginEditing((UITextView) -> Bool)
		case shouldChangeText((UITextView, NSRange, String) -> Bool)
		case shouldEndEditing((UITextView) -> Bool)
		case shouldInteractWithAttachment((UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)
		case shouldInteractWithURL((UITextView, URL, NSRange, UITextItemInteraction) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
public extension TextView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = TextView.Binding
		public typealias Inherited = ScrollView.Preparer
		public typealias Instance = UITextView
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TextView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.

		// 2. Signal bindings are performed on the object after construction.
			
		//	3. Action bindings are triggered by the object after construction.
		case .didBeginEditing(let x): delegate().addMultiHandler1(x, #selector(UITextViewDelegate.textViewDidBeginEditing(_:)))
		case .didChange(let x): delegate().addMultiHandler1(x, #selector(UITextViewDelegate.textViewDidChange(_:)))
		case .didChangeSelection(let x): delegate().addMultiHandler1(x, #selector(UITextViewDelegate.textViewDidChangeSelection(_:)))
		case .didEndEditing(let x): delegate().addMultiHandler1(x, #selector(UITextViewDelegate.textViewDidEndEditing(_:)))
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldBeginEditing(let x): delegate().addSingleHandler1(x, #selector(UITextViewDelegate.textViewShouldBeginEditing(_:)))
		case .shouldChangeText(let x): delegate().addSingleHandler3(x, #selector(UITextViewDelegate.textView(_:shouldChangeTextIn:replacementText:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler1(x, #selector(UITextViewDelegate.textViewShouldEndEditing(_:)))
		
		case .shouldInteractWithAttachment(let x): delegate().addSingleHandler4(x, #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)?))
		case .shouldInteractWithURL(let x): delegate().addSingleHandler4(x, #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, URL, NSRange, UITextItemInteraction) -> Bool)?))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .textInputTraits(let x): return x.value.apply(to: instance)
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsEditingTextAttributes(let x): return x.apply(instance) { i, v in i.allowsEditingTextAttributes = v }
		case .attributedText(let x): return x.apply(instance) { i, v in i.attributedText = v }
		case .clearsOnInsertion(let x): return x.apply(instance) { i, v in i.clearsOnInsertion = v }
		case .dataDetectorTypes(let x): return x.apply(instance) { i, v in i.dataDetectorTypes = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .inputAccessoryView(let x): return x.apply(instance) { i, v in i.inputAccessoryView = v?.uiView() }
		case .inputView(let x): return x.apply(instance) { i, v in i.inputView = v?.uiView() }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .isSelectable(let x): return x.apply(instance) { i, v in i.isSelectable = v }
		case .linkTextAttributes(let x): return x.apply(instance) { i, v in i.linkTextAttributes = v }
		case .selectedRange(let x): return x.apply(instance) { i, v in i.selectedRange = v }
		case .text(let x): return x.apply(instance) { i, v in i.text = v }
		case .textAlignment(let x): return x.apply(instance) { i, v in i.textAlignment = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		case .textContainerInset(let x): return x.apply(instance) { i, v in i.textContainerInset = v }
		case .typingAttributes(let x): return x.apply(instance) { i, v in i.typingAttributes = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .scrollRangeToVisible(let x): return x.apply(instance) { i, v in i.scrollRangeToVisible(v) }
			
		//	3. Action bindings are triggered by the object after construction.
		case .didBeginEditing: return nil
		case .didChange: return nil
		case .didChangeSelection: return nil
		case .didEndEditing: return nil
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldBeginEditing: return nil
		case .shouldChangeText: return nil
		case .shouldEndEditing: return nil
		
		case .shouldInteractWithAttachment: return nil
		case .shouldInteractWithURL: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TextView.Preparer {
	open class Storage: ScrollView.Preparer.Storage, UITextViewDelegate {}
	
	open class Delegate: ScrollView.Preparer.Delegate, UITextViewDelegate {
		open func textViewShouldBeginEditing(_ textView: UITextView) -> Bool {
			return singleHandler(textView)
		}
		
		open func textViewShouldEndEditing(_ textView: UITextView) -> Bool {
			return singleHandler(textView)
		}
		
		open func textViewDidBeginEditing(_ textView: UITextView) {
			multiHandler(textView)
		}
		
		open func textViewDidEndEditing(_ textView: UITextView) {
			multiHandler(textView)
		}
		
		open func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return singleHandler(textView, range, text)
		}
		
		open func textView(_ textView: UITextView, shouldInteractWith textAttachment: NSTextAttachment, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return singleHandler(textView, textAttachment, characterRange, interaction)
		}
		
		open func textView(_ textView: UITextView, shouldInteractWith url: URL, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return singleHandler(textView, url, characterRange, interaction)
		}
		
		open func textViewDidChange(_ textView: UITextView) {
			multiHandler(textView)
		}
		
		open func textViewDidChangeSelection(_ textView: UITextView) {
			multiHandler(textView)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TextViewBinding {
	public typealias TextViewName<V> = BindingName<V, TextView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TextView.Binding) -> TextViewName<V> {
		return TextViewName<V>(source: source, downcast: Binding.textViewBinding)
	}
}
public extension BindingName where Binding: TextViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TextViewName<$2> { return .name(TextView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var textInputTraits: TextViewName<Constant<TextInputTraits>> { return .name(TextView.Binding.textInputTraits) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsEditingTextAttributes: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.allowsEditingTextAttributes) }
	static var attributedText: TextViewName<Dynamic<NSAttributedString>> { return .name(TextView.Binding.attributedText) }
	static var clearsOnInsertion: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.clearsOnInsertion) }
	static var dataDetectorTypes: TextViewName<Dynamic<UIDataDetectorTypes>> { return .name(TextView.Binding.dataDetectorTypes) }
	static var font: TextViewName<Dynamic<UIFont?>> { return .name(TextView.Binding.font) }
	static var inputAccessoryView: TextViewName<Dynamic<ViewConvertible?>> { return .name(TextView.Binding.inputAccessoryView) }
	static var inputView: TextViewName<Dynamic<ViewConvertible?>> { return .name(TextView.Binding.inputView) }
	static var isEditable: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isEditable) }
	static var isSelectable: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isSelectable) }
	static var linkTextAttributes: TextViewName<Dynamic<[NSAttributedString.Key: Any]>> { return .name(TextView.Binding.linkTextAttributes) }
	static var selectedRange: TextViewName<Dynamic<NSRange>> { return .name(TextView.Binding.selectedRange) }
	static var text: TextViewName<Dynamic<String>> { return .name(TextView.Binding.text) }
	static var textAlignment: TextViewName<Dynamic<NSTextAlignment>> { return .name(TextView.Binding.textAlignment) }
	static var textColor: TextViewName<Dynamic<UIColor?>> { return .name(TextView.Binding.textColor) }
	static var textContainerInset: TextViewName<Dynamic<UIEdgeInsets>> { return .name(TextView.Binding.textContainerInset) }
	static var typingAttributes: TextViewName<Dynamic<[NSAttributedString.Key: Any]>> { return .name(TextView.Binding.typingAttributes) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var scrollRangeToVisible: TextViewName<Signal<NSRange>> { return .name(TextView.Binding.scrollRangeToVisible) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didBeginEditing: TextViewName<(UITextView) -> Void> { return .name(TextView.Binding.didBeginEditing) }
	static var didChange: TextViewName<(UITextView) -> Void> { return .name(TextView.Binding.didChange) }
	static var didChangeSelection: TextViewName<(UITextView) -> Void> { return .name(TextView.Binding.didChangeSelection) }
	static var didEndEditing: TextViewName<(UITextView) -> Void> { return .name(TextView.Binding.didEndEditing) }
	static var shouldBeginEditing: TextViewName<(UITextView) -> Bool> { return .name(TextView.Binding.shouldBeginEditing) }
	static var shouldChangeText: TextViewName<(UITextView, NSRange, String) -> Bool> { return .name(TextView.Binding.shouldChangeText) }
	static var shouldEndEditing: TextViewName<(UITextView) -> Bool> { return .name(TextView.Binding.shouldEndEditing) }
	static var shouldInteractWithAttachment: TextViewName<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool> { return .name(TextView.Binding.shouldInteractWithAttachment) }
	static var shouldInteractWithURL: TextViewName<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool> { return .name(TextView.Binding.shouldInteractWithURL) }
	
	// Composite binding names
	static func textChanged(_ void: Void = ()) -> TextViewName<SignalInput<String>> {
		return Binding.compositeName(
			value: { input in { textView in _ = input.send(value: textView.text) } },
			binding: TextView.Binding.didChange,
			downcast: Binding.textViewBinding
		)
	}
	static func attributedTextChanged(_ void: Void = ()) -> TextViewName<SignalInput<NSAttributedString>> {
		return Binding.compositeName(
			value: { input in { textView in _ = input.send(value: textView.attributedText) } },
			binding: TextView.Binding.didChange,
			downcast: Binding.textViewBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TextViewConvertible: ScrollViewConvertible {
	func uiTextView() -> UITextView
}
extension TextViewConvertible {
	public func uiScrollView() -> ScrollView.Instance { return uiTextView() }
}
extension UITextView: TextViewConvertible {
	public func uiTextView() -> UITextView { return self }
}
public extension TextView {
	func uiTextView() -> UITextView { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TextViewBinding: ScrollViewBinding {
	static func textViewBinding(_ binding: TextView.Binding) -> Self
	func asTextViewBinding() -> TextView.Binding?
}
public extension TextViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self {
		return textViewBinding(.inheritedBinding(binding))
	}
}
public extension TextViewBinding where Preparer.Inherited.Binding: TextViewBinding {
	func asTextViewBinding() -> TextView.Binding? {
		return asInheritedBinding()?.asTextViewBinding()
	}
}
public extension TextView.Binding {
	typealias Preparer = TextView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTextViewBinding() -> TextView.Binding? { return self }
	static func textViewBinding(_ binding: TextView.Binding) -> TextView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class Toolbar: Binder, ToolbarConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Toolbar {
	enum Binding: ToolbarBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		case barStyle(Dynamic<UIBarStyle>)
		case barTintColor(Dynamic<UIColor?>)
		case isTranslucent(Dynamic<Bool>)
		case items(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case shadowImage(Dynamic<ScopedValues<UIBarPosition, UIImage?>>)
		case tintColor(Dynamic<UIColor?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case position((UIBarPositioning) -> UIBarPosition)
	}
}

// MARK: - Binder Part 3: Preparer
public extension Toolbar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = Toolbar.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UIToolbar
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Toolbar.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
			
		case .position(let x): delegate().addSingleHandler1(x, #selector(UIToolbarDelegate.position(for:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setBackgroundImage(nil, forToolbarPosition: scope.barPosition, barMetrics: scope.barMetrics) },
				applyNew: { i, scope, v in i.setBackgroundImage(v, forToolbarPosition: scope.barPosition, barMetrics: scope.barMetrics) }
			)
		case .barStyle(let x): return x.apply(instance) { i, v in i.barStyle = v }
		case .barTintColor(let x): return x.apply(instance) { i, v in i.barTintColor = v }
		case .isTranslucent(let x): return x.apply(instance) { i, v in i.isTranslucent = v }
		case .items(let x): return x.apply(instance) { i, v in i.setItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
		case .shadowImage(let x):
			return x.apply(
				instance: instance,
				removeOld: { i, scope, v in i.setShadowImage(nil, forToolbarPosition: scope) },
				applyNew: { i, scope, v in i.setShadowImage(v, forToolbarPosition: scope) }
			)
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
			
			// 2. Signal bindings are performed on the object after construction.
			
		//	3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .position: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Toolbar.Preparer {
	open class Storage: View.Preparer.Storage, UIToolbarDelegate {}
	
	open class Delegate: DynamicDelegate, UIToolbarDelegate {
		open func position(for bar: UIBarPositioning) -> UIBarPosition {
			return singleHandler(bar)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ToolbarBinding {
	public typealias ToolbarName<V> = BindingName<V, Toolbar.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Toolbar.Binding) -> ToolbarName<V> {
		return ToolbarName<V>(source: source, downcast: Binding.scrollViewBinding)
	}
}
public extension BindingName where Binding: ToolbarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ToolbarName<$2> { return .name(Toolbar.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundImage: ToolbarName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>> { return .name(Toolbar.Binding.backgroundImage) }
	static var barStyle: ToolbarName<Dynamic<UIBarStyle>> { return .name(Toolbar.Binding.barStyle) }
	static var barTintColor: ToolbarName<Dynamic<UIColor?>> { return .name(Toolbar.Binding.barTintColor) }
	static var isTranslucent: ToolbarName<Dynamic<Bool>> { return .name(Toolbar.Binding.isTranslucent) }
	static var items: ToolbarName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> { return .name(Toolbar.Binding.items) }
	static var shadowImage: ToolbarName<Dynamic<ScopedValues<UIBarPosition, UIImage?>>> { return .name(Toolbar.Binding.shadowImage) }
	static var tintColor: ToolbarName<Dynamic<UIColor?>> { return .name(Toolbar.Binding.tintColor) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	//	3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var position: ToolbarName<(UIBarPositioning) -> UIBarPosition> { return .name(Toolbar.Binding.position) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ToolbarConvertible: ViewConvertible {
	func uiToolbar() -> Toolbar.Instance
}
extension ToolbarConvertible {
	public func uiView() -> View.Instance { return uiToolbar() }
}
extension UIToolbar: ToolbarConvertible, HasDelegate {
	public func uiToolbar() -> Toolbar.Instance { return self }
}
public extension Toolbar {
	func uiToolbar() -> Toolbar.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ToolbarBinding: ViewBinding {
	static func scrollViewBinding(_ binding: Toolbar.Binding) -> Self
	func asToolbarBinding() -> Toolbar.Binding?
}
public extension ToolbarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}
public extension ToolbarBinding where Preparer.Inherited.Binding: ToolbarBinding {
	func asToolbarBinding() -> Toolbar.Binding? {
		return asInheritedBinding()?.asToolbarBinding()
	}
}
public extension Toolbar.Binding {
	typealias Preparer = Toolbar.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asToolbarBinding() -> Toolbar.Binding? { return self }
	static func scrollViewBinding(_ binding: Toolbar.Binding) -> Toolbar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class ViewController: Binder, ViewControllerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ViewController {
	enum Binding: ViewControllerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case navigationItem(Constant<NavigationItem>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case additionalSafeAreaInsets(Dynamic<UIEdgeInsets>)
		case children(Dynamic<[ViewControllerConvertible]>)
		case definesPresentationContext(Dynamic<Bool>)
		case edgesForExtendedLayout(Dynamic<UIRectEdge>)
		case extendedLayoutIncludesOpaqueBars(Dynamic<Bool>)
		case hidesBottomBarWhenPushed(Dynamic<Bool>)
		case isEditing(Signal<SetOrAnimate<Bool>>)
		case isModalInPopover(Dynamic<Bool>)
		case modalPresentationCapturesStatusBarAppearance(Dynamic<Bool>)
		case modalPresentationStyle(Dynamic<UIModalPresentationStyle>)
		case modalTransitionStyle(Dynamic<UIModalTransitionStyle>)
		case preferredContentSize(Dynamic<CGSize>)
		case providesPresentationContextTransitionStyle(Dynamic<Bool>)
		case restorationClass(Dynamic<UIViewControllerRestoration.Type?>)
		case restorationIdentifier(Dynamic<String?>)
		case tabBarItem(Dynamic<TabBarItemConvertible>)
		case title(Dynamic<String>)
		case toolbarItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case transitioningDelegate(Dynamic<UIViewControllerTransitioningDelegate>)
		case view(Dynamic<ViewConvertible>)
		
		// 2. Signal bindings are performed on the object after construction.
		case present(Signal<Animatable<ModalPresentation?, ()>>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case childrenLayout(([UIView]) -> Layout)
	}
}

// MARK: - Binder Part 3: Preparer
public extension ViewController {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = ViewController.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = UIViewController
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		public var childrenLayout: (([UIView]) -> Layout)?
		public var view: InitialSubsequent<ViewConvertible>?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ViewController.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .childrenLayout(let x): childrenLayout = x
		case .view(let x): view = x.initialSubsequent()
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)

		// Need to set the embedded storage immediately (instead of waiting for the combine function) in case any of the swizzled methods get called (they rely on being able to access the embedded storage).
		instance.setAssociatedBinderStorage(storage)
		
		// The loadView function needs to be ready in case one of the bindings triggers a view load.
		if let v = view?.initial?.uiView() {
			instance.view = v
		}
		
		// The childrenLayout should be ready for when the children property starts
		storage.childrenLayout = childrenLayout
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .navigationItem(let x):
			x.value.apply(to: instance.navigationItem)
			return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .additionalSafeAreaInsets(let x): return x.apply(instance) { i, v in i.additionalSafeAreaInsets = v }
		case .children(let x):
			return x.apply(instance, storage) { i, s, v in
				let existing = i.children
				let next = v.map { $0.uiViewController() }
				
				for e in existing {
					if !next.contains(e) {
						e.willMove(toParent: nil)
					}
				}
				for n in next {
					if !existing.contains(n) {
						i.addChild(n)
					}
				}
				(storage.childrenLayout?(next.map { $0.view })).map(i.view.applyLayout)
				for n in next {
					if !existing.contains(n) {
						n.didMove(toParent: i)
					}
				}
				for e in existing {
					if !next.contains(e) {
						e.removeFromParent()
					}
				}
			}
		case .definesPresentationContext(let x): return x.apply(instance) { i, v in i.definesPresentationContext = v }
		case .edgesForExtendedLayout(let x): return x.apply(instance) { i, v in i.edgesForExtendedLayout = v }
		case .extendedLayoutIncludesOpaqueBars(let x): return x.apply(instance) { i, v in i.extendedLayoutIncludesOpaqueBars = v }
		case .hidesBottomBarWhenPushed(let x): return x.apply(instance) { i, v in i.hidesBottomBarWhenPushed = v }
		case .isEditing(let x): return x.apply(instance) { i, v in i.setEditing(v.value, animated: v.isAnimated) }
		case .isModalInPopover(let x): return x.apply(instance) { i, v in i.isModalInPopover = v }
		case .modalPresentationCapturesStatusBarAppearance(let x): return x.apply(instance) { i, v in i.modalPresentationCapturesStatusBarAppearance = v }
		case .modalPresentationStyle(let x): return x.apply(instance) { i, v in i.modalPresentationStyle = v }
		case .modalTransitionStyle(let x): return x.apply(instance) { i, v in i.modalTransitionStyle = v }
		case .preferredContentSize(let x): return x.apply(instance) { i, v in i.preferredContentSize = v }
		case .providesPresentationContextTransitionStyle(let x): return x.apply(instance) { i, v in i.providesPresentationContextTransitionStyle = v }
		case .restorationClass(let x): return x.apply(instance) { i, v in i.restorationClass = v }
		case .restorationIdentifier(let x): return x.apply(instance) { i, v in i.restorationIdentifier = v }
		case .tabBarItem(let x): return x.apply(instance) { i, v in i.tabBarItem = v.uiTabBarItem() }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .toolbarItems(let x): return x.apply(instance) { i, v in i.setToolbarItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
		case .transitioningDelegate(let x): return x.apply(instance) { i, v in i.transitioningDelegate = v }
		case .view:
			return view?.apply(instance, storage) { i, s, v in
				s.view = v
				if i.isViewLoaded {
					i.view = v.uiView()
				}
			}
			
		// 2. Signal bindings are performed on the object after construction.
		case .present(let x):
			return x.apply(instance, storage) { i, s, v in
				s.queuedModalPresentations.append(v)
				s.processModalPresentations(viewController: i)
			}
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .childrenLayout: return nil
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		// We previously set the embedded storage so that any delegate methods triggered during setup would be able to resolve the storage. Now that we're done setting up, we need to *clear* the storage so the embed function doesn't complain that the storage is already set.
		instance.setAssociatedBinderStorage(nil)
		
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ViewController.Preparer {
	private static var presenterKey = NSObject()
	
	open class Storage: AssociatedBinderStorage, UIPopoverPresentationControllerDelegate {
		open var view: ViewConvertible?
		open var childrenLayout: (([UIView]) -> Layout)?
		
		open var presentationAnimationInProgress: Bool = false
		open var currentModalPresentation: ModalPresentation? = nil
		open var queuedModalPresentations: [Animatable<ModalPresentation?, ()>] = []
		
		open override var isInUse: Bool {
			return true
		}
		
		private func presentationDismissed(viewController: UIViewController) {
			currentModalPresentation?.completion?.send(value: ())
			currentModalPresentation = nil
			processModalPresentations(viewController: viewController)
		}
		
		private func presentationAnimationCompleted(viewController: UIViewController, dismissed: Bool) {
			self.queuedModalPresentations.removeFirst()
			self.presentationAnimationInProgress = false
			if dismissed {
				presentationDismissed(viewController: viewController)
			}
		}
		
		open func popoverPresentationControllerDidDismissPopover(_ popoverPresentationController: UIPopoverPresentationController) {
			presentationDismissed(viewController: popoverPresentationController.presentingViewController)
		}
		
		private func present(viewController: UIViewController, modalPresentation: ModalPresentation, animated: Bool) {
			presentationAnimationInProgress = true
			currentModalPresentation = modalPresentation
			let presentation = modalPresentation.viewController.uiViewController()
			if let popover = presentation.popoverPresentationController, let configure = modalPresentation.popoverPositioning {
				configure(viewController, popover)
				popover.delegate = self
			} else if let presenter = presentation.presentationController {
				objc_setAssociatedObject(presenter, &presenterKey, OnDelete {
					guard presentation === self.currentModalPresentation?.viewController.uiViewController() else { return }
					self.presentationDismissed(viewController: viewController)
				}, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
			}
			viewController.present(presentation, animated: animated) {
				self.presentationAnimationCompleted(viewController: viewController, dismissed: false)
			}
		}
		
		private func dismiss(viewController: UIViewController, animated: Bool) {
			presentationAnimationInProgress = true
			guard let vc = viewController.presentedViewController else {
				self.presentationAnimationCompleted(viewController: viewController, dismissed: true)
				return
			}
			guard !(vc === currentModalPresentation?.viewController.uiViewController()) || vc.isBeingDismissed else {
				assertionFailure("Presentations interleaved with other APIs is not supported.")
				let completionHandlers = queuedModalPresentations.compactMap {
					$0.value?.completion
				}
				queuedModalPresentations.removeAll()
				presentationAnimationInProgress = false
				currentModalPresentation?.completion?.send(value: ())
				completionHandlers.forEach { $0.send(value: ()) }
				return
			}
			vc.dismiss(animated: animated, completion: { () -> Void in
				self.presentationAnimationCompleted(viewController: viewController, dismissed: true)
			})
		}
		
		open func processModalPresentations(viewController: UIViewController) {
			guard !presentationAnimationInProgress, let first = queuedModalPresentations.first else { return }
			if let modalPresentation = first.value {
				guard viewController.view.window != nil else { return }
				present(viewController: viewController, modalPresentation: modalPresentation, animated: first.isAnimated)
			} else {
				dismiss(viewController: viewController, animated: first.isAnimated)
			}
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ViewControllerBinding {
	public typealias ViewControllerName<V> = BindingName<V, ViewController.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ViewController.Binding) -> ViewControllerName<V> {
		return ViewControllerName<V>(source: source, downcast: Binding.viewControllerBinding)
	}
}
public extension BindingName where Binding: ViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ViewControllerName<$2> { return .name(ViewController.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var navigationItem: ViewControllerName<Constant<NavigationItem>> { return .name(ViewController.Binding.navigationItem) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var additionalSafeAreaInsets: ViewControllerName<Dynamic<UIEdgeInsets>> { return .name(ViewController.Binding.additionalSafeAreaInsets) }
	static var children: ViewControllerName<Dynamic<[ViewControllerConvertible]>> { return .name(ViewController.Binding.children) }
	static var definesPresentationContext: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.definesPresentationContext) }
	static var edgesForExtendedLayout: ViewControllerName<Dynamic<UIRectEdge>> { return .name(ViewController.Binding.edgesForExtendedLayout) }
	static var extendedLayoutIncludesOpaqueBars: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.extendedLayoutIncludesOpaqueBars) }
	static var hidesBottomBarWhenPushed: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.hidesBottomBarWhenPushed) }
	static var isEditing: ViewControllerName<Signal<SetOrAnimate<Bool>>> { return .name(ViewController.Binding.isEditing) }
	static var isModalInPopover: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.isModalInPopover) }
	static var modalPresentationCapturesStatusBarAppearance: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.modalPresentationCapturesStatusBarAppearance) }
	static var modalPresentationStyle: ViewControllerName<Dynamic<UIModalPresentationStyle>> { return .name(ViewController.Binding.modalPresentationStyle) }
	static var modalTransitionStyle: ViewControllerName<Dynamic<UIModalTransitionStyle>> { return .name(ViewController.Binding.modalTransitionStyle) }
	static var preferredContentSize: ViewControllerName<Dynamic<CGSize>> { return .name(ViewController.Binding.preferredContentSize) }
	static var providesPresentationContextTransitionStyle: ViewControllerName<Dynamic<Bool>> { return .name(ViewController.Binding.providesPresentationContextTransitionStyle) }
	static var restorationClass: ViewControllerName<Dynamic<UIViewControllerRestoration.Type?>> { return .name(ViewController.Binding.restorationClass) }
	static var restorationIdentifier: ViewControllerName<Dynamic<String?>> { return .name(ViewController.Binding.restorationIdentifier) }
	static var tabBarItem: ViewControllerName<Dynamic<TabBarItemConvertible>> { return .name(ViewController.Binding.tabBarItem) }
	static var title: ViewControllerName<Dynamic<String>> { return .name(ViewController.Binding.title) }
	static var toolbarItems: ViewControllerName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>> { return .name(ViewController.Binding.toolbarItems) }
	static var transitioningDelegate: ViewControllerName<Dynamic<UIViewControllerTransitioningDelegate>> { return .name(ViewController.Binding.transitioningDelegate) }
	static var view: ViewControllerName<Dynamic<ViewConvertible>> { return .name(ViewController.Binding.view) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var present: ViewControllerName<Signal<Animatable<ModalPresentation?, ()>>> { return .name(ViewController.Binding.present) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var childrenLayout: ViewControllerName<([UIView]) -> Layout> { return .name(ViewController.Binding.childrenLayout) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ViewControllerConvertible {
	func uiViewController() -> ViewController.Instance
}
extension UIViewController: ViewControllerConvertible, DefaultConstructable {
	public func uiViewController() -> ViewController.Instance { return self }
}
public extension ViewController {
	func uiViewController() -> ViewController.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ViewControllerBinding: BinderBaseBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self
	func asViewControllerBinding() -> ViewController.Binding?
}
public extension ViewControllerBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return viewControllerBinding(.inheritedBinding(binding))
	}
}
public extension ViewControllerBinding where Preparer.Inherited.Binding: ViewControllerBinding {
	func asViewControllerBinding() -> ViewController.Binding? {
		return asInheritedBinding()?.asViewControllerBinding()
	}
}
public extension ViewController.Binding {
	typealias Preparer = ViewController.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asViewControllerBinding() -> ViewController.Binding? { return self }
	static func viewControllerBinding(_ binding: ViewController.Binding) -> ViewController.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public struct ModalPresentation {
	let viewController: ViewControllerConvertible
	let popoverPositioning: ((_ presenter: UIViewController, _ popover: UIPopoverPresentationController) -> Void)?
	let completion: SignalInput<Void>?
	
	public init(_ viewController: ViewControllerConvertible, popoverPositioning: ((_ presenter: UIViewController, _ popover: UIPopoverPresentationController) -> Void)? = nil, completion: SignalInput<Void>? = nil) {
		self.viewController = viewController
		self.popoverPositioning = popoverPositioning
		self.completion = completion
	}
}

extension SignalInterface {
	public func modalPresentation<T>(_ construct: @escaping (T) -> ViewControllerConvertible) -> Signal<ModalPresentation?> where OutputValue == Optional<T> {
		return transform { result in
			switch result {
			case .success(.some(let t)): return .value(ModalPresentation(construct(t)))
			case .success: return .value(nil)
			case .failure(let e): return .end(e)
			}
		}
	}
}

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class View: Binder, ViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension View {
	enum Binding: ViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case layer(Constant<Layer>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case alpha(Dynamic<(CGFloat)>)
		case backgroundColor(Dynamic<(UIColor?)>)
		case clearsContextBeforeDrawing(Dynamic<(Bool)>)
		case clipsToBounds(Dynamic<(Bool)>)
		case contentMode(Dynamic<(UIView.ContentMode)>)
		case gestureRecognizers(Dynamic<[GestureRecognizerConvertible]>)
		case horizontalContentCompressionResistancePriority(Dynamic<UILayoutPriority>)
		case horizontalContentHuggingPriority(Dynamic<UILayoutPriority>)
		case isExclusiveTouch(Dynamic<(Bool)>)
		case isHidden(Dynamic<(Bool)>)
		case isMultipleTouchEnabled(Dynamic<(Bool)>)
		case isOpaque(Dynamic<(Bool)>)
		case isUserInteractionEnabled(Dynamic<(Bool)>)
		case layout(Dynamic<Layout>)
		case layoutMargins(Dynamic<(UIEdgeInsets)>)
		case mask(Dynamic<(ViewConvertible?)>)
		case motionEffects(Dynamic<([UIMotionEffect])>)
		case preservesSuperviewLayoutMargins(Dynamic<(Bool)>)
		case restorationIdentifier(Dynamic<String?>)
		case semanticContentAttribute(Dynamic<(UISemanticContentAttribute)>)
		case tag(Dynamic<Int>)
		case tintAdjustmentMode(Dynamic<(UIView.TintAdjustmentMode)>)
		case tintColor(Dynamic<(UIColor)>)
		case verticalContentCompressionResistancePriority(Dynamic<UILayoutPriority>)
		case verticalContentHuggingPriority(Dynamic<UILayoutPriority>)

		// 2. Signal bindings are performed on the object after construction.
		case becomeFirstResponder(Signal<Void>)
		case endEditing(Signal<Bool>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension View {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = View.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = UIView
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension View.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .layer(let x):
			x.value.apply(to: instance.layer)
			return nil
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .alpha(let x): return x.apply(instance) { i, v in i.alpha = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .clearsContextBeforeDrawing(let x): return x.apply(instance) { i, v in i.clearsContextBeforeDrawing = v }
		case .clipsToBounds(let x): return x.apply(instance) { i, v in i.clipsToBounds = v }
		case .contentMode(let x): return x.apply(instance) { i, v in i.contentMode = v }
		case .gestureRecognizers(let x): return x.apply(instance) { i, v in i.gestureRecognizers = v.map { $0.uiGestureRecognizer() } }
		case .horizontalContentCompressionResistancePriority(let x): return x.apply(instance) { i, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Axis.horizontal) }
		case .horizontalContentHuggingPriority(let x): return x.apply(instance) { i, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Axis.horizontal) }
		case .isExclusiveTouch(let x): return x.apply(instance) { i, v in i.isExclusiveTouch = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .isMultipleTouchEnabled(let x): return x.apply(instance) { i, v in i.isMultipleTouchEnabled = v }
		case .isOpaque(let x): return x.apply(instance) { i, v in i.isOpaque = v }
		case .isUserInteractionEnabled(let x): return x.apply(instance) { i, v in i.isUserInteractionEnabled = v }
		case .layout(let x): return x.apply(instance) { i, v in instance.applyLayout(v) }
		case .layoutMargins(let x): return x.apply(instance) { i, v in i.layoutMargins = v }
		case .mask(let x): return x.apply(instance) { i, v in i.mask = v?.uiView() }
		case .motionEffects(let x): return x.apply(instance) { i, v in i.motionEffects = v }
		case .preservesSuperviewLayoutMargins(let x): return x.apply(instance) { i, v in i.preservesSuperviewLayoutMargins = v }
		case .restorationIdentifier(let x): return x.apply(instance) { i, v in i.restorationIdentifier = v }
		case .semanticContentAttribute(let x): return x.apply(instance) { i, v in i.semanticContentAttribute = v }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .tintAdjustmentMode(let x): return x.apply(instance) { i, v in i.tintAdjustmentMode = v }
		case .tintColor(let x): return x.apply(instance) { i, v in i.tintColor = v }
		case .verticalContentCompressionResistancePriority(let x): return x.apply(instance) { i, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Axis.vertical) }
		case .verticalContentHuggingPriority(let x): return x.apply(instance) { i, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Axis.vertical) }

		// 2. Signal bindings are performed on the object after construction.
		case .becomeFirstResponder(let x): return x.apply(instance) { i, v in i.becomeFirstResponder() }
		case .endEditing(let x): return x.apply(instance) { i, v in i.endEditing(v) }
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension View.Preparer {
	public typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ViewBinding {
	public typealias ViewName<V> = BindingName<V, View.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> View.Binding) -> ViewName<V> {
		return ViewName<V>(source: source, downcast: Binding.viewBinding)
	}
}
public extension BindingName where Binding: ViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ViewName<$2> { return .name(View.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var layer: ViewName<Constant<Layer>> { return .name(View.Binding.layer) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alpha: ViewName<Dynamic<(CGFloat)>> { return .name(View.Binding.alpha) }
	static var backgroundColor: ViewName<Dynamic<(UIColor?)>> { return .name(View.Binding.backgroundColor) }
	static var clearsContextBeforeDrawing: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.clearsContextBeforeDrawing) }
	static var clipsToBounds: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.clipsToBounds) }
	static var contentMode: ViewName<Dynamic<(UIView.ContentMode)>> { return .name(View.Binding.contentMode) }
	static var gestureRecognizers: ViewName<Dynamic<[GestureRecognizerConvertible]>> { return .name(View.Binding.gestureRecognizers) }
	static var horizontalContentCompressionResistancePriority: ViewName<Dynamic<UILayoutPriority>> { return .name(View.Binding.horizontalContentCompressionResistancePriority) }
	static var horizontalContentHuggingPriority: ViewName<Dynamic<UILayoutPriority>> { return .name(View.Binding.horizontalContentHuggingPriority) }
	static var isExclusiveTouch: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isExclusiveTouch) }
	static var isHidden: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isHidden) }
	static var isMultipleTouchEnabled: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isMultipleTouchEnabled) }
	static var isOpaque: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isOpaque) }
	static var isUserInteractionEnabled: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.isUserInteractionEnabled) }
	static var layout: ViewName<Dynamic<Layout>> { return .name(View.Binding.layout) }
	static var layoutMargins: ViewName<Dynamic<(UIEdgeInsets)>> { return .name(View.Binding.layoutMargins) }
	static var mask: ViewName<Dynamic<(ViewConvertible?)>> { return .name(View.Binding.mask) }
	static var motionEffects: ViewName<Dynamic<([UIMotionEffect])>> { return .name(View.Binding.motionEffects) }
	static var preservesSuperviewLayoutMargins: ViewName<Dynamic<(Bool)>> { return .name(View.Binding.preservesSuperviewLayoutMargins) }
	static var restorationIdentifier: ViewName<Dynamic<String?>> { return .name(View.Binding.restorationIdentifier) }
	static var semanticContentAttribute: ViewName<Dynamic<(UISemanticContentAttribute)>> { return .name(View.Binding.semanticContentAttribute) }
	static var tag: ViewName<Dynamic<Int>> { return .name(View.Binding.tag) }
	static var tintAdjustmentMode: ViewName<Dynamic<(UIView.TintAdjustmentMode)>> { return .name(View.Binding.tintAdjustmentMode) }
	static var tintColor: ViewName<Dynamic<(UIColor)>> { return .name(View.Binding.tintColor) }
	static var verticalContentCompressionResistancePriority: ViewName<Dynamic<UILayoutPriority>> { return .name(View.Binding.verticalContentCompressionResistancePriority) }
	static var verticalContentHuggingPriority: ViewName<Dynamic<UILayoutPriority>> { return .name(View.Binding.verticalContentHuggingPriority) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var becomeFirstResponder: ViewName<Signal<Void>> { return .name(View.Binding.becomeFirstResponder) }
	static var endEditing: ViewName<Signal<Bool>> { return .name(View.Binding.endEditing) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension UIView: DefaultConstructable {}
public extension View {
	func uiView() -> Layout.View { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ViewBinding: BinderBaseBinding {
	static func viewBinding(_ binding: View.Binding) -> Self
	func asViewBinding() -> View.Binding?
}
public extension ViewBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return viewBinding(.inheritedBinding(binding))
	}
}
public extension ViewBinding where Preparer.Inherited.Binding: ViewBinding {
	func asViewBinding() -> View.Binding? {
		return asInheritedBinding()?.asViewBinding()
	}
}
public extension View.Binding {
	typealias Preparer = View.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asViewBinding() -> View.Binding? { return self }
	static func viewBinding(_ binding: View.Binding) -> View.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(iOS)

// MARK: - Binder Part 1: Binder
public class Window: Binder, WindowConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Window {
	enum Binding: WindowBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case frame(Dynamic<CGRect>)
		case rootViewController(Dynamic<ViewControllerConvertible>)
		case screen(Dynamic<UIScreen>)
		case windowLevel(Dynamic<UIWindow.Level>)
		
		// 2. Signal bindings are performed on the object after construction.
		case makeKey(Signal<Void>)
		
		// 3. Action bindings are triggered by the object after construction.
		case didBecomeVisible(SignalInput<Void>)
		case didBecomeHidden(SignalInput<Void>)
		case didBecomeKey(SignalInput<Void>)
		case didResignKey(SignalInput<Void>)
		case keyboardWillShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillChangeFrame(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidChangeFrame(SignalInput<[AnyHashable: Any]?>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension Window {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = Window.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = UIWindow
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var isHidden: InitialSubsequent<Bool>? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Window.Preparer {
	mutating func prepareBinding(_ binding: Window.Binding) {
		switch binding {
		case .inheritedBinding(.isHidden(let x)): isHidden = x.initialSubsequent()
		case .inheritedBinding(let s): inherited.prepareBinding(s)
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(.isHidden): return nil
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .frame(let x): return x.apply(instance) { i, v in i.frame = v }
		case .rootViewController(let x):
			return x.apply(instance) { i, v in
				let rootViewController = v.uiViewController()
				i.rootViewController = rootViewController
				if rootViewController.restorationIdentifier == nil {
					rootViewController.restorationIdentifier = "cwlviews.root"
				}
			}
		case .screen(let x): return x.apply(instance) { i, v in i.screen = v }
		case .windowLevel(let x): return x.apply(instance) { i, v in i.windowLevel = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .makeKey(let x): return x.apply(instance) { i, v in i.makeKey() }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didBecomeHidden(let x): return Signal.notifications(name: UIWindow.didBecomeHiddenNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
		case .didBecomeKey(let x): return Signal.notifications(name: UIWindow.didBecomeKeyNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
		case .didBecomeVisible(let x): return Signal.notifications(name: UIWindow.didBecomeVisibleNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
		case .didResignKey(let x): return Signal.notifications(name: UIWindow.didResignKeyNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
		case .keyboardDidChangeFrame(let x): return Signal.notifications(name: UIResponder.keyboardDidChangeFrameNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardDidHide(let x): return Signal.notifications(name: UIResponder.keyboardDidHideNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardDidShow(let x): return Signal.notifications(name: UIResponder.keyboardDidShowNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardWillChangeFrame(let x): return Signal.notifications(name: UIResponder.keyboardWillChangeFrameNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardWillHide(let x): return Signal.notifications(name: UIResponder.keyboardWillHideNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		case .keyboardWillShow(let x): return Signal.notifications(name: UIResponder.keyboardWillShowNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: View.Preparer.Storage) -> Lifetime? {
		var lifetimes = [Lifetime]()
		
		// `isHidden` needs to be applied after everything else
		lifetimes += (isHidden?.resume()).flatMap {
			inherited.applyBinding(.isHidden(.dynamic($0)), instance: instance, storage: storage)
		}
		
		lifetimes += inherited.inheritedFinalizedInstance(instance, storage: storage)
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Window.Preparer {
	public typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: WindowBinding {
	public typealias WindowName<V> = BindingName<V, Window.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Window.Binding) -> WindowName<V> {
		return WindowName<V>(source: source, downcast: Binding.windowBinding)
	}
}
public extension BindingName where Binding: WindowBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: WindowName<$2> { return .name(Window.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var frame: WindowName<Dynamic<CGRect>> { return .name(Window.Binding.frame) }
	static var rootViewController: WindowName<Dynamic<ViewControllerConvertible>> { return .name(Window.Binding.rootViewController) }
	static var screen: WindowName<Dynamic<UIScreen>> { return .name(Window.Binding.screen) }
	static var windowLevel: WindowName<Dynamic<UIWindow.Level>> { return .name(Window.Binding.windowLevel) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var makeKey: WindowName<Signal<Void>> { return .name(Window.Binding.makeKey) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBecomeVisible: WindowName<SignalInput<Void>> { return .name(Window.Binding.didBecomeVisible) }
	static var didBecomeHidden: WindowName<SignalInput<Void>> { return .name(Window.Binding.didBecomeHidden) }
	static var didBecomeKey: WindowName<SignalInput<Void>> { return .name(Window.Binding.didBecomeKey) }
	static var didResignKey: WindowName<SignalInput<Void>> { return .name(Window.Binding.didResignKey) }
	static var keyboardWillShow: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardWillShow) }
	static var keyboardDidShow: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardDidShow) }
	static var keyboardWillHide: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardWillHide) }
	static var keyboardDidHide: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardDidHide) }
	static var keyboardWillChangeFrame: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardWillChangeFrame) }
	static var keyboardDidChangeFrame: WindowName<SignalInput<[AnyHashable: Any]?>> { return .name(Window.Binding.keyboardDidChangeFrame) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol WindowConvertible: ViewConvertible {
	func uiWindow() -> Window.Instance
}
extension WindowConvertible {
	public func uiView() -> View.Instance { return uiWindow() }
}
extension UIWindow: WindowConvertible {
	public func uiWindow() -> Window.Instance { return self }
}
public extension Window {
	func uiWindow() -> Window.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol WindowBinding: ViewBinding {
	static func windowBinding(_ binding: Window.Binding) -> Self
	func asWindowBinding() -> Window.Binding?
}
public extension WindowBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return windowBinding(.inheritedBinding(binding))
	}
}
public extension WindowBinding where Preparer.Inherited.Binding: WindowBinding {
	func asWindowBinding() -> Window.Binding? {
		return asInheritedBinding()?.asWindowBinding()
	}
}
public extension Window.Binding {
	typealias Preparer = Window.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asWindowBinding() -> Window.Binding? { return self }
	static func windowBinding(_ binding: Window.Binding) -> Window.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif
