//
//  This file is part of a concatenation of the CwlViews framework with public
//  interfaces for exposing from libraries or use in Swift Playgrounds).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-05-11 02:03:25 +0000 from the following files:
//   CwlAdapter+Signals.swift
//   CwlAdapter.swift
//   CwlAdapterState.swift
//   CwlCodableContainer.swift
//   CwlMasterDetail.swift
//   CwlModelState.swift
//   CwlStackAdapter.swift
//   CwlTempVar.swift
//   CwlToggleVar.swift
//   CwlVar.swift
//   CwlAssociatedBinderStorage.swift
//   CwlBinder.swift
//   CwlBinderApplyable.swift
//   CwlBinderBase.swift
//   CwlBinderDelegate.swift
//   CwlBinderEmbedderConstructor.swift
//   CwlBinderPreparer.swift
//   CwlBinding.swift
//   CwlBindingName.swift
//   CwlConstant.swift
//   CwlDynamic.swift
//   CwlInitialSubsequent.swift
//   CwlScopedValues.swift
//   CwlSignalCallback.swift
//   CwlTargetAction.swift
//   CwlIndexedMutation.swift
//   CwlSetMutation.swift
//   CwlStackMutation.swift
//   CwlSubrangeMutation.swift
//   CwlTreeMutation.swift
//   CwlAnimatable.swift
//   CwlCoder.swift
//   CwlImageDrawn.swift
//   CwlKeyValueObservationLifetime.swift
//   CwlLayout.swift
//   CwlPreferredFonts.swift
//   CwlExtendedView.swift
//   CwlGradientLayer.swift
//   CwlLayer.swift
//   CwlShapeLayer.swift
//   CwlStackView.swift
//   CwlWebView.swift

import Foundation

extension Adapter: Lifetime {
	public func cancel() {
		if State.self is CodableContainer.Type, let value = combinedSignal.peek()?.state, var sc = value as? CodableContainer {
			sc.cancel()
		}
		input.cancel()
	}
}

extension Adapter: Codable where State: Codable {
	public init(from decoder: Decoder) throws {
		let c = try decoder.singleValueContainer()
		let p = try c.decode(State.self)
		self.init(adapterState: p)
	}
	
	public func encode(to encoder: Encoder) throws {
		if let s = combinedSignal.peek()?.state {
			var c = encoder.singleValueContainer()
			try c.encode(s)
		}
	}
}

extension Adapter: CodableContainer where State: PersistentAdapterState {
	public var childCodableContainers: [CodableContainer] {
		if let state = combinedSignal.peek()?.state {
			return (state as? CodableContainer)?.childCodableContainers ?? []
		} else {
			return []
		}
	}
	
	public var codableValueChanged: Signal<Void> {
		if State.self is CodableContainer.Type {
			return combinedSignal.flatMapLatest { (content: State.Output) -> Signal<Void> in
				let cc = content.state as! CodableContainer
				return cc.codableValueChanged.startWith(())
			}.dropActivation()
		}
		return combinedSignal.map { _ in () }.dropActivation()
	}
}

public struct Adapter<State: AdapterState>: SignalInterface, SignalInputInterface {
	public typealias OutputValue = State.Notification
	public typealias InputValue = State.Message
	private enum Keys: CodingKey { case `var` }
	
	let executionContext: Exec

	public let multiInput: SignalMultiInput<State.Message>
	public var input: SignalInput<State.Message> { return multiInput }
	
	let combinedSignal: SignalMulti<State.Output>
	public var signal: Signal<State.Notification> {
		return combinedSignal.compactMapActivation(select: .last, context: executionContext, activation: { $0.state.resume() }, remainder: { $0.notification })
	}
	
	public init(adapterState: State? = nil) {
		let (i, s) = Signal<State.Message>.multiChannel().tuple
		multiInput = i
		
		if let state = adapterState {
			let (ec, async) = state.instanceContext
			executionContext = ec
			let sig = async ? s.scheduleAsync(relativeTo: executionContext) : s
			combinedSignal = sig.reduce(initialState: (state, nil), context: executionContext) { (content: State.Output, message: State.Message) throws -> State.Output in
				try content.state.reduce(message: message, feedback: i)
			}
		} else {
			let initializer = { (message: State.Message) throws -> State.Output? in
				try State.initialize(message: message, feedback: i)
			}
			let (ec, async) = State.defaultContext
			executionContext = ec
			let sig = async ? s.scheduleAsync(relativeTo: executionContext) : s
			combinedSignal = sig.reduce(context: executionContext, initializer: initializer) { (content: State.Output, message: State.Message) throws -> State.Output in
				try content.state.reduce(message: message, feedback: i)
			}
		}
	}
}

public protocol AdapterState {
	associatedtype Message
	associatedtype Notification
	
	typealias Output = (state: Self, notification: Notification?)
	
	static var defaultContext: (Exec, Bool) { get }

	static func initialize(message: Message, feedback: SignalMultiInput<Message>) throws -> Output?

	var instanceContext: (Exec, Bool) { get }

	func reduce(message: Message, feedback: SignalMultiInput<Message>) throws -> Output
	func resume() -> Notification?
}

public extension AdapterState {
	static var defaultContext: (Exec, Bool) {
		return (.direct, false)
	}
	
	var instanceContext: (Exec, Bool) {
		return Self.defaultContext
	}
	
	static func initialize(message: Message, feedback: SignalMultiInput<Message>) throws -> Output? {
		return nil
	}
}

public protocol NonPersistentAdapterState: AdapterState, Codable {
	init()
}

public extension NonPersistentAdapterState {
	init(from decoder: Decoder) throws {
		self.init()
	}
	
	func encode(to encoder: Encoder) throws {
	}
}

public extension Adapter {
	init<Value>() where TempValue<Value> == State {
		self.init(adapterState: TempValue<Value>())
	}
}

public protocol PersistentAdapterState: AdapterState, Codable {
	associatedtype PersistentValue: Codable
	init(value: PersistentValue)
	var value: PersistentValue { get }
}

extension PersistentAdapterState where Notification == PersistentValue {
	public func resume() -> Notification? {
		return value
	}
}

extension Adapter where State: PersistentAdapterState {
	public var state: Signal<State> {
		return combinedSignal.compactMap { content in content.state }
	}
}

public extension PersistentAdapterState {
	init(from decoder: Decoder) throws {
		let c = try decoder.singleValueContainer()
		let p = try c.decode(PersistentValue.self)
		self.init(value: p)
	}
	
	func encode(to encoder: Encoder) throws {
		var c = encoder.singleValueContainer()
		try c.encode(value)
	}
}

extension Adapter where State: PersistentAdapterState {
	public func logJson(prefix: String = "", formatting: JSONEncoder.OutputFormatting = .prettyPrinted) -> Lifetime {
		return codableValueChanged
			.startWith(())
			.subscribe { _ in
				let enc = JSONEncoder()
				enc.outputFormatting = formatting
				if let data = try? enc.encode(self), let string = String(data: data, encoding: .utf8) {
					print("\(prefix)\(string)")
				}
		}
	}
}

public protocol PersistentContainerAdapterState: PersistentAdapterState, CodableContainer where PersistentValue: CodableContainer {}

extension PersistentContainerAdapterState {
	public var childCodableContainers: [CodableContainer] {
		return value.childCodableContainers
	}
	
	public var codableValueChanged: Signal<Void> {
		return value.codableValueChanged
	}
}

public protocol CodableContainer: Lifetime, Codable {
	var codableValueChanged: Signal<Void> { get }
	var childCodableContainers: [CodableContainer] { get }
}

extension CodableContainer {
	public var childCodableContainers: [CodableContainer] {
		return Mirror(reflecting: self).children.compactMap { $0.value as? CodableContainer }
	}
	
	public var codableValueChanged: Signal<Void> {
		let sequence = childCodableContainers.map { return $0.codableValueChanged }
		if sequence.isEmpty {
			return Signal<Void>.preclosed()
		} else if sequence.count == 1 {
			return sequence.first!
		} else {
			return Signal<Void>.merge(sequence: sequence)
		}
	}
	
	public mutating func cancel() {
		for var v in childCodableContainers {
			v.cancel()
		}
	}
}

extension Array: Lifetime where Element: CodableContainer {
	public mutating func cancel() {
		for var v in self {
			v.cancel()
		}
	}
}

extension Optional: Lifetime where Wrapped: CodableContainer {
	public mutating func cancel() {
		self?.cancel()
	}
}

extension Array: CodableContainer where Element: CodableContainer {
	public var childCodableContainers: [CodableContainer] {
		return flatMap { $0.childCodableContainers }
	}
}

extension Optional: CodableContainer where Wrapped: CodableContainer {
	public var childCodableContainers: [CodableContainer] {
		return self?.childCodableContainers ?? []
	}
}

/// An "Either" type for use in scenarios where "Equatable" and "Codable" are required but there's only ever a single "Master" instance so equality is implied. This is common in Navigation Controller stacks and Split Views.
public enum MasterDetail<Master: CodableContainer, Detail: CodableContainer>: CodableContainer {
	case master(Master)
	case detail(Detail)
	
	public var childCodableContainers: [CodableContainer] {
		switch self {
		case .master(let tvm): return [tvm]
		case .detail(let dvm): return [dvm]
		}
	}
	
	enum Keys: CodingKey { case master, detail }
	
	public func encode(to encoder: Encoder) throws {
		var c = encoder.container(keyedBy: Keys.self)
		switch self {
		case .master(let tvm): try c.encode(tvm, forKey: .master)
		case .detail(let dvm): try c.encode(dvm, forKey: .detail)
		}
	}
	
	public init(from decoder: Decoder) throws {
		let c = try decoder.container(keyedBy: Keys.self)
		if let tvm = try c.decodeIfPresent(Master.self, forKey: .master) {
			self = .master(tvm)
		} else {
			self = .detail(try c.decode(Detail.self, forKey: .detail))
		}
	}
}

public struct ModelState<Wrapped, M, N>: AdapterState {
	public typealias Message = M
	public typealias Notification = N
	public let instanceContext: (Exec, Bool) 
	
	let reducer: (_ model: inout Wrapped, _ message: Message, _ feedback: SignalMultiInput<Message>) throws -> Notification?
	let resumer: (_ model: Wrapped) -> Notification?
	let wrapped: Wrapped
	
	init(previous: ModelState<Wrapped, M, N>, nextWrapped: Wrapped) {
		self.instanceContext = previous.instanceContext
		self.reducer = previous.reducer
		self.resumer = previous.resumer
		self.wrapped = nextWrapped
	}
	
	public init(async: Bool = false, initial: Wrapped, resumer: @escaping (_ model: Wrapped) -> Notification? = { _ in nil }, reducer: @escaping (_ model: inout Wrapped, _ message: Message, _ feedback: SignalMultiInput<Message>) throws -> Notification?) {
		self.instanceContext = (Exec.syncQueue(), async)
		self.reducer = reducer
		self.resumer = resumer
		self.wrapped = initial
	}

	public func reduce(message: Message, feedback: SignalMultiInput<Message>) throws -> (state: ModelState<Wrapped, Message, Notification>, notification: N?) {
		var nextWrapped = wrapped
		let n = try reducer(&nextWrapped, message, feedback)
		return (ModelState<Wrapped, M, N>(previous: self, nextWrapped: nextWrapped), n)
	}
	
	public func resume() -> Notification? {
		return resumer(wrapped)
	}
}


public extension Adapter {
	/// Access the internal state outside of the reactive pipeline.
	///
	/// NOTE: this function is `throws` *not* `rethrows`. The function may throw regardless of whether the supplied `processor` may throw.
	///
	/// - Parameter processor: performs work with the underlying state
	/// - Returns: the result from `processor`
	/// - Throws: Other than any error thrown from `processor`, this function can throw if no model value is available (it might not be initialized or the execution context may have delayed the response).
	func sync<Wrapped, R, M, N>(_ processor: (Wrapped) throws -> R) throws -> R where ModelState<Wrapped, M, N> == State {
		// Don't `peek` inside the `invokeSync` since that would require re-entering the `executionContext`.
		let wrapped = try combinedSignal.capture().get().state.wrapped
		return try executionContext.invokeSync { return try processor(wrapped) }
	}
	
	func slice<Wrapped, Processed, M, N>(resume: N? = nil, _ processor: @escaping (Wrapped, N) throws -> Signal<Processed>.Next) -> Signal<Processed> where ModelState<Wrapped, M, N> == State {
		let s: Signal<State.Output>
		if let r = resume {
			s = combinedSignal.compactMapActivation(context: executionContext) { ($0.state, r) }
		} else {
			s = combinedSignal
		}
		return s.transform(context: executionContext) { result in
			switch result {
			case .failure(let e): return .end(e)
			case .success(_, nil): return .none
			case .success(let wrapped, .some(let notification)):
				do {
					return try processor(wrapped.wrapped, notification)
				} catch {
					return .error(error)
				}
			}
		}
	}
	
	func slice<Value, Wrapped, Processed, M, N>(initial: Value, resume: N? = nil, _ processor: @escaping (inout Value, Wrapped, N) throws -> Signal<Processed>.Next) -> Signal<Processed> where ModelState<Wrapped, M, N> == State {
		let s: Signal<State.Output>
		if let r = resume {
			s = combinedSignal.compactMapActivation(context: executionContext) { ($0.state, r) }
		} else {
			s = combinedSignal
		}
		return s.transform(initialState: initial, context: executionContext) { value, result in
			switch result {
			case .failure(let e): return .end(e)
			case .success(_, nil): return .none
			case .success(let wrapped, .some(let notification)):
				do {
					return try processor(&value, wrapped.wrapped, notification)
				} catch {
					return .error(error)
				}
			}
		}
	}

	func logJson<Wrapped, M, N, Value>(keyPath: KeyPath<Wrapped, Value>, prefix: String = "", formatting: JSONEncoder.OutputFormatting = .prettyPrinted) -> Lifetime where State == ModelState<Wrapped, M, N>, Value: Encodable {
		return combinedSignal.subscribeValues(context: executionContext) { (state, _) in
			let enc = JSONEncoder()
			enc.outputFormatting = formatting
			if let data = try? enc.encode(state.wrapped[keyPath: keyPath]), let string = String(data: data, encoding: .utf8) {
				print("\(prefix)\(string)")
			}
		}
	}
}

import Foundation

public typealias StackAdapter<PathElement: Codable> = Adapter<StackAdapterState<PathElement>>

/// This "Adapter" is a `ModelSignalValue` that manages a stack of navigation items as might be used by a UINavigationController. The adapter converts `push`, `popToCount` and `reload` messages into updates to the array of `PathElement`. The adapter includes convenient input signals, animated output signals and includes automatic implementation of coding and notification protocols.
public struct StackAdapterState<PathElement: Codable>: PersistentAdapterState {
	public typealias Message = StackMutation<PathElement>
	public typealias Notification = StackMutation<PathElement>
	
	public let value: [PathElement]
	public init(value: [PathElement]) {
		self.value = value
	}
	
	public func reduce(message: Message, feedback: SignalMultiInput<Message>) -> Output {
		switch message {
		case .push(let e):
			let next = StackAdapterState<PathElement>(value: value.appending(e))
			return Output(state: next, notification: message)
		case .pop:
			let next = StackAdapterState<PathElement>(value: Array(value.dropLast()))
			return Output(state: next, notification: message)
		case .popToCount(let i):
			guard i >= 1 else { return Output(state: self, notification: nil) }
			let next = StackAdapterState<PathElement>(value: Array(value.prefix(i)))
			return Output(state: next, notification: message)
		case .reload(let newStack):
			let next = StackAdapterState<PathElement>(value: newStack)
			return Output(state: next, notification: message)
		}
	}
	
	public func resume() -> Notification? {
		return Message.reload(value)
	}
	
	public static func initialize(message: Message, feedback: SignalMultiInput<Message>) -> Output? {
		return StackAdapterState<PathElement>(value: []).reduce(message: message, feedback: feedback)
	}
}

extension StackAdapterState: Codable where PathElement: Codable {}

extension StackAdapterState: Lifetime where PathElement: Lifetime {
	public mutating func cancel() {
		for var l in value {
			l.cancel()
		}
		self = StackAdapterState(value: value.map { element in
			var e = element
			e.cancel()
			return e
		})
	}
}

extension StackAdapterState: CodableContainer where PathElement: CodableContainer {
	public var childCodableContainers: [CodableContainer] {
		return value.childCodableContainers
	}
	
	public var codableValueChanged: Signal<Void> {
		return value.codableValueChanged
	}
}

public extension Adapter {
	init<PathElement: Codable>( _ value: [PathElement]) where StackAdapterState<PathElement> == State {
		self.init(adapterState: StackAdapterState<PathElement>(value: value))
	}
}

extension Adapter {
	public func push<PathElement>() -> SignalInput<PathElement> where State.Message == StackMutation<PathElement> {
		return Signal<PathElement>.channel().map { State.Message.push($0) }.bind(to: input)
	}
	
	public func popToCount<PathElement>() -> SignalInput<Int> where State.Message == StackMutation<PathElement> {
		return Signal<Int>.channel().map { State.Message.popToCount($0) }.bind(to: input)
	}
}

public struct TempValue<Value>: NonPersistentAdapterState {
	public typealias Message = Value
	public typealias Notification = Value
	
	let temporaryValue: Value?
	public init() {
		temporaryValue = nil
	}
	
	fileprivate init(temporaryValue: Value) {
		self.temporaryValue = temporaryValue
	}
	
	public func reduce(message: Value, feedback: SignalMultiInput<Message>) -> Output {
		return Output(state: TempValue(temporaryValue: message), notification: message)
	}
	
	public func resume() -> Notification? {
		return temporaryValue
	}
	
	public static func initialize(message: Message, feedback: SignalMultiInput<Message>) -> Output? {
		return Output(state: TempValue(temporaryValue: message), notification: message)
	}
}

public typealias TempVar<Value> = Adapter<TempValue<Value>>

public struct ToggleValue: PersistentAdapterState {
	public typealias Message = Void
	public typealias Notification = Bool
	
	public let value: Bool
	public init(value: Bool) {
		self.value = value
	}
	
	public func reduce(message: Void, feedback: SignalMultiInput<Message>) -> Output {
		return Output(state: ToggleValue(value: !value), notification: !value)
	}
	
	public func resume() -> Notification? { return value }
	
	public static func initialize(message: Message, feedback: SignalMultiInput<Message>) -> Output? {
		return nil
	}
}

public typealias ToggleVar = Adapter<ToggleValue>

public extension Adapter where State == ToggleValue {
	init(_ value: Bool) {
		self.init(adapterState: ToggleValue(value: value))
	}
}

public typealias Var<Value: Codable> = Adapter<VarState<Value>>

public struct VarState<Value: Codable>: PersistentAdapterState {
	public enum Message {
		case set(Value)
		case update(Value)
		case notify(Value)
	}
	public typealias Notification = Value
	
	public let value: Value
	public init(value: Value) {
		self.value = value
	}
	
	public func reduce(message: Message, feedback: SignalMultiInput<Message>) -> Output {
		switch message {
		case .set(let v): return Output(state: VarState<Value>(value: v), notification: v)
		case .update(let v): return Output(state: VarState<Value>(value: v), notification: nil)
		case .notify(let v): return Output(state: self, notification: v)
		}
	}
	
	public func resume() -> Notification? {
		return value
	}
	
	public static func initialize(message: Message, feedback: SignalMultiInput<Message>) -> Output? {
		switch message {
		case .set(let v): return Output(state: VarState<Value>(value: v), notification: v)
		case .update(let v): return Output(state: VarState<Value>(value: v), notification: nil)
		case .notify: return nil
		}
	}
}

extension VarState: Codable where Value: Codable {}

extension VarState: Lifetime where Value: Lifetime {
	public mutating func cancel() {
		var v = value
		v.cancel()
		self = VarState(value: v)
	}
}

extension VarState: CodableContainer where Value: CodableContainer {
	public var childCodableContainers: [CodableContainer] {
		return value.childCodableContainers
	}
	
	public var codableValueChanged: Signal<Void> {
		return value.codableValueChanged
	}
}

public extension Adapter {
	init<Value>(_ value: Value) where VarState<Value> == State {
		self.init(adapterState: VarState<Value>(value: value))
	}
}

public extension Adapter {
	func set<Value>() -> SignalInput<Value> where State.Message == VarState<Value>.Message {
		return Input().map { VarState<Value>.Message.set($0) }.bind(to: self)
	}
	
	func update<Value>() -> SignalInput<Value> where State.Message == VarState<Value>.Message {
		return Input().map { VarState<Value>.Message.update($0) }.bind(to: self)
	}
	
	func notify<Value>() -> SignalInput<Value> where State.Message == VarState<Value>.Message {
		return Input<Value>().map { VarState<Value>.Message.notify($0) }.bind(to: self)
	}
	
	func allChanges<Value>() -> Signal<Value> where State == VarState<Value> {
		return combinedSignal.compactMap { combined in combined.notification ?? combined.state.value }
	}
	
	func stateChanges<Value>() -> Signal<Value> where State == VarState<Value> {
		return combinedSignal.compactMap { combined in combined.state.value }
	}
}

public extension SignalInterface {
	func bind<InputInterface>(to interface: InputInterface) where InputInterface: SignalInputInterface, InputInterface.InputValue == VarState<OutputValue>.Message {
		return map { VarState<OutputValue>.Message.set($0) }.bind(to: interface)
	}
}

public extension SignalChannel {
	func bind<Target>(to interface: Target) -> InputInterface where Target: SignalInputInterface, Target.InputValue == VarState<Interface.OutputValue>.Message {
		return final { $0.map { VarState<Interface.OutputValue>.Message.set($0) }.bind(to: interface) }.input
	}
}

public extension BindingName {
	/// Build an action binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --><A>(name: BindingName<Value, Source, Binding>, value: Adapter<VarState<A>>) -> Binding where SignalInput<A> == Value {
		return name.binding(with: value.set())
	}
}

/// Implementation for `BinderStorage` that wraps Cocoa objects.
open class AssociatedBinderStorage: NSObject {
	public typealias Instance = NSObject
	private var lifetimes: [Lifetime]? = nil
	
	/// The embed function will avoid embedding and let the AssociatedBinderStorage release if this function returns false.
	/// Override and alter logic if a subclass may require the storage to persist when lifetimes is empty and the dynamic delegate is unused.
	open var isInUse: Bool {
		guard let ls = lifetimes else { fatalError("Embed must be called before isInUse") }
		return ls.isEmpty == false || dynamicDelegate != nil
	}
	
	/// Implementation of the `BinderStorage` method to embed supplied lifetimes in an instance. This may be performed once-only for a given instance and storage (the storage should have the same lifetime as the instance and should not be disconnected once connected).
	///
	/// - Parameters:
	///   - lifetimes: lifetimes that will be stored in this storage
	///   - instance: an NSObject where this storage will embed itself
	public func embed(lifetimes: [Lifetime], in instance: NSObjectProtocol) {
		assert(self.lifetimes == nil, "Bindings should be set once only")
		self.lifetimes = lifetimes
		guard isInUse else { return }
		
		assert(instance.associatedBinderStorage(subclass: AssociatedBinderStorage.self) == nil, "Bindings should be set once only")
		instance.setAssociatedBinderStorage(self)
	}
	
	/// Explicitly invoke `cancel` on each of the bindings.
	///
	/// WARNING: if `cancel` is invoked outside the main thread, it will be *asynchronously* invoked on the main thread.
	/// Normally, a `cancel` effect is expected to have synchronous effect but it since `cancel` on Binder objects is usually used for breaking reference counted loops, it is considered that the synchronous effect of cancel is less important than avoiding deadlocks â and deadlocks would be easy to accidentally trigger if this were synchronously invoked. If you need synchronous effect, ensure that cancel is invoked on the main thread.
	public func cancel() {
		guard Thread.isMainThread else { DispatchQueue.main.async(execute: self.cancel); return }
		
		// `cancel` is mutating so we must use a `for var` (we can't use `forEach`)
		for var l in lifetimes ?? [] {
			l.cancel()
		}
		
		dynamicDelegate?.implementedSelectors = [:]
		dynamicDelegate = nil
	}
	
	deinit {
		cancel()
	}
	
	/// The `dynamicDelegate` is a work-around for the fact that some Cocoa objects change their behavior if you have a delegate that implements a given delegate method. Since Binders will likely implement *all* of their delegate methods, the dynamicDelegate can be used to selectively respond to particular selectors at runtime.
	public var dynamicDelegate: DynamicDelegate?
	
	/// An override of the NSObject method so that the dynamicDelegate can work. When the dynamicDelegate states that it can respond to a given selector, that selector is directed to the dynamicDelegate instead. This function will only be involved if Objective-C message sends are sent to the BinderStorage â a rare occurrence outside of deliberate delegate invocations.
	///
	/// - Parameter selector: Objective-C selector that may be implemented by the dynamicDelegate
	/// - Returns: the dynamicDelegate, if it implements the selector
	open override func forwardingTarget(for selector: Selector) -> Any? {
		if let dd = dynamicDelegate, let value = dd.implementedSelectors[selector] {
			dd.associatedHandler = value
			return dd
		}
		return nil
	}
	
	/// An override of the NSObject method so that the dynamicDelegate can work.
	///
	/// - Parameter selector: Objective-C selector that may be implemented by the dynamicDelegate
	/// - Returns: true if the dynamicDelegate implements the selector, otherwise returns the super implementation
	open override func responds(to selector: Selector) -> Bool {
		if let dd = dynamicDelegate, let value = dd.implementedSelectors[selector] {
			dd.associatedHandler = value
			return true
		}
		return super.responds(to: selector)
	}
}

/// Used in conjunction with `AssociatedBinderStorage`, subclasses of `DynamicDelegate` can implement all delegate methods at compile time but have the `AssociatedBinderStorage` report true to `responds(to:)` only in the cases where the delegate method is selected for enabling.
open class DynamicDelegate: NSObject, DefaultConstructable {
	var implementedSelectors = Dictionary<Selector, Any>()
	var associatedHandler: Any?
	
	public required override init() {
		super.init()
	}
	
	public func handlesSelector(_ selector: Selector) -> Bool {
		return implementedSelectors[selector] != nil
	}
	
	public func multiHandler<T>(_ t: T) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T) -> Void]).forEach { f in f(t) }
	}
	
	public func multiHandler<T, U>(_ t: T, _ u: U) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U) -> Void]).forEach { f in f(t, u) }
	}
	
	public func multiHandler<T, U, V>(_ t: T, _ u: U, _ v: V) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U, V) -> Void]).forEach { f in f(t, u, v) }
	}
	
	public func multiHandler<T, U, V, W>(_ t: T, _ u: U, _ v: V, _ w: W) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U, V, W) -> Void]).forEach { f in f(t, u, v, w) }
	}
	
	public func multiHandler<T, U, V, W, X>(_ t: T, _ u: U, _ v: V, _ w: W, _ x: X) {
		defer { associatedHandler = nil }
		(associatedHandler as! [(T, U, V, W, X) -> Void]).forEach { f in f(t, u, v, w, x) }
	}
	
	public func singleHandler<T, R>(_ t: T) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T) -> R))(t)
	}
	
	public func singleHandler<T, U, R>(_ t: T, _ u: U) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U) -> R))(t, u)
	}
	
	public func singleHandler<T, U, V, R>(_ t: T, _ u: U, _ v: V) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U, V) -> R))(t, u, v)
	}
	
	public func singleHandler<T, U, V, W, R>(_ t: T, _ u: U, _ v: V, _ w: W) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U, V, W) -> R))(t, u, v, w)
	}
	
	public func singleHandler<T, U, V, W, X, R>(_ t: T, _ u: U, _ v: V, _ w: W, _ x: X) -> R {
		defer { associatedHandler = nil }
		return (associatedHandler as! ((T, U, V, W, X) -> R))(t, u, v, w, x)
	}
	
	public func addSingleHandler1<T, R>(_ value: @escaping (T) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	public func addSingleHandler2<T, U, R>(_ value: @escaping (T, U) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	public func addSingleHandler3<T, U, V, R>(_ value: @escaping (T, U, V) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	public func addSingleHandler4<T, U, V, W, R>(_ value: @escaping (T, U, V, W) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	public func addSingleHandler5<T, U, V, W, X, R>(_ value: @escaping (T, U, V, W, X) -> R, _ selector: Selector) {
		precondition(implementedSelectors[selector] == nil, "It is not possible to add multiple handlers to a delegate that returns a value.")
		implementedSelectors[selector] = value
	}
	
	public func addMultiHandler1<T>(_ value: @escaping (T) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T) -> Void]
		}
	}
	
	public func addMultiHandler2<T, U>(_ value: @escaping (T, U) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U) -> Void]
		}
	}
	
	public func addMultiHandler3<T, U, V>(_ value: @escaping (T, U, V) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U, V) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U, V) -> Void]
		}
	}
	
	public func addMultiHandler4<T, U, V, W>(_ value: @escaping (T, U, V, W) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U, V, W) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U, V, W) -> Void]
		}
	}
	
	public func addMultiHandler5<T, U, V, W, X>(_ value: @escaping (T, U, V, W, X) -> Void, _ selector: Selector) {
		if let existing = implementedSelectors[selector] {
			var existingArray = existing as! [(T, U, V, W, X) -> Void]
			existingArray.append(value)
		} else {
			implementedSelectors[selector] = [value] as [(T, U, V, W, X) -> Void]
		}
	}
}

private var associatedBinderStorageKey = NSObject()
public extension NSObjectProtocol {
	/// Accessor for any embedded AssociatedBinderStorage on an NSObject. This method is provided for debugging purposes; you should never normally need to access the storage obbject.
	///
	/// - Parameter for: an NSObject
	/// - Returns: the embedded AssociatedBinderStorage (if any)
	func associatedBinderStorage<S: AssociatedBinderStorage>(subclass: S.Type) -> S? {
		return objc_getAssociatedObject(self, &associatedBinderStorageKey) as? S
	}

	/// Accessor for any embedded AssociatedBinderStorage on an NSObject. This method is provided for debugging purposes; you should never normally need to access the storage obbject.
	///
	/// - Parameter newValue: an AssociatedBinderStorage or nil (if clearinging storage)
	func setAssociatedBinderStorage(_ newValue: AssociatedBinderStorage?) {
		objc_setAssociatedObject(self, &associatedBinderStorageKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
	}
}

public enum BinderState<Preparer: BinderPreparer> {
	case pending(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding])
	case constructed(Preparer.Output)
	case consumed
}

public protocol Binder: class {
	associatedtype Preparer: BinderPreparer
	
	var state: BinderState<Preparer> { get set }
	init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) 
}

public extension Binder {
 	typealias Instance = Preparer.Instance
	typealias Parameters = Preparer.Parameters
	typealias Output = Preparer.Output
	
	/// Invokes `consume` on the underlying state. If the state is not `pending`, this will trigger a fatal error. State will be set to `consumed`.
	///
	/// - Returns: the array of `Binding` from the state parameters.
	func consume() -> (type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		guard case .pending(let type, let parameters, let bindings) = state else {
			fatalError("Attempted to consume bindings from already constructed or consumed binder.")
		}
		state = .consumed
		return (type: type, parameters: parameters, bindings: bindings)
	}
}

extension Binder where Preparer.Parameters == Void {
	/// A constructor used when dynamically assembling arrays of bindings
	///
	/// - Parameters:
	///   - bindings: array of bindings
	public init(type: Preparer.Instance.Type = Preparer.Instance.self, bindings: [Preparer.Binding]) {
		self.init(type: type, parameters: (), bindings: bindings)
	}

	/// A constructor for a binder.
	///
	/// - Parameters:
	///   - bindings: list of bindings
	public init(type: Preparer.Instance.Type = Preparer.Instance.self, _ bindings: Preparer.Binding...) {
		self.init(type: type, parameters: (), bindings: bindings)
	}
}

private extension Binder where Preparer: BinderApplyable {
	var constructed: Preparer.Output? {
		guard case .constructed(let output) = state else { return nil }
		return output
	}
}

public extension Binder where Preparer: BinderApplyable {
	func apply(to instance: Preparer.Instance) {
		let (_, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { _ in instance }
		_ = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
	}
}

public extension Binder where Preparer: BinderConstructor, Preparer.Instance == Preparer.Output {
	func instance() -> Preparer.Instance {
		if let output = constructed { return output }
		let (type, parameters, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(instance)
		return output
	}

	func instance(parameters: Parameters) -> Preparer.Instance {
		if let output = constructed { return output }
		let (type, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(instance)
		return output
	}
}

public extension Binder where Preparer: BinderApplyable, Preparer.Storage == Preparer.Output {
	func wrap(instance: Preparer.Instance) -> Preparer.Output {
		if let output = constructed { return output }
		let (_, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { _ in instance }
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .consumed
		return output
	}
}

public extension Binder where Preparer: BinderConstructor, Preparer.Storage == Preparer.Output {
	func construct() -> Preparer.Output {
		let (type, parameters, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(output)
		return output
	}
	
	func construct(parameters: Parameters) -> Preparer.Output {
		let (type, _, bindings) = consume()
		let (preparer, instance, storage, lifetimes) = Preparer.bind(bindings) { preparer in
			preparer.constructInstance(type: type, parameters: parameters)
		}
		let output = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
		state = .constructed(output)
		return output
	}
}

/// Preparers usually default construct the `Storage` except in specific cases where the storage needs a reference to the instance.
public protocol BinderApplyable: BinderPreparer {
	/// Constructs the `Storage`
	///
	/// - Returns: the storage
	func constructStorage(instance: Instance) -> Storage
	
	/// - Returns: the output, after tying the lifetimes of the instance and storage together
	func combine(lifetimes: [Lifetime], instance: Instance, storage: Storage) -> Output
}

public extension BinderApplyable {
	static func bind(_ bindings: [Binding], to source: (_ preparer: Self) -> Instance) -> (Self, Instance, Storage, [Lifetime]) {
		var preparer = Self()
		for b in bindings {
			preparer.prepareBinding(b)
		}
		
		var lifetimes = [Lifetime]()
		let instance = source(preparer)
		let storage = preparer.constructStorage(instance: instance)
		
		preparer.prepareInstance(instance, storage: storage)
		
		for b in bindings {
			lifetimes += preparer.applyBinding(b, instance: instance, storage: storage)
		}
		
		lifetimes += preparer.finalizeInstance(instance, storage: storage)
		
		return (preparer, instance, storage, lifetimes)
	}
}


public struct BinderBase: BinderPreparer {
	public typealias Instance = Any
	public typealias Storage = Any

	public enum Binding: BinderBaseBinding {
		case lifetimes(Dynamic<[Lifetime]>)
		case adHocPrepare((Any) -> Void)
		case adHocFinalize((Any) -> Lifetime?)
	}

	public var inherited: BinderBase { get { return self } set { } }
	public var adHocPrepareClosures: [(Any) -> Void]?
	public var adHocFinalizeClosures: [(Any) -> Lifetime?]?

	public init() {}
	
	public func inheritedBinding(from: BinderBase.Binding) -> BinderBase.Binding? { return nil }
	public mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .adHocPrepare(let x): adHocPrepareClosures = adHocPrepareClosures?.appending(x) ?? [x]
		case .adHocFinalize(let x): adHocFinalizeClosures = adHocFinalizeClosures?.appending(x) ?? [x]
		default: break
		}
	}
	public func prepareInstance(_ instance: Instance, storage: Storage) {
		adHocPrepareClosures.map { array in array.forEach { c in c(instance) } }
	}
	public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .lifetimes(let x):
			switch x {
			case .constant(let lifetimes):
				return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
			case .dynamic(let signal):
				var previous: [Lifetime]?
				return signal.subscribe(context: .main) { next in
					if var previous = previous {
						for i in previous.indices {
							previous[i].cancel()
						}
					}
					if case .success(let next) = next {
						previous = next
					}
				}
			}
		case .adHocPrepare: return nil
		case .adHocFinalize: return nil
		}
	}
	public func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		return adHocFinalizeClosures.map { array in AggregateLifetime(lifetimes: array.compactMap { c in c(instance) }) }
	}
	public func combine(lifetimes: [Lifetime], instance: Any, storage: Any) -> Any { return () }
}

public protocol BinderBaseBinding: Binding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self
	func asBinderBaseBinding() -> BinderBase.Binding?
}
public extension BinderBaseBinding where Preparer.Inherited.Binding: BinderBaseBinding {
	func asBinderBaseBinding() -> BinderBase.Binding? {
		return asInheritedBinding()?.asBinderBaseBinding()
	}
}
public extension BinderBase.Binding {
	typealias Preparer = BinderBase
	func asInheritedBinding() -> Preparer.Inherited.Binding? { return nil }
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> BinderBase.Binding { return binding }
}

extension BindingName where Binding: BinderBaseBinding {
	public typealias BinderBaseName<V> = BindingName<V, BinderBase.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> BinderBase.Binding) -> BinderBaseName<V> {
		return BinderBaseName<V>(source: source, downcast: Binding.binderBaseBinding)
	}
}
public extension BindingName where Binding: BinderBaseBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BinderBaseName<$2> { return .name(BinderBase.Binding.$1) }
	static var lifetimes: BinderBaseName<Dynamic<[Lifetime]>> { return .name(BinderBase.Binding.lifetimes) }

	static var adHocPrepare: BinderBaseName<(Binding.Preparer.Instance) -> Void> {
		return Binding.compositeName(
			value: { f in { (any: Any) -> Void in f(any as! Binding.Preparer.Instance) } },
			binding: BinderBase.Binding.adHocPrepare,
			downcast: Binding.binderBaseBinding
		)
	}

	static var adHocFinalize: BinderBaseName<(Binding.Preparer.Instance) -> Lifetime?> {
		return Binding.compositeName(
			value: { f in { (any: Any) -> Lifetime? in return f(any as! Binding.Preparer.Instance) } },
			binding: BinderBase.Binding.adHocFinalize,
			downcast: Binding.binderBaseBinding
		)
	}
}

public protocol BinderDelegateEmbedder: BinderEmbedder where Instance: HasDelegate {
	associatedtype Delegate: DynamicDelegate
	init(delegateClass: Delegate.Type)
	var delegateClass: Delegate.Type { get }
	var dynamicDelegate: Delegate? { get set }
	var delegateIsRequired: Bool { get }
	func prepareDelegate(instance: Instance, storage: Storage)
}

public typealias BinderDelegateEmbedderConstructor = BinderDelegateEmbedder & BinderConstructor

public protocol HasDelegate: class {
	associatedtype DelegateProtocol
	var delegate: DelegateProtocol? { get set }
}

public extension BinderDelegateEmbedder {
	init() {
		self.init(delegateClass: Delegate.self)
	}
	
	var delegateIsRequired: Bool { return dynamicDelegate != nil }
	
	mutating func delegate() -> Delegate {
		if let d = dynamicDelegate {
			return d
		} else {
			let d = delegateClass.init()
			dynamicDelegate = d
			return d
		}
	}
}

public extension BinderDelegateEmbedder where Delegate: DynamicDelegate {
	func prepareDelegate(instance: Instance, storage: Storage) {
		if delegateIsRequired {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			if dynamicDelegate != nil {
				storage.dynamicDelegate = dynamicDelegate
			}
			instance.delegate = (storage as! Instance.DelegateProtocol)
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
	}
}

public protocol BinderDelegateDerived: BinderEmbedderConstructor where Inherited: BinderDelegateEmbedderConstructor {
	init(delegateClass: Inherited.Delegate.Type)
}

public extension BinderDelegateDerived {
	typealias Delegate = Inherited.Delegate
	init() {
		self.init(delegateClass: Inherited.Delegate.self)
	}
	var dynamicDelegate: Inherited.Delegate? {
		get { return inherited.dynamicDelegate }
		set { inherited.dynamicDelegate = newValue }
	}
}

/// Preparers usually construct the `Instance` from a subclass type except in specific cases where additional non-binding parameters are required for instance construction.
public protocol BinderConstructor: BinderApplyable {
	/// Constructs the `Instance`
	///
	/// - Parameter subclass: subclass of the instance type to use for construction
	/// - Returns: the instance
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance
}

public extension BinderConstructor where Instance: DefaultConstructable {
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		return type.init()
	}
}

/// All NSObject instances can use AssociatedBinderStorage which embeds lifetimes in the Objective-C associated object storage.
public protocol BinderEmbedder: BinderApplyable where Instance: NSObjectProtocol, Storage: AssociatedBinderStorage, Output == Instance {}
public extension BinderEmbedder {
	func combine(lifetimes: [Lifetime], instance: Instance, storage: Storage) -> Output {
		storage.embed(lifetimes: lifetimes, in: instance)
		return instance
	}
}

/// A `BinderEmbedderConstructor` is the standard configuration for a constructable NSObject.
public typealias BinderEmbedderConstructor = BinderEmbedder & BinderConstructor

public protocol DefaultConstructable {
	init()
}

/// A preparer interprets a set of bindings and applies them to an instance.
public protocol BinderPreparer: DefaultConstructable {
	associatedtype Instance
	associatedtype Output = Instance
	associatedtype Parameters = Void
	associatedtype Binding
	associatedtype Storage
	associatedtype Inherited: BinderPreparer

	var inherited: Inherited { get set }
	
	func inheritedBinding(from: Binding) -> Inherited.Binding?
	
	/// A first scan of the bindings. Information about bindings present may be recorded during this time.
	///
	/// NOTE: you don't need to process all bindings at your own level but you should pass inherited bindings through
	/// to the inherited preparer (unless you're handling it at your own level)
	///
	/// - Parameter binding: the binding to apply
	mutating func prepareBinding(_ binding: Binding)
	
	/// Bindings which need to be applied before others can be applied at this special early stage
	///
	/// NOTE: the first step should be to call `inheritedPrepareInstance`. `BinderDelegate` should call `prepareDelegate`
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	func prepareInstance(_ instance: Instance, storage: Storage)
	
	/// Apply typical bindings.
	///
	/// NOTE: you should process all bindings and pass inherited bindings through to the inherited preparer
	///
	/// - Parameters:
	///   - binding: the binding to apply
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`.
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime?
	
	/// Bindings which need to be applied after others can be applied at this last stage.
	///
	/// NOTE: the last step should be to call `inheritedFinalizedInstance`
	///
	/// - Parameters:
	///   - instance: the instance
	///   - storage: the storage
	/// - Returns: If maintaining bindings requires ongoing lifetime management, these lifetimes are maintained by returning instances of `Lifetime`
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime?
}

public extension BinderPreparer {
	mutating func inheritedPrepareBinding(_ binding: Binding) {
		guard let ls = inheritedBinding(from: binding) else { return }
		inherited.prepareBinding(ls)
	}

	mutating func prepareBinding(_ binding: Binding) {
		inheritedPrepareBinding(binding)
	}
	
	func inheritedPrepareInstance(_ instance: Instance, storage: Storage) {
		guard let i = instance as? Inherited.Instance, let s = storage as? Inherited.Storage else { return }
		inherited.prepareInstance(i, storage: s)
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
	}
	
	func inheritedApplyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		guard let ls = inheritedBinding(from: binding), let i = instance as? Inherited.Instance, let s = storage as? Inherited.Storage else { return nil }
		return inherited.applyBinding(ls, instance: i, storage: s)
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		return inheritedApplyBinding(binding, instance: instance, storage: storage)
	}
	
	func inheritedFinalizedInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		guard let i = instance as? Inherited.Instance, let s = storage as? Inherited.Storage else { return nil }
		return inherited.finalizeInstance(i, storage: s)
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

import Foundation

public protocol Binding {
	associatedtype Preparer: BinderPreparer
	func asInheritedBinding() -> Preparer.Inherited.Binding?
}

extension Binding {
	public typealias Name<V> = BindingName<V, Self, Self>
	
	public static func compositeName<Value, Param, Intermediate>(value: @escaping (Value) -> Param, binding: @escaping (Param) -> Intermediate, downcast: @escaping (Intermediate) -> Self) -> BindingName<Value, Intermediate, Self> {
		return BindingName<Value, Intermediate, Self>(
			source: { v in binding(value(v)) },
			downcast: downcast
		)
	}
	
	public static func keyPathActionName<Instance, Value, Intermediate>(_ keyPath: KeyPath<Instance, Value>, _ binding: @escaping (TargetAction) -> Intermediate, _ downcast: @escaping (Intermediate) -> Self) -> BindingName<SignalInput<Value>, Intermediate, Self> {
		return compositeName(
			value: { input in
				TargetAction.singleTarget(
					Input<Any?>().map { v in (v as! Instance)[keyPath: keyPath] }.bind(to: input)
				)
			},
			binding: binding,
			downcast: downcast
		)
	}
	
	public static func mappedInputName<Value, Mapped, Intermediate>(map: @escaping (Value) -> Mapped, binding: @escaping (SignalInput<Value>) -> Intermediate, downcast: @escaping (Intermediate) -> Self) -> BindingName<SignalInput<Mapped>, Intermediate, Self> {
		return compositeName(
			value: { Input<Value>().map(map).bind(to: $0) },
			binding: binding,
			downcast: downcast
		)
	}
	
	public static func mappedWrappedInputName<Value, Mapped, Param, Intermediate>(map: @escaping (Value) -> Mapped, wrap: @escaping (SignalInput<Value>) -> Param, binding: @escaping (Param) -> Intermediate, downcast: @escaping (Intermediate) -> Self) -> BindingName<SignalInput<Mapped>, Intermediate, Self> {
		return compositeName(
			value: { wrap(Input<Value>().map(map).bind(to: $0)) },
			binding: binding,
			downcast: downcast
		)
	}
}

infix operator --: AssignmentPrecedence
infix operator <--: AssignmentPrecedence
infix operator -->: AssignmentPrecedence

public struct BindingName<Value, Source, Binding> {
	public var source: (Value) -> Source
	public var downcast: (Source) -> Binding
	public init(source: @escaping (Value) -> Source, downcast: @escaping (Source) -> Binding) {
		self.source = source
		self.downcast = downcast
	}
	public func binding(with value: Value) -> Binding {
		return downcast(source(value))
	}
}

public extension BindingName {
	/// Build a signal binding (invocations on the instance after construction) from a name and a signal
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func <--<Interface: SignalInterface>(name: BindingName<Value, Source, Binding>, value: Interface) -> Binding where Signal<Interface.OutputValue> == Value {
		return name.binding(with: value.signal)
	}

	/// Build a value binding (property changes on the instance) from a name and a signal (values over time)
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func <--<Interface: SignalInterface>(name: BindingName<Value, Source, Binding>, value: Interface) -> Binding where Dynamic<Interface.OutputValue> == Value {
		return name.binding(with: Dynamic<Interface.OutputValue>.dynamic(value.signal))
	}

	/// Build an action binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --><InputInterface: SignalInputInterface>(name: BindingName<Value, Source, Binding>, value: InputInterface) -> Binding where SignalInput<InputInterface.InputValue> == Value {
		return name.binding(with: value.input)
	}

	/// Build a static binding (construction-only property) from a name and a constant value
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A>(name: BindingName<Value, Source, Binding>, value: A) -> Binding where Constant<A> == Value {
		return name.binding(with: Value.constant(value))
	}
	
	/// Build a value binding (property changes on the instance) from a name and a constant value
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A>(name: BindingName<Value, Source, Binding>, value: A) -> Binding where Dynamic<A> == Value {
		return name.binding(with: Dynamic<A>.constant(value))
	}

	/// Build a delegate binding (synchronous callback) from a name and function with no parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<R>(name: BindingName<Value, Source, Binding>, value: @escaping () -> R) -> Binding where Value == () -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with one parameter
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A) -> R) -> Binding where Value == (A) -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with two parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A, B) -> R) -> Binding where Value == (A, B) -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with three parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, C, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A, B, C) -> R) -> Binding where Value == (A, B, C) -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with four parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, C, D, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A, B, C, D) -> R) -> Binding where Value == (A, B, C, D) -> R {
		return name.binding(with: value)
	}

	/// Build a delegate binding (synchronous callback) from a name and function with five parameters
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --<A, B, C, D, E, R>(name: BindingName<Value, Source, Binding>, value: @escaping (A, B, C, D, E) -> R) -> Binding where Value == (A, B, C, D, E) -> R {
		return name.binding(with: value)
	}
}

public extension BindingName where Value == TargetAction {
	/// Build an `TargetAction` binding (callbacks triggered by the instance) from a name and a signal input.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func --><InputInterface: SignalInputInterface>(name: BindingName<TargetAction, Source, Binding>, value: InputInterface) -> Binding where InputInterface.InputValue == Any? {
		return name.binding(with: .singleTarget(value.input))
	}
	
	/// Build a first-responder `TargetAction` binding (callbacks triggered by the instance) from a name and a selector.
	///
	/// - Parameters:
	///   - name: the binding name
	///   - value: the binding argument
	/// - Returns: the binding
	static func -->(name: BindingName<TargetAction, Source, Binding>, value: Selector) -> Binding {
		return name.binding(with: TargetAction.firstResponder(value))
	}
}

/// A simple wrapper around a value used to identify "static" bindings (bindings which are applied only at construction time)
public struct Constant<Value> {
	public typealias ValueType = Value
	public let value: Value
	public init(_ value: Value) {
		self.value = value
	}
	public static func constant(_ value: Value) -> Constant<Value> {
		return Constant<Value>(value)
	}
}


/// An either type for a value or a signal emitting values of that type. Used for "value" bindings (bindings which set a property on the underlying instance)
public enum Dynamic<Value> {
	public typealias ValueType = Value
	case constant(Value)
	case dynamic(Signal<Value>)
	
	/// Gets the initial (i.e. used in the constructor) value from the `Dynamic`
	public func initialSubsequent() -> InitialSubsequent<Value> {
		switch self {
		case .constant(let v):
			return InitialSubsequent<Value>(initial: v)
		case .dynamic(let signal):
			let sc = signal.capture()
			return InitialSubsequent<Value>(initial: sc.values.last, subsequent: sc)
		}
	}
	
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	public func apply<I: AnyObject, B: AnyObject>(_ instance: I, _ storage: B, _ onError: Value? = nil, handler: @escaping (I, B, Value) -> Void) -> Lifetime? {
		switch self {
		case .constant(let v):
			handler(instance, storage, v)
			return nil
		case .dynamic(let signal):
			return signal.apply(instance, storage, onError, handler: handler)
		}
	}
	
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	public func apply<I: AnyObject>(_ instance: I, handler: @escaping (I, Value) -> Void) -> Lifetime? {
		switch self {
		case .constant(let v):
			handler(instance, v)
			return nil
		case .dynamic(let signal):
			return signal.apply(instance, handler: handler)
		}
	}
}

extension Signal {
	public func apply<I: AnyObject, B: AnyObject>(_ instance: I, _ storage: B, _ onError: OutputValue? = nil, handler: @escaping (I, B, OutputValue) -> Void) -> Lifetime? {
		return signal.subscribe(context: .main) { [unowned instance, unowned storage] r in
			switch (r, onError) {
			case (.success(let v), _): handler(instance, storage, v)
			case (.failure, .some(let v)): handler(instance, storage, v)
			case (.failure, .none): break
			}
		}
	}

	public func apply<I: AnyObject>(_ instance: I, handler: @escaping (I, OutputValue) -> Void) -> Lifetime? {
		return signal.subscribeValues(context: .main) { [unowned instance] v in handler(instance, v) }
	}
}

public struct InitialSubsequent<Value> {
	public let initial: Value?
	public let subsequent: SignalCapture<Value>?
	
	init<Interface: SignalInterface>(signal: Interface) where Interface.OutputValue == Value {
		let capture = signal.capture()
		let values = capture.values
		self.init(initial: values.last, subsequent: capture)
	}
	
	init(initial: Value? = nil, subsequent: SignalCapture<Value>? = nil) {
		self.initial = initial
		self.subsequent = subsequent
	}
	
	public func resume() -> Signal<Value>? {
		return subsequent?.resume()
	}
	
	public func apply<I: AnyObject>(_ instance: I, handler: @escaping (I, Value) -> Void) -> Lifetime? {
		return resume().flatMap { $0.apply(instance, handler: handler) }
	}
	
	public func apply<I: AnyObject, Storage: AnyObject>(_ instance: I, _ storage: Storage, handler: @escaping (I, Storage, Value) -> Void) -> Lifetime? {
		return resume().flatMap { $0.apply(instance, storage, handler: handler) }
	}
}

import Foundation

public struct ScopedValues<Scope, Value>: ExpressibleByArrayLiteral {
	public typealias ArrayLiteralElement = ScopedValues<Scope, Value>

	public let pairs: [(scope: Scope, value: Value)]
	
	public init(arrayLiteral elements: ScopedValues<Scope, Value>...) {
		self.pairs = elements.flatMap { $0.pairs }
	}
	
	public init(pairs: [(Scope, Value)]) {
		self.pairs = pairs
	}
	
	public init(scope: Scope, value: Value) {
		self.pairs = [(scope, value)]
	}
	
	public static func value(_ value: Value, for scope: Scope) -> ScopedValues<Scope, Value> {
		return ScopedValues(scope: scope, value: value)
	}
}

extension Dynamic {
	// Gets the subsequent (i.e. after construction) values from the `Dynamic`
	public func apply<I: AnyObject, Scope, V>(instance: I, removeOld: @escaping (I, Scope, V) -> Void, applyNew: @escaping (I, Scope, V) -> Void) -> Lifetime? where ScopedValues<Scope, V> == Value {
		var previous: ScopedValues<Scope, V>? = nil
		return apply(instance) { i, v in
			for (scope, value) in previous?.pairs ?? [] {
				removeOld(instance, scope, value)
			}
			previous = v
			for (scope, value) in v.pairs {
				applyNew(instance, scope, value)
			}
		}
	}
}

public struct Callback<Value, CallbackValue> {
	public let value: Value
	public let callback: SignalInput<CallbackValue>
	
	public init(_ value: Value, _ callback: SignalInput<CallbackValue>) {
		self.value = value
		self.callback = callback
	}
}

extension SignalInterface {
	public func callbackBind<CallbackInputInterface: SignalInputInterface>(to callback: CallbackInputInterface) -> Signal<Callback<OutputValue, CallbackInputInterface.InputValue>> {
		return map { value in Callback(value, callback.input) }
	}

	public func ignoreCallback<CallbackValue>() -> Signal<Callback<OutputValue, CallbackValue>> {
		let (i, _) = Signal<CallbackValue>.create()
		return map { value in Callback(value, i) }
	}
}

/// This type encapsulates the idea that target-action pairs in Cocoa may target a specific object (by setting the target to non-nil) or may let the responder chain search for a responder that handles a specific selector.
public enum TargetAction {
	case firstResponder(Selector)
	case singleTarget(SignalInput<Any?>)
}

public protocol TargetActionSender: class {
	var action: Selector? { get set }
	var target: AnyObject? { get set }
}

extension TargetAction {
	public func apply<Source: TargetActionSender>(to instance: Source, constructTarget: () -> SignalActionTarget, selector: Selector = SignalActionTarget.selector) -> Lifetime? {
		switch self {
		case .firstResponder(let s):
			instance.target = nil
			instance.action = s
			return nil
		case .singleTarget(let s):
			let target = constructTarget()
			instance.target = target
			instance.action = SignalActionTarget.selector
			return target.signal.cancellableBind(to: s)
		}
	}
}

/// This enum is intended to be embedded in an ArrayMutation<Element>. The ArrayMutation<Element> combines an IndexSet with this enum. This enum specifies what actions should be taken at the locations specified by the IndexSet.
///
/// 
public enum IndexedMutationKind {
	/// The values at the locations specified by the IndexSet should be deleted.
	/// NOTE: the IndexSet specifies the indexes *before* deletion (and must therefore be applied in reverse).
	case delete

	/// The associated Array<Element> contains values that should be inserted such that they have the indexes specified in IndexSet. The Array<Element> and IndexSet must have identical counts.
	/// NOTE: the IndexSet specifies the indexes *after* insertion (and must therefore be applied in forward order).
	case insert

	/// Elements are deleted from one end and inserted onto the other. If `Int` is positive, values are deleted from the `startIndex` end and inserted at the `endIndex` end, if `Int` is negative, value are deleted from the `endIndex` end and inserted at the `startIndex`end.
	/// The magnitude of `Int` specifies the number of deleted rows and the sign specified the end.
	/// The Array<Element> contains values that should be inserted at the other end of the collection.
	/// The IndexSet contains the indexes of any revealed (scrolled into view) rows
	case scroll(Int)

	/// The associated Array<Element> contains updated values at locations specified by the IndexSet. Semantically, the item should be modelled as updated but not replaced. The Array<Element> and IndexSet must have identical counts.
	// In many cases, update and replace are the same. The only differences relate to scenarios where the items are considered to have "identity". An update *retains* the previous identity whereas a replace *discards* any previous identity.
	case update
	
	/// The values at the locations specified by the IndexSet should be removed from their locations and spliced back in at the location specified by the associated Int index. For scrolled subranges, items may not be moved from outside or to outside the visible range (items moved from outside the visible range must be inserted and items moved outside the visible range must be deleted)
	/// NOTE: the IndexSet specifies the indexes *before* removal (and must therefore be applied in reverse) and the Int index specifies an index *after* removal.
	case move(Int)

	/// Equivalent to a Deletion of all previous indexes and an Insertion of the new values. The associated Array<Element> contains the new state of the array. All previous values should be discarded and the entire array replaced with this new version. The Array<Element> and IndexSet must have identical counts.
	/// NOTE: the IndexSet specifies the indexes *after* insertion (and must therefore be applied in forward order).
	case reload
}

/// An `ArrayMutation` communicates changes to an array in one context so that another array, mirroring its contents in another context, can mimic the same changes.
/// Subscribing to a stream of `ArrayMutation`s is sufficient to communication the complete state and animatable transitions of an array between to parts of a program.
/// In most cases, the source and destination will need to keep their own complete copy of the array to correctly calculate the effect of the mutation.
public struct IndexedMutation<Element, Metadata>: ExpressibleByArrayLiteral {
	/// Determines the meaning of this `ArrayMutation`
	public let kind: IndexedMutationKind

	/// The metadats type is typically `Void` for plain array mutations since application of an indexed mutation to an array leaves no storage for metadata.
	/// Subrange and tree mutations use the metadata for subrange details and "leaf" data but require specialized storage structures to receive that data. The semantics of the metadata is specific to the respective `apply` functions.
	/// NOTE: Any non-nil metadata is typically set buy the mutation but a metadata value of `nil` doesn't clear the metadata, it usually just has no effect. The exception is `.reload` operations which function like re-creating the storage and explicitly set the value in all cases.
	public let metadata: Metadata?
	
	/// The meaning of the indexSet is dependent on the `kind` â it may contain indexes in the array that will be deleted by this mutation or it may contain indexes that new entries will occupy after application of this mutation.
	public let indexSet: IndexSet
	
	/// New values that will be inserted at locations determined by the `kind` and the `indexSet`.
	public let values: Array<Element>
	
	/// Construct from components.
	public init(kind: IndexedMutationKind, metadata: Metadata?, indexSet: IndexSet, values: Array<Element>) {
		self.kind = kind
		self.metadata = metadata
		self.indexSet = indexSet
		self.values = values
	}
}

public extension IndexedMutation {
	/// Construct an empty array mutation that represents a no-op.
	init() {
		self.init(kind: .update, metadata: nil, indexSet: IndexSet(), values: [])
	}
	
	/// A .reload mutation can be constructed from an array literal (since it is equivalent to an array assignment).
	init(arrayLiteral elements: Element...) {
		self.init(kind: .reload, metadata: nil, indexSet: IndexSet(integersIn: elements.indices), values: elements)
	}

	/// Construct a mutation that discards any previous history and simply starts with a completely new array.
	init(metadata: Metadata? = nil, reload values: Array<Element>) {
		self.init(kind: .reload, metadata: metadata, indexSet: IndexSet(integersIn: values.indices), values: values)
	}

	/// Construct a mutation that represents a metadata-only change.
	init(metadata: Metadata) {
		self.init(kind: .update, metadata: metadata, indexSet: IndexSet(), values: [])
	}

	/// Construct a mutation that represents the deletion of the values at a set of indices.
	init(metadata: Metadata? = nil, deletedIndexSet: IndexSet) {
		self.init(kind: .delete, metadata: metadata, indexSet: deletedIndexSet, values: [])
	}
	
	/// Construct a mutation that represents advancing the visible window through a larger array.
	init(metadata: Metadata? = nil, scrollForwardRevealing indexSet: IndexSet, values: Array<Element>) {
		precondition(indexSet.count == values.count)
		self.init(kind: .scroll(indexSet.count), metadata: metadata, indexSet: indexSet, values: values)
	}
	
	/// Construct a mutation that represents retreating the visible window through a larger array.
	init(metadata: Metadata? = nil, scrollBackwardRevealing indexSet: IndexSet, values: Array<Element>) {
		precondition(indexSet.count == values.count)
		self.init(kind: .scroll(-indexSet.count), metadata: metadata, indexSet: indexSet, values: values)
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init(metadata: Metadata? = nil, insertedIndexSet: IndexSet, values: Array<Element>) {
		precondition(insertedIndexSet.count == values.count)
		self.init(kind: .insert, metadata: metadata, indexSet: insertedIndexSet, values: values)
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init(metadata: Metadata? = nil, updatedIndexSet: IndexSet, values: Array<Element>) {
		precondition(updatedIndexSet.count == values.count)
		self.init(kind: .update, metadata: metadata, indexSet: updatedIndexSet, values: values)
	}
	
	/// Construct a mutation that represents the insertion of a number of values at a set of indices. The count of indices must match the count of values.
	init(metadata: Metadata? = nil, movedIndexSet: IndexSet, targetIndex: Int) {
		self.init(kind: .move(targetIndex), metadata: metadata, indexSet: movedIndexSet, values: [])
	}
	

	/// Convenience constructor for deleting a single element
	static func deleted(at index: Int) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(deletedIndexSet: IndexSet(integer: index))
	}
	
	/// Convenience constructor for inserting a single element
	static func inserted(_ value: Element, at index: Int) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(insertedIndexSet: IndexSet(integer: index), values: [value])
	}
	
	/// Convenience constructor for inserting a single element
	static func updated(_ value: Element, at index: Int) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(updatedIndexSet: IndexSet(integer: index), values: [value])
	}
	
	/// Convenience constructor for inserting a single element
	static func moved(from oldIndex: Int, to newIndex: Int) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(movedIndexSet: IndexSet(integer: oldIndex), targetIndex: newIndex)
	}
	
	/// Convenience constructor for reloading
	static func reload(metadata: Metadata? = nil, _ values: [Element]) -> IndexedMutation<Element, Metadata> {
		return IndexedMutation<Element, Metadata>(reload: values)
	}
	
	/// Creates a new IndexedMutation by mapping the values array from this transform. NOTE: metdata is passed through unchanged.
	func mapValues<Other>(_ transform: (Element) -> Other) -> IndexedMutation<Other, Metadata> {
		return IndexedMutation<Other, Metadata>(kind: kind, metadata: metadata, indexSet: indexSet, values: values.map(transform))
	}
	
	/// Creates a new IndexedMutation by mapping the values array from this transform. NOTE: metdata is passed through unchanged.
	func mapMetadata<Alternate>(_ transform: (Metadata) -> Alternate) -> IndexedMutation<Element, Alternate> {
		return IndexedMutation<Element, Alternate>(kind: kind, metadata: metadata.map(transform), indexSet: indexSet, values: values)
	}
	
	/// Given a previous row count, returns the new row count after this mutation
	///
	/// - Parameter rowCount: old number of rows
	func delta(_ rowCount: inout Int) {
		switch kind {
		case .reload: rowCount = values.count
		case .delete: rowCount -= indexSet.count
		case .scroll(let offset): rowCount += values.count - (offset > 0 ? offset : -offset)
		case .insert: rowCount += values.count
		case .move: return
		case .update: return
		}
	}
	
	/// A no-op on rows is explicitly defined as an `.update` with an empty `values` array. Note that metadata may still be non-nil.
	var hasNoEffectOnValues: Bool {
		if case .update = kind, values.count == 0 {
			return true
		}
		return false
	}
	
	func insertionsAndRemovals(length: Int, insert: (Int, Element) -> Void, remove: (Int) -> Void) {
		switch kind {
		case .delete:
			indexSet.reversed().forEach { remove($0) }
		case .scroll(let offset):
			if offset > 0 {
				(0..<offset).forEach { remove($0) }
				values.enumerated().forEach { insert(length - offset + $0.offset, $0.element) }
			} else {
				((length + offset)..<length).forEach { remove($0) }
				values.enumerated().forEach { insert($0.offset, $0.element) }
			}
		case .move(let index):
			indexSet.forEach { remove($0) }
			values.enumerated().forEach { insert(index + $0.offset, $0.element) }
		case .insert:
			for (i, v) in zip(indexSet, values) {
				insert(i, v)
			}
		case .update:
			indexSet.forEach { remove($0) }
			for (i, v) in zip(indexSet, values) {
				insert(i, v)
			}
		case .reload:
			(0..<length).reversed().forEach { remove($0) }
			values.enumerated().forEach { insert($0.offset, $0.element) }
		}
	}
}

public typealias ArrayMutation<Element> = IndexedMutation<Element, Void>

extension IndexedMutation where Metadata == Void {
	/// Apply the mutation described by this value to the provided array
	func apply<C: RangeReplaceableCollection & MutableCollection>(to a: inout C) where C.Index == Int, C.Iterator.Element == Element {
		switch kind {
		case .delete:
			indexSet.rangeView.reversed().forEach { a.removeSubrange($0) }
		case .scroll(let offset):
			a.removeSubrange(offset > 0 ? a.startIndex..<offset : (a.endIndex + offset)..<a.endIndex)
			a.insert(contentsOf: values, at: offset > 0 ? a.endIndex : a.startIndex)
		case .move(let index):
			let moving = indexSet.map { a[$0] }
			indexSet.rangeView.reversed().forEach { a.removeSubrange($0) }
			a.insert(contentsOf: moving, at: index)
		case .insert:
			for (i, v) in zip(indexSet, values) {
				a.insert(v, at: i)
			}
		case .update:
			var progress = 0
			indexSet.rangeView.forEach { r in
				a.replaceSubrange(r, with: values[progress..<(progress + r.count)])
				progress += r.count
			}
		case .reload:
			a.replaceSubrange(a.startIndex..<a.endIndex, with: values)
		}
	}
}

import Foundation

public enum SetMutationKind {
	case delete
	case insert
	case update
	case reload
}

public struct SetMutation<Element> {
	public let kind: SetMutationKind
	public let values: Array<Element>
	
	public init(kind: SetMutationKind, values: Array<Element>) {
		self.kind = kind
		self.values = values
	}
	
	public static func delete(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .delete, values: values)
	}
	
	public static func insert(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .insert, values: values)
	}
	
	public static func update(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .update, values: values)
	}
	
	public static func reload(_ values: Array<Element>) -> SetMutation<Element> {
		return SetMutation(kind: .reload, values: values)
	}
	
	public func apply(to array: inout Array<Element>, equate: @escaping (Element, Element) -> Bool, compare: @escaping (Element, Element) -> Bool) -> [ArrayMutation<Element>] {
		switch kind {
		case .delete:
			var sorted = values.sorted(by: compare)
			var oldIndices = IndexSet()
			var arrayIndex = 0
			var sortedIndex = 0
			while arrayIndex < array.count && sortedIndex < sorted.count {
				if !equate(array[arrayIndex], sorted[sortedIndex]) {
					arrayIndex += 1
				} else {
					oldIndices.insert(arrayIndex)
					sortedIndex += 1
					arrayIndex += 1
				}
			}
			precondition(sortedIndex == sorted.count, "Unable to find deleted items.")
			oldIndices.reversed().forEach { array.remove(at: $0) }
			return [ArrayMutation<Element>(deletedIndexSet: oldIndices)]
		case .insert:
			var sorted = values.sorted(by: compare)
			var newIndices = IndexSet()
			var arrayIndex = 0
			var sortedIndex = 0
			while arrayIndex < array.count && sortedIndex < sorted.count {
				if compare(array[arrayIndex], sorted[sortedIndex]) {
					arrayIndex += 1
				} else {
					newIndices.insert(arrayIndex)
					array.insert(sorted[sortedIndex], at: arrayIndex)
					sortedIndex += 1
					arrayIndex += 1
				}
			}
			while sortedIndex < sorted.count {
				newIndices.insert(arrayIndex)
				array.insert(sorted[sortedIndex], at: arrayIndex)
				sortedIndex += 1
				arrayIndex += 1
			}
			return [ArrayMutation<Element>(insertedIndexSet: newIndices, values: sorted)]
		case .update:
			// It would be nice if this was better than n squared complexity and aggregated the updates, rather than issueing updates for individual rows.
			var result = Array<ArrayMutation<Element>>()
			for v in values {
				let oldIndex = array.firstIndex { u in equate(v, u) }!
				array.remove(at: oldIndex)
				let newIndex = array.firstIndex { u in compare(v, u) } ?? array.count
				array.insert(v, at: newIndex)
				if newIndex == oldIndex {
					result.append(.updated(v, at: oldIndex))
				} else {
					// This ordering (moved, then updated) is required to make UITableView animations work correctly.
					result.append(.moved(from: oldIndex, to: newIndex))
					result.append(.updated(v, at: newIndex))
				}
			}
			return result
		case .reload:
			array = values.sorted(by: compare)
			return [ArrayMutation<Element>(reload: array)]
		}
	}
}

extension SignalInterface {
	public func sortedArrayMutation<Element>(equate: @escaping (Element, Element) -> Bool, compare: @escaping (Element, Element) -> Bool) -> Signal<ArrayMutation<Element>> where SetMutation<Element> == OutputValue {
		return transform(initialState: Array<Element>()) { (array: inout Array<Element>, result: Signal<SetMutation<Element>>.Result) in
			switch result {
			case .success(let m): return .values(sequence: m.apply(to: &array, equate: equate, compare: compare))
			case .failure(let e): return .end(e)
			}
		}
	}
}

public enum StackMutation<Value>: ExpressibleByArrayLiteral {
	public init(arrayLiteral elements: Value...) {
		self = .reload(elements)
	}
	
	public typealias ArrayLiteralElement = Value
	
	case push(Value)
	case pop
	case popToCount(Int)
	case reload([Value])
	
	func apply(to stack: inout Array<Value>) {
		switch self {
		case .push(let v): stack.append(v)
		case .pop: stack.removeLast()
		case .popToCount(let c): stack.removeLast(stack.count - c)
		case .reload(let newStack): stack = newStack
		}
	}
}

extension SignalInterface {
	public func stackMap<A, B>(_ transform: @escaping (A) -> B) -> Signal<StackMutation<B>> where OutputValue == StackMutation<A> {
		return map { m in
			switch m {
				case .push(let a): return StackMutation<B>.push(transform(a))
				case .pop: return StackMutation<B>.pop
				case .popToCount(let i): return StackMutation<B>.popToCount(i)
				case .reload(let array): return StackMutation<B>.reload(array.map { transform($0) })
			}
		}
	}
}

/// When used as the `Metadata` parameter to an `IndexedMutation`, then the indexed mutation can represent a locally visible subrange within a larger global array.
/// NOTE: when `nil` the following behaviors are implied for each IndexedMutation kind:
///	- reload: the localOffset is 0 and the globalCount is the reload count
///   - delete: the globalCount is reduced by the deletion count 
///   - insert: the globalCount is increased by the insertion count 
///   - scroll: the localOffset is changed by the scroll count
///   - update: neither localOffset nor globalCount are changed
///   - move: neither localOffset nor globalCount are changed
public struct Subrange<Leaf> {
	/// This is offset for the visible range. When not provided, the `localOffset` is automatically updated by `.scroll` and reset to `0` on `.reload`.
	/// NOTE: `localOffset` doesn't affect the `IndexedMutation` itself (since the mutation operates entirely in local coordinates) but for animation purposes (which typically needs to occur in global coordinates), the `localOffset` is considered to apply *before* the animation (e.g. the scroll position shifts first, then the values in the new locations are updated).
	public let localOffset: Int?
	
	/// This is the length of the greater array after the mutation is applied. When not provided, the `globalCount` is automatically updated by `.insert`, `.delete` and reset to the local count on `.reload`.
	public let globalCount: Int?
	
	/// Additional metadata for this tier
	public let leaf: Leaf?
	
	public init(localOffset: Int?, globalCount: Int?, leaf: Leaf?) {
		self.localOffset = localOffset
		self.globalCount = globalCount
		self.leaf = leaf
	}
}

/// A data type that can be used to cache the destination end of a `Subrange<Leaf>` change stream.
public struct SubrangeState<Element, Leaf> {
	public var values: Deque<Element>?
	public var localOffset: Int = 0
	public var globalCount: Int = 0
	public var leaf: Leaf?

	public init(values: Deque<Element>? = nil, localOffset: Int = 0, globalCount: Int? = nil, leaf: Leaf? = nil) {
		self.values = values
		self.localOffset = localOffset
		self.globalCount = globalCount ?? values?.count ?? 0
		self.leaf = leaf
	}
}

public typealias SubrangeMutation<Element, Additional> = IndexedMutation<Element, Subrange<Additional>>

extension IndexedMutation {
	public func updateMetadata<Value, Leaf>(_ state: inout SubrangeState<Value, Leaf>) where Subrange<Leaf> == Metadata {
		switch kind {
		case .reload:
			state.localOffset = metadata?.localOffset ?? 0
			state.globalCount = metadata?.globalCount ?? values.count
			state.leaf = metadata?.leaf ?? nil
		case .delete:
			if let localOffset = metadata?.localOffset {
				state.localOffset = localOffset
			}
			state.globalCount = metadata?.globalCount ?? (state.globalCount - indexSet.count)
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		case .insert:
			if let localOffset = metadata?.localOffset {
				state.localOffset = localOffset
			}
			state.globalCount = metadata?.globalCount ?? (state.globalCount + indexSet.count)
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		case .scroll(let offset):
			state.localOffset = metadata?.localOffset ?? (state.localOffset + offset)
			if let globalCount = metadata?.globalCount {
				state.globalCount = globalCount
			}
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		case .update: fallthrough
		case .move:
			if let localOffset = metadata?.localOffset {
				state.localOffset = localOffset
			}
			if let globalCount = metadata?.globalCount {
				state.globalCount = globalCount
			}
			if let leaf = metadata?.leaf {
				state.leaf = leaf
			}
		}
	}
	
	public func apply<Submetadata>(toSubrange state: inout SubrangeState<Element, Submetadata>) where Subrange<Submetadata> == Metadata {
		if !hasNoEffectOnValues {
			var rows = state.values ?? []
			mapMetadata { _ in () }.apply(to: &rows)
			state.values = rows
		}
		
		updateMetadata(&state)
	}
}

extension IndexSet {
	/// Maintaining an `SubrangeOffset` with a local offset may require offsetting an `IndexSet`
	public func offset(by: Int) -> IndexSet {
		if by == 0 {
			return self
		}
		var result = IndexSet()
		for range in self.rangeView {
			result.insert(integersIn: (range.startIndex + by)..<(range.endIndex + by))
		}
		return result
	}
}

public struct TreeMutation<Leaf>: ExpressibleByArrayLiteral {
	public let mutations: IndexedMutation<TreeMutation<Leaf>, Leaf>
	
	public init(mutations: IndexedMutation<TreeMutation<Leaf>, Leaf>) {
		self.mutations = mutations
	}
	
	public init(arrayLiteral elements: TreeMutation<Leaf>...) {
		self.mutations = .reload(elements)
	}
	
	public static func leaf(_ value: Leaf, children: [TreeMutation<Leaf>]? = nil) -> TreeMutation<Leaf> {
		return TreeMutation<Leaf>(mutations: children.map { IndexedMutation(metadata: value, reload: $0) } ?? IndexedMutation(metadata: value))
	}
	
	public static func leaf<Value>(_ value: Value, children: [TreeMutation<Leaf>]? = nil) -> TreeMutation<Leaf> where Subrange<Value> == Leaf {
		let subrange = Subrange(localOffset: children.map { _ in 0 }, globalCount: children.map { $0.count }, leaf: value)
		return TreeMutation<Leaf>(mutations: children.map { IndexedMutation(metadata: subrange, reload: $0) } ?? IndexedMutation(metadata: subrange))
	}
}

public class TreeState<Metadata> {
	public weak var parent: TreeState<Metadata>?
	public var metadata: Metadata? = nil
	public var rows: Array<TreeState<Metadata>>? = nil
	
	public init(parent: TreeState<Metadata>?) {}
	
	public convenience init(parent: TreeState<Metadata>?, treeMutation: TreeMutation<Metadata>) {
		self.init(parent: parent)
		treeMutation.mutations.apply(toTree: self)
	}
}

public typealias TreeSubrangeMutation<Leaf> = TreeMutation<Subrange<Leaf>>

extension IndexedMutation where Element == TreeMutation<Metadata> {
	public func apply(toTree treeState: TreeState<Metadata>) {
		if let metadata = metadata {
			treeState.metadata = metadata
		}
		
		if !hasNoEffectOnValues {
			var rows: Array<TreeState<Metadata>> = []
			if case .update = kind {
				for (mutationIndex, rowIndex) in indexSet.enumerated() {
					values[mutationIndex].mutations.apply(toTree: rows[rowIndex])
				}
			} else {
				mapValues { mutation in TreeState<Metadata>.init(parent: treeState, treeMutation: mutation) }.mapMetadata { _ in () }.apply(to: &rows)
			}
			treeState.rows = rows
		}
	}
}

public typealias TreeRangeMutation<Leaf> = TreeMutation<Subrange<Leaf>>

public class TreeSubrangeState<Leaf> {
	public weak var parent: TreeSubrangeState<Leaf>?
	public var state = SubrangeState<TreeSubrangeState<Leaf>, Leaf>()

	public init(parent: TreeSubrangeState<Leaf>?) {}
	
	public convenience init(parent: TreeSubrangeState<Leaf>?, treeSubrangeMutation: TreeSubrangeMutation<Leaf>) {
		self.init(parent: parent)
		treeSubrangeMutation.mutations.apply(toTreeSubrange: self)
	}
}

extension IndexedMutation where Element == TreeMutation<Metadata> {
	public func apply<Leaf>(toTreeSubrange treeSubrangeState: TreeSubrangeState<Leaf>) where Subrange<Leaf> == Metadata {
		if !hasNoEffectOnValues {
			if case .update = kind {
				for (mutationIndex, rowIndex) in indexSet.enumerated() {
					values[mutationIndex].mutations.apply(toTreeSubrange: treeSubrangeState.state.values![rowIndex])
				}
			} else {
				mapValues { mutation in TreeSubrangeState<Leaf>.init(parent: treeSubrangeState, treeSubrangeMutation: mutation) }.apply(toSubrange: &treeSubrangeState.state)
			}
		}
		updateMetadata(&treeSubrangeState.state)
	}
}

/// A value abstraction of the arguments to some AppKit/UIKit methods with a `setValue(_:,animated:)` structure.
public struct Animatable<Value, AnimationType> {
	public let value: Value
	public let animation: AnimationType?
	
	public static func set(_ value: Value) -> Animatable<Value, AnimationType> {
		return Animatable<Value, AnimationType>(value: value, animation: nil)
	}
	public static func animate(_ value: Value, animation: AnimationType) -> Animatable<Value, AnimationType> {
		return Animatable<Value, AnimationType>(value: value, animation: animation)
	}
	
	var isAnimated: Bool {
		return animation != nil
	}
}

public typealias SetOrAnimate<Value> = Animatable<Value, ()>

extension Animatable where AnimationType == () {
	public static func animate(_ value: Value) -> Animatable<Value, AnimationType> {
		return Animatable<Value, AnimationType>(value: value, animation: ())
	}
}

public extension BindingName {
	static func --<A, AnimationType>(name: BindingName<Value, Source, Binding>, value: A) -> Binding where Dynamic<Animatable<A, AnimationType>> == Value {
		return name.binding(with: Value.constant(.set(value)))
	}
	
}

public enum AnimationChoice {
	case never
	case subsequent
	case always
}

extension SignalInterface {
	public func animate(_ choice: AnimationChoice = .subsequent) -> Signal<Animatable<OutputValue, ()>> {
		return map(initialState: false) { (alreadyReceived: inout Bool, value: OutputValue) in
			if alreadyReceived || choice == .always {
				return .animate(value)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(value)
			}
		}
	}

	public func animate(_ choice: AnimationChoice = .subsequent) -> Signal<Animatable<OutputValue?, ()>> {
		return map(initialState: false) { (alreadyReceived: inout Bool, value: OutputValue) in
			if alreadyReceived || choice == .always {
				return .animate(value)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(value)
			}
		}
	}
}

import Foundation

extension Adapter {
	#if os(iOS)
		public func storeToArchive<Value>() -> (UIApplication, NSKeyedArchiver) -> Void where State == VarState<Value> {
			return { _, archiver in archiver.encodeLatest(from: self) }
		}
	#elseif os(macOS)
		public func storeToArchive<Value>() -> (NSApplication, NSCoder) -> Void where State == VarState<Value> {
			return { _, archiver in archiver.encodeLatest(from: self) }
		}
	#endif
}

extension Adapter {
	#if os(iOS)
		public func loadFromArchive<Value>() -> (UIApplication, NSKeyedUnarchiver) -> Void where State == VarState<Value> {
			return { _, unarchiver in unarchiver.decodeSend(to: self.set()) }
		}
	#elseif os(macOS)
		public func loadFromArchive<Value>() -> (NSApplication, NSCoder) -> Void where State == VarState<Value> {
			return { _, unarchiver in unarchiver.decodeSend(to: self.set()) }
		}
	#endif
}

extension NSCoder {
	/// Gets the latest value from the signal and encodes the value as JSON data into self using the provided key
	///
	/// - Parameters:
	///   - interface: exposes the signal
	///   - forKey: key used for encoding (is `String.viewStateKey` by default)
	public func encodeLatest<Interface>(from interface: Interface, forKey: String = .viewStateKey) where Interface: SignalInterface, Interface.OutputValue: Codable {
		if let data = try? JSONEncoder().encode(interface.peek()) {
			_ = self.encode(data, forKey: forKey)
		}
	}
}

extension NSCoder {
	/// Decodes the JSON data in self, associated with the provided key, and sends into the signal input.
	///
	/// NOTE: this function does not send errors.
	///
	/// - Parameters:
	///   - inputInterface: exposes the signal input
	///   - forKey: key used for decoding (is `String.viewStateKey` by default)
	public func decodeSend<InputInterface>(to inputInterface: InputInterface, forKey: String = .viewStateKey) where InputInterface: SignalInputInterface, InputInterface.InputValue: Codable {
		if let data = self.decodeObject(forKey: forKey) as? Data, let value = try? JSONDecoder().decode(InputInterface.InputValue.self, from: data) {
			inputInterface.input.send(value: value)
		}
	}
}

public extension String {
	static let viewStateKey = "viewStateData"
}

import Foundation

#if os(macOS)
	extension NSImage {
		public static func drawn(width: CGFloat, height: CGFloat, flipped: Bool = true, _ function: @escaping (CGContext, CGRect) -> Void) -> NSImage {
			let size = CGSize(width: width, height: height)
			return NSImage(size: size, flipped: flipped) { rect -> Bool in
				guard let context = NSGraphicsContext.current else { return false }
				function(context.cgContext, rect)
				return true
			}
		}
	}
#else
	extension UIImage {
		public static func drawn(width: CGFloat, height: CGFloat, _ function: (CGContext, CGRect) -> Void) -> UIImage {
			let size = CGSize(width: width, height: height)
			UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
			if let graphicsContext = UIGraphicsGetCurrentContext() {
				function(graphicsContext, CGRect(origin: .zero, size: size))
			}
			let rectangleImage = UIGraphicsGetImageFromCurrentImageContext()
			UIGraphicsEndImageContext()
			return rectangleImage ?? UIImage()
		}
	}
#endif

import Foundation

extension NSKeyValueObservation: Lifetime {
	public func cancel() {
		self.invalidate()
	}
}

#if os(macOS)
	import AppKit
	
	public protocol ViewConvertible {
		func nsView() -> Layout.View
	}
	extension Layout.View: ViewConvertible {
		public func nsView() -> Layout.View {
			return self
		}
	}
#else
	import UIKit
	
	public protocol ViewConvertible {
		func uiView() -> Layout.View
	}
	extension Layout.View: ViewConvertible {
		public func uiView() -> Layout.View {
			return self
		}
	}
#endif

#if os(iOS)
	// This type handles a combination of `layoutMargin` and `safeAreaMargin` inset edges. If a `safeArea` edge is specified, it will be used instead of `layout` edge.
	public struct MarginEdges: OptionSet {
		public static var none: MarginEdges { return MarginEdges(rawValue: 0) }
		public static var topLayout: MarginEdges { return MarginEdges(rawValue: 1) }
		public static var leadingLayout: MarginEdges { return MarginEdges(rawValue: 2) }
		public static var bottomLayout: MarginEdges { return MarginEdges(rawValue: 4) }
		public static var trailingLayout: MarginEdges { return MarginEdges(rawValue: 8) }
		public static var topSafeArea: MarginEdges { return MarginEdges(rawValue: 16) }
		public static var leadingSafeArea: MarginEdges { return MarginEdges(rawValue: 32) }
		public static var bottomSafeArea: MarginEdges { return MarginEdges(rawValue: 64) }
		public static var trailingSafeArea: MarginEdges { return MarginEdges(rawValue: 128) }
		public static var allLayout: MarginEdges { return [.topLayout, .leadingLayout, .bottomLayout, .trailingLayout] }
		public static var allSafeArea: MarginEdges { return [.topSafeArea, .leadingSafeArea, .bottomSafeArea, .trailingSafeArea] }
		public let rawValue: UInt
		public init(rawValue: UInt) {
			self.rawValue = rawValue
		}
	}
#endif

#if os(macOS)
	public extension NSView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(view: self)) })
		}
	}
#else
	public extension UIView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(view: self, marginEdges: $0.marginEdges)) })
		}
	}
	
	public extension UIScrollView {
		/// Adds the views contained by `layout` in the arrangment described by the layout to `self`.
		///
		/// - Parameter layout: a set of views and layout descriptions
		func applyContentLayout(_ layout: Layout?) {
			applyLayoutToView(view: self, params: layout.map { (layout: $0, bounds: Layout.Bounds(scrollView: self)) })
		}
	}
#endif

/// A data structure for describing a layout as a series of nested columns and rows.
public struct Layout {
	/// A rough equivalent to UIStackViewAlignment, minus baseline cases which aren't handled
	public enum Alignment { case leading, trailing, center, fill }
	
	#if os(macOS)
		public typealias Axis = NSUserInterfaceLayoutOrientation
		public typealias View = NSView
		public typealias Guide = NSLayoutGuide
		public typealias EdgeInsets = NSEdgeInsets
	#else
		public typealias Axis = NSLayoutConstraint.Axis
		public typealias View = UIView
		public typealias Guide = UILayoutGuide
		public typealias EdgeInsets = UIEdgeInsets
	#endif

	/// When a layout is applied, it can animate one of three ways:
	///
	/// - none: Do not animate layout transitions
	/// - frames: Animate frame changes for views present both before and after but do not animate added or removed views
	/// - fade: Use a fade transition for all changes
	/// - all: Animate frame changes for views present both before and after and use fade transitions for other viewa
	public struct Animation {
		public enum Style {
			case frames
			case fade
			case both
		}
		public let style: Style
		public let duration: CFTimeInterval
		public init(style: Style, duration: CFTimeInterval) {
			self.style = style
			self.duration = duration
		}
		
		public static func frames(_ duration: CFTimeInterval = 0.2) -> Animation { return Animation(style: .frames, duration: duration) }
		public static func fade(_ duration: CFTimeInterval = 0.2) -> Animation { return Animation(style: .fade, duration: duration) }
		public static func both(_ duration: CFTimeInterval = 0.2) -> Animation { return Animation(style: .both, duration: duration) }
	}
	
	
	/// Layout is either horizontal or vertical (although any element within the layout may be a layout in the perpendicular direction)
	let axis: Axis
	
	/// Within the horizontal row or vertical column, layout entities may fill, center or align-leading or align-trailing
	let align: Alignment
	
	#if os(iOS)
		/// The layout may extend to the view bounds or may be limited by the safeAreaMargins or layoutMargins. The safeArea insets supercede the layoutMargins (prior to iOS 11, safeArea is interpreted as UIViewController top/bottom layout guides when laying out within a UIViewController, otherwise it is treated as a synonym for the layoutMargins). This value has no effect on macOS.	
		let marginEdges: MarginEdges
	#endif
	
	/// When applied to the top level `Layout` passed to 'applyLayout`, then replacing an existing layout on a view, if this variable is true, after applying the new layout, `layoutIfNeeded` will be called inside a `UIView.beginAnimations`/`UIView.endAnimations` block. Has no effect when set on a child `Layout`.
	let animation: Layout.Animation?
	
	/// This is the list of views, spaces and sublayouts that will be layed out.
	var entities: [Entity]
	
	/// The default constructor assigns all values. In general, it's easier to use the `.horizontal` or `.vertical` constructor where possible.
	#if os(iOS)
		init(axis: Axis, align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), entities: [Entity]) {
			self.axis = axis
			self.align = align
			self.entities = entities
			self.marginEdges = marginEdges
			self.animation = animation
		}
	
		/// A convenience constructor for a horizontal layout
		public static func horizontal(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), _ entities: Entity...) -> Layout {
			return .horizontal(align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		public static func horizontal(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), entities: [Entity]) -> Layout {
			return Layout(axis: .horizontal, align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a vertical layout
		public static func vertical(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), _ entities: Entity...) -> Layout {
			return .vertical(align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		public static func vertical(align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), entities: [Entity]) -> Layout {
			return Layout(axis: .vertical, align: align, marginEdges: marginEdges, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a nested pair of layouts that combine to form a single centered arrangment
		public static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, _ entities: Entity...) -> Layout {
			return .center(axis: axis, alignment: alignment, marginEdges: marginEdges, animation: animation, length: length, breadth: breadth, relativity: relativity, entities: entities)
		}
		public static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, entities: [Entity]) -> Layout {
			switch axis {
			case .vertical:
				let v = Entity.sublayout(axis: .vertical, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: v
				)
				return Layout(axis: .vertical, align: .center, marginEdges: marginEdges, animation: animation, entities: [matched])
			case .horizontal:
				let h = Entity.sublayout(axis: .horizontal, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: h
				)
				return Layout(axis: .horizontal, align: .center, marginEdges: marginEdges, animation: animation, entities: [matched])
			@unknown default: fatalError()
			}
		}
		
		/// A convenience constructor for a vertical layout
		public static func fill(axis: Layout.Axis = .vertical, align: Alignment = .fill, marginEdges: MarginEdges = .allSafeArea, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ view: ViewConvertible) -> Layout {
			switch axis {
			case .horizontal: return .horizontal(align: align, marginEdges: marginEdges, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			case .vertical: return .vertical(align: align, marginEdges: marginEdges, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			@unknown default: fatalError()
			}
		}
	#else
		init(axis: Axis, align: Alignment = .fill, animation: Layout.Animation? = .frames(), entities: [Entity]) {
			self.axis = axis
			self.align = align
			self.entities = entities
			self.animation = animation
		}
		
		/// A convenience constructor for a horizontal layout
		public static func horizontal(align: Alignment = .fill, animation: Layout.Animation? = .frames(), _ entities: Entity...) -> Layout {
			return .horizontal(align: align, animation: animation, entities: entities)
		}
		public static func horizontal(align: Alignment = .fill, animation: Layout.Animation? = .frames(), entities: [Entity]) -> Layout {
			return Layout(axis: .horizontal, align: align, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a vertical layout
		public static func vertical(align: Alignment = .fill, animation: Layout.Animation? = .frames(), _ entities: Entity...) -> Layout {
			return .vertical(align: align, animation: animation, entities: entities)
		}
		public static func vertical(align: Alignment = .fill, animation: Layout.Animation? = .frames(), entities: [Entity]) -> Layout {
			return Layout(axis: .vertical, align: align, animation: animation, entities: entities)
		}
		
		/// A convenience constructor for a nested pair of layouts that combine to form a single centered arrangment
		public static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, _ entities: Entity...) -> Layout {
			return .center(axis: axis, alignment: alignment, animation: animation, length: length, breadth: breadth, relativity: relativity, entities: entities)
		}
		public static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, entities: [Entity]) -> Layout {
			switch axis {
			case .vertical:
				let v = Entity.sublayout(axis: .vertical, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: v
				)
				return Layout(axis: .vertical, align: .center, animation: animation, entities: [matched])
			case .horizontal:
				let h = Entity.sublayout(axis: .horizontal, align: alignment, length: length, breadth: breadth, relativity: relativity, entities: entities)
				let matched = Entity.pair(
					.space(.fillRemaining),
					.space(.fillRemaining),
					separator: h
				)
				return Layout(axis: .horizontal, align: .center, animation: animation, entities: [matched])
			@unknown default: fatalError()
			}
		}
		
		/// A convenience constructor for a vertical layout
		public static func fill(axis: Layout.Axis = .vertical, align: Alignment = .fill, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ view: ViewConvertible) -> Layout {
			switch axis {
			case .horizontal: return .horizontal(align: align, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			case .vertical: return .vertical(align: align, animation: animation, .view(length: length, breadth: breadth, relativity: relativity, view))
			@unknown default: fatalError()
			}
		}
		
		/// A convenience constructor for a vertical layout 
		public static func inset(margins: EdgeInsets, animation: Layout.Animation? = .frames(), _ entity: Entity) -> Layout {
			return .horizontal(.space(.equalTo(constant: margins.left)), .vertical(.space(.equalTo(constant: margins.top)), entity, .space(.equalTo(constant: margins.bottom))), .space(.equalTo(constant: margins.right)))
		}
	#endif
	
	// Used for removing all views from their superviews
	func forEachView(_ visit: (View) -> Void) {
		entities.forEach { $0.forEachView(visit) }
	}
	
	// Used for finding the n-th subview, depth-first search order
	func traverse(over remaining: inout Int) -> ViewConvertible? {
		for e in entities {
			if let match = e.traverse(over: &remaining) {
				return match
			}
		}
		return nil
	}

	/// A linear time search for the view at a given index. Current state is intended for testing-only.
	///
	/// - Parameter at: the view returned will be the `at`-th view encountered in a depth-first walk.
	/// - Returns: the `at`-th view encountered or `nil` if never enountered
	public func view(at: Int) -> ViewConvertible? {
		if at < 0 {
			return nil
		}
		var remaining = at
		return traverse(over: &remaining)
	}

	/// The `Layout` describes a series of these `Entity`s which may be a space, a view or a sublayout. There is also a special `matched` layout which allows a series of "same length" entities.
	///
	/// - interViewSpace: AppKit and UIKit use an 8 screen unit space as the "standard" space between adjacent views.
	/// - space: an arbitrary space between views
	/// - view: a view with optional width and height (if not specified, the view will use its "intrinsic" size or will fill the available layout space)
	/// - layout: a nested layout which may be parallel or perpedicular to its container and whose size may be specified (like view)
	/// - matched: a sequence of alternating "same size" and independent entities (you can use `.space(0)` if you don't want independent entities).
	public struct Entity {
		enum Content {
			case space(Dimension)
			case sizedView(ViewConvertible, Size?)
			indirect case layout(Layout, size: Size?)
			indirect case matched(Matched)
		}
		let content: Content
		init(_ content: Content) {
			self.content = content
		}
		
		func forEachView(_ visit: (Layout.View) -> Void) {
			switch content {
			case .sizedView(let v, _):
				#if os(macOS)
					visit(v.nsView())
				#else
					visit(v.uiView())
				#endif
			case .layout(let l, _): l.forEachView(visit)
			case .matched(let matched):
				matched.first.forEachView(visit)
				matched.subsequent.forEach { element in
					switch element {
					case .free(let entity): entity.forEachView(visit)
					case .dependent(let dependent): dependent.entity.forEachView(visit)
					}
				}
			case .space: break
			}
		}

		func traverse(over remaining: inout Int) -> ViewConvertible? {
			switch content {
			case .sizedView(let v, _):
				if remaining == 0 {
					return v
				} else {
					remaining -= 1
				}
				return nil
			case .layout(let l, _):
				return l.traverse(over: &remaining)
			case .matched(let matched):
				if let v = matched.first.traverse(over: &remaining) {
					return v
				}
				for s in matched.subsequent {
					switch s {
					case .free(let entity):
						if let v = entity.traverse(over: &remaining) {
							return v
						}
					case .dependent(let dependent):
						if let v = dependent.entity.traverse(over: &remaining) {
							return v
						}
					}
				}
				return nil
			case .space:
				return nil
			}
		}
		
		public static func space(_ dimension: Dimension = .standardSpace) -> Entity {
			return Entity(.space(dimension))
		}
		
		public static func view(length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ view: ViewConvertible) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			return Entity(.sizedView(view, size))
		}

		public static func sublayout(axis: Axis, align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: axis, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: axis, align: align, entities: entities), size: size))
			#endif
		}
		
		public static func sublayout(axis: Axis, align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, entities: [Entity]) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: axis, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: axis, align: align, entities: entities), size: size))
			#endif
		}
		
		public static func horizontal(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .horizontal, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .horizontal, align: align, entities: entities), size: size))
			#endif
		}
		
		public static func horizontal(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: [Entity]) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .horizontal, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .horizontal, align: align, entities: entities), size: size))
			#endif
		}
		
		public static func vertical(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .vertical, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .vertical, align: align, entities: entities), size: size))
			#endif
		}
		
		public static func vertical(align: Alignment = .fill, length: Dimension? = nil, breadth: Dimension? = nil, relativity: Size.Relativity = .independent, entities: [Entity]) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(Layout(axis: .vertical, align: align, marginEdges: .none, entities: entities), size: size))
			#else
				return Entity(.layout(Layout(axis: .vertical, align: align, entities: entities), size: size))
			#endif
		}

		public static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, _ entities: Entity...) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#else
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#endif
		}

		public static func center(axis: Layout.Axis = .vertical, alignment: Alignment = .center, animation: Layout.Animation? = .frames(), length: Dimension? = nil, breadth: Dimension? = .equalTo(ratio: 1.0), relativity: Size.Relativity = .independent, entities: [Entity]) -> Entity {
			let size = Size(length: length, breadth: breadth, relativity: relativity)
			#if os(iOS)
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#else
				return Entity(.layout(.center(axis: axis, alignment: alignment, animation: animation, entities: entities), size: size))
			#endif
		}
		
		public static func pair(_ left: Entity, _ right: Entity, separator: Entity = .space(), priority: Dimension.Priority = .required) -> Entity {
			return Entity(.matched(Matched(
				first: left,
				subsequent: [
					.free(separator),
					.dependent(.init(dimension: .equalTo(ratio: 1.0, priority: priority), right))
				]
			)))
		}
		
		public static func matched(_ first: Entity, _ subsequent: Matched.Element...) -> Entity {
			return Entity(.matched(.init(first: first, subsequent: subsequent)))
		}
		
		public static func matched(_ first: Entity, subsequent: [Matched.Element]) -> Entity {
			return Entity(.matched(.init(first: first, subsequent: subsequent)))
		}
		
		public static func same(priority: Dimension.Priority = .required, _ entities: Entity...) -> Entity {
			return same(entities: entities)
		}
		
		public static func same(priority: Dimension.Priority = .required, entities: [Entity]) -> Entity {
			guard let first = entities.first else { return .space(0) }
			return Entity(.matched(.init(first: first, subsequent: entities.dropFirst().map { .same(priority: priority, $0) })))
		}
		
		public static func inset(margins: EdgeInsets, _ entity: Entity) -> Entity {
			return .horizontal(.space(.equalTo(constant: margins.left)), .vertical(.space(.equalTo(constant: margins.top)), entity, .space(.equalTo(constant: margins.bottom))), .space(.equalTo(constant: margins.right)))
		}
	}
	
	/// A `Matched` element in a layout is a first element, followed by an array of free and dependent elements. The dependent elements all have a dimension  relationship to the first element (e.g. same size).
	public struct Matched {
		public struct Dependent {
			public let dimension: Dimension
			public let entity: Entity
			public init(dimension: Dimension, _ entity: Entity) {
				self.entity = entity
				self.dimension = dimension
			}
		}
		public enum Element {
			case dependent(Dependent)
			case free(Entity)

			public static func same(priority: Dimension.Priority = .required, _ entity: Entity) -> Element {
				return .dependent(.init(dimension: Dimension.equalTo(ratio: 1, priority: priority), entity))
			}
		}
		public let first: Entity
		public let subsequent: [Element]
		public init(first: Entity, subsequent: [Element]) {
			self.first = first
			self.subsequent = subsequent
		}
	}

	/// A `Size` is the combination of both length (size of a layout object in the direction of layout) or breadth (size of a layout object perpendicular to the layout direction). If the length includes a ratio, it is relative to the parent container but the breadth can be relative to the length, allowing for specifying an aspect ratio.
	public struct Size {
		public enum Relativity {
			case independent
			case lengthRelativeToBreadth
			case breadthRelativeToLength
			
			var isLengthRelativeToBreadth: Bool {
				if case .lengthRelativeToBreadth = self { return true } else { return false }
			}
			var isBreadthRelativeToLength: Bool {
				if case .breadthRelativeToLength = self { return true } else { return false }
			}
		}
		public let length: Dimension?
		public let breadth: Dimension?
		public let relativity: Relativity
		
		public init(length: Dimension? = nil, breadth: Dimension?, relativity: Relativity = .independent) {
			self.length = length
			self.breadth = breadth
			self.relativity = relativity
		}
	}

	/// When length (size of a layout object in the direction of layout) or breadth (size of a layout object perpendicular to the layout direction) is specified, it can be specified:
	///	* relative to the parent container (ratio)
	///	* in raw screen units (constant)
	/// The greater/less than and priority can also be specified.
	public struct Dimension: ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral {
		public typealias FloatLiteralType = Double
		public typealias IntegerLiteralType = Int
		
		#if os(macOS)
			public typealias Relation = NSLayoutConstraint.Relation
			public typealias Priority = NSLayoutConstraint.Priority
		#else
			public typealias Relation = NSLayoutConstraint.Relation
			public typealias Priority = UILayoutPriority
		#endif
		
		public let ratio: CGFloat
		public let constant: CGFloat
		public let relationship: Relation
		public let priority: Dimension.Priority
		public init(ratio: CGFloat = 0, constant: CGFloat = 0, relationship: Dimension.Relation = .equal, priority: Dimension.Priority = .required) {
			self.ratio = ratio
			self.constant = constant
			self.relationship = relationship
			self.priority = priority
		}
		
		public init(floatLiteral value: Double) {
			self.init(constant: CGFloat(value))
		}
		
		public init(integerLiteral value: Int) {
			self.init(constant: CGFloat(value))
		}
		
		public static func constant(_ value: CGFloat) -> Dimension {
			return Dimension(constant: value)
		}
		
		public static func ratio(_ value: CGFloat, constant: CGFloat = 0) -> Dimension {
			return Dimension(ratio: value, constant: constant)
		}
		
		public static var standardSpace = Dimension(ratio: 0, constant: 8, relationship: .equal, priority: .layoutHigh) 
		
		public static func lessThanOrEqualTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -> Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .lessThanOrEqual, priority: priority)
		}
		
		public static func greaterThanOrEqualTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -> Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .greaterThanOrEqual, priority: priority)
		}
		
		public static func equalTo(ratio: CGFloat = 0, constant: CGFloat = 0, priority: Dimension.Priority = .required) -> Dimension {
			return Dimension(ratio: ratio, constant: constant, relationship: .equal, priority: priority)
		}
		
		public static var fillRemaining: Dimension {
			return equalTo(ratio: 1, priority: .layoutMid)
		}
		
		func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension, priorityAdjustment: Int) -> NSLayoutConstraint {
			let constraint: NSLayoutConstraint
			switch relationship {
			case .equal: constraint = first.constraint(equalTo: second, multiplier: ratio, constant: constant)
			case .lessThanOrEqual: constraint = first.constraint(lessThanOrEqualTo: second, multiplier: ratio, constant: constant)
			case .greaterThanOrEqual: constraint = first.constraint(greaterThanOrEqualTo: second, multiplier: ratio, constant: constant)
			@unknown default: fatalError()
			}
			constraint.priority = adjustedPriority(priority, count: priorityAdjustment)
			constraint.isActive = true
			return constraint
		}
		
		public func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension) -> NSLayoutConstraint {
			return scaledConstraintBetween(first: first, second: second, priorityAdjustment: 0)
		}
		
		func scaledConstraintBetween(first: NSLayoutDimension, second: NSLayoutDimension, constraints: inout [NSLayoutConstraint]) {
			constraints.append(scaledConstraintBetween(first: first, second: second, priorityAdjustment: constraints.count))
		}
		
		func unscaledConstraintBetween<AnchorType>(first: NSLayoutAnchor<AnchorType>, second: NSLayoutAnchor<AnchorType>, constraints: inout [NSLayoutConstraint], reverse: Bool = false) {
			let constraint: NSLayoutConstraint
			switch (relationship, reverse) {
			case (.equal, _): constraint = first.constraint(equalTo: second, constant: reverse ? -constant: constant)
			case (.lessThanOrEqual, false), (.greaterThanOrEqual, true): constraint = first.constraint(lessThanOrEqualTo: second, constant: reverse ? -constant: constant)
			case (.greaterThanOrEqual, false), (.lessThanOrEqual, true): constraint = first.constraint(greaterThanOrEqualTo: second, constant: reverse ? -constant: constant)
			@unknown default: fatalError()
			}
			constraint.priority = adjustedPriority(priority, count: constraints.count)
			constraint.isActive = true
			constraints.append(constraint)
		}
	}

	/// Bounds are used internally to capture a set of guides and anchors. On the Mac, these are merely copied from a single NSLayoutGuide or an NSView. On iOS, these may be copied from a blend of UIViewController top/bottomLayoutGuides, safeAreaLayoutGuides, layoutMarginsGuides or a UIView.
	fileprivate struct Bounds {
		var leading: NSLayoutXAxisAnchor
		var top: NSLayoutYAxisAnchor
		var trailing: NSLayoutXAxisAnchor
		var bottom: NSLayoutYAxisAnchor
		var width: NSLayoutDimension
		var height: NSLayoutDimension
		var centerX: NSLayoutXAxisAnchor
		var centerY: NSLayoutYAxisAnchor
		
		init(box: Layout.Box) {
			leading = box.leadingAnchor
			top = box.topAnchor
			trailing = box.trailingAnchor
			bottom = box.bottomAnchor
			width = box.widthAnchor
			height = box.heightAnchor
			centerX = box.centerXAnchor
			centerY = box.centerYAnchor
		}
		
		#if os(iOS)
			init(scrollView: UIScrollView) {
				leading = scrollView.contentLayoutGuide.leadingAnchor
				top = scrollView.contentLayoutGuide.topAnchor
				trailing = scrollView.contentLayoutGuide.trailingAnchor
				bottom = scrollView.contentLayoutGuide.bottomAnchor
				width = scrollView.contentLayoutGuide.widthAnchor
				height = scrollView.contentLayoutGuide.heightAnchor
				centerX = scrollView.contentLayoutGuide.centerXAnchor
				centerY = scrollView.contentLayoutGuide.centerYAnchor
			}
			
			init(view: Layout.View, marginEdges: MarginEdges) {
				leading = marginEdges.contains(.leadingSafeArea) ? view.safeAreaLayoutGuide.leadingAnchor : (marginEdges.contains(.leadingLayout) ? view.layoutMarginsGuide.leadingAnchor : view.leadingAnchor)
				top = marginEdges.contains(.topSafeArea) ? view.safeAreaLayoutGuide.topAnchor : (marginEdges.contains(.topLayout) ? view.layoutMarginsGuide.topAnchor : view.topAnchor)
				trailing = marginEdges.contains(.trailingSafeArea) ? view.safeAreaLayoutGuide.trailingAnchor : (marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.trailingAnchor : view.trailingAnchor)
				bottom = marginEdges.contains(.bottomSafeArea) ? view.safeAreaLayoutGuide.bottomAnchor : (marginEdges.contains(.bottomLayout) ? view.layoutMarginsGuide.bottomAnchor : view.bottomAnchor)
				width = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.widthAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.widthAnchor : view.widthAnchor)
				height = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.heightAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.heightAnchor : view.heightAnchor)
				centerX = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.centerXAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.centerXAnchor : view.centerXAnchor)
				centerY = (marginEdges.contains(.leadingSafeArea) && marginEdges.contains(.trailingSafeArea)) ? view.safeAreaLayoutGuide.centerYAnchor : (marginEdges.contains(.leadingLayout) && marginEdges.contains(.trailingLayout) ? view.layoutMarginsGuide.centerYAnchor : view.centerYAnchor)
			}
		#else
			init(view: Layout.View) {
				leading = view.leadingAnchor
				top = view.topAnchor
				trailing = view.trailingAnchor
				bottom = view.bottomAnchor
				width = view.widthAnchor
				height = view.heightAnchor
				centerX = view.centerXAnchor
				centerY = view.centerYAnchor
			}
		#endif
	}

	private struct State {
		let view: View
		let storage: Storage
		
		var dimension: Dimension? = nil
		var previousEntityBounds: Bounds? = nil
		var containerBounds: Bounds
		
		init(containerBounds: Bounds, in view: View, storage: Storage) {
			self.containerBounds = containerBounds
			self.view = view
			self.storage = storage
		}
	}

	fileprivate class Storage: NSObject {
		let layout: Layout
		var constraints: [NSLayoutConstraint] = []
		var boxes: [Layout.Box] = []
		
		init(layout: Layout) {
			self.layout = layout
		}
	}

	private func twoPointConstraint<First, Second>(firstSource: NSLayoutAnchor<First>, firstTarget: NSLayoutAnchor<First>, secondSource: NSLayoutAnchor<Second>, secondTarget: NSLayoutAnchor<Second>, secondRelationLessThan: Bool? = nil, constraints: inout [NSLayoutConstraint]) {
		let first = firstSource.constraint(equalTo: firstTarget)
		first.priority = .required
		first.isActive = true
		constraints.append(first)
		
		let secondLow = secondSource.constraint(equalTo: secondTarget)
		
		var secondHigh: NSLayoutConstraint? = nil
		if secondRelationLessThan == true {
			secondHigh = secondSource.constraint(lessThanOrEqualTo: secondTarget)
		} else if secondRelationLessThan == false {
			secondHigh = secondSource.constraint(greaterThanOrEqualTo: secondTarget)
		}
		if let high = secondHigh {
			secondLow.priority = adjustedPriority(.layoutLow, count: constraints.count)
			high.priority = adjustedPriority(.layoutHigh, count: constraints.count + 1)
			high.isActive = true
			constraints.append(high)
		} else {
			secondLow.priority = adjustedPriority(.layoutHigh, count: constraints.count)
		}
		secondLow.isActive = true
		constraints.append(secondLow)
	}
	
	private func constrain(bounds: Bounds, leading: Dimension, length: Dimension?, breadth: Dimension?, relativity: Size.Relativity, state: inout State) {
		switch axis {
		case .horizontal:
			leading.unscaledConstraintBetween(first: bounds.leading, second: state.containerBounds.leading, constraints: &state.storage.constraints)
			
			if let l = length {
				l.scaledConstraintBetween(first: bounds.width, second: relativity.isLengthRelativeToBreadth ? bounds.height : state.containerBounds.width, constraints: &state.storage.constraints)
			}
			if let b = breadth {
				b.scaledConstraintBetween(first: bounds.height, second: relativity.isBreadthRelativeToLength ? bounds.width : state.containerBounds.height, constraints: &state.storage.constraints)
			}
			
			switch self.align {
			case .leading:
				twoPointConstraint(firstSource: bounds.top, firstTarget: state.containerBounds.top, secondSource: bounds.bottom, secondTarget: state.containerBounds.bottom, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .trailing:
				twoPointConstraint(firstSource: bounds.bottom, firstTarget: state.containerBounds.bottom, secondSource: bounds.top, secondTarget: state.containerBounds.top, secondRelationLessThan: false, constraints: &state.storage.constraints)
			case .center:
				twoPointConstraint(firstSource: bounds.centerY, firstTarget: state.containerBounds.centerY, secondSource: bounds.height, secondTarget: state.containerBounds.height, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .fill:
				twoPointConstraint(firstSource: bounds.top, firstTarget: state.containerBounds.top, secondSource: bounds.bottom, secondTarget: state.containerBounds.bottom, secondRelationLessThan: nil, constraints: &state.storage.constraints)
			}
			
			state.containerBounds.leading = bounds.trailing
		case .vertical:
			leading.unscaledConstraintBetween(first: bounds.top, second: state.containerBounds.top, constraints: &state.storage.constraints)
			
			if let l = length {
				l.scaledConstraintBetween(first: bounds.height, second: relativity.isLengthRelativeToBreadth ? bounds.width : state.containerBounds.height, constraints: &state.storage.constraints)
			}
			
			if let b = breadth {
				b.scaledConstraintBetween(first: bounds.width, second: relativity.isBreadthRelativeToLength ? bounds.height : state.containerBounds.width, constraints: &state.storage.constraints)
			}
			
			switch self.align {
			case .leading:
				twoPointConstraint(firstSource: bounds.leading, firstTarget: state.containerBounds.leading, secondSource: bounds.trailing, secondTarget: state.containerBounds.trailing, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .trailing:
				twoPointConstraint(firstSource: bounds.trailing, firstTarget: state.containerBounds.trailing, secondSource: bounds.leading, secondTarget: state.containerBounds.leading, secondRelationLessThan: false, constraints: &state.storage.constraints)
			case .center:
				twoPointConstraint(firstSource: bounds.centerX, firstTarget: state.containerBounds.centerX, secondSource: bounds.width, secondTarget: state.containerBounds.width, secondRelationLessThan: true, constraints: &state.storage.constraints)
			case .fill:
				twoPointConstraint(firstSource: bounds.leading, firstTarget: state.containerBounds.leading, secondSource: bounds.trailing, secondTarget: state.containerBounds.trailing, secondRelationLessThan: nil, constraints: &state.storage.constraints)
			}
			
			state.containerBounds.top = bounds.bottom
		@unknown default:	fatalError()
		}
	}
	
	@discardableResult
	private func layout(entity: Entity, state: inout State, needDimensionAnchor: Bool = false) -> NSLayoutDimension? {
		switch entity.content {
		case .space(let dimension):
			if let d = state.dimension, (d.ratio != 0 || d.constant != 0) {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				constrain(bounds: Bounds(box: box), leading: Dimension(), length: d, breadth: nil, relativity: .independent, state: &state)
				state.previousEntityBounds = nil
			}
			if dimension.ratio != 0 || needDimensionAnchor {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				constrain(bounds: Bounds(box: box), leading: Dimension(), length: dimension, breadth: nil, relativity: .independent, state: &state)
				state.previousEntityBounds = Bounds(box: box)
				return axis == .horizontal ? box.widthAnchor : box.heightAnchor
			}
			state.dimension = dimension
			return nil
		case .layout(let l, let size):
			let box = Layout.Box()
			state.view.addLayoutBox(box)
			state.storage.boxes.append(box)
			let bounds = Bounds(box: box)
			l.add(to: state.view, containerBounds: bounds, storage: state.storage)
			constrain(bounds: bounds, leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relativity: size?.relativity ?? .independent, state: &state)
			state.dimension = nil
			state.previousEntityBounds = bounds
			return needDimensionAnchor ? (axis == .horizontal ? box.widthAnchor : box.heightAnchor) : nil
		case .matched(let matched):
			if needDimensionAnchor {
				let box = Layout.Box()
				state.view.addLayoutBox(box)
				state.storage.boxes.append(box)
				var subState = State(containerBounds: state.containerBounds, in: state.view, storage: state.storage)
				layout(entity: entity, state: &subState)
				state.dimension = nil
				state.previousEntityBounds = Bounds(box: box)
				return axis == .horizontal ? box.widthAnchor : box.heightAnchor
			} else {
				let first = layout(entity: matched.first, state: &state, needDimensionAnchor: true)!
				for element in matched.subsequent {
					switch element {
					case .free(let free):
						layout(entity: free, state: &state)
					case .dependent(let dependent):
						let match = layout(entity: dependent.entity, state: &state, needDimensionAnchor: true)!
						dependent.dimension.scaledConstraintBetween(first: match, second: first, constraints: &state.storage.constraints)
					}
				}
				return nil
			}
		case .sizedView(let v, let size):
			#if os(macOS)
				let view = v.nsView()
				view.translatesAutoresizingMaskIntoConstraints = false
				state.view.addSubview(view)
				constrain(bounds: Bounds(view: view), leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relativity: size?.relativity ?? .independent, state: &state)
				state.dimension = nil
				state.previousEntityBounds = Bounds(view: view)
			#else
				let view = v.uiView()
				view.translatesAutoresizingMaskIntoConstraints = false
				state.view.addSubview(view)
				constrain(bounds: Bounds(view: view, marginEdges: .none), leading: state.dimension ?? Dimension(), length: size?.length, breadth: size?.breadth, relativity: size?.relativity ?? .independent, state: &state)
				state.dimension = nil
				state.previousEntityBounds = Bounds(view: view, marginEdges: .none)
		#endif
			return needDimensionAnchor ? (axis == .horizontal ? view.widthAnchor : view.heightAnchor) : nil
		}
	}
	
	fileprivate func add(to view: Layout.View, containerBounds: Bounds, storage: Storage) {
		var state = State(containerBounds: containerBounds, in: view, storage: storage)
		for entity in entities {
			layout(entity: entity, state: &state)
		}
		if let previous = state.previousEntityBounds {
			switch axis {
			case .horizontal:
				(state.dimension ?? Dimension()).unscaledConstraintBetween(first: previous.trailing, second: state.containerBounds.trailing, constraints: &state.storage.constraints, reverse: true)
			case .vertical:
				(state.dimension ?? Dimension()).unscaledConstraintBetween(first: previous.bottom, second: state.containerBounds.bottom, constraints: &state.storage.constraints, reverse: true)
			@unknown default: fatalError()
			}
		}
	}
}

// DEBUGGING TIP:
// As of Xcode 8, the "Debug View Hierarchy" option does not show layout guides, making debugging of constraints involving layout guides tricky. To aid debugging in these cases, set the following condition to `true && DEBUG` and CwlLayout will create views instead of layout guides.
// Otherwise, you can set this to `false && DEBUG`.
#if true && DEBUG
	private extension Layout {
		typealias Box = Layout.View
	}
	private extension Layout.View {
		func addLayoutBox(_ layoutBox: Layout.Box) {
			layoutBox.translatesAutoresizingMaskIntoConstraints = false
			self.addSubview(layoutBox)
		}
		func removeLayoutBox(_ layoutBox: Layout.Box) {
			layoutBox.removeFromSuperview()
		}
	}
#else
	private extension Layout {
		typealias Box = Layout.Guide
	}
	private extension Layout.View {
		func addLayoutBox(_ layoutBox: Layout.Box) {
			self.addLayoutGuide(layoutBox)
		}
		func removeLayoutBox(_ layoutBox: Layout.Box) {
			self.removeLayoutGuide(layoutBox)
		}
	}
#endif

// NOTE:
//
// Views often have their own intrinsic size, and they maintain this size at
// either the `.defaultLow` or `.defaultHigh` priority. Unfortunately, layout
// doesn't work well if this intrinsic priority is perfectly balanced with the
// user-applied layout priority.
//
// For this reason, CwlLayout defaults to using the following layout priorities
// which are scaled to be slightly different to the default priorities. This
// allows you to easily set layout priorities above, between or below the
// intrinisic priorities without always resorting to `.required`.
//
public extension Layout.Dimension.Priority {
	#if os(macOS)
		// .fittingSizeLevel = .fittingSizeCompression = 50
		static let fittingSizeLevel = NSLayoutConstraint.Priority.fittingSizeCompression
		// .layoutLow = 156.25
		static let layoutLow = NSLayoutConstraint.Priority(rawValue: (5 / 32) * NSLayoutConstraint.Priority.required.rawValue)
		// .defaultLow = 250
		// .layoutMid = 437.5
		static let layoutMid = NSLayoutConstraint.Priority(rawValue: (14 / 32) * NSLayoutConstraint.Priority.required.rawValue)
		// .dragThatCannotResizeWindow = 490
		// .windowSizeStayPut = 500
		// .dragThatCanResizeWindow = 510
		// .defaultHigh = 750
		// .layoutHigh = 843.75
		static let layoutHigh = NSLayoutConstraint.Priority(rawValue: (27 / 32) * NSLayoutConstraint.Priority.required.rawValue)
		// .required = 1000
	#else
		// .fittingSizeLevel = 50
		// .layoutLow = 156.25
		static let layoutLow = UILayoutPriority(rawValue: (5 / 32) * UILayoutPriority.required.rawValue)
		// .defaultLow = 250
		// .layoutMid = 437.5
		static let layoutMid = UILayoutPriority(rawValue: (14 / 32) * UILayoutPriority.required.rawValue)
		// .layoutHigh = 843.75
		static let layoutHigh = UILayoutPriority(rawValue: (27 / 32) * UILayoutPriority.required.rawValue)
		// .required = 1000
	#endif
}

private var associatedLayoutKey = NSObject()
private extension Layout.View {
	var associatedLayoutStorage: Layout.Storage? {
		get { return objc_getAssociatedObject(self, &associatedLayoutKey) as? Layout.Storage }
		set { return objc_setAssociatedObject(self, &associatedLayoutKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN) }
	}
}

private extension Layout.View {
	func remove(constraintsAndBoxes previousLayout: Layout.Storage?, subviews: Set<Layout.View>) {
		guard let previous = previousLayout else { return }
		for constraint in previous.constraints {
			constraint.isActive = false
		}
		for box in previous.boxes {
			self.removeLayoutBox(box)
		}
		subviews.forEach { $0.removeFromSuperview() }
	}
}

// Applying a rolloing set of priorities reduces the chance of ambiguity. Later constraints will always take precedence.
// NOTE: this does not eliminate ambiguity due to conflicting `.required` contraints or views with equal hugging or compression resistance.
private func adjustedPriority(_ priority: Layout.Dimension.Priority, count: Int) -> Layout.Dimension.Priority {
	if priority == .required {
		return priority
	}
	
	let fitting = Layout.Dimension.Priority.fittingSizeLevel.rawValue + (1 / 128)
	return Layout.Dimension.Priority(rawValue: max(fitting, priority.rawValue - Float(count) / 128))
}

private func applyLayoutToView(view: Layout.View, params: (layout: Layout, bounds: Layout.Bounds)?) {
	var removedViews = Set<Layout.View>()
	
	// Check for a previous layout and get the old views
	let previous = view.associatedLayoutStorage
	previous?.layout.forEachView { view in removedViews.insert(view) }
	
	guard let (layout, bounds) = params else {
		// If there's no new layout, remove the old layout and we're done
		view.remove(constraintsAndBoxes: previous, subviews: removedViews)
		return
	}
	
	// Check if this will be animated
	let shouldAnimate = layout.animation?.style != .none && previous != nil
	
	// Exclude views in the new layout from the removed set. If we're animating, we'll need animated and added sets too.
	var animatedViews = Set<Layout.View>()
	var addedViews = Set<Layout.View>()
	layout.forEachView { v in
		if let animated = removedViews.remove(v), shouldAnimate {
			animatedViews.insert(animated)
		} else if shouldAnimate {
			addedViews.insert(v)
		}
	}

	// Now that we know the precise removed set, remove them.
	let removalChange = { view.remove(constraintsAndBoxes: previous, subviews: removedViews) }
	if shouldAnimate && layout.animation?.style != .frames && addedViews.count == 0 && removedViews.count > 0 {
		// If we're animating the removal of views but not the insertion of views, animate this removal
		fadeTransition(view: view, duration: layout.animation?.duration ?? 0, removalChange)
	} else {
		removalChange()
	}
	
	// Apply the new layout
	let storage = Layout.Storage(layout: layout)
	layout.add(to: view, containerBounds: bounds, storage: storage)
	
	// If we're not animating, store the layout and we're done.
	if !shouldAnimate {
		view.associatedLayoutStorage = storage
		return
	}

	// NOTE: the case where `removedViews.count > 0` but `addedViews.count == 0` is handled above
	if addedViews.count > 0 {
		// Apply the layout, so new views have a precise size
		view.relayout()
		
		// Remove the new views and revert to the old layout
		view.remove(constraintsAndBoxes: storage, subviews: addedViews)
		if let p = previous {
			let oldStorage = Layout.Storage(layout: layout)
			p.layout.add(to: view, containerBounds: bounds, storage: oldStorage)

			// Immediately remove the old constraints but keep the old views
			view.remove(constraintsAndBoxes: oldStorage, subviews: [])
		}
		
		removedViews.forEach { $0.removeFromSuperview() }
		addedViews.forEach { view.addSubview($0) }
		
		// Reapply the new layout. Since the new views are already in-place
		let reapplyStorage = Layout.Storage(layout: layout)
		layout.add(to: view, containerBounds: bounds, storage: reapplyStorage)
		view.associatedLayoutStorage = reapplyStorage
	} else {
		view.associatedLayoutStorage = storage
	}
	
	// Animate the frames of the new layout
	let shouldFade: Bool
	switch layout.animation?.style {
	case .both?, .fade?: shouldFade = true
	case .frames?, nil: shouldFade = false
	}
	let frameChanges = {
		if shouldFade {
			fadeTransition(view: view, duration: layout.animation?.duration ?? 0, { view.relayout() })
		} else {
			view.relayout()
		}
	}
	if layout.animation?.style == .fade {
		frameChanges()
	} else {
		frameAnimation(view: view, duration: layout.animation?.duration ?? 0, frameChanges)
	}
}

private extension Layout.View {
	func relayout() {
		#if os(macOS)
			layoutSubtreeIfNeeded()
		#else
			layoutIfNeeded()
		#endif
	}
}

private func fadeTransition(view: Layout.View, duration: CFTimeInterval, _ changes: @escaping () -> ()) {
	#if os(macOS)
		let transition = CATransition()
		transition.duration = duration
		transition.type = .fade
		view.layer?.add(transition, forKey: nil)
		changes()
	#else
		UIView.transition(with: view, duration: duration, options: [.transitionCrossDissolve, .allowUserInteraction], animations: changes)
	#endif
}

private func frameAnimation(view: Layout.View, duration: CFTimeInterval, _ changes: @escaping () -> ()) {
	#if os(macOS)
		NSAnimationContext.beginGrouping()
		NSAnimationContext.current.duration = duration
		NSAnimationContext.current.allowsImplicitAnimation = true
		changes()
		NSAnimationContext.endGrouping()
	#else
		UIView.transition(with: view, duration: duration, options: [.transitionCrossDissolve, .allowUserInteraction], animations: changes)
	#endif
}

#if os(iOS)
	import UIKit
	
	@available(iOSApplicationExtension 8.2, *)
	public extension UIFont {
		static func preferredFont(forTextStyle style: UIFont.TextStyle, weight: UIFont.Weight = .regular, slant: Float = 0) -> UIFont {
			let base = UIFontDescriptor.preferredFontDescriptor(withTextStyle: style)
			let traits: [UIFontDescriptor.TraitKey: Any] = [.weight: weight, .slant: slant]
			let modified = base.addingAttributes([.traits: traits])
			return UIFont(descriptor: modified, size: 0)
		}
	}

	public func preferredFontSize(forTextStyle style: UIFont.TextStyle) -> CGFloat {
		return UIFontDescriptor.preferredFontDescriptor(withTextStyle: style).pointSize
	}
#endif

#if os(macOS)
	import AppKit

	@available(OSXApplicationExtension 10.11, *)
	public extension NSFont {
		enum TextStyle {
			case controlContent
			case label
			case menu
			case menuBar
			case message
			case monospacedDigit
			case palette
			case system
			case titleBar
			case toolTips
		}
		enum TextSize {
			case controlMini
			case controlRegular
			case controlSmall
			case label
			case points(CGFloat)
			case system
			case title1
			case title2
		}

		static func preferredFont(forTextStyle style: TextStyle, size: TextSize = .system, weight: NSFont.Weight = .regular, slant: CGFloat = 0) -> NSFont {
			let pointSize: CGFloat
			switch size {
			case .controlMini: pointSize = NSFont.systemFontSize(for: .mini)
			case .controlRegular: pointSize = NSFont.systemFontSize(for: .regular)
			case .controlSmall: pointSize = NSFont.systemFontSize(for: .small)
			case .label: pointSize = NSFont.labelFontSize
			case .points(let other): pointSize = other
			case .system: pointSize = NSFont.systemFontSize
			case .title1: pointSize = NSFont.systemFontSize + 5
			case .title2: pointSize = NSFont.systemFontSize + 2
			}
			
			let base: NSFont
			switch style {
			case .controlContent: base = NSFont.controlContentFont(ofSize: pointSize)
			case .label: base = NSFont.labelFont(ofSize: pointSize)
			case .menu: base = NSFont.menuFont(ofSize: pointSize)
			case .menuBar:  base = NSFont.menuBarFont(ofSize: pointSize)
			case .message:  base = NSFont.messageFont(ofSize: pointSize)
			case .monospacedDigit:  base = NSFont.monospacedDigitSystemFont(ofSize: pointSize, weight: weight)
			case .palette:  base = NSFont.paletteFont(ofSize: pointSize)
			case .system:  base = NSFont.systemFont(ofSize: pointSize)
			case .titleBar:  base = NSFont.titleBarFont(ofSize: pointSize)
			case .toolTips:  base = NSFont.toolTipsFont(ofSize: pointSize)
			}

			let traits: [NSFontDescriptor.TraitKey: Any] = [.weight: weight, .slant: slant]
			let modified = base.fontDescriptor.addingAttributes([.traits: traits])
			
			return NSFont(descriptor: modified, size: 0) ?? base
		}
	}
#endif

// MARK: - Binder Part 1: Binder
public class ExtendedView<Subclass: Layout.View & ViewWithDelegate & HasDelegate>: Binder, ViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

extension ExtendedView where Subclass == CwlExtendedView {
	public convenience init(bindings: [Preparer.Binding]) {
		self.init(type: CwlExtendedView.self, parameters: (), bindings: bindings)
	}
	
	public convenience init(_ bindings: Preparer.Binding...) {
		self.init(type: CwlExtendedView.self, parameters: (), bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ExtendedView {
	enum Binding: ExtendedViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		@available(macOS 10.10, *) @available(iOS, unavailable) case backgroundColor(Dynamic<NSColor?>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case sizeDidChange(SignalInput<CGSize>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	#if os(macOS)
		typealias NSColor = AppKit.NSColor
	#else
		typealias NSColor = ()
	#endif
}

// MARK: - Binder Part 3: Preparer
public extension ExtendedView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = ExtendedView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = Subclass
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ExtendedView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .sizeDidChange(let x): delegate().addMultiHandler1({ s in x.send(value: s) }, #selector(ViewDelegate.layoutSubviews(view:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .backgroundColor(let x):
			return x.apply(instance) { i, v in
				#if os(macOS)
					i.backgroundColor = v
				#endif
			}
		case .sizeDidChange: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ExtendedView.Preparer {
	open class Storage: View.Preparer.Storage, ViewDelegate {}
	
	open class Delegate: DynamicDelegate, ViewDelegate {
		open func layoutSubviews(view: Layout.View) {
			multiHandler(view.bounds.size)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ExtendedViewBinding {
	public typealias ExtendedViewName<V> = BindingName<V, ExtendedView<Binding.SubclassType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ExtendedView<Binding.SubclassType>.Binding) -> ExtendedViewName<V> {
		return ExtendedViewName<V>(source: source, downcast: Binding.extendedViewBinding)
	}
}
public extension BindingName where Binding: ExtendedViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ExtendedViewName<$2> { return .name(ExtendedView.Binding.$1) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	#if os(macOS)
		static var backgroundColor: ExtendedViewName<Dynamic<NSColor?>> { return .name(ExtendedView.Binding.backgroundColor) }
	#endif
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var sizeDidChange: ExtendedViewName<SignalInput<CGSize>> { return .name(ExtendedView.Binding.sizeDidChange) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public extension ExtendedView {
	#if os(iOS)
		func uiView() -> View.Instance { return instance() }
	#elseif os(macOS)
		func nsView() -> View.Instance { return instance() }
	#endif
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ExtendedViewBinding: ViewBinding {
	associatedtype SubclassType: Layout.View & ViewWithDelegate & HasDelegate
	static func extendedViewBinding(_ binding: ExtendedView<SubclassType>.Binding) -> Self
	func asExtendedViewBinding() -> ExtendedView<SubclassType>.Binding?
}
public extension ExtendedViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return extendedViewBinding(.inheritedBinding(binding))
	}
}
public extension ExtendedViewBinding where Preparer.Inherited.Binding: ExtendedViewBinding, Preparer.Inherited.Binding.SubclassType == SubclassType {
	func asExtendedViewBinding() -> ExtendedView<SubclassType>.Binding? {
		return asInheritedBinding()?.asExtendedViewBinding()
	}
}
public extension ExtendedView.Binding {
	typealias Preparer = ExtendedView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asExtendedViewBinding() -> ExtendedView.Binding? { return self }
	static func extendedViewBinding(_ binding: ExtendedView.Binding) -> ExtendedView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
@objc public protocol ViewDelegate: class {
	@objc optional func layoutSubviews(view: Layout.View)
}

public protocol ViewWithDelegate: class {
	var delegate: ViewDelegate? { get set }

	#if os(macOS)
		var backgroundColor: NSColor? { get set }
	#endif
}

#if os(macOS)
	extension ViewWithDelegate {
		// This default implementation is so that you're not required to implement `backgroundColor` to implement an ExtendedView
		var backgroundColor: NSColor? {
			get {
				return ((self as? NSView)?.layer?.backgroundColor).flatMap { NSColor(cgColor: $0) }
			}
			set {
				if let layer = (self as? NSView)?.layer {
					layer.backgroundColor = newValue?.cgColor 
				}
			}
		}
	}
#endif

/// Implementation of ViewWithDelegate on top of the base UIView.
/// You can use this view directly, subclass it or implement `ViewWithDelegate` and `HasDelegate` on top of another `UIView` to use that view with the `ExtendedView` binder.
open class CwlExtendedView: Layout.View, ViewWithDelegate, HasDelegate {
	public unowned var delegate: ViewDelegate?
	
	#if os(macOS)
		open var backgroundColor: NSColor?
	
		open override func draw(_ dirtyRect: NSRect) {
			super.draw(dirtyRect)
			
			if let backgroundColor = backgroundColor {
				backgroundColor.setFill()
				dirtyRect.fill()
			}
		}
	#endif
	
	#if os(iOS)
		open override func layoutSubviews() {
			delegate?.layoutSubviews?(view: self)
			super.layoutSubviews()
		}
	#elseif os(macOS)
		open override func layout() {
			delegate?.layoutSubviews?(view: self)
			super.layout()
		}
	#endif
}

// MARK: - Binder Part 1: Binder
public class GradientLayer: Binder, GradientLayerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension GradientLayer {
	enum Binding: GradientLayerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case colors(Dynamic<[CGColor]>)
		case locations(Dynamic<[CGFloat]>)
		case endPoint(Dynamic<CGPoint>)
		case startPoint(Dynamic<CGPoint>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension GradientLayer {
	struct Preparer: BinderDelegateDerived {
		public typealias Binding = GradientLayer.Binding
		public typealias Delegate = Inherited.Delegate
		public typealias Inherited = Layer.Preparer
		public typealias Instance = CAGradientLayer
		
		public var inherited: Inherited
		public init(delegateClass: Delegate.Type) {
			inherited = Inherited(delegateClass: delegateClass)
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension GradientLayer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .colors(let x): return x.apply(instance) { i, v in i.colors = v }
		case .locations(let x): return x.apply(instance) { i, v in i.locations = v.map { NSNumber(value: Double($0)) } }
		case .endPoint(let x): return x.apply(instance) { i, v in i.endPoint = v }
		case .startPoint(let x): return x.apply(instance) { i, v in i.startPoint = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension GradientLayer.Preparer {
	public typealias Storage = Layer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: GradientLayerBinding {
	public typealias GradientLayerName<V> = BindingName<V, GradientLayer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> GradientLayer.Binding) -> GradientLayerName<V> {
		return GradientLayerName<V>(source: source, downcast: Binding.gradientLayerBinding)
	}
}
public extension BindingName where Binding: GradientLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: GradientLayerName<$2> { return .name(GradientLayer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var colors: GradientLayerName<Dynamic<[CGColor]>> { return .name(GradientLayer.Binding.colors) }
	static var locations: GradientLayerName<Dynamic<[CGFloat]>> { return .name(GradientLayer.Binding.locations) }
	static var endPoint: GradientLayerName<Dynamic<CGPoint>> { return .name(GradientLayer.Binding.endPoint) }
	static var startPoint: GradientLayerName<Dynamic<CGPoint>> { return .name(GradientLayer.Binding.startPoint) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol GradientLayerConvertible: LayerConvertible {
	func caGradientLayer() -> GradientLayer.Instance
}
public extension GradientLayerConvertible {
	func caLayer() -> Layer.Instance { return caGradientLayer() }
}
extension CAGradientLayer: GradientLayerConvertible {
	public func caGradientLayer() -> GradientLayer.Instance { return self }
}
public extension GradientLayer {
	func caGradientLayer() -> GradientLayer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol GradientLayerBinding: LayerBinding {
	static func gradientLayerBinding(_ binding: GradientLayer.Binding) -> Self
	func asGradientLayerBinding() -> GradientLayer.Binding?
}
public extension GradientLayerBinding {
	static func layerBinding(_ binding: Layer.Binding) -> Self {
		return gradientLayerBinding(.inheritedBinding(binding))
	}
}
public extension GradientLayerBinding where Preparer.Inherited.Binding: GradientLayerBinding {
	func asGradientLayerBinding() -> GradientLayer.Binding? {
		return asInheritedBinding()?.asGradientLayerBinding()
	}
}
public extension GradientLayer.Binding {
	typealias Preparer = GradientLayer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asGradientLayerBinding() -> GradientLayer.Binding? { return self }
	static func gradientLayerBinding(_ binding: GradientLayer.Binding) -> GradientLayer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

// MARK: - Binder Part 1: Binder
public class Layer: Binder, LayerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Layer {
	enum Binding: LayerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case actions(Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>)
		case affineTransform(Dynamic<CGAffineTransform>)
		case anchorPoint(Dynamic<CGPoint>)
		case anchorPointZ(Dynamic<CGFloat>)
		case backgroundColor(Dynamic<CGColor>)
		case borderColor(Dynamic<CGColor>)
		case borderWidth(Dynamic<CGFloat>)
		case bounds(Dynamic<CGRect>)
		case contents(Dynamic<Any?>)
		case contentsCenter(Dynamic<CGRect>)
		case contentsGravity(Dynamic<CALayerContentsGravity>)
		case contentsRect(Dynamic<CGRect>)
		case contentsScale(Dynamic<CGFloat>)
		case cornerRadius(Dynamic<CGFloat>)
		case drawsAsynchronously(Dynamic<Bool>)
		case edgeAntialiasingMask(Dynamic<CAEdgeAntialiasingMask>)
		case frame(Dynamic<CGRect>)
		case isDoubleSided(Dynamic<Bool>)
		case isGeometryFlipped(Dynamic<Bool>)
		case isHidden(Dynamic<Bool>)
		case isOpaque(Dynamic<Bool>)
		case magnificationFilter(Dynamic<CALayerContentsFilter>)
		case mask(Dynamic<LayerConvertible?>)
		case masksToBounds(Dynamic<Bool>)
		case minificationFilter(Dynamic<CALayerContentsFilter>)
		case minificationFilterBias(Dynamic<Float>)
		case name(Dynamic<String>)
		case needsDisplayOnBoundsChange(Dynamic<Bool>)
		case opacity(Dynamic<Float>)
		case position(Dynamic<CGPoint>)
		case rasterizationScale(Dynamic<CGFloat>)
		case shadowColor(Dynamic<CGColor?>)
		case shadowOffset(Dynamic<CGSize>)
		case shadowOpacity(Dynamic<Float>)
		case shadowPath(Dynamic<CGPath?>)
		case shadowRadius(Dynamic<CGFloat>)
		case shouldRasterize(Dynamic<Bool>)
		case style(Dynamic<[AnyHashable: Any]>)
		case sublayers(Dynamic<[LayerConvertible]>)
		case sublayerTransform(Dynamic<CATransform3D>)
		case transform(Dynamic<CATransform3D>)
		case zPosition(Dynamic<CGFloat>)

		@available(macOS 10.13, *) @available(iOS, unavailable) case autoresizingMask(Dynamic<CAAutoresizingMask>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case backgroundFilters(Dynamic<[CIFilter]?>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case compositingFilter(Dynamic<CIFilter?>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case constraints(Dynamic<[CAConstraint]>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case filters(Dynamic<[CIFilter]?>)

		//	2. Signal bindings are performed on the object after construction.
		case addAnimation(Signal<AnimationForKey>)
		case needsDisplay(Signal<Void>)
		case needsDisplayInRect(Signal<CGRect>)
		case removeAllAnimations(Signal<Void>)
		case removeAnimationForKey(Signal<String>)
		case scrollRectToVisible(Signal<CGRect>)

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case display((CALayer) -> Void)
		case draw((CALayer, CGContext) -> Void)
		case layoutSublayers((CALayer) -> Void)
		case willDraw((CALayer) -> Void)
	}

	#if os(macOS)
		typealias CAAutoresizingMask = QuartzCore.CAAutoresizingMask
		typealias CIFilter = QuartzCore.CIFilter
		typealias CAConstraint = QuartzCore.CAConstraint
	#else
		typealias CAConstraint = ()
		typealias CAAutoresizingMask = ()
		typealias CIFilter = ()
	#endif
}

// MARK: - Binder Part 3: Preparer
public extension Layer {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = Layer.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = CALayer
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Layer.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .display(let x): delegate().addMultiHandler1(x, #selector(CALayerDelegate.display(_:)))
		case .draw(let x): delegate().addMultiHandler2(x, #selector(CALayerDelegate.draw(_:in:)))
		case .willDraw(let x): delegate().addMultiHandler1(x, #selector(CALayerDelegate.layerWillDraw(_:)))
		case .layoutSublayers(let x): delegate().addMultiHandler1(x, #selector(CALayerDelegate.layoutSublayers(of:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .actions(let x):
			return x.apply(instance, storage) { i, s, v in
				var actions = i.actions ?? [String: CAAction]()
				for (key, input) in v {
					if let i = input {
						actions[key] = s
						storage.layerActions[key] = i
					} else {
						actions[key] = NSNull()
						s.layerActions.removeValue(forKey: key)
					}
				}
				i.actions = actions
			}
		case .affineTransform(let x): return x.apply(instance) { i, v in i.setAffineTransform(v) }
		case .anchorPoint(let x): return x.apply(instance) { i, v in i.anchorPoint = v }
		case .anchorPointZ(let x): return x.apply(instance) { i, v in i.anchorPointZ = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .borderColor(let x): return x.apply(instance) { i, v in i.borderColor = v }
		case .borderWidth(let x): return x.apply(instance) { i, v in i.borderWidth = v }
		case .bounds(let x): return x.apply(instance) { i, v in i.bounds = v }
		case .contents(let x): return x.apply(instance) { i, v in i.contents = v }
		case .contentsCenter(let x): return x.apply(instance) { i, v in i.contentsCenter = v }
		case .contentsGravity(let x): return x.apply(instance) { i, v in i.contentsGravity = v }
		case .contentsRect(let x): return x.apply(instance) { i, v in i.contentsRect = v }
		case .contentsScale(let x): return x.apply(instance) { i, v in i.contentsScale = v }
		case .cornerRadius(let x): return x.apply(instance) { i, v in i.cornerRadius = v }
		case .drawsAsynchronously(let x): return x.apply(instance) { i, v in i.drawsAsynchronously = v }
		case .edgeAntialiasingMask(let x): return x.apply(instance) { i, v in i.edgeAntialiasingMask = v }
		case .frame(let x): return x.apply(instance) { i, v in i.frame = v }
		case .isDoubleSided(let x): return x.apply(instance) { i, v in i.isDoubleSided = v }
		case .isGeometryFlipped(let x): return x.apply(instance) { i, v in i.isGeometryFlipped = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .isOpaque(let x): return x.apply(instance) { i, v in i.isOpaque = v }
		case .magnificationFilter(let x): return x.apply(instance) { i, v in i.magnificationFilter = v }
		case .mask(let x): return x.apply(instance) { i, v in i.mask = v?.caLayer() }
		case .masksToBounds(let x): return x.apply(instance) { i, v in i.masksToBounds = v }
		case .minificationFilter(let x): return x.apply(instance) { i, v in i.minificationFilter = v }
		case .minificationFilterBias(let x): return x.apply(instance) { i, v in i.minificationFilterBias = v }
		case .name(let x): return x.apply(instance) { i,v in i.name = v }
		case .needsDisplayOnBoundsChange(let x): return x.apply(instance) { i, v in i.needsDisplayOnBoundsChange = v }
		case .opacity(let x): return x.apply(instance) { i, v in i.opacity = v }
		case .position(let x): return x.apply(instance) { i, v in i.position = v }
		case .rasterizationScale(let x): return x.apply(instance) { i, v in i.rasterizationScale = v }
		case .shadowColor(let x): return x.apply(instance) { i, v in i.shadowColor = v }
		case .shadowOffset(let x): return x.apply(instance) { i, v in i.shadowOffset = v }
		case .shadowOpacity(let x): return x.apply(instance) { i, v in i.shadowOpacity = v }
		case .shadowPath(let x): return x.apply(instance) { i, v in i.shadowPath = v }
		case .shadowRadius(let x): return x.apply(instance) { i, v in i.shadowRadius = v }
		case .shouldRasterize(let x): return x.apply(instance) { i, v in i.shouldRasterize = v }
		case .style(let x): return x.apply(instance) { i,v in i.style = v }
		case .sublayers(let x): return x.apply(instance) { i, v in i.sublayers = v.map { $0.caLayer() } }
		case .sublayerTransform(let x): return x.apply(instance) { i, v in i.sublayerTransform = v }
		case .transform(let x): return x.apply(instance) { i, v in i.transform = v }
		case .zPosition(let x): return x.apply(instance) { i, v in i.zPosition = v }
		
		case .autoresizingMask(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.autoresizingMask = v }
			#else
				return nil
			#endif
		case .backgroundFilters(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.backgroundFilters = v }
			#else
				return nil
			#endif
		case .compositingFilter(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.compositingFilter = v }
			#else
				return nil
			#endif
		case .constraints(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.constraints = v }
			#else
				return nil
			#endif
		case .filters(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.filters = v }
			#else
				return nil
			#endif

		//	2. Signal bindings are performed on the object after construction.
		case .addAnimation(let x): return x.apply(instance) { i, v in i.addAnimationForKey(v) }
		case .needsDisplay(let x): return x.apply(instance) { i, v in i.setNeedsDisplay() }
		case .needsDisplayInRect(let x): return x.apply(instance) { i, v in i.setNeedsDisplay(v) }
		case .removeAllAnimations(let x): return x.apply(instance) { i, v in i.removeAllAnimations() }
		case .removeAnimationForKey(let x): return x.apply(instance) { i, v in i.removeAnimation(forKey: v) }
		case .scrollRectToVisible(let x): return x.apply(instance) { i, v in i.scrollRectToVisible(v) }

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .display: return nil
		case .draw: return nil
		case .layoutSublayers: return nil
		case .willDraw: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Layer.Preparer {
	open class Storage: AssociatedBinderStorage, CAAction, CALayerDelegate {
		// LayerBinderStorage implementation
		open var layerActions = [String: SignalInput<[AnyHashable: Any]?>]()
		@objc open func run(forKey event: String, object anObject: Any, arguments dict: [AnyHashable: Any]?) {
			_ = layerActions[event]?.send(value: dict)
		}

		open func action(for layer: CALayer, forKey event: String) -> CAAction? {
			return layerActions[event] != nil ? self : nil
		}
	}
	
	open class Delegate: DynamicDelegate, CALayerDelegate {
		open func layerWillDraw(_ layer: CALayer) {
			multiHandler(layer)
		}
		
		open func display(_ layer: CALayer) {
			multiHandler(layer)
		}
		
		@objc(drawLayer:inContext:) open func draw(_ layer: CALayer, in ctx: CGContext) {
			multiHandler(layer, ctx)
		}
		
		open func layoutSublayers(of layer: CALayer) {
			multiHandler(layer)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: LayerBinding {
	public typealias LayerName<V> = BindingName<V, Layer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Layer.Binding) -> LayerName<V> {
		return LayerName<V>(source: source, downcast: Binding.layerBinding)
	}
}
public extension BindingName where Binding: LayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: LayerName<$2> { return .name(Layer.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var actions: LayerName<Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>> { return .name(Layer.Binding.actions) }
	static var affineTransform: LayerName<Dynamic<CGAffineTransform>> { return .name(Layer.Binding.affineTransform) }
	static var anchorPoint: LayerName<Dynamic<CGPoint>> { return .name(Layer.Binding.anchorPoint) }
	static var anchorPointZ: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.anchorPointZ) }
	static var backgroundColor: LayerName<Dynamic<CGColor>> { return .name(Layer.Binding.backgroundColor) }
	static var borderColor: LayerName<Dynamic<CGColor>> { return .name(Layer.Binding.borderColor) }
	static var borderWidth: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.borderWidth) }
	static var bounds: LayerName<Dynamic<CGRect>> { return .name(Layer.Binding.bounds) }
	static var contents: LayerName<Dynamic<Any?>> { return .name(Layer.Binding.contents) }
	static var contentsCenter: LayerName<Dynamic<CGRect>> { return .name(Layer.Binding.contentsCenter) }
	static var contentsGravity: LayerName<Dynamic<CALayerContentsGravity>> { return .name(Layer.Binding.contentsGravity) }
	static var contentsRect: LayerName<Dynamic<CGRect>> { return .name(Layer.Binding.contentsRect) }
	static var contentsScale: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.contentsScale) }
	static var cornerRadius: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.cornerRadius) }
	static var drawsAsynchronously: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.drawsAsynchronously) }
	static var edgeAntialiasingMask: LayerName<Dynamic<CAEdgeAntialiasingMask>> { return .name(Layer.Binding.edgeAntialiasingMask) }
	static var frame: LayerName<Dynamic<CGRect>> { return .name(Layer.Binding.frame) }
	static var isDoubleSided: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.isDoubleSided) }
	static var isGeometryFlipped: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.isGeometryFlipped) }
	static var isHidden: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.isHidden) }
	static var isOpaque: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.isOpaque) }
	static var magnificationFilter: LayerName<Dynamic<CALayerContentsFilter>> { return .name(Layer.Binding.magnificationFilter) }
	static var mask: LayerName<Dynamic<LayerConvertible?>> { return .name(Layer.Binding.mask) }
	static var masksToBounds: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.masksToBounds) }
	static var minificationFilter: LayerName<Dynamic<CALayerContentsFilter>> { return .name(Layer.Binding.minificationFilter) }
	static var minificationFilterBias: LayerName<Dynamic<Float>> { return .name(Layer.Binding.minificationFilterBias) }
	static var name: LayerName<Dynamic<String>> { return .name(Layer.Binding.name) }
	static var needsDisplayOnBoundsChange: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.needsDisplayOnBoundsChange) }
	static var opacity: LayerName<Dynamic<Float>> { return .name(Layer.Binding.opacity) }
	static var position: LayerName<Dynamic<CGPoint>> { return .name(Layer.Binding.position) }
	static var rasterizationScale: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.rasterizationScale) }
	static var shadowColor: LayerName<Dynamic<CGColor?>> { return .name(Layer.Binding.shadowColor) }
	static var shadowOffset: LayerName<Dynamic<CGSize>> { return .name(Layer.Binding.shadowOffset) }
	static var shadowOpacity: LayerName<Dynamic<Float>> { return .name(Layer.Binding.shadowOpacity) }
	static var shadowPath: LayerName<Dynamic<CGPath?>> { return .name(Layer.Binding.shadowPath) }
	static var shadowRadius: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.shadowRadius) }
	static var shouldRasterize: LayerName<Dynamic<Bool>> { return .name(Layer.Binding.shouldRasterize) }
	static var style: LayerName<Dynamic<[AnyHashable: Any]>> { return .name(Layer.Binding.style) }
	static var sublayers: LayerName<Dynamic<[LayerConvertible]>> { return .name(Layer.Binding.sublayers) }
	static var sublayerTransform: LayerName<Dynamic<CATransform3D>> { return .name(Layer.Binding.sublayerTransform) }
	static var transform: LayerName<Dynamic<CATransform3D>> { return .name(Layer.Binding.transform) }
	static var zPosition: LayerName<Dynamic<CGFloat>> { return .name(Layer.Binding.zPosition) }
	
	@available(macOS 10.13, *) @available(iOS, unavailable) static var autoresizingMask: LayerName<Dynamic<Layer.CAAutoresizingMask>> { return .name(Layer.Binding.autoresizingMask) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var backgroundFilters: LayerName<Dynamic<[Layer.CIFilter]?>> { return .name(Layer.Binding.backgroundFilters) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var compositingFilter: LayerName<Dynamic<Layer.CIFilter?>> { return .name(Layer.Binding.compositingFilter) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var constraints: LayerName<Dynamic<[Layer.CAConstraint]>> { return .name(Layer.Binding.constraints) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var filters: LayerName<Dynamic<[Layer.CIFilter]?>> { return .name(Layer.Binding.filters) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var addAnimation: LayerName<Signal<AnimationForKey>> { return .name(Layer.Binding.addAnimation) }
	static var needsDisplay: LayerName<Signal<Void>> { return .name(Layer.Binding.needsDisplay) }
	static var needsDisplayInRect: LayerName<Signal<CGRect>> { return .name(Layer.Binding.needsDisplayInRect) }
	static var removeAllAnimations: LayerName<Signal<Void>> { return .name(Layer.Binding.removeAllAnimations) }
	static var removeAnimationForKey: LayerName<Signal<String>> { return .name(Layer.Binding.removeAnimationForKey) }
	static var scrollRectToVisible: LayerName<Signal<CGRect>> { return .name(Layer.Binding.scrollRectToVisible) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var display: LayerName<(CALayer) -> Void> { return .name(Layer.Binding.display) }
	static var draw: LayerName<(CALayer, CGContext) -> Void> { return .name(Layer.Binding.draw) }
	static var layoutSublayers: LayerName<(CALayer) -> Void> { return .name(Layer.Binding.layoutSublayers) }
	static var willDraw: LayerName<(CALayer) -> Void> { return .name(Layer.Binding.willDraw) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol LayerConvertible {
	func caLayer() -> Layer.Instance
}
extension CALayer: LayerConvertible, HasDelegate, DefaultConstructable {
	public func caLayer() -> Layer.Instance { return self }
}
public extension Layer {
	 func caLayer() -> Layer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol LayerBinding: BinderBaseBinding {
	static func layerBinding(_ binding: Layer.Binding) -> Self
	func asLayerBinding() -> Layer.Binding?
}
public extension LayerBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return layerBinding(.inheritedBinding(binding))
	}
}
public extension LayerBinding where Preparer.Inherited.Binding: LayerBinding {
	func asLayerBinding() -> Layer.Binding? {
		return asInheritedBinding()?.asLayerBinding()
	}
}
public extension Layer.Binding {
	typealias Preparer = Layer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asLayerBinding() -> Layer.Binding? { return self }
	static func layerBinding(_ binding: Layer.Binding) -> Layer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public struct AnimationForKey {
	public let animation: CAAnimation
	public let key: String?
	
	public init(animation: CAAnimation, forKey: String? = nil) {
		self.animation = animation
		self.key = forKey
	}
	
	public static var fade: AnimationForKey {
		let t = CATransition()
		t.type = CATransitionType.fade
		
		// NOTE: fade animations are always applied under key kCATransition so it's pointless trying to set a key
		return AnimationForKey(animation: t, forKey: nil)
	}
	
	public enum Direction {
		case left, right, top, bottom
		func transition(ofType: CATransitionType, forKey: String? = nil) -> AnimationForKey {
			let t = CATransition()
			t.type = ofType
			switch self {
			case .left: t.subtype = CATransitionSubtype.fromLeft
			case .right: t.subtype = CATransitionSubtype.fromRight
			case .top: t.subtype = CATransitionSubtype.fromTop
			case .bottom: t.subtype = CATransitionSubtype.fromBottom
			}
			return AnimationForKey(animation: t, forKey: forKey)
		}
	}
	
	public static func moveIn(from: Direction, forKey: String? = nil) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.moveIn, forKey: forKey)
	}
	
	public static func push(from: Direction, forKey: String? = nil) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.push, forKey: forKey)
	}
	
	public static func reveal(from: Direction, forKey: String? = nil) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.reveal, forKey: forKey)
	}
}

public extension CALayer {
	func addAnimationForKey(_ animationForKey: AnimationForKey) {
		add(animationForKey.animation, forKey: animationForKey.key)
	}
}

// MARK: - Binder Part 1: Binder
public class ShapeLayer: Binder, ShapeLayerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ShapeLayer {
	enum Binding: ShapeLayerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case fillColor(Dynamic<CGColor?>)
		case fillRule(Dynamic<CAShapeLayerFillRule>)
		case lineCap(Dynamic<CAShapeLayerLineCap>)
		case lineDashPattern(Dynamic<[NSNumber]?>)
		case lineDashPhase(Dynamic<CGFloat>)
		case lineJoin(Dynamic<CAShapeLayerLineJoin>)
		case lineWidth(Dynamic<CGFloat>)
		case miterLimit(Dynamic<CGFloat>)
		case path(Dynamic<CGPath>)
		case strokeColor(Dynamic<CGColor?>)
		case strokeEnd(Dynamic<CGFloat>)
		case strokeStart(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension ShapeLayer {
	struct Preparer: BinderDelegateDerived {
		public typealias Binding = ShapeLayer.Binding
		public typealias Delegate = Inherited.Delegate
		public typealias Inherited = Layer.Preparer
		public typealias Instance = CAShapeLayer
		
		public var inherited = Inherited()
		public init(delegateClass: Delegate.Type) {
			inherited = Inherited(delegateClass: delegateClass)
		}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ShapeLayer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .fillColor(let x): return x.apply(instance) { i, v in i.fillColor = v }
		case .fillRule(let x): return x.apply(instance) { i, v in i.fillRule = v }
		case .lineCap(let x): return x.apply(instance) { i, v in i.lineCap = v }
		case .lineDashPattern(let x): return x.apply(instance) { i, v in i.lineDashPattern = v }
		case .lineDashPhase(let x): return x.apply(instance) { i, v in i.lineDashPhase = v }
		case .lineJoin(let x): return x.apply(instance) { i, v in i.lineJoin = v }
		case .lineWidth(let x): return x.apply(instance) { i, v in i.lineWidth = v }
		case .miterLimit(let x): return x.apply(instance) { i, v in i.miterLimit = v }
		case .path(let x): return x.apply(instance) { i, v in i.path = v }
		case .strokeColor(let x): return x.apply(instance) { i, v in i.strokeColor = v }
		case .strokeEnd(let x): return x.apply(instance) { i, v in i.strokeEnd = v }
		case .strokeStart(let x): return x.apply(instance) { i, v in i.strokeStart = v }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ShapeLayer.Preparer {
	public typealias Storage = Layer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ShapeLayerBinding {
	public typealias ShapeLayerName<V> = BindingName<V, ShapeLayer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ShapeLayer.Binding) -> ShapeLayerName<V> {
		return ShapeLayerName<V>(source: source, downcast: Binding.shapeLayerBinding)
	}
}
public extension BindingName where Binding: ShapeLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ShapeLayerName<$2> { return .name(ShapeLayer.Binding.$1) }
	static var fillColor: ShapeLayerName<Dynamic<CGColor?>> { return .name(ShapeLayer.Binding.fillColor) }
	static var fillRule: ShapeLayerName<Dynamic<CAShapeLayerFillRule>> { return .name(ShapeLayer.Binding.fillRule) }
	static var lineCap: ShapeLayerName<Dynamic<CAShapeLayerLineCap>> { return .name(ShapeLayer.Binding.lineCap) }
	static var lineDashPattern: ShapeLayerName<Dynamic<[NSNumber]?>> { return .name(ShapeLayer.Binding.lineDashPattern) }
	static var lineDashPhase: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.lineDashPhase) }
	static var lineJoin: ShapeLayerName<Dynamic<CAShapeLayerLineJoin>> { return .name(ShapeLayer.Binding.lineJoin) }
	static var lineWidth: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.lineWidth) }
	static var miterLimit: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.miterLimit) }
	static var path: ShapeLayerName<Dynamic<CGPath>> { return .name(ShapeLayer.Binding.path) }
	static var strokeColor: ShapeLayerName<Dynamic<CGColor?>> { return .name(ShapeLayer.Binding.strokeColor) }
	static var strokeEnd: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.strokeEnd) }
	static var strokeStart: ShapeLayerName<Dynamic<CGFloat>> { return .name(ShapeLayer.Binding.strokeStart) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ShapeLayerConvertible: LayerConvertible {
	func caShapeLayer() -> ShapeLayer.Instance
}
extension ShapeLayerConvertible {
	public func caLayer() -> Layer.Instance { return caShapeLayer() }
}
extension CAShapeLayer: ShapeLayerConvertible {
	public func caShapeLayer() -> ShapeLayer.Instance { return self }
}
public extension ShapeLayer {
	func caShapeLayer() -> ShapeLayer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ShapeLayerBinding: LayerBinding {
	static func shapeLayerBinding(_ binding: ShapeLayer.Binding) -> Self
	func asShapeLayerBinding() -> ShapeLayer.Binding?
}
public extension ShapeLayerBinding {
	static func layerBinding(_ binding: Layer.Binding) -> Self {
		return shapeLayerBinding(.inheritedBinding(binding))
	}
}
public extension ShapeLayerBinding where Preparer.Inherited.Binding: ShapeLayerBinding {
	func asShapeLayerBinding() -> ShapeLayer.Binding? {
		return asInheritedBinding()?.asShapeLayerBinding()
	}
}
public extension ShapeLayer.Binding {
	typealias Preparer = ShapeLayer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asShapeLayerBinding() -> ShapeLayer.Binding? { return self }
	static func shapeLayerBinding(_ binding: ShapeLayer.Binding) -> ShapeLayer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

// MARK: - Binder Part 1: Binder
public class StackView: Binder, StackViewConvertible {
	#if os(macOS)
		public typealias NSUIView = NSView
		public typealias NSUIStackView = NSStackView
		public typealias NSUIStackViewDistribution = NSStackView.Distribution
		public typealias NSUIStackViewAlignment = NSLayoutConstraint.Attribute
		public typealias NSUIUserInterfaceLayoutOrientation = NSUserInterfaceLayoutOrientation
		public typealias NSUILayoutPriority = NSLayoutConstraint.Priority
	#else
		public typealias NSUIView = UIView
		public typealias NSUIStackView = UIStackView
		public typealias NSUIStackViewDistribution = UIStackView.Distribution
		public typealias NSUIStackViewAlignment = UIStackView.Alignment
		public typealias NSUIUserInterfaceLayoutOrientation = NSLayoutConstraint.Axis
		public typealias NSUILayoutPriority = UILayoutPriority
	#endif

	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension StackView {
	enum Binding: StackViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case alignment(Dynamic<NSUIStackViewAlignment>)
		case arrangedSubviews(Dynamic<[ViewConvertible]>)
		case axis(Dynamic<NSUIUserInterfaceLayoutOrientation>)
		case distribution(Dynamic<NSUIStackViewDistribution>)
		case spacing(Dynamic<CGFloat>)
		
		@available(macOS 10.13, *) @available(iOS, unavailable) case edgeInsets(Dynamic<NSUIEdgeInsets>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case horizontalClippingResistance(Dynamic<NSUILayoutPriority>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case horizontalHuggingPriority(Dynamic<NSUILayoutPriority>)
		@available(macOS, unavailable) @available(iOS 11, *) case isLayoutMarginsRelativeArrangement(Dynamic<Bool>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case verticalClippingResistance(Dynamic<NSUILayoutPriority>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case verticalHuggingPriority(Dynamic<NSUILayoutPriority>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	#if os(macOS)
		typealias NSUIEdgeInsets = NSEdgeInsets
	#else
		typealias NSUIEdgeInsets = UIEdgeInsets
	#endif
}

// MARK: - Binder Part 3: Preparer
public extension StackView {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = StackView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSUIStackView
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension StackView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .alignment(let x): return x.apply(instance) { i, v in i.alignment = v }
		case .axis(let x):
			return x.apply(instance) { i, v in
				#if os(macOS)
					i.orientation = v
				#else
					i.axis = v
				#endif
			}
		case .arrangedSubviews(let x):
			return x.apply(instance) { i, v in
				i.arrangedSubviews.forEach { $0.removeFromSuperview() }
				#if os(macOS)
					v.forEach { i.addArrangedSubview($0.nsView()) }
				#else
					v.forEach { i.addArrangedSubview($0.uiView()) }
				#endif
			}
		case .distribution(let x): return x.apply(instance) { i, v in i.distribution = v }
		case .spacing(let x): return x.apply(instance) { i, v in i.spacing = v }

		case .edgeInsets(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.edgeInsets = v }
			#else
				return nil
			#endif
		case .horizontalClippingResistance(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setClippingResistancePriority(v, for: .horizontal) }
			#else
				return nil
			#endif
		case .horizontalHuggingPriority(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setHuggingPriority(v, for: .horizontal) }
			#else
				return nil
			#endif
		case .isLayoutMarginsRelativeArrangement(let x):
			#if os(macOS)
				return nil
			#else
				return x.apply(instance) { i, v in i.isLayoutMarginsRelativeArrangement = v }
			#endif
		case .verticalClippingResistance(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setClippingResistancePriority(v, for: .vertical) }
			#else
				return nil
			#endif
		case .verticalHuggingPriority(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setHuggingPriority(v, for: .vertical) }
			#else
				return nil
			#endif
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension StackView.Preparer {
	#if os(macOS)
		open class Storage: View.Preparer.Storage {
			open var gravity: NSStackView.Gravity = .center
		}
	#else
		public typealias Storage = View.Preparer.Storage
	#endif
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: StackViewBinding {
	public typealias StackViewName<V> = BindingName<V, StackView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> StackView.Binding) -> StackViewName<V> {
		return StackViewName<V>(source: source, downcast: Binding.stackViewBinding)
	}
}
public extension BindingName where Binding: StackViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: StackViewName<$2> { return .name(StackView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var alignment: StackViewName<Dynamic<StackView.NSUIStackViewAlignment>> { return .name(StackView.Binding.alignment) }
	static var arrangedSubviews: StackViewName<Dynamic<[ViewConvertible]>> { return .name(StackView.Binding.arrangedSubviews) }
	static var axis: StackViewName<Dynamic<StackView.NSUIUserInterfaceLayoutOrientation>> { return .name(StackView.Binding.axis) }
	static var distribution: StackViewName<Dynamic<StackView.NSUIStackViewDistribution>> { return .name(StackView.Binding.distribution) }
	static var spacing: StackViewName<Dynamic<CGFloat>> { return .name(StackView.Binding.spacing) }
	
	@available(macOS 10.13, *) @available(iOS, unavailable) static var edgeInsets: StackViewName<Dynamic<StackView.NSUIEdgeInsets>> { return .name(StackView.Binding.edgeInsets) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var horizontalClippingResistance: StackViewName<Dynamic<StackView.NSUILayoutPriority>> { return .name(StackView.Binding.horizontalClippingResistance) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var horizontalHuggingPriority: StackViewName<Dynamic<StackView.NSUILayoutPriority>> { return .name(StackView.Binding.horizontalHuggingPriority) }
	@available(macOS, unavailable) @available(iOS 11, *) static var isLayoutMarginsRelativeArrangement: StackViewName<Dynamic<Bool>> { return .name(StackView.Binding.isLayoutMarginsRelativeArrangement) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var verticalClippingResistance: StackViewName<Dynamic<StackView.NSUILayoutPriority>> { return .name(StackView.Binding.verticalClippingResistance) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var verticalHuggingPriority: StackViewName<Dynamic<StackView.NSUILayoutPriority>> { return .name(StackView.Binding.verticalHuggingPriority) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
#if os(macOS)
	public protocol StackViewConvertible: ViewConvertible {
		func nsStackView() -> StackView.Instance
	}
	public extension StackViewConvertible {
		func nsView() -> View.Instance { return nsStackView() }
	}
	extension NSStackView: StackViewConvertible {
		public func nsStackView() -> StackView.Instance { return self }
	}
	public extension StackView {
		func nsStackView() -> StackView.Instance { return instance() }
	}
#else
	public protocol StackViewConvertible: ViewConvertible {
		func uiStackView() -> StackView.Instance
	}
	public extension StackViewConvertible {
		func uiView() -> View.Instance { return uiStackView() }
	}
	extension UIStackView: StackViewConvertible {
		public func uiStackView() -> StackView.Instance { return self }
	}
	public extension StackView {
		func uiStackView() -> StackView.Instance { return instance() }
	}
#endif

// MARK: - Binder Part 8: Downcast protocols
public protocol StackViewBinding: ViewBinding {
	static func stackViewBinding(_ binding: StackView.Binding) -> Self
	func asStackViewBinding() -> StackView.Binding?
}
public extension StackViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return stackViewBinding(.inheritedBinding(binding))
	}
}
public extension StackViewBinding where Preparer.Inherited.Binding: StackViewBinding {
	func asStackViewBinding() -> StackView.Binding? {
		return asInheritedBinding()?.asStackViewBinding()
	}
}
public extension StackView.Binding {
	typealias Preparer = StackView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asStackViewBinding() -> StackView.Binding? { return self }
	static func stackViewBinding(_ binding: StackView.Binding) -> StackView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

import WebKit

// MARK: - Binder Part 1: Binder
public class WebView: Binder, WebViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	#if os(macOS)
		public static func scrollEmbedded(type: WKWebView.Type = WKWebView.self, _ bindings: Binding...) -> ScrollView {
			return ScrollView(
				.borderType -- .noBorder,
				.hasVerticalScroller -- true,
				.hasHorizontalScroller -- true,
				.autohidesScrollers -- true,
				.contentView -- ClipView(
					.documentView -- WebView(type: type, bindings: bindings)
				)
			)
		}
	#endif
}

// On macOS, `WebView` refers to WebKit.WebView until 10.14. This typealias can be used on macOS (or cross-platform scenarios) instead of `WebKit` to disambiguate, until the deployment target is 10.14 or higher.
public typealias WebKitView = WebView

// MARK: - Binder Part 2: Binding
public extension WebView {
	enum Binding: WebViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case allowsAirPlayForMediaPlayback(Constant<Bool>)
		case allowsInlineMediaPlayback(Constant<Bool>)
		case allowsPictureInPictureForMediaPlayback(Constant<Bool>)
		case applicationNameForUserAgent(Constant<String?>)
		case ignoresViewportScaleLimits(Constant<Bool>)
		case javaScriptCanOpenWindowsAutomatically(Constant<Bool>)
		case javaScriptEnabled(Constant<Bool>)
		case mediaTypesRequiringUserActionForPlayback(Constant<WKAudiovisualMediaTypes>)
		case minimumFontSize(Constant<CGFloat>)
		case processPool(Constant<WKProcessPool>)
		case suppressesIncrementalRendering(Constant<Bool>)
		case urlSchemeHandlers(Constant<[String: WKURLSchemeHandler]>)
		case userContentController(Constant<WKUserContentController>)

		@available(macOS 10.10, *) @available(iOS, unavailable) case javaEnabled(Constant<Bool>)
		@available(macOS 10.10, *) @available(iOS, unavailable) case plugInsEnabled(Constant<Bool>)
		@available(macOS 10.10, *) @available(iOS, unavailable) case tabFocusesLinks(Constant<Bool>)
		@available(macOS 10.12, *) @available(iOS, unavailable) case userInterfaceDirectionPolicy(Constant<WKUserInterfaceDirectionPolicy>)
		@available(macOS, unavailable) @available(iOS 9, *) case allowsPictureInPictureMediaPlayback(Constant<Bool>)
		@available(macOS, unavailable) @available(iOS 11, *) case scrollView(Constant<ScrollView>)
		@available(macOS, unavailable) @available(iOS 11, *) case dataDetectorTypes(Constant<WKDataDetectorTypes>)
		@available(macOS, unavailable) @available(iOS 11, *) case selectionGranularity(Constant<WKSelectionGranularity>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsBackForwardNavigationGestures(Dynamic<Bool>)
		case allowsLinkPreview(Dynamic<Bool>)
		case customUserAgent(Dynamic<String?>)
		
		@available(macOS 10.13, *) @available(iOS, unavailable) case allowsMagnification(Dynamic<Bool>)
		@available(macOS 10.13, *) @available(iOS, unavailable) case magnification(Dynamic<(factor: CGFloat, centeredAt: CGPoint)>)
		
		//	2. Signal bindings are performed on the object after construction.
		case evaluateJavaScript(Signal<Callback<String, (Any?, Error?)>>)
		case goBack(Signal<Callback<Void, WKNavigation?>>)
		case goForward(Signal<Callback<Void, WKNavigation?>>)
		case goTo(Signal<Callback<WKBackForwardListItem, WKNavigation?>>)
		case load(Signal<Callback<URLRequest, WKNavigation?>>)
		case loadData(Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>)
		case loadFile(Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>)
		case loadHTMLString(Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>)
		case reload(Signal<Callback<Void, WKNavigation?>>)
		case reloadFromOrigin(Signal<Callback<Void, WKNavigation?>>)
		case stopLoading(Signal<Void>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case createWebView((_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?)
		case didClose((WKWebView) -> Void)
		case didCommit((WKWebView, WKNavigation) -> Void)
		case didStartProvisionalNavigation((WKWebView, WKNavigation) -> Void)
		case didReceiveServerRedirectForProvisionalNavigation((WKWebView, WKNavigation) -> Void)
		case didFail((WKWebView, WKNavigation, Error) -> Void)
		case didFailProvisionalNavigation((WKWebView, WKNavigation, Error) -> Void)
		case didFinish((WKWebView, WKNavigation) -> Void)
		case contentProcessDidTerminate((WKWebView) -> Void)
		case decideActionPolicy((WKWebView, WKNavigationAction, (WKNavigationActionPolicy) -> Void) -> Void)
		case decideResponsePolicy((WKWebView, WKNavigationResponse, (WKNavigationActionPolicy) -> Void) -> Void)
		case didReceiveAuthenticationChallenge((WKWebView, URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) -> Void)
		case runJavaScriptAlertPanel((WKWebView, String, WKFrameInfo, () -> Void) -> Void)
		case runJavaScriptConfirmPanel((WKWebView, String, WKFrameInfo, (Bool) -> Void) -> Void)
		case runJavaScriptTextInputPanel((WKWebView, String, String?, WKFrameInfo, (String?) -> Void) -> Void)
		
		@available(macOS, unavailable) @available(iOS 10.0, *) case commitPreviewingViewController((_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void)
		@available(macOS, unavailable) @available(iOS 10.0, *) case previewingViewController((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?)
		@available(macOS 10.12, *) @available(iOS, unavailable) case runOpenPanel((WKWebView, WKOpenPanelParameters, WKFrameInfo, ([URL]?) -> Void) -> Void)
		@available(macOS, unavailable) @available(iOS 10.0, *) case shouldPreviewElement((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool)
	}

	#if os(macOS)
		typealias UIViewController = ()
		typealias WKDataDetectorTypes = ()
		typealias WKPreviewElementInfo = ()
		typealias WKPreviewActionItem = ()
		typealias WKOpenPanelParameters = WebKit.WKOpenPanelParameters
		typealias WKSelectionGranularity = ()
		typealias WKUserInterfaceDirectionPolicy = WebKit.WKUserInterfaceDirectionPolicy
	#else
		typealias UIViewController = UIKit.UIViewController
		typealias WKDataDetectorTypes = WebKit.WKDataDetectorTypes
		typealias WKOpenPanelParameters = ()
		typealias WKPreviewElementInfo = WebKit.WKPreviewElementInfo
		typealias WKPreviewActionItem = WebKit.WKPreviewActionItem
		typealias WKSelectionGranularity = WebKit.WKSelectionGranularity
		typealias WKUserInterfaceDirectionPolicy = ()
	#endif
}

// MARK: - Binder Part 3: Preparer
public extension WebView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = WebView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = WKWebView
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		mutating func webConfiguration() -> WKWebViewConfiguration {
			if let pwc = possibleWebConfiguration {
				return pwc
			}
			let newConfiguration = WKWebViewConfiguration()
			possibleWebConfiguration = newConfiguration
			return newConfiguration
		}
		var possibleWebConfiguration: WKWebViewConfiguration?
		
		mutating func webPreferences() -> WKPreferences {
			return webConfiguration().preferences
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension WebView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .allowsAirPlayForMediaPlayback(let x): webConfiguration().allowsAirPlayForMediaPlayback = x.value
		case .allowsInlineMediaPlayback(let x):
			#if os(iOS)
				webConfiguration().allowsInlineMediaPlayback = x.value
			#endif
		case .allowsPictureInPictureMediaPlayback(let x):
			#if os(iOS)
				webConfiguration().allowsPictureInPictureMediaPlayback = x.value
			#endif
		case .applicationNameForUserAgent(let x): webConfiguration().applicationNameForUserAgent = x.value
		case .dataDetectorTypes(let x): 
			#if os(iOS)
				webConfiguration().dataDetectorTypes = x.value
			#endif
		case .ignoresViewportScaleLimits(let x):
			#if os(iOS)
				webConfiguration().ignoresViewportScaleLimits = x.value
			#endif
		case .javaEnabled(let x):
			#if os(macOS)
				webPreferences().javaEnabled = x.value
			#endif
		case .javaScriptCanOpenWindowsAutomatically(let x): webPreferences().javaScriptCanOpenWindowsAutomatically = x.value
		case .javaScriptEnabled(let x): webPreferences().javaScriptEnabled = x.value
		case .mediaTypesRequiringUserActionForPlayback(let x): webConfiguration().mediaTypesRequiringUserActionForPlayback = x.value
		case .minimumFontSize(let x): webPreferences().minimumFontSize = x.value
		case .plugInsEnabled(let x):
			#if os(macOS)
				webPreferences().plugInsEnabled = x.value
			#endif
		case .processPool(let x): webConfiguration().processPool = x.value
		case .selectionGranularity(let x): 
			#if os(iOS)
				webConfiguration().selectionGranularity = x.value
			#endif
		case .suppressesIncrementalRendering(let x): webConfiguration().suppressesIncrementalRendering = x.value
		case .tabFocusesLinks(let x):
			#if os(macOS)
				webPreferences().tabFocusesLinks = x.value
			#endif
		case .urlSchemeHandlers(let x):
			for (key, value) in x.value {
				webConfiguration().setURLSchemeHandler(value, forURLScheme: key)
			}
		case .userContentController(let x): webConfiguration().userContentController = x.value

		case .didClose(let x): delegate().addMultiHandler1(x, #selector(WKUIDelegate.webViewDidClose(_:)))
		case .didCommit(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didCommit:)))
		case .didStartProvisionalNavigation(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didStartProvisionalNavigation:)))
		case .didReceiveServerRedirectForProvisionalNavigation(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didReceiveServerRedirectForProvisionalNavigation:)))
		case .didFail(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:didFail:withError:)))
		case .didFailProvisionalNavigation(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:didFailProvisionalNavigation:withError:)))
		case .didFinish(let x): delegate().addMultiHandler2(x, #selector(WKNavigationDelegate.webView(_:didFinish:)))
		case .contentProcessDidTerminate(let x): delegate().addMultiHandler1(x, #selector(WKNavigationDelegate.webViewWebContentProcessDidTerminate(_:)))
		case .decideActionPolicy(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -> (WKWebView,WKNavigationAction, @escaping (WKNavigationActionPolicy) -> Void) -> Void)?))
		case .decideResponsePolicy(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -> (WKWebView, WKNavigationResponse, @escaping (WKNavigationResponsePolicy) -> Void) -> Void)?))
		case .didReceiveAuthenticationChallenge(let x): delegate().addMultiHandler3(x, #selector(WKNavigationDelegate.webView(_:didReceive:completionHandler:)))
		case .runJavaScriptAlertPanel(let x): delegate().addMultiHandler4(x, #selector(WKUIDelegate.webView(_:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:)))
		case .runJavaScriptConfirmPanel(let x): delegate().addMultiHandler4(x, #selector(WKUIDelegate.webView(_:runJavaScriptConfirmPanelWithMessage:initiatedByFrame:completionHandler:)))
		case .runJavaScriptTextInputPanel(let x): delegate().addMultiHandler5(x, #selector(WKUIDelegate.webView(_:runJavaScriptTextInputPanelWithPrompt:defaultText:initiatedByFrame:completionHandler:)))
		case .createWebView(let x): delegate().addSingleHandler4(x, #selector(WKUIDelegate.webView(_:createWebViewWith:for:windowFeatures:)))
		case .runOpenPanel(let x):
			#if os(macOS)
				delegate().addMultiHandler4(x, #selector(WKUIDelegate.webView(_:runOpenPanelWith:initiatedByFrame:completionHandler:)))
			#endif
		case .shouldPreviewElement(let x):
			#if os(iOS)
				delegate().addSingleHandler2(x, #selector(WKUIDelegate.webView(_:shouldPreviewElement:)))
			#endif
		case .previewingViewController(let x):
			#if os(iOS)
				delegate().addSingleHandler3(x, #selector(WKUIDelegate.webView(_:previewingViewControllerForElement:defaultActions:)))
			#endif
		case .commitPreviewingViewController(let x):
			#if os(iOS)
				delegate().addMultiHandler2(x, #selector(WKUIDelegate.webView(_:commitPreviewingViewController:)))
			#endif
		default: break
		}
	}
	
	func constructInstance(type: WKWebView.Type, parameters: ()) -> WKWebView {
		if let configuration = possibleWebConfiguration {
			return type.init(frame: .zero, configuration: configuration)
		} else {
			return type.init(frame: .zero)
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		if delegateIsRequired {
			precondition(instance.uiDelegate == nil, "Conflicting delegate applied to instance")
			instance.uiDelegate = storage
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .allowsAirPlayForMediaPlayback: return nil
		case .allowsInlineMediaPlayback: return nil
		case .allowsPictureInPictureForMediaPlayback: return nil
		case .applicationNameForUserAgent: return nil
		case .dataDetectorTypes: return nil
		case .ignoresViewportScaleLimits: return nil
		case .javaScriptCanOpenWindowsAutomatically: return nil
		case .javaScriptEnabled: return nil
		case .mediaTypesRequiringUserActionForPlayback: return nil
		case .minimumFontSize: return nil
		case .processPool: return nil
		case .selectionGranularity: return nil
		case .suppressesIncrementalRendering: return nil
		case .urlSchemeHandlers: return nil
		case .userContentController: return nil
		case .javaEnabled: return nil
		case .plugInsEnabled: return nil
		case .tabFocusesLinks: return nil
		case .userInterfaceDirectionPolicy: return nil
		case .allowsPictureInPictureMediaPlayback: return nil
		
		case .scrollView(let x):
			#if os(macOS)
				return nil
			#else
				x.value.apply(to: instance.scrollView)
				return nil
			#endif
			
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .allowsBackForwardNavigationGestures(let x): return x.apply(instance) { i, v in i.allowsBackForwardNavigationGestures = v }
		
		case .allowsLinkPreview(let x):
			return x.apply(instance) { i, v in
				i.allowsLinkPreview = v
			}
		case .allowsMagnification(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.allowsMagnification = v }
			#else
				return nil
			#endif
		case .customUserAgent(let x):
			return x.apply(instance) { i, v in
				i.customUserAgent = v
			}
		case .magnification(let x):
			#if os(macOS)
				return x.apply(instance) { i, v in i.setMagnification(v.factor, centeredAt: v.centeredAt) }
			#else
				return nil
			#endif
		
		//	2. Signal bindings are performed on the object after construction.
		case .evaluateJavaScript(let x): return x.apply(instance) { i, v in i.evaluateJavaScript(v.value) { (output, error) in v.callback.send(value: (output, error)) } }
		case .goBack(let x): return x.apply(instance) { i, v in v.callback.send(value: i.goBack()) }
		case .goForward(let x):return x.apply(instance) { i, v in v.callback.send(value: i.goForward()) }
		case .goTo(let x): return x.apply(instance) { i, v in v.callback.send(value: i.go(to: v.value)) }
		case .load(let x): return x.apply(instance) { i, v in v.callback.send(value: i.load(v.value)) }
		case .loadHTMLString(let x): return x.apply(instance) { i, v in v.callback.send(value: i.loadHTMLString(v.value.string, baseURL: v.value.baseURL)) }
		case .reload(let x): return x.apply(instance) { i, v in v.callback.send(value: i.reload()) }
		case .reloadFromOrigin(let x): return x.apply(instance) { i, v in v.callback.send(value: i.reloadFromOrigin()) }
		case .stopLoading(let x): return x.apply(instance) { i, v in i.stopLoading() }

		case .loadData(let x): return x.apply(instance) { i, v in v.callback.send(value: i.load(v.value.data, mimeType: v.value.mimeType, characterEncodingName: v.value.characterEncodingName, baseURL: v.value.baseURL)) }
		case .loadFile(let x): return x.apply(instance) { i, v in v.callback.send(value: i.loadFileURL(v.value.url, allowingReadAccessTo: v.value.allowingReadAccessTo)) }
			
		//	3. Action bindings are triggered by the object after construction.
		case .contentProcessDidTerminate: return nil
		case .decideActionPolicy: return nil
		case .decideResponsePolicy: return nil
		case .didCommit: return nil
		case .didFail: return nil
		case .didFailProvisionalNavigation: return nil
		case .didFinish: return nil
		case .didReceiveAuthenticationChallenge: return nil
		case .didReceiveServerRedirectForProvisionalNavigation: return nil
		case .didStartProvisionalNavigation: return nil
		case .runJavaScriptAlertPanel: return nil
		case .runJavaScriptConfirmPanel: return nil
		case .runJavaScriptTextInputPanel: return nil

		case .didClose: return nil
		case .runOpenPanel: return nil

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .createWebView: return nil
		
		case .commitPreviewingViewController: return nil
		case .previewingViewController: return nil
		case .shouldPreviewElement: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension WebView.Preparer {
	open class Storage: View.Preparer.Storage, WKUIDelegate, WKNavigationDelegate {}

	open class Delegate: DynamicDelegate, WKUIDelegate, WKNavigationDelegate {
		open func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		open func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		open func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		open func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
			multiHandler(webView, (navigation, error))
		}
		
		open func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
			multiHandler(webView, (navigation, error))
		}
		
		open func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
			multiHandler(webView, navigation)
		}
		
		open func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
			multiHandler(webView, ())
		}
		
		open func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
			multiHandler(webView, navigationAction, decisionHandler)
		}
		
		open func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -> Void) {
			multiHandler(webView, navigationResponse, decisionHandler)
		}
		
		open func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
			multiHandler(webView, challenge, completionHandler)
		}
		
		open func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
			multiHandler(webView, message, frame, completionHandler)
		}
		
		open func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
			multiHandler(webView, message, frame, completionHandler)
		}
		
		open func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
			multiHandler(webView, prompt, defaultText, frame)
		}
		
		open func webView(_ webView: WKWebView, createWebViewWith configuration: WKWebViewConfiguration, for navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures) -> WKWebView? {
			return singleHandler(webView, configuration, navigationAction, windowFeatures)
		}

		open func webViewDidClose(_ webView: WKWebView) {
			multiHandler(webView)
		}

		#if os(iOS)
			open func webView(_ webView: WKWebView, shouldPreviewElement elementInfo: WKPreviewElementInfo) -> Bool {
				return singleHandler(webView, elementInfo)
			}
			
			open func webView(_ webView: WKWebView, commitPreviewingViewController previewingViewController: UIViewController) {
				multiHandler(webView, previewingViewController)
			}
			
			open func webView(_ webView: WKWebView, previewingViewControllerForElement elementInfo: WKPreviewElementInfo, defaultActions previewActions: [WKPreviewActionItem]) -> UIViewController? {
				return singleHandler(webView, elementInfo, previewActions)
			}
		#else
			open func webView(_ webView: WKWebView, runOpenPanelWith parameters: WebView.WKOpenPanelParameters, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping ([URL]?) -> Void) {
				multiHandler(webView, parameters, frame, completionHandler)
			}
		#endif
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: WebViewBinding {
	public typealias WebViewName<V> = BindingName<V, WebView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> WebView.Binding) -> WebViewName<V> {
		return WebViewName<V>(source: source, downcast: Binding.webViewBinding)
	}
}
public extension BindingName where Binding: WebViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: WebViewName<$2> { return .name(WebView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var allowsAirPlayForMediaPlayback: WebViewName<Constant<Bool>> { return .name(WebView.Binding.allowsAirPlayForMediaPlayback) }
	static var allowsInlineMediaPlayback: WebViewName<Constant<Bool>> { return .name(WebView.Binding.allowsInlineMediaPlayback) }
	static var allowsPictureInPictureForMediaPlayback: WebViewName<Constant<Bool>> { return .name(WebView.Binding.allowsPictureInPictureForMediaPlayback) }
	static var applicationNameForUserAgent: WebViewName<Constant<String?>> { return .name(WebView.Binding.applicationNameForUserAgent) }
	static var ignoresViewportScaleLimits: WebViewName<Constant<Bool>> { return .name(WebView.Binding.ignoresViewportScaleLimits) }
	static var javaScriptCanOpenWindowsAutomatically: WebViewName<Constant<Bool>> { return .name(WebView.Binding.javaScriptCanOpenWindowsAutomatically) }
	static var javaScriptEnabled: WebViewName<Constant<Bool>> { return .name(WebView.Binding.javaScriptEnabled) }
	static var mediaTypesRequiringUserActionForPlayback: WebViewName<Constant<WKAudiovisualMediaTypes>> { return .name(WebView.Binding.mediaTypesRequiringUserActionForPlayback) }
	static var minimumFontSize: WebViewName<Constant<CGFloat>> { return .name(WebView.Binding.minimumFontSize) }
	static var processPool: WebViewName<Constant<WKProcessPool>> { return .name(WebView.Binding.processPool) }
	static var suppressesIncrementalRendering: WebViewName<Constant<Bool>> { return .name(WebView.Binding.suppressesIncrementalRendering) }
	static var urlSchemeHandlers: WebViewName<Constant<[String: WKURLSchemeHandler]>> { return .name(WebView.Binding.urlSchemeHandlers) }
	static var userContentController: WebViewName<Constant<WKUserContentController>> { return .name(WebView.Binding.userContentController) }
	
	@available(macOS 10.10, *) @available(iOS, unavailable) static var javaEnabled: WebViewName<Constant<Bool>> { return .name(WebView.Binding.javaEnabled) }
	@available(macOS 10.10, *) @available(iOS, unavailable) static var plugInsEnabled: WebViewName<Constant<Bool>> { return .name(WebView.Binding.plugInsEnabled) }
	@available(macOS 10.10, *) @available(iOS, unavailable) static var tabFocusesLinks: WebViewName<Constant<Bool>> { return .name(WebView.Binding.tabFocusesLinks) }
	@available(macOS 10.12, *) @available(iOS, unavailable) static var userInterfaceDirectionPolicy: WebViewName<Constant<WebView.WKUserInterfaceDirectionPolicy>> { return .name(WebView.Binding.userInterfaceDirectionPolicy) }
	@available(macOS, unavailable) @available(iOS 9, *) static var allowsPictureInPictureMediaPlayback: WebViewName<Constant<Bool>> { return .name(WebView.Binding.allowsPictureInPictureMediaPlayback) }
	@available(macOS, unavailable) @available(iOS 11, *) static var scrollView: WebViewName<Constant<ScrollView>> { return .name(WebView.Binding.scrollView) }
	@available(macOS, unavailable) @available(iOS 11, *) static var dataDetectorTypes: WebViewName<Constant<WebView.WKDataDetectorTypes>> { return .name(WebView.Binding.dataDetectorTypes) }
	@available(macOS, unavailable) @available(iOS 11, *) static var selectionGranularity: WebViewName<Constant<WebView.WKSelectionGranularity>> { return .name(WebView.Binding.selectionGranularity) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsBackForwardNavigationGestures: WebViewName<Dynamic<Bool>> { return .name(WebView.Binding.allowsBackForwardNavigationGestures) }
	
	static var allowsLinkPreview: WebViewName<Dynamic<Bool>> { return .name(WebView.Binding.allowsLinkPreview) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var allowsMagnification: WebViewName<Dynamic<Bool>> { return .name(WebView.Binding.allowsMagnification) }
	static var customUserAgent: WebViewName<Dynamic<String?>> { return .name(WebView.Binding.customUserAgent) }
	@available(macOS 10.13, *) @available(iOS, unavailable) static var magnification: WebViewName<Dynamic<(factor: CGFloat, centeredAt: CGPoint)>> { return .name(WebView.Binding.magnification) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var evaluateJavaScript: WebViewName<Signal<Callback<String, (Any?, Error?)>>> { return .name(WebView.Binding.evaluateJavaScript) }
	static var goBack: WebViewName<Signal<Callback<Void, WKNavigation?>>> { return .name(WebView.Binding.goBack) }
	static var goForward: WebViewName<Signal<Callback<Void, WKNavigation?>>> { return .name(WebView.Binding.goForward) }
	static var goTo: WebViewName<Signal<Callback<WKBackForwardListItem, WKNavigation?>>> { return .name(WebView.Binding.goTo) }
	static var load: WebViewName<Signal<Callback<URLRequest, WKNavigation?>>> { return .name(WebView.Binding.load) }
	static var loadHTMLString: WebViewName<Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>> { return .name(WebView.Binding.loadHTMLString) }
	static var reload: WebViewName<Signal<Callback<Void, WKNavigation?>>> { return .name(WebView.Binding.reload) }
	static var reloadFromOrigin: WebViewName<Signal<Callback<Void, WKNavigation?>>> { return .name(WebView.Binding.reloadFromOrigin) }
	static var stopLoading: WebViewName<Signal<Void>> { return .name(WebView.Binding.stopLoading) }
	
	static var loadData: WebViewName<Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>> { return .name(WebView.Binding.loadData) }
	static var loadFile: WebViewName<Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>> { return .name(WebView.Binding.loadFile) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var createWebView: WebViewName<(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?> { return .name(WebView.Binding.createWebView) }
	static var didClose: WebViewName<(WKWebView) -> Void> { return .name(WebView.Binding.didClose) }
	static var didCommit: WebViewName<(WKWebView, WKNavigation) -> Void> { return .name(WebView.Binding.didCommit) }
	static var didStartProvisionalNavigation: WebViewName<(WKWebView, WKNavigation) -> Void> { return .name(WebView.Binding.didStartProvisionalNavigation) }
	static var didReceiveServerRedirectForProvisionalNavigation: WebViewName<(WKWebView, WKNavigation) -> Void> { return .name(WebView.Binding.didReceiveServerRedirectForProvisionalNavigation) }
	static var didFail: WebViewName<(WKWebView, WKNavigation, Error) -> Void> { return .name(WebView.Binding.didFail) }
	static var didFailProvisionalNavigation: WebViewName<(WKWebView, WKNavigation, Error) -> Void> { return .name(WebView.Binding.didFailProvisionalNavigation) }
	static var didFinish: WebViewName<(WKWebView, WKNavigation) -> Void> { return .name(WebView.Binding.didFinish) }
	static var contentProcessDidTerminate: WebViewName<(WKWebView) -> Void> { return .name(WebView.Binding.contentProcessDidTerminate) }
	static var decideActionPolicy: WebViewName<(WKWebView, WKNavigationAction, (WKNavigationActionPolicy) -> Void) -> Void> { return .name(WebView.Binding.decideActionPolicy) }
	static var decideResponsePolicy: WebViewName<(WKWebView, WKNavigationResponse, (WKNavigationActionPolicy) -> Void) -> Void> { return .name(WebView.Binding.decideResponsePolicy) }
	static var didReceiveAuthenticationChallenge: WebViewName<(WKWebView, URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) -> Void> { return .name(WebView.Binding.didReceiveAuthenticationChallenge) }
	static var runJavaScriptAlertPanel: WebViewName<(WKWebView, String, WKFrameInfo, () -> Void) -> Void> { return .name(WebView.Binding.runJavaScriptAlertPanel) }
	static var runJavaScriptConfirmPanel: WebViewName<(WKWebView, String, WKFrameInfo, (Bool) -> Void) -> Void> { return .name(WebView.Binding.runJavaScriptConfirmPanel) }
	static var runJavaScriptTextInputPanel: WebViewName<(WKWebView, String, String?, WKFrameInfo, (String?) -> Void) -> Void> { return .name(WebView.Binding.runJavaScriptTextInputPanel) }
	
	@available(macOS, unavailable) @available(iOS 10.0, *) static var commitPreviewingViewController: WebViewName<(_ webView: WKWebView, _ previewingViewController: WebView.UIViewController) -> Void> { return .name(WebView.Binding.commitPreviewingViewController) }
	@available(macOS, unavailable) @available(iOS 10.0, *) static var previewingViewController: WebViewName<(_ webView: WKWebView, _ elementInfo: WebView.WKPreviewElementInfo, _ previewActions: [WebView.WKPreviewActionItem]) -> WebView.UIViewController?> { return .name(WebView.Binding.previewingViewController) }
	@available(macOS 10.12, *) @available(iOS, unavailable) static var runOpenPanel: WebViewName<(WKWebView, WebView.WKOpenPanelParameters, WKFrameInfo, ([URL]?) -> Void) -> Void> { return .name(WebView.Binding.runOpenPanel) }
	@available(macOS, unavailable) @available(iOS 10.0, *) static var shouldPreviewElement: WebViewName<(_ webView: WKWebView, _ elementInfo: WebView.WKPreviewElementInfo) -> Bool> { return .name(WebView.Binding.shouldPreviewElement) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol WebViewConvertible: ViewConvertible {
	func wkWebView() -> WebView.Instance
}
extension WebViewConvertible {
	#if os(macOS)
		public func nsView() -> View.Instance { return wkWebView() }
	#else
		public func uiView() -> View.Instance { return wkWebView() }
	#endif
}
extension WKWebView: WebViewConvertible, HasDelegate {
	public func wkWebView() -> WebView.Instance { return self }
	public var delegate: WKNavigationDelegate? {
		get { return navigationDelegate }
		set { navigationDelegate = newValue }
	}
}
public extension WebView {
	func wkWebView() -> WebView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol WebViewBinding: ViewBinding {
	static func webViewBinding(_ binding: WebView.Binding) -> Self
	func asWebViewBinding() -> WebView.Binding?
}
public extension WebViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return webViewBinding(.inheritedBinding(binding))
	}
}
public extension WebViewBinding where Preparer.Inherited.Binding: WebViewBinding {
	func asWebViewBinding() -> WebView.Binding? {
		return asInheritedBinding()?.asWebViewBinding()
	}
}
public extension WebView.Binding {
	typealias Preparer = WebView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asWebViewBinding() -> WebView.Binding? { return self }
	static func webViewBinding(_ binding: WebView.Binding) -> WebView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

