//
//  This file is part of a concatenation of the CwlViews framework with public
//  interfaces for exposing from libraries or use in Swift Playgrounds).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-05-11 02:03:27 +0000 from the following files:
//   CwlApplication_macOS.swift
//   CwlButton_macOS.swift
//   CwlClickGestureRecognizer_macOS.swift
//   CwlClipView_macOS.swift
//   CwlControl_macOS.swift
//   CwlGestureRecognizer_macOS.swift
//   CwlImageView_macOS.swift
//   CwlMagnificationGestureRecognizer_macOS.swift
//   CwlMenuItem_macOS.swift
//   CwlMenu_macOS.swift
//   CwlOutlineView_macOS.swift
//   CwlPanGestureRecognizer_macOS.swift
//   CwlPopUpButton_macOS.swift
//   CwlPressGestureRecognizer_macOS.swift
//   CwlRotationGestureRecognizer_macOS.swift
//   CwlScrollView_macOS.swift
//   CwlSegmentedControl_macOS.swift
//   CwlSlider_macOS.swift
//   CwlSplitView_macOS.swift
//   CwlTabViewItem_macOS.swift
//   CwlTabView_macOS.swift
//   CwlTableCellView_macOS.swift
//   CwlTableColumn_macOS.swift
//   CwlTableHeaderView_macOS.swift
//   CwlTableRowView_macOS.swift
//   CwlTableView_macOS.swift
//   CwlTextField_macOS.swift
//   CwlTextView_macOS.swift
//   CwlToolbarItem_macOS.swift
//   CwlToolbar_macOS.swift
//   CwlView_macOS.swift
//   CwlWindow_macOS.swift

import AppKit

#if os(macOS)

import Foundation
import CloudKit
import simd

public func applicationMain(type: NSApplication.Type = NSApplication.self, _ application: @escaping () -> Application) {
	let instance = type.shared
	let bindings = application().consume().bindings
	let (preparer, _, storage, lifetimes) = Application.Preparer.bind(bindings, to: { _ in instance })
	_ = preparer.combine(lifetimes: lifetimes, instance: instance, storage: storage)
	_ = NSApplicationMain(CommandLine.argc, CommandLine.unsafeArgv)
}

// MARK: - Binder Part 1: Binder
public class Application: Binder {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		precondition(type == Preparer.Instance.self, "Custom application subclass must be specified as parameter to `applicationMain`")
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Application {
	enum Binding: ApplicationBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static styles are applied at construction and are subsequently immutable.
	
		// 1. Value bindings may be applied at construction and may subsequently change.
		case activationPolicy(Dynamic<NSApplication.ActivationPolicy>)
		case applicationIconImage(Dynamic<NSImage?>)
		case dockMenu(Dynamic<MenuConvertible?>)
		case mainMenu(Dynamic<MenuConvertible?>)
		case menuBarVisible(Dynamic<Bool>)
		case presentationOptions(Dynamic<NSApplication.PresentationOptions>)
		case relauchOnLogin(Dynamic<Bool>)
		case remoteNotifications(Dynamic<NSApplication.RemoteNotificationType>)
		
		@available(macOS 10.14, *) case appearance(Dynamic<NSAppearance?>)
		
		// 2. Signal bindings are performed on the object after construction.
		case activate(Signal<Bool>)
		case arrangeInFront(Signal<Void>)
		case deactivate(Signal<Void>)
		case hide(Signal<Void>)
		case hideOtherApplications(Signal<Void>)
		case miniaturizeAll(Signal<Void>)
		case orderFrontCharacterPalette(Signal<Void>)
		case orderFrontColorPanel(Signal<Void>)
		case orderFrontStandardAboutPanel(Signal<Dictionary<NSApplication.AboutPanelOptionKey, Any>>)
		case presentError(Signal<Callback<Error, Bool>>)
		case requestUserAttention(Signal<(NSApplication.RequestUserAttentionType, Signal<Void>)>)
		case terminate(Signal<Void>)
		case unhide(Signal<Bool>)
		case unhideAllApplications(Signal<Void>)
		
		// 3. Action bindings are triggered by the object after construction.
		case didBecomeActive(SignalInput<Void>)
		case didChangeOcclusionState(SignalInput<Void>)
		case didChangeScreenParameters(SignalInput<Void>)
		case didFinishLaunching(SignalInput<[AnyHashable: Any]>)
		case didFinishRestoringWindows(SignalInput<Void>)
		case didHide(SignalInput<Void>)
		case didResignActive(SignalInput<Void>)
		case didUnhide(SignalInput<Void>)
		case didUpdate(SignalInput<Void>)
		case willBecomeActive(SignalInput<Void>)
		case willFinishLaunching(SignalInput<Void>)
		case willHide(SignalInput<Void>)
		case willResignActive(SignalInput<Void>)
		case willUnhide(SignalInput<Void>)
		case willUpdate(SignalInput<Void>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case continueUserActivity((_ application: NSApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([NSUserActivityRestoring]) -> Void) -> Bool)
		case didDecodeRestorableState((_ application: NSApplication, NSCoder) -> Void)
		case didFailToContinueUserActivity((_ application: NSApplication, _ userActivityType: String, _ error: Error) -> Void)
		case didFailToRegisterForRemoteNotifications((_ application: NSApplication, _ error: Error) -> Void)
		case didReceiveRemoteNotification((_ application: NSApplication, _ notification: [String: Any]) -> Void)
		case didRegisterForRemoteNotifications((_ application: NSApplication, _ token: Data) -> Void)
		case didUpdateUserActivity((_ application: NSApplication, NSUserActivity) -> Void)
		case openFile((_ application: NSApplication, _ filename: String) -> Bool)
		case openFiles((_ application: NSApplication, _ filenames: [String]) -> Void)
		case openFileWithoutUI((_ application: Any, _ filename: String) -> Bool)
		case openTempFile((_ application: NSApplication, _ filename: String) -> Bool)
		case openUntitledFile((_ application: NSApplication) -> Bool)
		case printFile((_ application: NSApplication, _ filename: String) -> Bool)
		case printFiles((_ application: NSApplication, _ filenames: [String], _ settings: [NSPrintInfo.AttributeKey: Any], _ showPrintPanels: Bool) -> NSApplication.PrintReply)
		case shouldHandleReopen((_ application: NSApplication, _ hasVisibleWindows: Bool) -> Bool)
		case shouldOpenUntitledFile((_ application: NSApplication) -> Bool)
		case shouldTerminate((_ application: NSApplication) -> NSApplication.TerminateReply)
		case shouldTerminateAfterLastWindowClosed((_ application: NSApplication) -> Bool)
		case userDidAcceptCloudKitShare((_ application: NSApplication, CKShare.Metadata) -> Void)
		case willContinueUserActivity((_ application: NSApplication, _ type: String) -> Bool)
		case willEncodeRestorableState((_ application: NSApplication, NSCoder) -> Void)
		case willPresentError((_ application: NSApplication, Error) -> Error)
		case willTerminate((_ notification: Notification) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension Application {
	struct Preparer: BinderDelegateEmbedder {
		public typealias Binding = Application.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = NSApplication
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var dockMenuInUse: Bool = false
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Application.Preparer {
	var delegateIsRequired: Bool { return dynamicDelegate != nil || dockMenuInUse }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .continueUserActivity(let x): delegate().addSingleHandler3(x, #selector(NSApplicationDelegate.application(_:continue:restorationHandler:)))
		case .dockMenu: dockMenuInUse = true
		case .didDecodeRestorableState(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didDecodeRestorableState:)))
		case .didFailToContinueUserActivity(let x): delegate().addMultiHandler3(x, #selector(NSApplicationDelegate.application(_:didFailToContinueUserActivityWithType:error:)))
		case .didFailToRegisterForRemoteNotifications(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didFailToRegisterForRemoteNotificationsWithError:)))
		case .didReceiveRemoteNotification(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didReceiveRemoteNotification:)))
		case .didRegisterForRemoteNotifications(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didRegisterForRemoteNotificationsWithDeviceToken:)))
		case .didUpdateUserActivity(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:didUpdate:)))
		case .openFile(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:openFile:)))
		case .openFiles(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:openFiles:)))
		case .openFileWithoutUI(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:openFileWithoutUI:)))
		case .openTempFile(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:openTempFile:)))
		case .openUntitledFile(let x): delegate().addSingleHandler1(x, #selector(NSApplicationDelegate.applicationOpenUntitledFile(_:)))
		case .printFile(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:printFile:)))
		case .printFiles(let x): delegate().addSingleHandler4(x, #selector(NSApplicationDelegate.application(_:printFiles:withSettings:showPrintPanels:)))
		case .shouldHandleReopen(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.applicationShouldHandleReopen(_:hasVisibleWindows:)))
		case .shouldOpenUntitledFile(let x): delegate().addSingleHandler1(x, #selector(NSApplicationDelegate.applicationShouldOpenUntitledFile(_:)))
		case .shouldTerminate(let x): delegate().addSingleHandler1(x, #selector(NSApplicationDelegate.applicationShouldTerminate(_:)))
		case .shouldTerminateAfterLastWindowClosed(let x): delegate().addSingleHandler1(x, #selector(NSApplicationDelegate.applicationShouldTerminateAfterLastWindowClosed(_:)))
		case .userDidAcceptCloudKitShare(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:userDidAcceptCloudKitShareWith:)))
		case .willContinueUserActivity(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:willContinueUserActivityWithType:)))
		case .willEncodeRestorableState(let x): delegate().addMultiHandler2(x, #selector(NSApplicationDelegate.application(_:willEncodeRestorableState:)))
		case .willPresentError(let x): delegate().addSingleHandler2(x, #selector(NSApplicationDelegate.application(_:willPresentError:)))
		case .willTerminate(let x): delegate().addMultiHandler1(x, #selector(NSApplicationDelegate.applicationWillTerminate(_:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static styles are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .activationPolicy(let x): return x.apply(instance) { i, v in i.setActivationPolicy(v) }
		case .appearance(let x):
			return x.apply(instance) { i, v in
				if #available(OSX 10.14, *) {
					i.appearance = v
				}
			}
		case .applicationIconImage(let x): return x.apply(instance) { i, v in i.applicationIconImage = v }
		case .dockMenu(let x): return x.apply(instance, storage) { i, s, v in s.dockMenu = v?.nsMenu() }
		case .mainMenu(let x): return x.apply(instance) { i, v in i.mainMenu = v?.nsMenu() }
		case .menuBarVisible(let x): return x.apply(instance) { i, v in NSMenu.setMenuBarVisible(v) }
		case .presentationOptions(let x): return x.apply(instance) { i, v in i.presentationOptions = v }
		case .relauchOnLogin(let x): return x.apply(instance) { i, v in v ? i.enableRelaunchOnLogin() : i.disableRelaunchOnLogin() }
		case .remoteNotifications(let x): return x.apply(instance) { i, v in v.isEmpty ? i.unregisterForRemoteNotifications() : i.registerForRemoteNotifications(matching: v) }
			
		// 2. Signal bindings are performed on the object after construction.
		case .activate(let x): return x.apply(instance) { i, v in i.activate(ignoringOtherApps: v) }
		case .arrangeInFront(let x): return x.apply(instance) { i, v in i.arrangeInFront(nil) }
		case .deactivate(let x): return x.apply(instance) { i, v in i.deactivate() }
		case .hide(let x): return x.apply(instance) { i, v in i.hide(nil) }
		case .hideOtherApplications(let x): return x.apply(instance) { i, v in i.hideOtherApplications(nil) }
		case .miniaturizeAll(let x): return x.apply(instance) { i, v in i.miniaturizeAll(nil) }
		case .orderFrontCharacterPalette(let x): return x.apply(instance) { i, v in i.orderFrontCharacterPalette(nil) }
		case .orderFrontColorPanel(let x): return x.apply(instance) { i, v in i.orderFrontColorPanel(nil) }
		case .orderFrontStandardAboutPanel(let x): return x.apply(instance) { i, v in i.orderFrontStandardAboutPanel(options: v) }
		case .presentError(let x):
			return x.apply(instance) { i, v in
				let handled = i.presentError(v.value)
				_ = v.callback.send(value: handled)
			}
		case .requestUserAttention(let x):
			var outstandingRequests = [Lifetime]()
			return x.apply(instance) { i, v in
				let requestIndex = i.requestUserAttention(v.0)
				outstandingRequests += v.1.subscribe { [weak i] r in i?.cancelUserAttentionRequest(requestIndex) }
			}
		case .terminate(let x): return x.apply(instance) { i, v in i.terminate(nil) }
		case .unhide(let x): return x.apply(instance) { i, v in v ? i.unhide(nil) : i.unhideWithoutActivation() }
		case .unhideAllApplications(let x): return x.apply(instance) { i, v in i.unhideAllApplications(nil) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didBecomeActive(let x): return Signal.notifications(name: NSApplication.didBecomeActiveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeOcclusionState(let x): return Signal.notifications(name: NSApplication.didChangeOcclusionStateNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeScreenParameters(let x): return Signal.notifications(name: NSApplication.didChangeScreenParametersNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didFinishLaunching(let x): return Signal.notifications(name: NSApplication.didFinishLaunchingNotification, object: instance).compactMap { n -> [AnyHashable: Any] in n.userInfo ?? [:] }.cancellableBind(to: x)
		case .didFinishRestoringWindows(let x): return Signal.notifications(name: NSApplication.didFinishRestoringWindowsNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didHide(let x): return Signal.notifications(name: NSApplication.didHideNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didResignActive(let x): return Signal.notifications(name: NSApplication.didResignActiveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didUnhide(let x): return Signal.notifications(name: NSApplication.didUnhideNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didUpdate(let x): return Signal.notifications(name: NSApplication.didUpdateNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willBecomeActive(let x): return Signal.notifications(name: NSApplication.willBecomeActiveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willFinishLaunching(let x): return Signal.notifications(name: NSApplication.willFinishLaunchingNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willHide(let x): return Signal.notifications(name: NSApplication.willHideNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willResignActive(let x): return Signal.notifications(name: NSApplication.willResignActiveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willUnhide(let x): return Signal.notifications(name: NSApplication.willUnhideNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willUpdate(let x): return Signal.notifications(name: NSApplication.willUpdateNotification, object: instance).map { n in () }.cancellableBind(to: x)

		case .didFailToContinueUserActivity: return nil
		case .didFailToRegisterForRemoteNotifications: return nil
		case .didReceiveRemoteNotification: return nil
		case .didRegisterForRemoteNotifications: return nil
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .continueUserActivity: return nil
		case .didDecodeRestorableState: return nil
		case .didUpdateUserActivity: return nil
		case .openFile: return nil
		case .openFiles: return nil
		case .openFileWithoutUI: return nil
		case .openTempFile: return nil
		case .openUntitledFile: return nil
		case .printFile: return nil
		case .printFiles: return nil
		case .shouldHandleReopen: return nil
		case .shouldOpenUntitledFile: return nil
		case .shouldTerminate: return nil
		case .shouldTerminateAfterLastWindowClosed: return nil
		case .willContinueUserActivity: return nil
		case .willEncodeRestorableState: return nil
		case .willPresentError: return nil
		case .willTerminate: return nil

		case .userDidAcceptCloudKitShare: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Application.Preparer {
	open class Storage: AssociatedBinderStorage, NSApplicationDelegate {
		open var dockMenu: NSMenu?
		
		open override var isInUse: Bool {
			return super.isInUse || dockMenu != nil
		}
		
		open func applicationDockMenu(_ sender: NSApplication) -> NSMenu? {
			return dockMenu
		}
	}
	
	open class Delegate: DynamicDelegate, NSApplicationDelegate {
		open func applicationShouldTerminate(_ application: NSApplication) -> NSApplication.TerminateReply {
			return singleHandler(application)
		}
		
		open func applicationShouldTerminateAfterLastWindowClosed(_ application: NSApplication) -> Bool {
			return singleHandler(application)
		}
		
		open func applicationShouldHandleReopen(_ application: NSApplication, hasVisibleWindows: Bool) -> Bool {
			return singleHandler(application, hasVisibleWindows)
		}
		
		open func application(_ application: NSApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([NSUserActivityRestoring]) -> Void) -> Bool {
			return singleHandler(application, userActivity, restorationHandler)
		}
		
		open func application(_ application: NSApplication, willPresentError error: Error) -> Error {
			return singleHandler(application, error)
		}
		
		open func application(_ application: NSApplication, willContinueUserActivityWithType userActivityType: String) -> Bool {
			return singleHandler(application, userActivityType)
		}
		
		open func application(_ application: Any, openFileWithoutUI filename: String) -> Bool {
			return singleHandler(application, filename)
		}
		
		open func application(_ application: NSApplication, openFile filename: String) -> Bool {
			return singleHandler(application, filename)
		}
		
		open func application(_ application: NSApplication, openFiles filenames: [String]) {
			multiHandler(application, filenames)
		}
		
		open func application(_ application: NSApplication, printFile filename: String) -> Bool {
			return singleHandler(application, filename)
		}
		
		open func application(_ application: NSApplication, printFiles filenames: [String], withSettings printSettings: [NSPrintInfo.AttributeKey: Any], showPrintPanels: Bool) -> NSApplication.PrintReply {
			return singleHandler(application, filenames, printSettings, showPrintPanels)
		}
		
		open func application(_ application: NSApplication, openTempFile filename: String) -> Bool {
			return singleHandler(application, filename)
		}
		
		open func applicationOpenUntitledFile(_ application: NSApplication) -> Bool {
			return singleHandler(application)
		}
		
		open func applicationShouldOpenUntitledFile(_ application: NSApplication) -> Bool {
			return singleHandler(application)
		}
		
		open func applicationWillTerminate(_ notification: Notification) {
			multiHandler(notification)
		}
		
		open func application(_ application: NSApplication, didUpdate userActivity: NSUserActivity) {
			return multiHandler(application, userActivity)
		}
		
		open func application(_ application: NSApplication, willEncodeRestorableState coder: NSCoder) {
			return multiHandler(application, coder)
		}
		
		open func application(_ application: NSApplication, didDecodeRestorableState coder: NSCoder) {
			return multiHandler(application, coder)
		}
		
		open func application(_ application: NSApplication, didFailToContinueUserActivityWithType userActivityType: String, error: Error) {
			multiHandler(application, userActivityType, error)
		}
		
		open func application(_ application: NSApplication, didReceiveRemoteNotification userInfo: [String: Any]) {
			multiHandler(application, userInfo)
		}
		
		open func application(_ application: NSApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
			multiHandler(application, deviceToken)
		}
		
		open func application(_ application: NSApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
			multiHandler(application, error)
		}
		
		open func application(_ application: NSApplication, userDidAcceptCloudKitShareWith metadata: CKShare.Metadata) {
			multiHandler(application, metadata)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ApplicationBinding {
	public typealias ApplicationName<V> = BindingName<V, Application.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Application.Binding) -> ApplicationName<V> {
		return ApplicationName<V>(source: source, downcast: Binding.applicationBinding)
	}
}
public extension BindingName where Binding: ApplicationBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ApplicationName<$2> { return .name(Application.Binding.$1) }
	
	//	0. Static styles are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var activationPolicy: ApplicationName<Dynamic<NSApplication.ActivationPolicy>> { return .name(Application.Binding.activationPolicy) }
	static var applicationIconImage: ApplicationName<Dynamic<NSImage?>> { return .name(Application.Binding.applicationIconImage) }
	static var dockMenu: ApplicationName<Dynamic<MenuConvertible?>> { return .name(Application.Binding.dockMenu) }
	static var mainMenu: ApplicationName<Dynamic<MenuConvertible?>> { return .name(Application.Binding.mainMenu) }
	static var menuBarVisible: ApplicationName<Dynamic<Bool>> { return .name(Application.Binding.menuBarVisible) }
	static var presentationOptions: ApplicationName<Dynamic<NSApplication.PresentationOptions>> { return .name(Application.Binding.presentationOptions) }
	static var relauchOnLogin: ApplicationName<Dynamic<Bool>> { return .name(Application.Binding.relauchOnLogin) }
	static var remoteNotifications: ApplicationName<Dynamic<NSApplication.RemoteNotificationType>> { return .name(Application.Binding.remoteNotifications) }

	@available(macOS 10.14, *) static var appearance: ApplicationName<Dynamic<NSAppearance?>> { return .name(Application.Binding.appearance) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var activate: ApplicationName<Signal<Bool>> { return .name(Application.Binding.activate) }
	static var arrangeInFront: ApplicationName<Signal<Void>> { return .name(Application.Binding.arrangeInFront) }
	static var deactivate: ApplicationName<Signal<Void>> { return .name(Application.Binding.deactivate) }
	static var hide: ApplicationName<Signal<Void>> { return .name(Application.Binding.hide) }
	static var hideOtherApplications: ApplicationName<Signal<Void>> { return .name(Application.Binding.hideOtherApplications) }
	static var miniaturizeAll: ApplicationName<Signal<Void>> { return .name(Application.Binding.miniaturizeAll) }
	static var orderFrontCharacterPalette: ApplicationName<Signal<Void>> { return .name(Application.Binding.orderFrontCharacterPalette) }
	static var orderFrontColorPanel: ApplicationName<Signal<Void>> { return .name(Application.Binding.orderFrontColorPanel) }
	static var orderFrontStandardAboutPanel: ApplicationName<Signal<Dictionary<NSApplication.AboutPanelOptionKey, Any>>> { return .name(Application.Binding.orderFrontStandardAboutPanel) }
	static var presentError: ApplicationName<Signal<Callback<Error, Bool>>> { return .name(Application.Binding.presentError) }
	static var requestUserAttention: ApplicationName<Signal<(NSApplication.RequestUserAttentionType, Signal<Void>)>> { return .name(Application.Binding.requestUserAttention) }
	static var terminate: ApplicationName<Signal<Void>> { return .name(Application.Binding.terminate) }
	static var unhide: ApplicationName<Signal<Bool>> { return .name(Application.Binding.unhide) }
	static var unhideAllApplications: ApplicationName<Signal<Void>> { return .name(Application.Binding.unhideAllApplications) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBecomeActive: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.didBecomeActive) }
	static var didChangeOcclusionState: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.didChangeOcclusionState) }
	static var didChangeScreenParameters: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.didChangeScreenParameters) }
	static var didFinishLaunching: ApplicationName<SignalInput<[AnyHashable: Any]>> { return .name(Application.Binding.didFinishLaunching) }
	static var didFinishRestoringWindows: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.didFinishRestoringWindows) }
	static var didHide: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.didHide) }
	static var didResignActive: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.didResignActive) }
	static var didUnhide: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.didUnhide) }
	static var didUpdate: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.didUpdate) }
	static var willBecomeActive: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.willBecomeActive) }
	static var willFinishLaunching: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.willFinishLaunching) }
	static var willHide: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.willHide) }
	static var willResignActive: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.willResignActive) }
	static var willUnhide: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.willUnhide) }
	static var willUpdate: ApplicationName<SignalInput<Void>> { return .name(Application.Binding.willUpdate) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var continueUserActivity: ApplicationName<(_ application: NSApplication, _ userActivity: NSUserActivity, _ restorationHandler: @escaping ([NSUserActivityRestoring]) -> Void) -> Bool> { return .name(Application.Binding.continueUserActivity) }
	static var didDecodeRestorableState: ApplicationName<(_ application: NSApplication, NSCoder) -> Void> { return .name(Application.Binding.didDecodeRestorableState) }
	static var didFailToContinueUserActivity: ApplicationName<(NSApplication, String, Error) -> Void> { return .name(Application.Binding.didFailToContinueUserActivity) }
	static var didFailToRegisterForRemoteNotifications: ApplicationName<(NSApplication, Error) -> Void> { return .name(Application.Binding.didFailToRegisterForRemoteNotifications) }
	static var didReceiveRemoteNotification: ApplicationName<(NSApplication, [String: Any]) -> Void> { return .name(Application.Binding.didReceiveRemoteNotification) }
	static var didRegisterForRemoteNotifications: ApplicationName<(NSApplication, Data) -> Void> { return .name(Application.Binding.didRegisterForRemoteNotifications) }
	static var didUpdateUserActivity: ApplicationName<(_ application: NSApplication, NSUserActivity) -> Void> { return .name(Application.Binding.didUpdateUserActivity) }
	static var openFile: ApplicationName<(_ application: NSApplication, _ filename: String) -> Bool> { return .name(Application.Binding.openFile) }
	static var openFiles: ApplicationName<(_ application: NSApplication, _ filenames: [String]) -> Void> { return .name(Application.Binding.openFiles) }
	static var openFileWithoutUI: ApplicationName<(_ application: Any, _ filename: String) -> Bool> { return .name(Application.Binding.openFileWithoutUI) }
	static var openTempFile: ApplicationName<(_ application: NSApplication, _ filename: String) -> Bool> { return .name(Application.Binding.openTempFile) }
	static var openUntitledFile: ApplicationName<(_ application: NSApplication) -> Bool> { return .name(Application.Binding.openUntitledFile) }
	static var printFile: ApplicationName<(_ application: NSApplication, _ filename: String) -> Bool> { return .name(Application.Binding.printFile) }
	static var printFiles: ApplicationName<(_ application: NSApplication, _ filenames: [String], _ settings: [NSPrintInfo.AttributeKey: Any], _ showPrintPanels: Bool) -> NSApplication.PrintReply> { return .name(Application.Binding.printFiles) }
	static var shouldHandleReopen: ApplicationName<(_ application: NSApplication, _ hasVisibleWindows: Bool) -> Bool> { return .name(Application.Binding.shouldHandleReopen) }
	static var shouldOpenUntitledFile: ApplicationName<(_ application: NSApplication) -> Bool> { return .name(Application.Binding.shouldOpenUntitledFile) }
	static var shouldTerminate: ApplicationName<(_ application: NSApplication) -> NSApplication.TerminateReply> { return .name(Application.Binding.shouldTerminate) }
	static var shouldTerminateAfterLastWindowClosed: ApplicationName<(_ application: NSApplication) -> Bool> { return .name(Application.Binding.shouldTerminateAfterLastWindowClosed) }
	static var userDidAcceptCloudKitShare: ApplicationName<(_ application: NSApplication, CKShare.Metadata) -> Void> { return .name(Application.Binding.userDidAcceptCloudKitShare) }
	static var willContinueUserActivity: ApplicationName<(_ application: NSApplication, _ type: String) -> Bool> { return .name(Application.Binding.willContinueUserActivity) }
	static var willEncodeRestorableState: ApplicationName<(_ application: NSApplication, NSCoder) -> Void> { return .name(Application.Binding.willEncodeRestorableState) }
	static var willPresentError: ApplicationName<(_ application: NSApplication, Error) -> Error> { return .name(Application.Binding.willPresentError) }
	static var willTerminate: ApplicationName<(_ notification: Notification) -> Void> { return .name(Application.Binding.willTerminate) }

	// Composite binding names
	static func shouldTerminateAfterLastWindowClosed(_ void: Void = ()) -> ApplicationName<Constant<Bool>> {
		return Binding.compositeName(
			value: { constant in { (application: NSApplication) -> Bool in return true } },
			binding: Application.Binding.shouldTerminateAfterLastWindowClosed,
			downcast: Binding.applicationBinding
		)
	}
	
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension NSApplication: HasDelegate {}

// MARK: - Binder Part 8: Downcast protocols
public protocol ApplicationBinding: BinderBaseBinding {
	static func applicationBinding(_ binding: Application.Binding) -> Self
	func asApplicationBinding() -> Application.Binding?
}
public extension ApplicationBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return applicationBinding(.inheritedBinding(binding))
	}
}
public extension ApplicationBinding where Preparer.Inherited.Binding: ApplicationBinding {
	func asApplicationBinding() -> Application.Binding? {
		return asInheritedBinding()?.asApplicationBinding()
	}
}
public extension Application.Binding {
	typealias Preparer = Application.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asApplicationBinding() -> Application.Binding? { return self }
	static func applicationBinding(_ binding: Application.Binding) -> Application.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class Button: Binder, ButtonConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Button {
	enum Binding: ButtonBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsMixedState(Dynamic<Bool>)
		case alternateImage(Dynamic<NSImage?>)
		case alternateTitle(Dynamic<String>)
		case attributedAlternateTitle(Dynamic<NSAttributedString>)
		case attributedTitle(Dynamic<NSAttributedString>)
		case bezelColor(Dynamic<NSColor?>)
		case bezelStyle(Dynamic<NSButton.BezelStyle>)
		case buttonType(Dynamic<NSButton.ButtonType>)
		case highlight(Dynamic<Bool>)
		case image(Dynamic<NSImage?>)
		case imageHugsTitle(Dynamic<Bool>)
		case imagePosition(Dynamic<NSControl.ImagePosition>)
		case imageScaling(Dynamic<NSImageScaling>)
		case isBordered(Dynamic<Bool>)
		case isSpringLoaded(Dynamic<Bool>)
		case isTransparent(Dynamic<Bool>)
		case keyEquivalent(Dynamic<String>)
		case keyEquivalentModifierMask(Dynamic<NSEvent.ModifierFlags>)
		case maxAcceleratorLevel(Dynamic<Int>)
		case performKeyEquivalent(Dynamic<NSEvent>)
		case periodicDelay(Dynamic<(delay: Float, interval: Float)>)
		case showsBorderOnlyWhileMouseInside(Dynamic<Bool>)
		case sound(Dynamic<NSSound?>)
		case state(Dynamic<NSControl.StateValue>)
		case title(Dynamic<String>)

		@available(macOS 10.14, *) case contentTintColor(Dynamic<NSColor?>)

		//	2. Signal bindings are performed on the object after construction.
		case setNextState(Signal<Void>)

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension Button {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = Button.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = NSButton
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}
		
// MARK: - Binder Part 4: Preparer overrides
public extension Button.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .allowsMixedState(let x): return x.apply(instance) { i, v in i.allowsMixedState = v }
		case .alternateImage(let x): return x.apply(instance) { i, v in i.alternateImage = v }
		case .alternateTitle(let x): return x.apply(instance) { i, v in i.alternateTitle = v }
		case .attributedAlternateTitle(let x): return x.apply(instance) { i, v in i.attributedAlternateTitle = v }
		case .attributedTitle(let x): return x.apply(instance) { i, v in i.attributedTitle = v }
		case .bezelColor(let x): return x.apply(instance) { i, v in i.bezelColor = v }
		case .bezelStyle(let x): return x.apply(instance) { i, v in i.bezelStyle = v }
		case .buttonType(let x): return x.apply(instance) { i, v in i.setButtonType(v) }
		case .contentTintColor(let x):
			return x.apply(instance) { i, v in
				if #available(macOS 10.14, *) {
					i.contentTintColor = v
				}
			}
		case .highlight(let x): return x.apply(instance) { i, v in i.highlight(v) }
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .imageHugsTitle(let x): return x.apply(instance) { i, v in i.imageHugsTitle = v }
		case .imagePosition(let x): return x.apply(instance) { i, v in i.imagePosition = v }
		case .imageScaling(let x): return x.apply(instance) { i, v in i.imageScaling = v }
		case .isBordered(let x): return x.apply(instance) { i, v in i.isBordered = v }
		case .isSpringLoaded(let x): return x.apply(instance) { i, v in i.isSpringLoaded = v }
		case .isTransparent(let x): return x.apply(instance) { i, v in i.isTransparent = v }
		case .keyEquivalent(let x): return x.apply(instance) { i, v in i.keyEquivalent = v }
		case .keyEquivalentModifierMask(let x): return x.apply(instance) { i, v in i.keyEquivalentModifierMask = v }
		case .maxAcceleratorLevel(let x): return x.apply(instance) { i, v in i.maxAcceleratorLevel = v }
		case .performKeyEquivalent(let x): return x.apply(instance) { i, v in i.performKeyEquivalent(with: v) }
		case .periodicDelay(let x): return x.apply(instance) { i, v in i.setPeriodicDelay(v.delay, interval: v.interval) }
		case .showsBorderOnlyWhileMouseInside(let x): return x.apply(instance) { i, v in i.showsBorderOnlyWhileMouseInside = v }
		case .sound(let x): return x.apply(instance) { i, v in i.sound = v }
		case .state(let x): return x.apply(instance) { i, v in i.state = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }

		//	2. Signal bindings are performed on the object after construction.
		case .setNextState(let x): return x.apply(instance) { i, v in i.setNextState() }

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Button.Preparer {
	public typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ButtonBinding {
	public typealias ButtonName<V> = BindingName<V, Button.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Button.Binding) -> ButtonName<V> {
		return ButtonName<V>(source: source, downcast: Binding.buttonBinding)
	}
}
public extension BindingName where Binding: ButtonBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ButtonName<$2> { return .name(Button.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMixedState: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.allowsMixedState) }
	static var alternateImage: ButtonName<Dynamic<NSImage?>> { return .name(Button.Binding.alternateImage) }
	static var alternateTitle: ButtonName<Dynamic<String>> { return .name(Button.Binding.alternateTitle) }
	static var attributedAlternateTitle: ButtonName<Dynamic<NSAttributedString>> { return .name(Button.Binding.attributedAlternateTitle) }
	static var attributedTitle: ButtonName<Dynamic<NSAttributedString>> { return .name(Button.Binding.attributedTitle) }
	static var bezelColor: ButtonName<Dynamic<NSColor?>> { return .name(Button.Binding.bezelColor) }
	static var bezelStyle: ButtonName<Dynamic<NSButton.BezelStyle>> { return .name(Button.Binding.bezelStyle) }
	static var buttonType: ButtonName<Dynamic<NSButton.ButtonType>> { return .name(Button.Binding.buttonType) }
	static var highlight: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.highlight) }
	static var image: ButtonName<Dynamic<NSImage?>> { return .name(Button.Binding.image) }
	static var imageHugsTitle: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.imageHugsTitle) }
	static var imagePosition: ButtonName<Dynamic<NSControl.ImagePosition>> { return .name(Button.Binding.imagePosition) }
	static var imageScaling: ButtonName<Dynamic<NSImageScaling>> { return .name(Button.Binding.imageScaling) }
	static var isBordered: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.isBordered) }
	static var isSpringLoaded: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.isSpringLoaded) }
	static var isTransparent: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.isTransparent) }
	static var keyEquivalent: ButtonName<Dynamic<String>> { return .name(Button.Binding.keyEquivalent) }
	static var keyEquivalentModifierMask: ButtonName<Dynamic<NSEvent.ModifierFlags>> { return .name(Button.Binding.keyEquivalentModifierMask) }
	static var maxAcceleratorLevel: ButtonName<Dynamic<Int>> { return .name(Button.Binding.maxAcceleratorLevel) }
	static var performKeyEquivalent: ButtonName<Dynamic<NSEvent>> { return .name(Button.Binding.performKeyEquivalent) }
	static var periodicDelay: ButtonName<Dynamic<(delay: Float, interval: Float)>> { return .name(Button.Binding.periodicDelay) }
	static var showsBorderOnlyWhileMouseInside: ButtonName<Dynamic<Bool>> { return .name(Button.Binding.showsBorderOnlyWhileMouseInside) }
	static var sound: ButtonName<Dynamic<NSSound?>> { return .name(Button.Binding.sound) }
	static var state: ButtonName<Dynamic<NSControl.StateValue>> { return .name(Button.Binding.state) }
	static var title: ButtonName<Dynamic<String>> { return .name(Button.Binding.title) }

	@available(macOS 10.14, *) static var contentTintColor: ButtonName<Dynamic<NSColor?>> { return .name(Button.Binding.contentTintColor) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var setNextState: ButtonName<Signal<Void>> { return .name(Button.Binding.setNextState) }
	
	//	3. Action bindings are triggered by the object after construction.
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ButtonConvertible: ControlConvertible {
	func nsButton() -> Button.Instance
}
extension ButtonConvertible {
	public func nsControl() -> Control.Instance { return nsButton() }
}
extension NSButton: ButtonConvertible {
	public func nsButton() -> Button.Instance { return self }
}
public extension Button {
	func nsButton() -> Button.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ButtonBinding: ControlBinding {
	static func buttonBinding(_ binding: Button.Binding) -> Self
	func asButtonBinding() -> Button.Binding?
}
public extension ButtonBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return buttonBinding(.inheritedBinding(binding))
	}
}
public extension ButtonBinding where Preparer.Inherited.Binding: ButtonBinding {
	func asButtonBinding() -> Button.Binding? {
		return asInheritedBinding()?.asButtonBinding()
	}
}
public extension Button.Binding {
	typealias Preparer = Button.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asButtonBinding() -> Button.Binding? { return self }
	static func buttonBinding(_ binding: Button.Binding) -> Button.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class ClickGestureRecognizer: Binder, ClickGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ClickGestureRecognizer {
	enum Binding: ClickGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case buttonMask(Dynamic<Int>)
		case numberOfClicksRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension ClickGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = ClickGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = NSClickGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ClickGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .buttonMask(let x): return x.apply(instance) { i, v in i.buttonMask = v }
		case .numberOfClicksRequired(let x): return x.apply(instance) { i, v in i.numberOfClicksRequired = v }
			
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ClickGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ClickGestureRecognizerBinding {
	public typealias ClickGestureRecognizerName<V> = BindingName<V, ClickGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ClickGestureRecognizer.Binding) -> ClickGestureRecognizerName<V> {
		return ClickGestureRecognizerName<V>(source: source, downcast: Binding.clickGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: ClickGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ClickGestureRecognizerName<$2> { return .name(ClickGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var buttonMask: ClickGestureRecognizerName<Dynamic<Int>> { return .name(ClickGestureRecognizer.Binding.buttonMask) }
	static var numberOfClicksRequired: ClickGestureRecognizerName<Dynamic<Int>> { return .name(ClickGestureRecognizer.Binding.numberOfClicksRequired) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ClickGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsClickGestureRecognizer() -> ClickGestureRecognizer.Instance
}
extension ClickGestureRecognizerConvertible {
	public func nsGestureRecognizer() -> GestureRecognizer.Instance { return nsClickGestureRecognizer() }
}
extension NSClickGestureRecognizer: ClickGestureRecognizerConvertible {
	public func nsClickGestureRecognizer() -> ClickGestureRecognizer.Instance { return self }
}
public extension ClickGestureRecognizer {
	func nsClickGestureRecognizer() -> ClickGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ClickGestureRecognizerBinding: GestureRecognizerBinding {
	static func clickGestureRecognizerBinding(_ binding: ClickGestureRecognizer.Binding) -> Self
	func asClickGestureRecognizerBinding() -> ClickGestureRecognizer.Binding?
}
public extension ClickGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return clickGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension ClickGestureRecognizerBinding where Preparer.Inherited.Binding: ClickGestureRecognizerBinding {
	func asClickGestureRecognizerBinding() -> ClickGestureRecognizer.Binding? {
		return asInheritedBinding()?.asClickGestureRecognizerBinding()
	}
}
public extension ClickGestureRecognizer.Binding {
	typealias Preparer = ClickGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asClickGestureRecognizerBinding() -> ClickGestureRecognizer.Binding? { return self }
	static func clickGestureRecognizerBinding(_ binding: ClickGestureRecognizer.Binding) -> ClickGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class ClipView: Binder, ClipViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ClipView {
	enum Binding: ClipViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundColor(Dynamic<NSColor>)
		case bottomConstraintPriority(Dynamic<Layout.Dimension.Priority>)
		case copiesOnScroll(Dynamic<Bool>)
		case documentCursor(Dynamic<NSCursor?>)
		case documentView(Dynamic<ViewConvertible?>)
		case drawsBackground(Dynamic<Bool>)
		case trailingConstraintPriority(Dynamic<Layout.Dimension.Priority>)

		// 2. Signal bindings are performed on the object after construction.
		case scrollTo(Signal<CGPoint>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension ClipView {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = ClipView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSClipView
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ClipView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .copiesOnScroll(let x): return x.apply(instance) { i, v in i.copiesOnScroll = v }
		case .documentCursor(let x): return x.apply(instance) { i, v in i.documentCursor = v }
		case .documentView(let x): return x.apply(instance, storage) { i, s, v in
			if let view = v?.nsView() {
				view.translatesAutoresizingMaskIntoConstraints = false
				i.addSubview(view)
				s.updateConstraints(clipView: i, documentView: view)
				i.documentView = view
			} else {
				s.clearConstraints()
				i.documentView = nil
			}
		}
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .bottomConstraintPriority(let x):
			return x.apply(instance, storage) { i, s, v in
				s.bottomPriority = v
				if let documentView = i.documentView {
					s.updateConstraints(clipView: i, documentView: documentView)
				}
			}
		case .trailingConstraintPriority(let x):
			return x.apply(instance, storage) { i, s, v in
				s.trailingPriority = v
				if let documentView = i.documentView {
					s.updateConstraints(clipView: i, documentView: documentView)
				}
			}
		
		// 2. Signal bindings are performed on the object after construction.
		case .scrollTo(let x): return x.apply(instance) { i, v in i.scroll(to: v) }

		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ClipView.Preparer {
	open class Storage: View.Preparer.Storage {
		open var trailingPriority: Layout.Dimension.Priority = .dragThatCannotResizeWindow
		open var bottomPriority: Layout.Dimension.Priority = .dragThatCannotResizeWindow
		open var constraints: [NSLayoutConstraint]?
		
		open func clearConstraints() {
			guard let existingConstraints = constraints else { return }
			NSLayoutConstraint.deactivate(existingConstraints)
			constraints = nil
		}
		
		open func updateConstraints(clipView: NSClipView, documentView: NSView) {
			clearConstraints()
			
			let trailingConstraint = documentView.trailingAnchor.constraint(equalTo: clipView.trailingAnchor)
			trailingConstraint.priority = trailingPriority
			let bottomConstraint = documentView.bottomAnchor.constraint(equalTo: clipView.bottomAnchor)
			bottomConstraint.priority = bottomPriority
			let newConstraints = [
				bottomConstraint,
				trailingConstraint,
				documentView.topAnchor.constraint(equalTo: clipView.topAnchor),
				documentView.leadingAnchor.constraint(equalTo: clipView.leadingAnchor)
			]
			NSLayoutConstraint.activate(newConstraints)
			constraints = newConstraints
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ClipViewBinding {
	public typealias ClipViewName<V> = BindingName<V, ClipView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ClipView.Binding) -> ClipViewName<V> {
		return ClipViewName<V>(source: source, downcast: Binding.clipViewBinding)
	}
}
public extension BindingName where Binding: ClipViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ClipViewName<$2> { return .name(ClipView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundColor: ClipViewName<Dynamic<NSColor>> { return .name(ClipView.Binding.backgroundColor) }
	static var copiesOnScroll: ClipViewName<Dynamic<Bool>> { return .name(ClipView.Binding.copiesOnScroll) }
	static var documentCursor: ClipViewName<Dynamic<NSCursor?>> { return .name(ClipView.Binding.documentCursor) }
	static var documentView: ClipViewName<Dynamic<ViewConvertible?>> { return .name(ClipView.Binding.documentView) }
	static var drawsBackground: ClipViewName<Dynamic<Bool>> { return .name(ClipView.Binding.drawsBackground) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var scrollTo: ClipViewName<Signal<CGPoint>> { return .name(ClipView.Binding.scrollTo) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ClipViewConvertible: ViewConvertible {
	func nsClipView() -> ClipView.Instance
}
extension ClipViewConvertible {
	public func nsView() -> View.Instance { return nsClipView() }
}
extension NSClipView: ClipViewConvertible {
	public func nsClipView() -> ClipView.Instance { return self }
}
public extension ClipView {
	func nsClipView() -> ClipView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ClipViewBinding: ViewBinding {
	static func clipViewBinding(_ binding: ClipView.Binding) -> Self
	func asClipViewBinding() -> ClipView.Binding?
}
public extension ClipViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return clipViewBinding(.inheritedBinding(binding))
	}
}
public extension ClipViewBinding where Preparer.Inherited.Binding: ClipViewBinding {
	func asClipViewBinding() -> ClipView.Binding? {
		return asInheritedBinding()?.asClipViewBinding()
	}
}
public extension ClipView.Binding {
	typealias Preparer = ClipView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asClipViewBinding() -> ClipView.Binding? { return self }
	static func clipViewBinding(_ binding: ClipView.Binding) -> ClipView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class Control: Binder, ControlConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Control {
	enum Binding: ControlBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case alignment(Dynamic<NSTextAlignment>)
		case allowsExpansionToolTips(Dynamic<Bool>)
		case attributedStringValue(Dynamic<NSAttributedString>)
		case baseWritingDirection(Dynamic<NSWritingDirection>)
		case doubleValue(Dynamic<Double>)
		case floatValue(Dynamic<Float>)
		case font(Dynamic<NSFont>)
		case formatter(Dynamic<Foundation.Formatter?>)
		case ignoresMultiClick(Dynamic<Bool>)
		case integerValue(Dynamic<Int>)
		case intValue(Dynamic<Int32>)
		case isContinuous(Dynamic<Bool>)
		case isEnabled(Dynamic<Bool>)
		case isHighlighted(Dynamic<Bool>)
		case lineBreakMode(Dynamic<NSLineBreakMode>)
		case objectValue(Dynamic<Any>)
		case refusesFirstResponder(Dynamic<Bool>)
		case sendActionOn(Dynamic<NSEvent.EventTypeMask>)
		case size(Dynamic<NSControl.ControlSize>)
		case stringValue(Dynamic<String>)
		case tag(Dynamic<Int>)
		case usesSingleLineMode(Dynamic<Bool>)
		
		//	2. Signal bindings are performed on the object after construction.
		case abortEditing(Signal<Void>)
		case performClick(Signal<Void>)
		case sizeToFit(Signal<Void>)
		case validateEditing(Signal<Void>)
		
		//	3. Action bindings are triggered by the object after construction.
		case action(TargetAction)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case textDidBeginEditing((NSText) -> Void)
		case textDidChange((NSText) -> Void)
		case textDidEndEditing((NSText) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension Control {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = Control.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSControl
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Control.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .alignment(let x): return x.apply(instance) { i, v in i.alignment = v }
		case .allowsExpansionToolTips(let x): return x.apply(instance) { i, v in i.allowsExpansionToolTips = v }
		case .attributedStringValue(let x): return x.apply(instance) { i, v in i.attributedStringValue = v }
		case .baseWritingDirection(let x): return x.apply(instance) { i, v in i.baseWritingDirection = v }
		case .doubleValue(let x): return x.apply(instance) { i, v in i.doubleValue = v }
		case .floatValue(let x): return x.apply(instance) { i, v in i.floatValue = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .formatter(let x): return x.apply(instance) { i, v in i.formatter = v }
		case .ignoresMultiClick(let x): return x.apply(instance) { i, v in i.ignoresMultiClick = v }
		case .integerValue(let x): return x.apply(instance) { i, v in i.integerValue = v }
		case .intValue(let x): return x.apply(instance) { i, v in i.intValue = v }
		case .isContinuous(let x): return x.apply(instance) { i, v in i.isContinuous = v }
		case .isEnabled(let x): return x.apply(instance, storage, false) { i, s, v in i.isEnabled = v }
		case .isHighlighted(let x): return x.apply(instance) { i, v in i.isHighlighted = v }
		case .lineBreakMode(let x): return x.apply(instance) { i, v in i.lineBreakMode = v }
		case .objectValue(let x): return x.apply(instance) { i, v in i.objectValue = v }
		case .refusesFirstResponder(let x): return x.apply(instance) { i, v in i.refusesFirstResponder = v }
		case .sendActionOn(let x): return x.apply(instance) { i, v in _ = i.sendAction(on: v) }
		case .size(let x): return x.apply(instance) { i, v in i.controlSize = v }
		case .stringValue(let x): return x.apply(instance) { i, v in i.stringValue = v }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .usesSingleLineMode(let x): return x.apply(instance) { i, v in i.usesSingleLineMode = v }
			
		//	2. Signal bindings are performed on the object after construction.
		case .abortEditing(let x): return x.apply(instance) { i, v in i.abortEditing() }
		case .performClick(let x): return x.apply(instance) { i, v in i.performClick(nil) }
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }
		case .validateEditing(let x): return x.apply(instance) { i, v in i.validateEditing() }
			
		//	3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: SignalActionTarget.init)
			
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case .textDidBeginEditing(let x):
			return Signal.notifications(name: NSControl.textDidBeginEditingNotification, object: instance).compactMap { n in
				return n.userInfo?["NSFieldEditor"] as? NSText
			}.subscribeValues { x($0) }
		case .textDidChange(let x):
			return Signal.notifications(name: NSControl.textDidChangeNotification, object: instance).compactMap { n in
				return n.userInfo?["NSFieldEditor"] as? NSText
			}.subscribeValues { x($0) }
		case .textDidEndEditing(let x):
			return Signal.notifications(name: NSControl.textDidEndEditingNotification, object: instance).compactMap { n in
				return n.userInfo?["NSFieldEditor"] as? NSText
			}.subscribeValues { x($0) }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Control.Preparer {
	public typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ControlBinding {
	public typealias ControlName<V> = BindingName<V, Control.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Control.Binding) -> ControlName<V> {
		return ControlName<V>(source: source, downcast: Binding.controlBinding)
	}
}
public extension BindingName where Binding: ControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ControlName<$2> { return .name(Control.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var alignment: ControlName<Dynamic<NSTextAlignment>> { return .name(Control.Binding.alignment) }
	static var allowsExpansionToolTips: ControlName<Dynamic<Bool>> { return .name(Control.Binding.allowsExpansionToolTips) }
	static var attributedStringValue: ControlName<Dynamic<NSAttributedString>> { return .name(Control.Binding.attributedStringValue) }
	static var baseWritingDirection: ControlName<Dynamic<NSWritingDirection>> { return .name(Control.Binding.baseWritingDirection) }
	static var doubleValue: ControlName<Dynamic<Double>> { return .name(Control.Binding.doubleValue) }
	static var floatValue: ControlName<Dynamic<Float>> { return .name(Control.Binding.floatValue) }
	static var font: ControlName<Dynamic<NSFont>> { return .name(Control.Binding.font) }
	static var formatter: ControlName<Dynamic<Foundation.Formatter?>> { return .name(Control.Binding.formatter) }
	static var ignoresMultiClick: ControlName<Dynamic<Bool>> { return .name(Control.Binding.ignoresMultiClick) }
	static var integerValue: ControlName<Dynamic<Int>> { return .name(Control.Binding.integerValue) }
	static var intValue: ControlName<Dynamic<Int32>> { return .name(Control.Binding.intValue) }
	static var isContinuous: ControlName<Dynamic<Bool>> { return .name(Control.Binding.isContinuous) }
	static var isEnabled: ControlName<Dynamic<Bool>> { return .name(Control.Binding.isEnabled) }
	static var isHighlighted: ControlName<Dynamic<Bool>> { return .name(Control.Binding.isHighlighted) }
	static var lineBreakMode: ControlName<Dynamic<NSLineBreakMode>> { return .name(Control.Binding.lineBreakMode) }
	static var objectValue: ControlName<Dynamic<Any>> { return .name(Control.Binding.objectValue) }
	static var refusesFirstResponder: ControlName<Dynamic<Bool>> { return .name(Control.Binding.refusesFirstResponder) }
	static var sendActionOn: ControlName<Dynamic<NSEvent.EventTypeMask>> { return .name(Control.Binding.sendActionOn) }
	static var size: ControlName<Dynamic<NSControl.ControlSize>> { return .name(Control.Binding.size) }
	static var stringValue: ControlName<Dynamic<String>> { return .name(Control.Binding.stringValue) }
	static var tag: ControlName<Dynamic<Int>> { return .name(Control.Binding.tag) }
	static var usesSingleLineMode: ControlName<Dynamic<Bool>> { return .name(Control.Binding.usesSingleLineMode) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var abortEditing: ControlName<Signal<Void>> { return .name(Control.Binding.abortEditing) }
	static var performClick: ControlName<Signal<Void>> { return .name(Control.Binding.performClick) }
	static var sizeToFit: ControlName<Signal<Void>> { return .name(Control.Binding.sizeToFit) }
	static var validateEditing: ControlName<Signal<Void>> { return .name(Control.Binding.validateEditing) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var action: ControlName<TargetAction> { return .name(Control.Binding.action) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var textDidBeginEditing: ControlName<(NSText) -> Void> { return .name(Control.Binding.textDidBeginEditing) }
	static var textDidChange: ControlName<(NSText) -> Void> { return .name(Control.Binding.textDidChange) }
	static var textDidEndEditing: ControlName<(NSText) -> Void> { return .name(Control.Binding.textDidEndEditing) }

	// Composite binding names
	static func action( _ void: Void = ()) -> ControlName<SignalInput<Void>> {
		return Binding.compositeName(
			value: { input in
				TargetAction.singleTarget(
					Input<Any?>().map { _ in () }.bind(to: input)
				)
			},
			binding: Control.Binding.action,
			downcast: Binding.controlBinding
		)
	}
	static func action<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> ControlName<SignalInput<Value>> {
		return Binding.keyPathActionName(keyPath, Control.Binding.action, Binding.controlBinding)
	}
	static func stringChanged(_ void: Void = ()) -> ControlName<SignalInput<String>> {
		return Binding.compositeName(
			value: { input in { text in _ = input.send(value: text.string) } },
			binding: Control.Binding.textDidChange,
			downcast: Binding.controlBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ControlConvertible: ViewConvertible {
	func nsControl() -> Control.Instance
}
extension ControlConvertible {
	public func nsView() -> View.Instance { return nsControl() }
}
extension NSControl: ControlConvertible, TargetActionSender {
	public func nsControl() -> Control.Instance { return self }
}
public extension Control {
	func nsControl() -> Control.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ControlBinding: ViewBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self
	func asControlBinding() -> Control.Binding?
}
public extension ControlBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return controlBinding(.inheritedBinding(binding))
	}
}
public extension ControlBinding where Preparer.Inherited.Binding: ControlBinding {
	func asControlBinding() -> Control.Binding? {
		return asInheritedBinding()?.asControlBinding()
	}
}
public extension Control.Binding {
	typealias Preparer = Control.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asControlBinding() -> Control.Binding? { return self }
	static func controlBinding(_ binding: Control.Binding) -> Control.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class GestureRecognizer: Binder, GestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension GestureRecognizer {
	enum Binding: GestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowedTouchTypes(Dynamic<NSTouch.TouchTypeMask>)
		case pressureConfiguration(Dynamic<NSPressureConfiguration>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case action(TargetAction)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldAttemptToRecognize((NSGestureRecognizer, NSEvent) -> Bool)
		case shouldBegin((NSGestureRecognizer) -> Bool)
		case shouldRecognizeSimultaneously((NSGestureRecognizer, NSGestureRecognizer) -> Bool)
		case shouldRequireFailure((NSGestureRecognizer, NSGestureRecognizer) -> Bool)
		case shouldRequireToFail((NSGestureRecognizer, NSGestureRecognizer) -> Bool)
		case shouldReceiveTouch((NSGestureRecognizer, NSTouch) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
public extension GestureRecognizer {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = GestureRecognizer.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = NSGestureRecognizer
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension GestureRecognizer.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		case .shouldBegin(let x): delegate().addSingleHandler1(x, #selector(NSGestureRecognizerDelegate.gestureRecognizerShouldBegin(_:)))
		case .shouldRecognizeSimultaneously(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:)))
		case .shouldRequireFailure(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldRequireFailureOf:)))
		case .shouldRequireToFail(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldBeRequiredToFailBy:)))
		case .shouldAttemptToRecognize(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldAttemptToRecognizeWith:)))
		case .shouldReceiveTouch(let x): delegate().addSingleHandler2(x, #selector(NSGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:)))
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowedTouchTypes(let x): return x.apply(instance) { i, v in i.allowedTouchTypes = v }
		case .pressureConfiguration(let x): return x.apply(instance) { i, v in i.pressureConfiguration = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: SignalActionTarget.init)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldAttemptToRecognize: return nil
		case .shouldBegin: return nil
		case .shouldRecognizeSimultaneously: return nil
		case .shouldRequireFailure: return nil
		case .shouldRequireToFail: return nil
		
		case .shouldReceiveTouch: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension GestureRecognizer.Preparer {
	open class Storage: AssociatedBinderStorage, NSGestureRecognizerDelegate {}
	
	open class Delegate: DynamicDelegate, NSGestureRecognizerDelegate {
		open func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldAttemptToRecognizeWith event: NSEvent) -> Bool {
			return singleHandler(gestureRecognizer, event)
		}
		
		open func gestureRecognizerShouldBegin(_ gestureRecognizer: NSGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer)
		}
		
		open func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: NSGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		open func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: NSGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		@objc(gestureRecognizer: shouldBeRequiredToFailByGestureRecognizer:) open func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: NSGestureRecognizer) -> Bool {
			return singleHandler(gestureRecognizer, otherGestureRecognizer)
		}
		
		open func gestureRecognizer(_ gestureRecognizer: NSGestureRecognizer, shouldReceive touch: NSTouch) -> Bool {
			return singleHandler(gestureRecognizer, touch)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: GestureRecognizerBinding {
	public typealias GestureRecognizerName<V> = BindingName<V, GestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> GestureRecognizer.Binding) -> GestureRecognizerName<V> {
		return GestureRecognizerName<V>(source: source, downcast: Binding.gestureRecognizerBinding)
	}
}
public extension BindingName where Binding: GestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: GestureRecognizerName<$2> { return .name(GestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowedTouchTypes: GestureRecognizerName<Dynamic<NSTouch.TouchTypeMask>> { return .name(GestureRecognizer.Binding.allowedTouchTypes) }
	static var pressureConfiguration: GestureRecognizerName<Dynamic<NSPressureConfiguration>> { return .name(GestureRecognizer.Binding.pressureConfiguration) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: GestureRecognizerName<TargetAction> { return .name(GestureRecognizer.Binding.action) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldAttemptToRecognize: GestureRecognizerName<(NSGestureRecognizer, NSEvent) -> Bool> { return .name(GestureRecognizer.Binding.shouldAttemptToRecognize) }
	static var shouldBegin: GestureRecognizerName<(NSGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldBegin) }
	static var shouldRecognizeSimultaneously: GestureRecognizerName<(NSGestureRecognizer, NSGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldRecognizeSimultaneously) }
	static var shouldRequireFailure: GestureRecognizerName<(NSGestureRecognizer, NSGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldRequireFailure) }
	static var shouldRequireToFail: GestureRecognizerName<(NSGestureRecognizer, NSGestureRecognizer) -> Bool> { return .name(GestureRecognizer.Binding.shouldRequireToFail) }
	static var shouldReceiveTouch: GestureRecognizerName<(NSGestureRecognizer, NSTouch) -> Bool> { return .name(GestureRecognizer.Binding.shouldReceiveTouch) }

	// Composite binding names
	static func action<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> GestureRecognizerName<SignalInput<Value>> {
		return Binding.keyPathActionName(keyPath, GestureRecognizer.Binding.action, Binding.gestureRecognizerBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol GestureRecognizerConvertible {
	func nsGestureRecognizer() -> GestureRecognizer.Instance
}
extension NSGestureRecognizer: GestureRecognizerConvertible, TargetActionSender, DefaultConstructable, HasDelegate {
	public func nsGestureRecognizer() -> GestureRecognizer.Instance { return self }
}
public extension GestureRecognizer {
	func nsGestureRecognizer() -> GestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol GestureRecognizerBinding: BinderBaseBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self
	func asGestureRecognizerBinding() -> GestureRecognizer.Binding?
}
public extension GestureRecognizerBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return gestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension GestureRecognizerBinding where Preparer.Inherited.Binding: GestureRecognizerBinding {
	func asGestureRecognizerBinding() -> GestureRecognizer.Binding? {
		return asInheritedBinding()?.asGestureRecognizerBinding()
	}
}
public extension GestureRecognizer.Binding {
	typealias Preparer = GestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asGestureRecognizerBinding() -> GestureRecognizer.Binding? { return self }
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> GestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class ImageView: Binder, ImageViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ImageView {
	enum Binding: ImageViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsCutCopyPaste(Dynamic<Bool>)
		case animates(Dynamic<Bool>)
		case image(Dynamic<NSImage?>)
		case imageAlignment(Dynamic<NSImageAlignment>)
		case imageFrameStyle(Dynamic<NSImageView.FrameStyle>)
		case imageScaling(Dynamic<NSImageScaling>)
		case isEditable(Dynamic<Bool>)
		@available(macOS 10.14, *) case contentTintColor(Dynamic<NSColor?>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension ImageView {
	struct Preparer: BinderEmbedderConstructor /* or BinderDelegateEmbedderConstructor */ {
		public typealias Binding = ImageView.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = NSImageView
		
		public var inherited = Inherited()
		public init() {}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ImageView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .allowsCutCopyPaste(let x): return x.apply(instance) { i, v in i.allowsCutCopyPaste = v }
		case .animates(let x): return x.apply(instance) { i, v in i.animates = v }
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .imageAlignment(let x): return x.apply(instance) { i, v in i.imageAlignment = v }
		case .imageFrameStyle(let x): return x.apply(instance) { i, v in i.imageFrameStyle = v }
		case .imageScaling(let x): return x.apply(instance) { i, v in i.imageScaling = v }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .contentTintColor(let x):
			return x.apply(instance) { i, v in
				if #available(OSX 10.14, *) {
					i.contentTintColor = v
				}
			}
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ImageView.Preparer {
	public typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ImageViewBinding {
	public typealias ImageViewName<V> = BindingName<V, ImageView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ImageView.Binding) -> ImageViewName<V> {
		return ImageViewName<V>(source: source, downcast: Binding.imageViewBinding)
	}
}
public extension BindingName where Binding: ImageViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ImageViewName<$2> { return .name(ImageView.Binding.$1) }
	static var allowsCutCopyPaste: ImageViewName<Dynamic<Bool>> { return .name(ImageView.Binding.allowsCutCopyPaste) }
	static var animates: ImageViewName<Dynamic<Bool>> { return .name(ImageView.Binding.animates) }
	static var image: ImageViewName<Dynamic<NSImage?>> { return .name(ImageView.Binding.image) }
	static var imageAlignment: ImageViewName<Dynamic<NSImageAlignment>> { return .name(ImageView.Binding.imageAlignment) }
	static var imageFrameStyle: ImageViewName<Dynamic<NSImageView.FrameStyle>> { return .name(ImageView.Binding.imageFrameStyle) }
	static var imageScaling: ImageViewName<Dynamic<NSImageScaling>> { return .name(ImageView.Binding.imageScaling) }
	static var isEditable: ImageViewName<Dynamic<Bool>> { return .name(ImageView.Binding.isEditable) }
	@available(macOS 10.14, *) static var contentTintColor: ImageViewName<Dynamic<NSColor?>> { return .name(ImageView.Binding.contentTintColor) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ImageViewConvertible: ControlConvertible {
	func nsImageView() -> ImageView.Instance
}
extension ImageViewConvertible {
	public func nsControl() -> Control.Instance { return nsImageView() }
}
extension NSImageView: ImageViewConvertible /* , HasDelegate // if Preparer is BinderDelegateEmbedderConstructor */ {
	public func nsImageView() -> ImageView.Instance { return self }
}
public extension ImageView {
	func nsImageView() -> ImageView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ImageViewBinding: ControlBinding {
	static func imageViewBinding(_ binding: ImageView.Binding) -> Self
	func asImageViewBinding() -> ImageView.Binding?
}
public extension ImageViewBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return imageViewBinding(.inheritedBinding(binding))
	}
}
public extension ImageViewBinding where Preparer.Inherited.Binding: ImageViewBinding {
	func asImageViewBinding() -> ImageView.Binding? {
		return asInheritedBinding()?.asImageViewBinding()
	}
}
public extension ImageView.Binding {
	typealias Preparer = ImageView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asImageViewBinding() -> ImageView.Binding? { return self }
	static func imageViewBinding(_ binding: ImageView.Binding) -> ImageView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class MagnificationGestureRecognizer: Binder, MagnificationGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension MagnificationGestureRecognizer {
	enum Binding: MagnificationGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case magnification(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension MagnificationGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = MagnificationGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = NSMagnificationGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension MagnificationGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .magnification(let x): return x.apply(instance) { i, v in i.magnification = v }
			
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension MagnificationGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: MagnificationGestureRecognizerBinding {
	public typealias MagnificationGestureRecognizerName<V> = BindingName<V, MagnificationGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> MagnificationGestureRecognizer.Binding) -> MagnificationGestureRecognizerName<V> {
		return MagnificationGestureRecognizerName<V>(source: source, downcast: Binding.magnificationGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: MagnificationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: MagnificationGestureRecognizerName<$2> { return .name(MagnificationGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var magnification: MagnificationGestureRecognizerName<Dynamic<CGFloat>> { return .name(MagnificationGestureRecognizer.Binding.magnification) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol MagnificationGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsMagnificationGestureRecognizer() -> MagnificationGestureRecognizer.Instance
}
extension MagnificationGestureRecognizerConvertible {
	public func nsGestureRecognizer() -> GestureRecognizer.Instance { return nsMagnificationGestureRecognizer() }
}
extension NSMagnificationGestureRecognizer: MagnificationGestureRecognizerConvertible {
	public func nsMagnificationGestureRecognizer() -> MagnificationGestureRecognizer.Instance { return self }
}
public extension MagnificationGestureRecognizer {
	func nsMagnificationGestureRecognizer() -> MagnificationGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol MagnificationGestureRecognizerBinding: GestureRecognizerBinding {
	static func magnificationGestureRecognizerBinding(_ binding: MagnificationGestureRecognizer.Binding) -> Self
	func asMagnificationGestureRecognizerBinding() -> MagnificationGestureRecognizer.Binding?
}
public extension MagnificationGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return magnificationGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension MagnificationGestureRecognizerBinding where Preparer.Inherited.Binding: MagnificationGestureRecognizerBinding {
	func asMagnificationGestureRecognizerBinding() -> MagnificationGestureRecognizer.Binding? {
		return asInheritedBinding()?.asMagnificationGestureRecognizerBinding()
	}
}
public extension MagnificationGestureRecognizer.Binding {
	typealias Preparer = MagnificationGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asMagnificationGestureRecognizerBinding() -> MagnificationGestureRecognizer.Binding? { return self }
	static func magnificationGestureRecognizerBinding(_ binding: MagnificationGestureRecognizer.Binding) -> MagnificationGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class MenuItem: Binder, MenuItemConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension MenuItem {
	enum Binding: MenuItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)
		case isHidden(Dynamic<Bool>)
		case isAlternate(Dynamic<Bool>)
		case title(Dynamic<String>)
		case attributedTitle(Dynamic<NSAttributedString?>)
		case tag(Dynamic<Int>)
		case representedObject(Dynamic<AnyObject?>)
		case state(Dynamic<NSControl.StateValue>)
		case indentationLevel(Dynamic<Int>)
		case image(Dynamic<NSImage?>)
		case onStateImage(Dynamic<NSImage?>)
		case offStateImage(Dynamic<NSImage?>)
		case mixedStateImage(Dynamic<NSImage?>)
		case submenu(Dynamic<MenuConvertible?>)
		case keyEquivalent(Dynamic<String>)
		case keyEquivalentModifierMask(Dynamic<NSEvent.ModifierFlags>)
		case toolTip(Dynamic<String?>)
		case view(Dynamic<ViewConvertible?>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case action(TargetAction)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension MenuItem {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = MenuItem.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = NSMenuItem
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension MenuItem.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .attributedTitle(let x): return x.apply(instance) { i, v in i.attributedTitle = v }
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .indentationLevel(let x): return x.apply(instance) { i, v in i.indentationLevel = v }
		case .isAlternate(let x): return x.apply(instance) { i, v in i.isAlternate = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .keyEquivalent(let x): return x.apply(instance) { i, v in i.keyEquivalent = v }
		case .keyEquivalentModifierMask(let x): return x.apply(instance) { i, v in i.keyEquivalentModifierMask = v }
		case .mixedStateImage(let x): return x.apply(instance) { i, v in i.mixedStateImage = v }
		case .offStateImage(let x): return x.apply(instance) { i, v in i.offStateImage = v }
		case .onStateImage(let x): return x.apply(instance) { i, v in i.onStateImage = v }
		case .representedObject(let x): return x.apply(instance) { i, v in i.representedObject = v }
		case .state(let x): return x.apply(instance) { i, v in i.state = v }
		case .submenu(let x): return x.apply(instance) { i, v in i.submenu = v?.nsMenu() }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .toolTip(let x): return x.apply(instance) { i, v in i.toolTip = v }
		case .view(let x): return x.apply(instance) { i, v in i.view = v?.nsView() }

		// 2. Signal bindings are performed on the object after construction.
			
		// 3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: SignalActionTarget.init)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension MenuItem.Preparer {
	public typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: MenuItemBinding {
	public typealias MenuItemName<V> = BindingName<V, MenuItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> MenuItem.Binding) -> MenuItemName<V> {
		return MenuItemName<V>(source: source, downcast: Binding.menuItemBinding)
	}
}
public extension BindingName where Binding: MenuItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: MenuItemName<$2> { return .name(MenuItem.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var isEnabled: MenuItemName<Dynamic<Bool>> { return .name(MenuItem.Binding.isEnabled) }
	static var isHidden: MenuItemName<Dynamic<Bool>> { return .name(MenuItem.Binding.isHidden) }
	static var isAlternate: MenuItemName<Dynamic<Bool>> { return .name(MenuItem.Binding.isAlternate) }
	static var title: MenuItemName<Dynamic<String>> { return .name(MenuItem.Binding.title) }
	static var attributedTitle: MenuItemName<Dynamic<NSAttributedString?>> { return .name(MenuItem.Binding.attributedTitle) }
	static var tag: MenuItemName<Dynamic<Int>> { return .name(MenuItem.Binding.tag) }
	static var representedObject: MenuItemName<Dynamic<AnyObject?>> { return .name(MenuItem.Binding.representedObject) }
	static var state: MenuItemName<Dynamic<NSControl.StateValue>> { return .name(MenuItem.Binding.state) }
	static var indentationLevel: MenuItemName<Dynamic<Int>> { return .name(MenuItem.Binding.indentationLevel) }
	static var image: MenuItemName<Dynamic<NSImage?>> { return .name(MenuItem.Binding.image) }
	static var onStateImage: MenuItemName<Dynamic<NSImage?>> { return .name(MenuItem.Binding.onStateImage) }
	static var offStateImage: MenuItemName<Dynamic<NSImage?>> { return .name(MenuItem.Binding.offStateImage) }
	static var mixedStateImage: MenuItemName<Dynamic<NSImage?>> { return .name(MenuItem.Binding.mixedStateImage) }
	static var submenu: MenuItemName<Dynamic<MenuConvertible?>> { return .name(MenuItem.Binding.submenu) }
	static var keyEquivalent: MenuItemName<Dynamic<String>> { return .name(MenuItem.Binding.keyEquivalent) }
	static var keyEquivalentModifierMask: MenuItemName<Dynamic<NSEvent.ModifierFlags>> { return .name(MenuItem.Binding.keyEquivalentModifierMask) }
	static var toolTip: MenuItemName<Dynamic<String?>> { return .name(MenuItem.Binding.toolTip) }
	static var view: MenuItemName<Dynamic<ViewConvertible?>> { return .name(MenuItem.Binding.view) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: MenuItemName<TargetAction> { return .name(MenuItem.Binding.action) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.

	// Composite binding names
	static func action<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> MenuItemName<SignalInput<Value>> {
		return Binding.keyPathActionName(keyPath, MenuItem.Binding.action, Binding.menuItemBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol MenuItemConvertible {
	func nsMenuItem() -> MenuItem.Instance
}
extension NSMenuItem: MenuItemConvertible, DefaultConstructable, TargetActionSender {
	public func nsMenuItem() -> MenuItem.Instance { return self }
}
public extension MenuItem {
	func nsMenuItem() -> MenuItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol MenuItemBinding: BinderBaseBinding {
	static func menuItemBinding(_ binding: MenuItem.Binding) -> Self
	func asMenuItemBinding() -> MenuItem.Binding?
}
public extension MenuItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return menuItemBinding(.inheritedBinding(binding))
	}
}
public extension MenuItemBinding where Preparer.Inherited.Binding: MenuItemBinding {
	func asMenuItemBinding() -> MenuItem.Binding? {
		return asInheritedBinding()?.asMenuItemBinding()
	}
}
public extension MenuItem.Binding {
	typealias Preparer = MenuItem.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asMenuItemBinding() -> MenuItem.Binding? { return self }
	static func menuItemBinding(_ binding: MenuItem.Binding) -> MenuItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class Menu: Binder, MenuConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Menu {
	enum Binding: MenuBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case systemName(Constant<SystemMenu>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsContextMenuPlugIns(Dynamic<Bool>)
		case autoenablesItems(Dynamic<Bool>)
		case font(Dynamic<NSFont>)
		case items(Dynamic<[MenuItemConvertible]>)
		case minimumWidth(Dynamic<CGFloat>)
		case showsStateColumn(Dynamic<Bool>)
		case title(Dynamic<String>)
		case userInterfaceLayoutDirection(Dynamic<NSUserInterfaceLayoutDirection>)

		// 2. Signal bindings are performed on the object after construction.
		case cancelTracking(Signal<Void>)
		case cancelTrackingWithoutAnimation(Signal<Void>)
		case performAction(Signal<Int>)
		case popUp(Signal<(item: Int, at: NSPoint, in: NSView?)>)
		case popUpContextMenu(Signal<(with: NSEvent, for: NSView)>)
		
		// 3. Action bindings are triggered by the object after construction.
		case didBeginTracking(SignalInput<Void>)
		case didEndTracking(SignalInput<Void>)
		case didSendAction(SignalInput<Int>)
		case willSendAction(SignalInput<Int>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case confinementRect((_ menu: NSMenu, _ screen: NSScreen?) -> NSRect)
		case didClose((_ menu: NSMenu) -> Void)
		case willHighlight((_ menu: NSMenu, _ item: NSMenuItem?, _ index: Int?) -> Void)
		case willOpen((_ menu: NSMenu) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension Menu {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = Menu.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = NSMenu
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var systemName: SystemMenu?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Menu.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance {
		let x: NSMenu
		if let sn = systemName {
			let name = sn.rawValue
			let codingProxy = MenuCodingProxy(name: name)
			let archiver = NSKeyedArchiver(requiringSecureCoding: false)
			archiver.setClassName(NSStringFromClass(type), for: MenuCodingProxy.self)
			archiver.outputFormat = .binary
			archiver.encode(codingProxy, forKey: NSKeyedArchiveRootObjectKey)
			archiver.finishEncoding()

			x = (try? NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(archiver.encodedData) as? NSMenu) ?? NSMenu()
		} else {
			x = type.init()
		}
		return x
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .confinementRect(let x): delegate().addSingleHandler2(x, #selector(NSMenuDelegate.confinementRect(for:on:)))
		case .didClose(let x): delegate().addMultiHandler1(x, #selector(NSMenuDelegate.menuDidClose(_:)))
		case .systemName(let x): systemName = x.value
		case .willHighlight(let x): delegate().addMultiHandler3(x, #selector(NSMenuDelegate.menu(_:willHighlight:)))
		case .willOpen(let x): delegate().addMultiHandler1(x, #selector(NSMenuDelegate.menuWillOpen(_:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .systemName: return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsContextMenuPlugIns(let x): return x.apply(instance) { i, v in i.allowsContextMenuPlugIns = v }
		case .autoenablesItems(let x): return x.apply(instance) { i, v in i.autoenablesItems = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .items(let x):
			return x.apply(instance) { i, v in
				i.removeAllItems()
				v.forEach { i.addItem($0.nsMenuItem()) }
			}
		case .minimumWidth(let x): return x.apply(instance) { i, v in i.minimumWidth = v }
		case .showsStateColumn(let x): return x.apply(instance) { i, v in i.showsStateColumn = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .userInterfaceLayoutDirection(let x): return x.apply(instance) { i, v in i.userInterfaceLayoutDirection = v }
		
		// 2. Signal bindings are performed on the object after construction.
		case .cancelTracking(let x): return x.apply(instance) { i, v in i.cancelTracking() }
		case .cancelTrackingWithoutAnimation(let x): return x.apply(instance) { i, v in i.cancelTrackingWithoutAnimation() }
		case .performAction(let x): return x.apply(instance) { i, v in i.performActionForItem(at: v) }
		case .popUp(let x):
			return x.apply(instance) { i, v in
				let item = v.item >= 0 ? (i.items.at(v.item) ?? i.items.last) : i.items.first
				i.popUp(positioning: item, at: v.at, in: v.in)
			}
		case .popUpContextMenu(let x): return x.apply(instance) { i, v in NSMenu.popUpContextMenu(i, with: v.with, for: v.for) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didBeginTracking(let x):
			return Signal.notifications(name: NSMenu.didBeginTrackingNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didClose: return nil
		case .didEndTracking(let x):
			return Signal.notifications(name: NSMenu.didEndTrackingNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didSendAction(let x):
			return Signal.notifications(name: NSMenu.didSendActionNotification, object: instance).compactMap { n -> Int? in
				if let menuItem = n.userInfo?["MenuItem"] as? NSMenuItem, let menu = menuItem.menu, let index = menu.items.firstIndex(where: { i in i == menuItem }) {
					return index
				}
				return nil
				}.cancellableBind(to: x)
		case .willHighlight: return nil
		case .willOpen: return nil
		case .willSendAction(let x):
			return Signal.notifications(name: NSMenu.willSendActionNotification, object: instance).compactMap { n -> Int? in
				if let menuItem = n.userInfo?["MenuItem"] as? NSMenuItem, let menu = menuItem.menu, let index = menu.items.firstIndex(of: menuItem) {
					return index
				}
				return nil
			}.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .confinementRect: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Menu.Preparer {
	open class Storage: AssociatedBinderStorage, NSMenuDelegate {}

	open class Delegate: DynamicDelegate, NSMenuDelegate {
		open func menuWillOpen(_ menu: NSMenu) {
			multiHandler(menu)
		}
		
		open func menuDidClose(_ menu: NSMenu) {
			multiHandler(menu)
		}
		
		open func confinementRect(for menu: NSMenu, on screen: NSScreen?) -> NSRect {
			return singleHandler(menu, screen)
		}
		
		open func menu(_ menu: NSMenu, willHighlight menuItem: NSMenuItem?) {
			let match = menuItem.flatMap { item in menu.items.enumerated().first { offset, element in item == element } }
			multiHandler(menu, menuItem, match?.offset)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: MenuBinding {
	public typealias MenuName<V> = BindingName<V, Menu.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Menu.Binding) -> MenuName<V> {
		return MenuName<V>(source: source, downcast: Binding.menuBinding)
	}
}
public extension BindingName where Binding: MenuBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: MenuName<$2> { return .name(Menu.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var systemName: MenuName<Constant<SystemMenu>> { return .name(Menu.Binding.systemName) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsContextMenuPlugIns: MenuName<Dynamic<Bool>> { return .name(Menu.Binding.allowsContextMenuPlugIns) }
	static var autoenablesItems: MenuName<Dynamic<Bool>> { return .name(Menu.Binding.autoenablesItems) }
	static var font: MenuName<Dynamic<NSFont>> { return .name(Menu.Binding.font) }
	static var items: MenuName<Dynamic<[MenuItemConvertible]>> { return .name(Menu.Binding.items) }
	static var minimumWidth: MenuName<Dynamic<CGFloat>> { return .name(Menu.Binding.minimumWidth) }
	static var showsStateColumn: MenuName<Dynamic<Bool>> { return .name(Menu.Binding.showsStateColumn) }
	static var title: MenuName<Dynamic<String>> { return .name(Menu.Binding.title) }
	static var userInterfaceLayoutDirection: MenuName<Dynamic<NSUserInterfaceLayoutDirection>> { return .name(Menu.Binding.userInterfaceLayoutDirection) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var popUpContextMenu: MenuName<Signal<(with: NSEvent, for: NSView)>> { return .name(Menu.Binding.popUpContextMenu) }
	static var popUp: MenuName<Signal<(item: Int, at: NSPoint, in: NSView?)>> { return .name(Menu.Binding.popUp) }
	static var performAction: MenuName<Signal<Int>> { return .name(Menu.Binding.performAction) }
	static var cancelTracking: MenuName<Signal<Void>> { return .name(Menu.Binding.cancelTracking) }
	static var cancelTrackingWithoutAnimation: MenuName<Signal<Void>> { return .name(Menu.Binding.cancelTrackingWithoutAnimation) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var willOpen: MenuName<(NSMenu) -> Void> { return .name(Menu.Binding.willOpen) }
	static var didClose: MenuName<(NSMenu) -> Void> { return .name(Menu.Binding.didClose) }
	static var didBeginTracking: MenuName<SignalInput<Void>> { return .name(Menu.Binding.didBeginTracking) }
	static var didEndTracking: MenuName<SignalInput<Void>> { return .name(Menu.Binding.didEndTracking) }
	static var willHighlight: MenuName<(NSMenu, NSMenuItem?, Int?) -> Void> { return .name(Menu.Binding.willHighlight) }
	static var willSendAction: MenuName<SignalInput<Int>> { return .name(Menu.Binding.willSendAction) }
	static var didSendAction: MenuName<SignalInput<Int>> { return .name(Menu.Binding.didSendAction) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var confinementRect: MenuName<(_ menu: NSMenu, _ screen: NSScreen?) -> NSRect> { return .name(Menu.Binding.confinementRect) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol MenuConvertible {
	func nsMenu() -> Menu.Instance
}
extension NSMenu: MenuConvertible, HasDelegate, DefaultConstructable {
	public func nsMenu() -> Menu.Instance { return self }
}
public extension Menu {
	func nsMenu() -> Menu.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol MenuBinding: BinderBaseBinding {
	static func menuBinding(_ binding: Menu.Binding) -> Self
	func asMenuBinding() -> Menu.Binding?
}
public extension MenuBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return menuBinding(.inheritedBinding(binding))
	}
}
public extension MenuBinding where Preparer.Inherited.Binding: MenuBinding {
	func asMenuBinding() -> Menu.Binding? {
		return asInheritedBinding()?.asMenuBinding()
	}
}
public extension Menu.Binding {
	typealias Preparer = Menu.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asMenuBinding() -> Menu.Binding? { return self }
	static func menuBinding(_ binding: Menu.Binding) -> Menu.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public enum SystemMenu: String {
	case apple = "NSAppleMenu"
	case font = "NSFontMenu"
	case help = "NSHelpMenu"
	case recentDocuments = "NSRecentDocumentsMenu"
	case services = "NSServicesMenu"
	case windows = "NSWindowsMenu"
}

class MenuCodingProxy: NSObject, NSCoding {
	let name: String
	
	func encode(with aCoder: NSCoder) {
		aCoder.encode("", forKey: "NSTitle")
		aCoder.encode(name, forKey: "NSName")
	 }

	init(name: String) {
		self.name = name
		super.init()
	}

	required init?(coder aDecoder: NSCoder) {
		name = ""
		super.init()
	 }
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class OutlineView<NodeData>: Binder, OutlineViewConvertible {
	public static func scrollEmbedded(type: NSOutlineView.Type = NSOutlineView.self, _ bindings: Binding...) -> ScrollView {
		return ScrollView(
			.borderType -- .noBorder,
			.hasVerticalScroller -- true,
			.hasHorizontalScroller -- true,
			.autohidesScrollers -- true,
			.contentView -- ClipView(
				.documentView -- OutlineView<NodeData>(type: type, bindings: bindings)
			)
		)
	}

	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension OutlineView {
	enum Binding: OutlineViewBinding {
		public typealias NodeDataType = NodeData
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsColumnReordering(Dynamic<Bool>)
		case allowsColumnResizing(Dynamic<Bool>)
		case allowsColumnSelection(Dynamic<Bool>)
		case allowsEmptySelection(Dynamic<Bool>)
		case allowsMultipleSelection(Dynamic<Bool>)
		case allowsTypeSelect(Dynamic<Bool>)
		case autoresizesOutlineColumn(Dynamic<Bool>)
		case autosaveExpandedItems(Dynamic<Bool>)
		case autosaveName(Dynamic<NSTableView.AutosaveName?>)
		case autosaveTableColumns(Dynamic<Bool>)
		case backgroundColor(Dynamic<NSColor>)
		case columnAutoresizingStyle(Dynamic<NSTableView.ColumnAutoresizingStyle>)
		case columns(Dynamic<[TableColumn<NodeData>]>)
		case cornerView(Dynamic<ViewConvertible?>)
		case draggingDestinationFeedbackStyle(Dynamic<NSTableView.DraggingDestinationFeedbackStyle>)
		case floatsGroupRows(Dynamic<Bool>)
		case gridColor(Dynamic<NSColor>)
		case gridStyleMask(Dynamic<NSTableView.GridLineStyle>)
		case headerView(Dynamic<TableHeaderViewConvertible?>)
		case indentationMarkerFollowsCell(Dynamic<Bool>)
		case indentationPerLevel(Dynamic<CGFloat>)
		case intercellSpacing(Dynamic<NSSize>)
		case outlineTableColumnIdentifier(Dynamic<NSUserInterfaceItemIdentifier>)
		case rowHeight(Dynamic<CGFloat>)
		case rowSizeStyle(Dynamic<NSTableView.RowSizeStyle>)
		case selectionHighlightStyle(Dynamic<NSTableView.SelectionHighlightStyle>)
		case stronglyReferencesItems(Dynamic<Bool>)
		case treeData(Dynamic<TreeAnimation<NodeData>>)
		case userInterfaceLayoutDirection(Dynamic<NSUserInterfaceLayoutDirection>)
		case usesAlternatingRowBackgroundColors(Dynamic<Bool>)
		case verticalMotionCanBeginDrag(Dynamic<Bool>)
		
		// 2. Signal bindings are performed on the object after construction.
		case collapseIndexPath(Signal<(indexPath: IndexPath?, collapseChildren: Bool)>)
		case deselectAll(Signal<Void>)
		case deselectColumn(Signal<NSUserInterfaceItemIdentifier>)
		case deselectIndexPath(Signal<IndexPath>)
		case expandIndexPath(Signal<(indexPath: IndexPath?, expandChildren: Bool)>)
		case hideRowActions(Signal<Void>)
		case hideRows(Signal<(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)>)
		case highlightColumn(Signal<NSUserInterfaceItemIdentifier?>)
		case moveColumn(Signal<(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)>)
		case scrollColumnToVisible(Signal<NSUserInterfaceItemIdentifier>)
		case scrollIndexPathToVisible(Signal<IndexPath>)
		case selectAll(Signal<Void>)
		case selectColumns(Signal<(identifiers: Set<NSUserInterfaceItemIdentifier>, byExtendingSelection: Bool)>)
		case selectIndexPaths(Signal<(indexPaths: Set<IndexPath>, byExtendingSelection: Bool)>)
		case setDropIndexPath(Signal<(indexPath: IndexPath?, dropChildIndex: Int)>)
		case sizeLastColumnToFit(Signal<Void>)
		case sizeToFit(Signal<Void>)
		case unhideRows(Signal<(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)>)
		
		// 3. Action bindings are triggered by the object after construction.
		case columnMoved(SignalInput<(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)>)
		case columnResized(SignalInput<(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)>)
		case doubleAction(TargetAction)
		case selectionChanged(SignalInput<(selectedColumns: Set<NSUserInterfaceItemIdentifier>, selectedIndexPaths: Set<IndexPath>)>)
		case selectionIsChanging(SignalInput<Void>)
		case indexPathDidCollapse(SignalInput<IndexPath>)
		case indexPathDidExpand(SignalInput<IndexPath>)
		case indexPathWillCollapse(SignalInput<IndexPath>)
		case indexPathWillExpand(SignalInput<IndexPath>)
		case visibleIndexPathsChanged(SignalInput<Set<IndexPath>>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case acceptDrop((_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ indexPath: IndexPath?, _ childIndex: Int) -> Bool)
		case didClickTableColumn((NSOutlineView, NSTableColumn) -> Void)
		case didDragTableColumn((NSOutlineView, NSTableColumn) -> Void)
		case draggingSessionEnded((_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -> Void)
		case draggingSessionWillBegin((_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ willBeginAt: NSPoint, _ forItems: [IndexPath]) -> Void)
		case groupRowCellConstructor((Int) -> TableCellViewConvertible)
		case heightOfRow((NSOutlineView, _ indexPath: IndexPath) -> CGFloat)
		case isIndexPathExpandable((_ outlineView: NSOutlineView, IndexPath) -> Bool)
		case mouseDownInHeaderOfTableColumn((NSOutlineView, NSTableColumn) -> Void)
		case nextTypeSelectMatch((_ outlineView: NSOutlineView, _ from: IndexPath, _ to: IndexPath, _ for: String) -> IndexPath?)
		case pasteboardWriter((_ outlineView: NSOutlineView, _ forIndexPath: IndexPath) -> NSPasteboardWriting?)
		case rowView((_ outlineView: NSOutlineView, _ indexPath: IndexPath) -> TableRowViewConvertible?)
		case selectionIndexesForProposedSelection((_ outlineView: NSOutlineView, _ proposedSelectionIndexes: Set<IndexPath>) -> Set<IndexPath>)
		case selectionShouldChange((_ outlineView: NSOutlineView) -> Bool)
		case shouldCollapse((_ outlineView: NSOutlineView, _ indexPath: IndexPath) -> Bool)
		case shouldExpand((_ outlineView: NSOutlineView, _ indexPath: IndexPath) -> Bool)
		case shouldReorderColumn((_ outlineView: NSOutlineView, _ column: NSTableColumn, _ newIndex: Int) -> Bool)
		case shouldSelectIndexPath((_ outlineView: NSOutlineView, _ indexPath: IndexPath) -> Bool)
		case shouldSelectTableColumn((_ outlineView: NSOutlineView, _ column: NSTableColumn?) -> Bool)
		case shouldTypeSelectForEvent((_ outlineView: NSOutlineView, _ event: NSEvent, _ searchString: String?) -> Bool)
		case sizeToFitWidthOfColumn((_ outlineView: NSOutlineView, _ column: NSTableColumn) -> CGFloat)
		case sortDescriptorsDidChange((NSOutlineView, [NSSortDescriptor]) -> Void)
		case typeSelectString((_ outlineView: NSOutlineView, _ column: NSTableColumn?, _ indexPath: IndexPath) -> String?)
		case updateDraggingItems((_ outlineView: NSOutlineView, _ forDrag: NSDraggingInfo) -> Void)
		case validateDrop((_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ proposedIndexPath: IndexPath?, _ proposedChildIndex: Int) -> NSDragOperation)
	}
}

// MARK: - Binder Part 3: Preparer
public extension OutlineView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = OutlineView.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = NSOutlineView
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage(visibleIndexPathsChanged: visibleIndexPathsChanged) }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var singleAction: TargetAction?
		var doubleAction: TargetAction?
		var outlineColumn: NSUserInterfaceItemIdentifier? = nil
		var visibleIndexPathsChanged: MultiOutput<Set<IndexPath>>?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension OutlineView.Preparer {
	var delegateIsRequired: Bool { return true }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.action(let x)): singleAction = x
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .acceptDrop(let x): delegate().addSingleHandler4(x, #selector(NSOutlineViewDataSource.outlineView(_:acceptDrop:item:childIndex:)))
		case .didClickTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:didClick:)))
		case .didDragTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:didDrag:)))
		case .doubleAction(let x): doubleAction = x
		case .draggingSessionEnded(let x): delegate().addMultiHandler4(x, #selector(NSOutlineViewDataSource.outlineView(_:draggingSession:endedAt:operation:)))
		case .heightOfRow(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:heightOfRowByItem:)))
		case .isIndexPathExpandable(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDataSource.outlineView(_:isItemExpandable:)))
		case .mouseDownInHeaderOfTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:mouseDownInHeaderOf:)))
		case .nextTypeSelectMatch(let x): delegate().addSingleHandler4(x, #selector(NSOutlineViewDelegate.outlineView(_:nextTypeSelectMatchFromItem:toItem:for:)))
		case .pasteboardWriter(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDataSource.outlineView(_:pasteboardWriterForItem:)))
		case .rowView(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:rowViewForItem:)))
		case .selectionIndexesForProposedSelection(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:selectionIndexesForProposedSelection:)))
		case .selectionShouldChange(let x): delegate().addSingleHandler1(x, #selector(NSOutlineViewDelegate.selectionShouldChange(in:)))
		case .shouldCollapse(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldCollapseItem:)))
		case .shouldExpand(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldExpandItem:)))
		case .shouldReorderColumn(let x): delegate().addSingleHandler3(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldReorderColumn:toColumn:)))
		case .shouldSelectTableColumn(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldSelect:)))
		case .shouldSelectIndexPath(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldSelectItem:)))
		case .shouldTypeSelectForEvent(let x): delegate().addSingleHandler3(x, #selector(NSOutlineViewDelegate.outlineView(_:shouldTypeSelectFor:withCurrentSearch:)))
		case .sizeToFitWidthOfColumn(let x): delegate().addSingleHandler2(x, #selector(NSOutlineViewDelegate.outlineView(_:sizeToFitWidthOfColumn:)))
		case .sortDescriptorsDidChange(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDataSource.outlineView(_:sortDescriptorsDidChange:)))
		case .typeSelectString(let x): delegate().addSingleHandler3(x, #selector(NSOutlineViewDelegate.outlineView(_:typeSelectStringFor:item:)))
		case .updateDraggingItems(let x): delegate().addMultiHandler2(x, #selector(NSOutlineViewDataSource.outlineView(_:updateDraggingItemsForDrag:)))
		case .validateDrop(let x): delegate().addSingleHandler4(x, #selector(NSOutlineViewDataSource.outlineView(_:validateDrop:proposedItem:proposedChildIndex:)))
		case .visibleIndexPathsChanged(let x):
			visibleIndexPathsChanged = visibleIndexPathsChanged ?? Input().multicast()
			visibleIndexPathsChanged?.signal.bind(to: x)
		default: break
		}
	}
	
	// NOTE: due to the fact that `NSOutlineView` is a subclass of `NSTableView` but uses an *unrelated* delegate protocol type, we need to manually re-implement `prepareDelegate` here since the delegate does *not* conform to the `NSTableViewDelegate` protocol specified in the `HasDelegate` conformance.
	func prepareDelegate(instance: Instance, storage: Storage) {
		if delegateIsRequired {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			if dynamicDelegate != nil {
				storage.dynamicDelegate = dynamicDelegate
			}
			instance.delegate = storage
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		instance.dataSource = storage
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(.action): return nil
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsColumnReordering(let x): return x.apply(instance) { i, v in i.allowsColumnReordering = v }
		case .allowsColumnResizing(let x): return x.apply(instance) { i, v in i.allowsColumnResizing = v }
		case .allowsColumnSelection(let x): return x.apply(instance) { i, v in i.allowsColumnSelection = v }
		case .allowsEmptySelection(let x): return x.apply(instance) { i, v in i.allowsEmptySelection = v }
		case .allowsMultipleSelection(let x): return x.apply(instance) { i, v in i.allowsMultipleSelection = v }
		case .allowsTypeSelect(let x): return x.apply(instance) { i, v in i.allowsTypeSelect = v }
		case .autoresizesOutlineColumn(let x): return x.apply(instance) { i, v in i.autoresizesOutlineColumn = v }
		case .autosaveExpandedItems(let x): return x.apply(instance) { i, v in i.autosaveExpandedItems = v }
		case .autosaveName(let x): return x.apply(instance) { i, v in i.autosaveName = v }
		case .autosaveTableColumns(let x): return x.apply(instance) { i, v in i.autosaveTableColumns = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .columnAutoresizingStyle(let x): return x.apply(instance) { i, v in i.columnAutoresizingStyle = v }
		case .columns(let x): return x.apply(instance, storage) { i, s, v in s.applyColumns(v.map { $0.construct() }, to: i) }
		case .cornerView(let x): return x.apply(instance) { i, v in i.cornerView = v?.nsView() }
		case .draggingDestinationFeedbackStyle(let x): return x.apply(instance) { i, v in i.draggingDestinationFeedbackStyle = v }
		case .floatsGroupRows(let x): return x.apply(instance) { i, v in i.floatsGroupRows = v }
		case .gridColor(let x): return x.apply(instance) { i, v in i.gridColor = v }
		case .gridStyleMask(let x): return x.apply(instance) { i, v in i.gridStyleMask = v }
		case .headerView(let x): return x.apply(instance) { i, v in i.headerView = v?.nsTableHeaderView() }
		case .indentationMarkerFollowsCell(let x): return x.apply(instance) { i, v in i.indentationMarkerFollowsCell = v }
		case .indentationPerLevel(let x): return x.apply(instance) { i, v in i.indentationPerLevel = v }
		case .intercellSpacing(let x): return x.apply(instance) { i, v in i.intercellSpacing = v }
		case .outlineTableColumnIdentifier(let x): return x.apply(instance, storage) { i, s, v in s.outlineColumnIdentifier = v }
		case .rowHeight(let x): return x.apply(instance) { i, v in i.rowHeight = v }
		case .rowSizeStyle(let x): return x.apply(instance) { i, v in i.rowSizeStyle = v }
		case .selectionHighlightStyle(let x): return x.apply(instance) { i, v in i.selectionHighlightStyle = v }
		case .treeData(let x): return x.apply(instance, storage) { i, s, v in s.applyTreeAnimation(v, to: i) }
		case .userInterfaceLayoutDirection(let x): return x.apply(instance) { i, v in i.userInterfaceLayoutDirection = v }
		case .usesAlternatingRowBackgroundColors(let x): return x.apply(instance) { i, v in i.usesAlternatingRowBackgroundColors = v }
		case .verticalMotionCanBeginDrag(let x): return x.apply(instance) { i, v in i.verticalMotionCanBeginDrag = v }

		case .stronglyReferencesItems(let x): return x.apply(instance) { i, v in i.stronglyReferencesItems = v }
		
		// 2. Signal bindings are performed on the object after construction.
		case .collapseIndexPath(let x):
			return x.apply(instance, storage) { i, s, v in
				if let indexPath = v.indexPath, let item = s.item(forIndexPath: indexPath, in: i) {
					i.collapseItem(item, collapseChildren: v.collapseChildren)
				} else {
					i.collapseItem(nil, collapseChildren: v.collapseChildren)
				}
			}
		case .deselectAll(let x): return x.apply(instance) { i, v in i.deselectAll(nil) }
		case .deselectColumn(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v })?.offset {
					i.deselectColumn(index)
				}
			}
		case .deselectIndexPath(let x):
			return x.apply(instance, storage) { i, s, v in
				if let row: Int = s.row(forIndexPath: v, in: i) {
					i.deselectRow(row)
				}
			}
		case .expandIndexPath(let x):
			return x.apply(instance, storage) { i, s, v in
				if let indexPath = v.indexPath, let item = s.item(forIndexPath: indexPath, in: i) {
					i.expandItem(item, expandChildren: v.expandChildren)
				} else {
					i.expandItem(nil, expandChildren: v.expandChildren)
				}
			}
		case .hideRowActions(let x): return x.apply(instance) { i, v in i.rowActionsVisible = false }
		case .hideRows(let x): return x.apply(instance) { i, v in i.hideRows(at: v.indexes, withAnimation: v.withAnimation) }
		case .highlightColumn(let x):
			return x.apply(instance) { i, v in
				i.highlightedTableColumn = v.flatMap { (identifier: NSUserInterfaceItemIdentifier) -> NSTableColumn? in
					return i.tableColumns.first(where: { $0.identifier == identifier })
				}
			}
		case .moveColumn(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v.identifier })?.offset {
					i.moveColumn(index, toColumn: v.toIndex)
				}
			}
		case .scrollColumnToVisible(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v })?.offset {
					i.scrollColumnToVisible(index)
				}
			}
		case .scrollIndexPathToVisible(let x):
			return x.apply(instance, storage) { i, s, v in
				if let row: Int = s.row(forIndexPath: v, in: i) {
					i.scrollRowToVisible(row)
				}
			}
		case .selectAll(let x): return x.apply(instance) { i, v in i.selectAll(nil) }
		case .selectColumns(let x):
			return x.apply(instance) { i, v in
				let indexes = v.identifiers.compactMap { identifier in i.tableColumns.enumerated().first(where: { $0.element.identifier == identifier })?.offset }
				let indexSet = IndexSet(indexes)
				i.selectColumnIndexes(indexSet, byExtendingSelection: v.byExtendingSelection)
			}
		case .selectIndexPaths(let x):
			return x.apply(instance, storage) { i, s, v in
				let indexes = v.indexPaths.compactMap { s.row(forIndexPath: $0, in: i) }
				i.selectRowIndexes(IndexSet(indexes), byExtendingSelection: v.byExtendingSelection)
			}
		case .setDropIndexPath(let x):
			return x.apply(instance, storage) { i, s, v in
				if let indexPath = v.indexPath, let item = s.item(forIndexPath: indexPath, in: i) {
					i.setDropItem(item, dropChildIndex: v.dropChildIndex)
				} else {
					i.setDropItem(nil, dropChildIndex: v.dropChildIndex)
				}
			}
		case .sizeLastColumnToFit(let x): return x.apply(instance) { i, v in i.sizeLastColumnToFit() }
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }
		case .unhideRows(let x): return x.apply(instance) { i, v in i.unhideRows(at: v.indexes, withAnimation: v.withAnimation) }

		// 3. Action bindings are triggered by the object after construction.
		case .columnMoved(let x):
			return Signal.notifications(name: NSTableView.columnDidMoveNotification, object: instance).compactMap { [weak instance] notification -> (column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)? in
				guard let index = (notification.userInfo?["NSNewColumn"] as? NSNumber)?.intValue, let column = instance?.tableColumns.at(index) else {
					return nil
				}
				guard let oldIndex = (notification.userInfo?["NSNewColumn"] as? NSNumber)?.intValue else {
					return nil
				}
				return (column: column.identifier, oldIndex: oldIndex, newIndex: index)
				}.cancellableBind(to: x)
		case .columnResized(let x):
			return Signal.notifications(name: NSTableView.columnDidResizeNotification, object: instance).compactMap { notification -> (column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)? in
				guard let column = (notification.userInfo?["NSTableColumn"] as? NSTableColumn) else {
					return nil
				}
				guard let oldWidth = (notification.userInfo?["NSOldWidth"] as? NSNumber)?.doubleValue else {
					return nil
				}
				return (column: column.identifier, oldWidth: CGFloat(oldWidth), newWidth: column.width)
			}.cancellableBind(to: x)
		case .didClickTableColumn: return nil
		case .didDragTableColumn: return nil
		case .doubleAction: return nil
		case .mouseDownInHeaderOfTableColumn: return nil
		case .selectionChanged(let x):
			return Signal.notifications(name: NSTableView.selectionDidChangeNotification, object: instance).compactMap { [weak instance, weak storage] n -> (selectedColumns: Set<NSUserInterfaceItemIdentifier>, selectedIndexPaths: Set<IndexPath>)? in
				guard let i = instance else {
					return nil
				}
				let selectedColumns = Set<NSUserInterfaceItemIdentifier>(i.selectedColumnIndexes.compactMap { i.tableColumns.at($0)?.identifier })
				let selectedIndexPaths = Set(i.selectedRowIndexes.compactMap { storage?.indexPath(forRow: $0, in: i) })
				return (selectedColumns: selectedColumns, selectedIndexPaths: selectedIndexPaths)
				}.cancellableBind(to: x)
		case .selectionIsChanging(let x):
			return Signal.notifications(name: NSTableView.selectionIsChangingNotification, object: instance).map { notification -> Void in () }.cancellableBind(to: x)
		case .sortDescriptorsDidChange: return nil
		case .indexPathDidCollapse(let x):
			return Signal.notifications(name: NSOutlineView.itemDidCollapseNotification, object: instance).compactMap { [weak instance, weak storage] notification -> IndexPath? in
				guard let b = storage, let i = instance else { return nil }
				return notification.userInfo?["NSObject"].flatMap { b.indexPath(forItem: $0, in: i) }
				}.cancellableBind(to: x)
		case .indexPathDidExpand(let x):
			return Signal.notifications(name: NSOutlineView.itemDidExpandNotification, object: instance).compactMap { [weak instance, weak storage] notification -> IndexPath? in
				guard let b = storage, let i = instance else { return nil }
				return notification.userInfo?["NSObject"].flatMap { b.indexPath(forItem: $0, in: i) }
			}.cancellableBind(to: x)
		case .indexPathWillCollapse(let x):
			return Signal.notifications(name: NSOutlineView.itemWillCollapseNotification, object: instance).compactMap { [weak instance, weak storage] notification -> IndexPath? in
				guard let b = storage, let i = instance else { return nil }
				return notification.userInfo?["NSObject"].flatMap { b.indexPath(forItem: $0, in: i) }
			}.cancellableBind(to: x)
		case .indexPathWillExpand(let x):
			return Signal.notifications(name: NSOutlineView.itemWillExpandNotification, object: instance).compactMap { [weak instance, weak storage] notification -> IndexPath? in
				guard let b = storage, let i = instance else { return nil }
				return notification.userInfo?["NSObject"].flatMap { b.indexPath(forItem: $0, in: i) }
				}.cancellableBind(to: x)
		case .visibleIndexPathsChanged: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .acceptDrop: return nil
		case .draggingSessionEnded: return nil
		case .draggingSessionWillBegin: return nil
		case .groupRowCellConstructor(let x):
			storage.groupRowCellConstructor = x
			return nil
		case .heightOfRow: return nil
		case .isIndexPathExpandable: return nil
		case .nextTypeSelectMatch: return nil
		case .pasteboardWriter: return nil
		case .rowView: return nil
		case .selectionIndexesForProposedSelection: return nil
		case .selectionShouldChange: return nil
		case .shouldCollapse: return nil
		case .shouldExpand: return nil
		case .shouldReorderColumn: return nil
		case .shouldSelectTableColumn: return nil
		case .shouldSelectIndexPath: return nil
		case .shouldTypeSelectForEvent: return nil
		case .sizeToFitWidthOfColumn: return nil
		case .typeSelectString: return nil
		case .updateDraggingItems: return nil
		case .validateDrop: return nil
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		var lifetimes = [Lifetime]()
		
		switch (singleAction, doubleAction) {
		case (nil, nil): break
		case (.firstResponder(let sa)?, .firstResponder(let da)?):
			instance.action = sa
			instance.doubleAction = da
			instance.target = nil
		case (.singleTarget(let st)?, .singleTarget(let dt)?):
			let target = SignalDoubleActionTarget()
			instance.target = target 
			lifetimes += target.signal.cancellableBind(to: st)
			lifetimes += target.signal.cancellableBind(to: dt)
			instance.action = SignalDoubleActionTarget.selector
			instance.doubleAction = SignalDoubleActionTarget.secondSelector
		case (let s?, nil):
			lifetimes += s.apply(to: instance, constructTarget: SignalActionTarget.init)
		case (nil, let d?):
			lifetimes += d.apply(to: instance, constructTarget: SignalActionTarget.init)
			instance.doubleAction = instance.action
			instance.action = nil
		case (.some, .some): fatalError("Action and double action may not use mix of single target and first responder")
		}
		
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension OutlineView.Preparer {
	open class Storage: View.Preparer.Storage, NSOutlineViewDelegate, NSOutlineViewDataSource {
		public let visibleIndexPathsChanged: MultiOutput<Set<IndexPath>>?
		
		open var actionTarget: SignalDoubleActionTarget? = nil
		open var treeState = TreeSubrangeState<NodeData>(parent: nil)
		open var visibleIndexPaths: Set<IndexPath> = []
		open var groupRowCellConstructor: ((Int) -> TableCellViewConvertible)?
		open var columns: [TableColumn<NodeData>.Preparer.Storage] = []
		open var outlineColumnIdentifier: NSUserInterfaceItemIdentifier? = nil
		
		public init(visibleIndexPathsChanged: MultiOutput<Set<IndexPath>>?) {
			self.visibleIndexPathsChanged = visibleIndexPathsChanged
		}

		open override var isInUse: Bool { return true }
		
		open func columnForIdentifier(_ identifier: NSUserInterfaceItemIdentifier) -> (offset: Int, element: TableColumn<NodeData>.Preparer.Storage)? {
			return columns.enumerated().first { (tuple: (offset: Int, element: TableColumn<NodeData>.Preparer.Storage)) -> Bool in
				tuple.element.tableColumn.identifier == identifier
			}
		}
		
		open func outlineView(_ outlineView: NSOutlineView, itemForPersistentObject object: Any) -> Any? {
			guard let indexPath = object as? IndexPath else { return nil }
			return item(forIndexPath: indexPath, in: outlineView)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, persistentObjectForItem item: Any?) -> Any? {
			if let i = item, let indexPath = indexPath(forItem: i, in: outlineView) {
				return indexPath
			}
			return nil
		}
		
		open func outlineView(_ outlineView: NSOutlineView, didAdd: NSTableRowView, forRow: Int) {
			DispatchQueue.main.async {
				if let vrsi = self.visibleIndexPathsChanged?.input, let path = self.indexPath(forRow: forRow, in: outlineView) {
					if self.visibleIndexPaths.insert(path).inserted {
						vrsi.send(value: self.visibleIndexPaths)
					}
				}
			}
		}
		
		open func outlineView(_ outlineView: NSOutlineView, didRemove: NSTableRowView, forRow: Int) {
			DispatchQueue.main.async {
				if let vrsi = self.visibleIndexPathsChanged?.input, let path = self.indexPath(forRow: forRow, in: outlineView) {
					if self.visibleIndexPaths.insert(path).inserted {
						vrsi.send(value: self.visibleIndexPaths)
					}
				}
			}
		}
		
		open func outlineView(_ outlineView: NSOutlineView, child: Int, ofItem: Any?) -> Any {
			if ofItem == nil {
				return treeState.state.values?.at(child) ?? TreeSubrangeState<NodeData>(parent: nil)
			}
			return (ofItem as? TreeSubrangeState<NodeData>)?.state.values?.at(child) ?? TreeSubrangeState<NodeData>(parent: nil)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, isItemExpandable item: Any) -> Bool {
			return ((item as? TreeSubrangeState<NodeData>)?.state.values ?? nil) != nil
		}
		
		open func outlineView(_ outlineView: NSOutlineView, numberOfChildrenOfItem item: Any?) -> Int {
			if item == nil {
				return treeState.state.globalCount
			}
			return (item as? TreeSubrangeState<NodeData>)?.state.globalCount ?? 0
		}
		
		open func outlineView(_ outlineView: NSOutlineView, objectValueFor tableColumn: NSTableColumn?, byItem item: Any?) -> Any? {
			return item
		}
		
		open func outlineView(_ outlineView: NSOutlineView, viewFor tableColumn: NSTableColumn?, item: Any) -> NSView? {
			if let tc = tableColumn {
				if let col = columnForIdentifier(tc.identifier) {
					let leaf = (item as? TreeSubrangeState<NodeData>)?.state.leaf
					let identifier = col.element.cellIdentifier?(leaf) ?? tc.identifier
					
					let cellView: NSTableCellView
					let cellInput: SignalInput<NodeData>?
					if let reusedView = outlineView.makeView(withIdentifier: identifier, owner: outlineView), let downcast = reusedView as? NSTableCellView {
						cellView = downcast
						cellInput = cellView.associatedRowInput(valueType: NodeData.self)
					} else if let cc = col.element.cellConstructor {
						let dataTuple = Signal<NodeData>.create()
						let constructed = cc(identifier, dataTuple.signal.multicast()).nsTableCellView()
						if constructed.identifier == nil {
							constructed.identifier = identifier
						}
						cellView = constructed
						cellInput = dataTuple.input
						cellView.setAssociatedRowInput(to: dataTuple.input)
					} else {
						return col.element.dataMissingCell?()?.nsTableCellView()
					}
					
					if let l = leaf {
						_ = cellInput?.send(value: l)
					}
					return cellView
				}
			} else {
				return groupRowCellConstructor?(outlineView.row(forItem: item)).nsTableCellView()
			}
			return nil
		}
		
		open var outlineTableColumn: TableColumn<NodeData>.Preparer.Storage?
		open func applyOutlineTableColumn(_ outlineTableColumn: TableColumn<NodeData>.Preparer.Storage, to outlineView: NSOutlineView) {
			self.outlineTableColumn = outlineTableColumn
			applyColumns(columns, to: outlineView)
		}
		
		open func applyColumns(_ v: [TableColumn<NodeData>.Preparer.Storage], to outlineView: NSOutlineView) {
			columns = v
			let columnsArray = v.map { $0.tableColumn }
			var newColumnSet = Set(columnsArray)
			if let otc = outlineTableColumn?.tableColumn ?? outlineView.outlineTableColumn {
				newColumnSet.insert(otc)
			}
			let oldColumnSet = Set(outlineView.tableColumns)
			
			for c in columnsArray {
				if !oldColumnSet.contains(c) {
					outlineView.addTableColumn(c)
				}
				if !newColumnSet.contains(c) {
					outlineView.removeTableColumn(c)
				}
			}
			if let oci = outlineColumnIdentifier, let tc = columnForIdentifier(oci)?.element.tableColumn {
				outlineView.outlineTableColumn = tc
			} else {
				outlineView.outlineTableColumn = outlineView.tableColumns.first
			}
		}
		
		open func applyTreeAnimation(_ treeAnimation: TreeAnimation<NodeData>, to outlineView: NSOutlineView) {
			treeAnimation.value.mutations.apply(toTreeSubrange: treeState)
			outlineView.animate(treeAnimation.value, in: treeState, animation: treeAnimation.animation ?? [])
		}
		
		open func indexPath(forItem: Any, in outlineView: NSOutlineView) -> IndexPath? {
			var indexes = IndexPath()
			let next = { (item: inout TreeSubrangeState<NodeData>?) -> (parent: TreeSubrangeState<NodeData>, item: TreeSubrangeState<NodeData>)? in
				if let parent = item?.parent, let next = item {
					item = parent
					return (parent, next)
				}
				return nil
			}
			for (parent, item) in sequence(state: forItem as? TreeSubrangeState<NodeData>, next: next) {
				if let i = parent.state.values?.firstIndex(where: { $0 === item }) {
					indexes.append(i)
				} else {
					return nil
				}
			}
			return indexes
		}
		
		open func indexPath(forRow row: Int, in outlineView: NSOutlineView) -> IndexPath? {
			if let item = outlineView.item(atRow: row) {
				return indexPath(forItem: item, in: outlineView)
			}
			return nil
		}
		
		open func row(forIndexPath indexPath: IndexPath, in outlineView: NSOutlineView) -> Int? {
			if let i = item(forIndexPath: indexPath, in: outlineView) {
				return outlineView.row(forItem: i)
			}
			return nil
		}
		
		open func item(forIndexPath indexPath: IndexPath, in: NSOutlineView) -> Any? {
			var node = treeState
			for index in sequence(state: indexPath, next: { $0.popFirst() }) {
				guard let next = node.state.values?.at(index) else { return nil }
				node = next
			}
			return node
		}
	}
	
	open class Delegate: DynamicDelegate, NSOutlineViewDelegate, NSOutlineViewDataSource {
		private func storage(for outlineView: NSOutlineView) -> Storage? {
			return outlineView.delegate as? Storage
		}
		
		open func outlineView(_ outlineView: NSOutlineView, didDrag tableColumn: NSTableColumn) {
			multiHandler(outlineView, tableColumn)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, didClick tableColumn: NSTableColumn) {
			multiHandler(outlineView, tableColumn)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, mouseDownInHeaderOf tableColumn: NSTableColumn) {
			multiHandler(outlineView, tableColumn)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, rowViewForItem item: Any) -> NSTableRowView? {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return (singleHandler(outlineView, indexPath) as NSTableRowView?)?.nsTableRowView()
			}
			return nil
		}
		
		open func outlineView(_ outlineView: NSOutlineView, heightOfRowByItem item: Any) -> CGFloat {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(indexPath)
			}
			return outlineView.rowHeight
		}
		
		open func outlineView(_ outlineView: NSOutlineView, shouldReorderColumn columnIndex: Int, toColumn newColumnIndex: Int) -> Bool {
			if let column = outlineView.tableColumns.at(columnIndex) {
				return singleHandler(outlineView, column.identifier, newColumnIndex)
			}
			return false
		}
		
		open func outlineView(_ outlineView: NSOutlineView, sizeToFitWidthOfColumn column: Int) -> CGFloat {
			if let column = outlineView.tableColumns.at(column) {
				return singleHandler(outlineView, column.identifier)
			}
			return 0
		}
		
		open func outlineView(_ outlineView: NSOutlineView, shouldTypeSelectFor event: NSEvent, withCurrentSearch searchString: String?) -> Bool {
			return singleHandler(outlineView, event, searchString)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, typeSelectStringFor tableColumn: NSTableColumn?, item: Any) -> String? {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(outlineView, tableColumn, indexPath)
			}
			return nil
		}
		
		open func outlineView(_ outlineView: NSOutlineView, nextTypeSelectMatchFromItem startItem: Any, toItem endItem: Any, for searchString: String) -> Any? {
			if let startIndexPath = storage(for: outlineView)?.indexPath(forItem: startItem, in: outlineView), let endIndexPath = storage(for: outlineView)?.indexPath(forItem: endItem, in: outlineView) {
				if let indexPath = singleHandler(outlineView, startIndexPath, endIndexPath, searchString) as IndexPath? {
					return storage(for: outlineView)?.item(forIndexPath: indexPath, in: outlineView)
				}
			}
			return nil
		}
		
		open func outlineView(_ outlineView: NSOutlineView, shouldSelect tableColumn: NSTableColumn?) -> Bool {
			return singleHandler(outlineView, tableColumn)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, selectionIndexesForProposedSelection proposedSelectionIndexes: IndexSet) -> IndexSet {
			var indexPaths = Set<IndexPath>()
			for index in proposedSelectionIndexes {
				if let path = storage(for: outlineView)?.indexPath(forRow: index, in: outlineView) {
					indexPaths.insert(path)
				}
			}
			let indexPathResult = singleHandler(indexPaths) as [IndexPath]
			var result = IndexSet()
			for indexPath in indexPathResult {
				if let index = storage(for: outlineView)?.row(forIndexPath: indexPath, in: outlineView) {
					result.insert(index)
				}
			}
			return result
		}
		
		open func outlineView(_ outlineView: NSOutlineView, shouldSelectItem item: Any) -> Bool {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(outlineView, indexPath)
			}
			return false
		}
		
		open func selectionShouldChange(in outlineView: NSOutlineView) -> Bool {
			return singleHandler(outlineView)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, shouldExpandItem item: Any) -> Bool {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(indexPath)
			}
			return false
		}
		
		open func outlineView(_ outlineView: NSOutlineView, shouldCollapseItem item: Any) -> Bool {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(indexPath)
			}
			return false
		}
		
		open func outlineView(_ outlineView: NSOutlineView, acceptDrop info: NSDraggingInfo, item: Any?, childIndex index: Int) -> Bool {
			if let i = item {
				if let indexPath = storage(for: outlineView)?.indexPath(forItem: i, in: outlineView) {
					return singleHandler(outlineView, info, indexPath, index)
				} else {
					return false
				}
			}
			return singleHandler(outlineView, info, nil as IndexPath?, index)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, sortDescriptorsDidChange oldDescriptors: [NSSortDescriptor]) {
			multiHandler(outlineView, oldDescriptors)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, draggingSession session: NSDraggingSession, endedAt screenPoint: NSPoint, operation: NSDragOperation) {
			return singleHandler(outlineView, session, screenPoint, operation)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, draggingSession session: NSDraggingSession, willBeginAt screenPoint: NSPoint, forItems draggedItems: [Any]) {
			let indexPaths = draggedItems.compactMap { storage(for: outlineView)?.indexPath(forItem: $0, in: outlineView) }
			return singleHandler(outlineView, session, screenPoint, indexPaths)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, isItemExpandable: Any) -> Bool {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: isItemExpandable, in: outlineView) {
				return singleHandler(indexPath)
			}
			return false
		}
		
		open func outlineView(_ outlineView: NSOutlineView, pasteboardWriterForItem item: Any) -> NSPasteboardWriting? {
			if let indexPath = storage(for: outlineView)?.indexPath(forItem: item, in: outlineView) {
				return singleHandler(outlineView, indexPath)
			}
			return nil
		}
		
		open func outlineView(_ outlineView: NSOutlineView, updateDraggingItemsForDrag draggingInfo: NSDraggingInfo) {
			multiHandler(outlineView, draggingInfo)
		}
		
		open func outlineView(_ outlineView: NSOutlineView, validateDrop info: NSDraggingInfo, proposedItem item: Any?, proposedChildIndex index: Int) -> NSDragOperation {
			if let i = item {
				if let indexPath = storage(for: outlineView)?.indexPath(forItem: i, in: outlineView) {
					return singleHandler(outlineView, info, indexPath, index)
				} else {
					return []
				}
			}
			return singleHandler(outlineView, info, nil as IndexPath?, index)
		}
	}
}

private extension NSOutlineView {
	func animate<NodeData>(_ treeMutation: TreeSubrangeMutation<NodeData>, in treeState: TreeSubrangeState<NodeData>, animation: NSTableView.AnimationOptions) {
		let indices = treeMutation.mutations.indexSet.offset(by: treeState.state.localOffset)
		
		switch treeMutation.mutations.kind {
		case .delete:
			removeItems(at: indices, inParent: treeState, withAnimation: animation)
		case .move(let destination):
			beginUpdates()
			for (count, index) in indices.enumerated() {
				moveItem(at: index, inParent: treeState, to: destination + count, inParent: treeState)
			}
			endUpdates()
		case .insert:
			insertItems(at: indices, inParent: treeState, withAnimation: animation)
		case .scroll:
			beginUpdates()
			for i in indices {
				guard let item = treeState.state.values?.at(i) else { continue }
				reloadItem(item, reloadChildren: true)
			}
			endUpdates()
		case .update:
			beginUpdates()
			for (mutationIndex, valueIndex) in indices.enumerated() {
				guard let childAnimation = treeMutation.mutations.values.at(mutationIndex), let childState = treeState.state.values?.at(valueIndex) else { continue }
				animate(childAnimation, in: childState, animation: animation)
			}
			endUpdates()
		case .reload:
			reloadData()
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: OutlineViewBinding {
	public typealias OutlineViewName<V> = BindingName<V, OutlineView<Binding.NodeDataType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> OutlineView<Binding.NodeDataType>.Binding) -> OutlineViewName<V> {
		return OutlineViewName<V>(source: source, downcast: Binding.outlineViewBinding)
	}
}
public extension BindingName where Binding: OutlineViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: OutlineViewName<$2> { return .name(OutlineView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsColumnReordering: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.allowsColumnReordering) }
	static var allowsColumnResizing: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.allowsColumnResizing) }
	static var allowsColumnSelection: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.allowsColumnSelection) }
	static var allowsEmptySelection: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.allowsEmptySelection) }
	static var allowsMultipleSelection: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.allowsMultipleSelection) }
	static var allowsTypeSelect: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.allowsTypeSelect) }
	static var autoresizesOutlineColumn: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.autoresizesOutlineColumn) }
	static var autosaveExpandedItems: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.autosaveExpandedItems) }
	static var autosaveName: OutlineViewName<Dynamic<NSTableView.AutosaveName?>> { return .name(OutlineView.Binding.autosaveName) }
	static var autosaveTableColumns: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.autosaveTableColumns) }
	static var backgroundColor: OutlineViewName<Dynamic<NSColor>> { return .name(OutlineView.Binding.backgroundColor) }
	static var columnAutoresizingStyle: OutlineViewName<Dynamic<NSTableView.ColumnAutoresizingStyle>> { return .name(OutlineView.Binding.columnAutoresizingStyle) }
	static var columns: OutlineViewName<Dynamic<[TableColumn<Binding.NodeDataType>]>> { return .name(OutlineView.Binding.columns) }
	static var cornerView: OutlineViewName<Dynamic<ViewConvertible?>> { return .name(OutlineView.Binding.cornerView) }
	static var draggingDestinationFeedbackStyle: OutlineViewName<Dynamic<NSTableView.DraggingDestinationFeedbackStyle>> { return .name(OutlineView.Binding.draggingDestinationFeedbackStyle) }
	static var floatsGroupRows: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.floatsGroupRows) }
	static var gridColor: OutlineViewName<Dynamic<NSColor>> { return .name(OutlineView.Binding.gridColor) }
	static var gridStyleMask: OutlineViewName<Dynamic<NSTableView.GridLineStyle>> { return .name(OutlineView.Binding.gridStyleMask) }
	static var headerView: OutlineViewName<Dynamic<TableHeaderViewConvertible?>> { return .name(OutlineView.Binding.headerView) }
	static var indentationMarkerFollowsCell: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.indentationMarkerFollowsCell) }
	static var indentationPerLevel: OutlineViewName<Dynamic<CGFloat>> { return .name(OutlineView.Binding.indentationPerLevel) }
	static var intercellSpacing: OutlineViewName<Dynamic<NSSize>> { return .name(OutlineView.Binding.intercellSpacing) }
	static var outlineTableColumnIdentifier: OutlineViewName<Dynamic<NSUserInterfaceItemIdentifier>> { return .name(OutlineView.Binding.outlineTableColumnIdentifier) }
	static var rowHeight: OutlineViewName<Dynamic<CGFloat>> { return .name(OutlineView.Binding.rowHeight) }
	static var rowSizeStyle: OutlineViewName<Dynamic<NSTableView.RowSizeStyle>> { return .name(OutlineView.Binding.rowSizeStyle) }
	static var selectionHighlightStyle: OutlineViewName<Dynamic<NSTableView.SelectionHighlightStyle>> { return .name(OutlineView.Binding.selectionHighlightStyle) }
	static var stronglyReferencesItems: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.stronglyReferencesItems) }
	static var treeData: OutlineViewName<Dynamic<TreeAnimation<Binding.NodeDataType>>> { return .name(OutlineView.Binding.treeData) }
	static var userInterfaceLayoutDirection: OutlineViewName<Dynamic<NSUserInterfaceLayoutDirection>> { return .name(OutlineView.Binding.userInterfaceLayoutDirection) }
	static var usesAlternatingRowBackgroundColors: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.usesAlternatingRowBackgroundColors) }
	static var verticalMotionCanBeginDrag: OutlineViewName<Dynamic<Bool>> { return .name(OutlineView.Binding.verticalMotionCanBeginDrag) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var collapseIndexPath: OutlineViewName<Signal<(indexPath: IndexPath?, collapseChildren: Bool)>> { return .name(OutlineView.Binding.collapseIndexPath) }
	static var deselectAll: OutlineViewName<Signal<Void>> { return .name(OutlineView.Binding.deselectAll) }
	static var deselectColumn: OutlineViewName<Signal<NSUserInterfaceItemIdentifier>> { return .name(OutlineView.Binding.deselectColumn) }
	static var deselectIndexPath: OutlineViewName<Signal<IndexPath>> { return .name(OutlineView.Binding.deselectIndexPath) }
	static var expandIndexPath: OutlineViewName<Signal<(indexPath: IndexPath?, expandChildren: Bool)>> { return .name(OutlineView.Binding.expandIndexPath) }
	static var hideRowActions: OutlineViewName<Signal<Void>> { return .name(OutlineView.Binding.hideRowActions) }
	static var hideRows: OutlineViewName<Signal<(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)>> { return .name(OutlineView.Binding.hideRows) }
	static var highlightColumn: OutlineViewName<Signal<NSUserInterfaceItemIdentifier?>> { return .name(OutlineView.Binding.highlightColumn) }
	static var moveColumn: OutlineViewName<Signal<(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)>> { return .name(OutlineView.Binding.moveColumn) }
	static var scrollColumnToVisible: OutlineViewName<Signal<NSUserInterfaceItemIdentifier>> { return .name(OutlineView.Binding.scrollColumnToVisible) }
	static var scrollIndexPathToVisible: OutlineViewName<Signal<IndexPath>> { return .name(OutlineView.Binding.scrollIndexPathToVisible) }
	static var selectAll: OutlineViewName<Signal<Void>> { return .name(OutlineView.Binding.selectAll) }
	static var selectColumns: OutlineViewName<Signal<(identifiers: Set<NSUserInterfaceItemIdentifier>, byExtendingSelection: Bool)>> { return .name(OutlineView.Binding.selectColumns) }
	static var selectIndexPaths: OutlineViewName<Signal<(indexPaths: Set<IndexPath>, byExtendingSelection: Bool)>> { return .name(OutlineView.Binding.selectIndexPaths) }
	static var setDropIndexPath: OutlineViewName<Signal<(indexPath: IndexPath?, dropChildIndex: Int)>> { return .name(OutlineView.Binding.setDropIndexPath) }
	static var sizeLastColumnToFit: OutlineViewName<Signal<Void>> { return .name(OutlineView.Binding.sizeLastColumnToFit) }
	static var sizeToFit: OutlineViewName<Signal<Void>> { return .name(OutlineView.Binding.sizeToFit) }
	static var unhideRows: OutlineViewName<Signal<(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)>> { return .name(OutlineView.Binding.unhideRows) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var columnMoved: OutlineViewName<SignalInput<(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)>> { return .name(OutlineView.Binding.columnMoved) }
	static var columnResized: OutlineViewName<SignalInput<(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)>> { return .name(OutlineView.Binding.columnResized) }
	static var doubleAction: OutlineViewName<TargetAction> { return .name(OutlineView.Binding.doubleAction) }
	static var selectionChanged: OutlineViewName<SignalInput<(selectedColumns: Set<NSUserInterfaceItemIdentifier>, selectedIndexPaths: Set<IndexPath>)>> { return .name(OutlineView.Binding.selectionChanged) }
	static var selectionIsChanging: OutlineViewName<SignalInput<Void>> { return .name(OutlineView.Binding.selectionIsChanging) }
	static var indexPathDidCollapse: OutlineViewName<SignalInput<IndexPath>> { return .name(OutlineView.Binding.indexPathDidCollapse) }
	static var indexPathDidExpand: OutlineViewName<SignalInput<IndexPath>> { return .name(OutlineView.Binding.indexPathDidExpand) }
	static var indexPathWillCollapse: OutlineViewName<SignalInput<IndexPath>> { return .name(OutlineView.Binding.indexPathWillCollapse) }
	static var indexPathWillExpand: OutlineViewName<SignalInput<IndexPath>> { return .name(OutlineView.Binding.indexPathWillExpand) }
	static var visibleIndexPathsChanged: OutlineViewName<SignalInput<Set<IndexPath>>> { return .name(OutlineView.Binding.visibleIndexPathsChanged) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var acceptDrop: OutlineViewName<(_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ indexPath: IndexPath?, _ childIndex: Int) -> Bool> { return .name(OutlineView.Binding.acceptDrop) }
	static var didClickTableColumn: OutlineViewName<(NSOutlineView, NSTableColumn) -> Void> { return .name(OutlineView.Binding.didClickTableColumn) }
	static var didDragTableColumn: OutlineViewName<(NSOutlineView, NSTableColumn) -> Void> { return .name(OutlineView.Binding.didDragTableColumn) }
	static var draggingSessionEnded: OutlineViewName<(_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -> Void> { return .name(OutlineView.Binding.draggingSessionEnded) }
	static var draggingSessionWillBegin: OutlineViewName<(_ outlineView: NSOutlineView, _ draggingSession: NSDraggingSession, _ willBeginAt: NSPoint, _ forItems: [IndexPath]) -> Void> { return .name(OutlineView.Binding.draggingSessionWillBegin) }
	static var groupRowCellConstructor: OutlineViewName<(Int) -> TableCellViewConvertible> { return .name(OutlineView.Binding.groupRowCellConstructor) }
	static var heightOfRow: OutlineViewName<(NSOutlineView, _ indexPath: IndexPath) -> CGFloat> { return .name(OutlineView.Binding.heightOfRow) }
	static var isIndexPathExpandable: OutlineViewName<(_ outlineView: NSOutlineView, IndexPath) -> Bool> { return .name(OutlineView.Binding.isIndexPathExpandable) }
	static var mouseDownInHeaderOfTableColumn: OutlineViewName<(NSOutlineView, NSTableColumn) -> Void> { return .name(OutlineView.Binding.mouseDownInHeaderOfTableColumn) }
	static var nextTypeSelectMatch: OutlineViewName<(_ outlineView: NSOutlineView, _ from: IndexPath, _ to: IndexPath, _ for: String) -> IndexPath?> { return .name(OutlineView.Binding.nextTypeSelectMatch) }
	static var pasteboardWriter: OutlineViewName<(_ outlineView: NSOutlineView, _ forIndexPath: IndexPath) -> NSPasteboardWriting?> { return .name(OutlineView.Binding.pasteboardWriter) }
	static var rowView: OutlineViewName<(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -> TableRowViewConvertible?> { return .name(OutlineView.Binding.rowView) }
	static var selectionIndexesForProposedSelection: OutlineViewName<(_ outlineView: NSOutlineView, _ proposedSelectionIndexes: Set<IndexPath>) -> Set<IndexPath>> { return .name(OutlineView.Binding.selectionIndexesForProposedSelection) }
	static var selectionShouldChange: OutlineViewName<(_ outlineView: NSOutlineView) -> Bool> { return .name(OutlineView.Binding.selectionShouldChange) }
	static var shouldCollapse: OutlineViewName<(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -> Bool> { return .name(OutlineView.Binding.shouldCollapse) }
	static var shouldExpand: OutlineViewName<(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -> Bool> { return .name(OutlineView.Binding.shouldExpand) }
	static var shouldReorderColumn: OutlineViewName<(_ outlineView: NSOutlineView, _ column: NSTableColumn, _ newIndex: Int) -> Bool> { return .name(OutlineView.Binding.shouldReorderColumn) }
	static var shouldSelectIndexPath: OutlineViewName<(_ outlineView: NSOutlineView, _ indexPath: IndexPath) -> Bool> { return .name(OutlineView.Binding.shouldSelectIndexPath) }
	static var shouldSelectTableColumn: OutlineViewName<(_ outlineView: NSOutlineView, _ column: NSTableColumn?) -> Bool> { return .name(OutlineView.Binding.shouldSelectTableColumn) }
	static var shouldTypeSelectForEvent: OutlineViewName<(_ outlineView: NSOutlineView, _ event: NSEvent, _ searchString: String?) -> Bool> { return .name(OutlineView.Binding.shouldTypeSelectForEvent) }
	static var sizeToFitWidthOfColumn: OutlineViewName<(_ outlineView: NSOutlineView, _ column: NSTableColumn) -> CGFloat> { return .name(OutlineView.Binding.sizeToFitWidthOfColumn) }
	static var sortDescriptorsDidChange: OutlineViewName<(NSOutlineView, [NSSortDescriptor]) -> Void> { return .name(OutlineView.Binding.sortDescriptorsDidChange) }
	static var typeSelectString: OutlineViewName<(_ outlineView: NSOutlineView, _ column: NSTableColumn?, _ indexPath: IndexPath) -> String?> { return .name(OutlineView.Binding.typeSelectString) }
	static var updateDraggingItems: OutlineViewName<(_ outlineView: NSOutlineView, _ forDrag: NSDraggingInfo) -> Void> { return .name(OutlineView.Binding.updateDraggingItems) }
	static var validateDrop: OutlineViewName<(_ outlineView: NSOutlineView, _ info: NSDraggingInfo, _ proposedIndexPath: IndexPath?, _ proposedChildIndex: Int) -> NSDragOperation> { return .name(OutlineView.Binding.validateDrop) }

	// Composite binding names
	static func doubleAction<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> OutlineViewName<SignalInput<Value>> {
		return Binding.keyPathActionName(keyPath, OutlineView.Binding.doubleAction, Binding.outlineViewBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol OutlineViewConvertible: ControlConvertible {
	func nsOutlineView() -> NSOutlineView
}
extension NSOutlineView: OutlineViewConvertible {
	public func nsOutlineView() -> NSOutlineView { return self }
}
public extension OutlineViewConvertible {
	func nsControl() -> Control.Instance { return nsOutlineView() }
}
public extension OutlineView {
	func nsOutlineView() -> NSOutlineView { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol OutlineViewBinding: ControlBinding {
	associatedtype NodeDataType
	static func outlineViewBinding(_ binding: OutlineView<NodeDataType>.Binding) -> Self
	func asOutlineViewBinding() -> OutlineView<NodeDataType>.Binding?
}
public extension OutlineViewBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return outlineViewBinding(OutlineView<NodeDataType>.Binding.inheritedBinding(binding))
	}
}
public extension OutlineViewBinding where Preparer.Inherited.Binding: OutlineViewBinding, Preparer.Inherited.Binding.NodeDataType == NodeDataType {
	func asOutlineViewBinding() -> OutlineView<NodeDataType>.Binding? {
		return asInheritedBinding()?.asOutlineViewBinding()
	}
}
public extension OutlineView.Binding {
	typealias Preparer = OutlineView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asOutlineViewBinding() -> OutlineView.Binding? { return self }
	static func outlineViewBinding(_ binding: OutlineView<NodeDataType>.Binding) -> OutlineView<NodeDataType>.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public typealias TreeAnimation<NodeData> = Animatable<TreeSubrangeMutation<NodeData>, NSTableView.AnimationOptions>

public struct OutlineCell<NodeData> {
	public let row: Int
	public let column: Int
	public let columnIdentifier: NSUserInterfaceItemIdentifier
	public let data: IndexPath?
	
	public init(row: Int, column: Int, outlineView: NSOutlineView) {
		self.row = row
		self.data = (outlineView.delegate as? OutlineView<NodeData>.Preparer.Storage)?.indexPath(forRow: row, in: outlineView)
		self.column = column
		self.columnIdentifier = outlineView.tableColumns[column].identifier
	}
	
	public init(row: Int, column: NSTableColumn, outlineView: NSOutlineView) {
		self.row = row
		self.column = outlineView.column(withIdentifier: column.identifier)
		self.columnIdentifier = column.identifier
		self.data = (outlineView.delegate as? OutlineView<NodeData>.Preparer.Storage)?.indexPath(forRow: row, in: outlineView)
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class PanGestureRecognizer: Binder, PanGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension PanGestureRecognizer {
	enum Binding: PanGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case buttonMask(Dynamic<Int>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension PanGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = PanGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = NSPanGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension PanGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .buttonMask(let x): return x.apply(instance) { i, v in i.buttonMask = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PanGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PanGestureRecognizerBinding {
	public typealias PanGestureRecognizerName<V> = BindingName<V, PanGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PanGestureRecognizer.Binding) -> PanGestureRecognizerName<V> {
		return PanGestureRecognizerName<V>(source: source, downcast: Binding.panGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: PanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PanGestureRecognizerName<$2> { return .name(PanGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var buttonMask: PanGestureRecognizerName<Dynamic<Int>> { return .name(PanGestureRecognizer.Binding.buttonMask) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol PanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsPanGestureRecognizer() -> PanGestureRecognizer.Instance
}
extension PanGestureRecognizerConvertible {
	public func nsGestureRecognizer() -> GestureRecognizer.Instance { return nsPanGestureRecognizer() }
}
extension NSPanGestureRecognizer: PanGestureRecognizerConvertible {
	public func nsPanGestureRecognizer() -> PanGestureRecognizer.Instance { return self }
}
public extension PanGestureRecognizer {
	func nsPanGestureRecognizer() -> PanGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol PanGestureRecognizerBinding: GestureRecognizerBinding {
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -> Self
	func asPanGestureRecognizerBinding() -> PanGestureRecognizer.Binding?
}
public extension PanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return panGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension PanGestureRecognizerBinding where Preparer.Inherited.Binding: PanGestureRecognizerBinding {
	func asPanGestureRecognizerBinding() -> PanGestureRecognizer.Binding? {
		return asInheritedBinding()?.asPanGestureRecognizerBinding()
	}
}
public extension PanGestureRecognizer.Binding {
	typealias Preparer = PanGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPanGestureRecognizerBinding() -> PanGestureRecognizer.Binding? { return self }
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -> PanGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class PopUpButton: Binder, PopUpButtonConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension PopUpButton {
	enum Binding: PopUpButtonBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case autoenablesItems(Dynamic<Bool>)
		case menu(Dynamic<MenuConvertible>)
		case preferredEdge(Dynamic<NSRectEdge>)
		case pullsDown(Dynamic<Bool>)
		case selectedIndex(Dynamic<Int>)
		case title(Dynamic<String>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case willPopUp(SignalInput<Void>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension PopUpButton {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = PopUpButton.Binding
		public typealias Inherited = Button.Preparer
		public typealias Instance = NSPopUpButton
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var pullsDown = InitialSubsequent<Bool>()
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension PopUpButton.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .pullsDown(let x): pullsDown = x.initialSubsequent()
		default: break
		}
	}
	
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		return type.init(frame: NSRect.zero, pullsDown: pullsDown.initial ?? false)
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .autoenablesItems(let x): return x.apply(instance) { i, v in i.autoenablesItems = v }
		case .menu(let x): return x.apply(instance) { i, v in i.menu = v.nsMenu() }
		case .preferredEdge(let x): return x.apply(instance) { i, v in i.preferredEdge = v }
		case .pullsDown: return pullsDown.resume()?.apply(instance) { i, v in i.pullsDown = v }
		case .selectedIndex(let x): return x.apply(instance) { i, v in i.selectItem(at: v) }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case .willPopUp(let x): return Signal.notifications(name: NSPopUpButton.willPopUpNotification, object: instance).map { n in () }.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PopUpButton.Preparer {
	public typealias Storage = Button.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PopUpButtonBinding {
	public typealias PopUpButtonName<V> = BindingName<V, PopUpButton.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PopUpButton.Binding) -> PopUpButtonName<V> {
		return PopUpButtonName<V>(source: source, downcast: Binding.popUpButtonBinding)
	}
}
public extension BindingName where Binding: PopUpButtonBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PopUpButtonName<$2> { return .name(PopUpButton.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var autoenablesItems: PopUpButtonName<Dynamic<Bool>> { return .name(PopUpButton.Binding.autoenablesItems) }
	static var menu: PopUpButtonName<Dynamic<MenuConvertible>> { return .name(PopUpButton.Binding.menu) }
	static var preferredEdge: PopUpButtonName<Dynamic<NSRectEdge>> { return .name(PopUpButton.Binding.preferredEdge) }
	static var pullsDown: PopUpButtonName<Dynamic<Bool>> { return .name(PopUpButton.Binding.pullsDown) }
	static var selectedIndex: PopUpButtonName<Dynamic<Int>> { return .name(PopUpButton.Binding.selectedIndex) }
	static var title: PopUpButtonName<Dynamic<String>> { return .name(PopUpButton.Binding.title) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var willPopUp: PopUpButtonName<SignalInput<Void>> { return .name(PopUpButton.Binding.willPopUp) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol PopUpButtonConvertible: ButtonConvertible {
	func nsPopUpButton() -> PopUpButton.Instance
}
extension PopUpButtonConvertible {
	public func nsButton() -> Button.Instance { return nsPopUpButton() }
}
extension NSPopUpButton: PopUpButtonConvertible {
	public func nsPopUpButton() -> PopUpButton.Instance { return self }
}
public extension PopUpButton {
	func nsPopUpButton() -> PopUpButton.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol PopUpButtonBinding: ButtonBinding {
	static func popUpButtonBinding(_ binding: PopUpButton.Binding) -> Self
	func asPopUpButtonBinding() -> PopUpButton.Binding?
}
public extension PopUpButtonBinding {
	static func buttonBinding(_ binding: Button.Binding) -> Self {
		return popUpButtonBinding(.inheritedBinding(binding))
	}
}
public extension PopUpButtonBinding where Preparer.Inherited.Binding: PopUpButtonBinding {
	func asPopUpButtonBinding() -> PopUpButton.Binding? {
		return asInheritedBinding()?.asPopUpButtonBinding()
	}
}
public extension PopUpButton.Binding {
	typealias Preparer = PopUpButton.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPopUpButtonBinding() -> PopUpButton.Binding? { return self }
	static func popUpButtonBinding(_ binding: PopUpButton.Binding) -> PopUpButton.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class PressGestureRecognizer: Binder, PressGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension PressGestureRecognizer {
	enum Binding: PressGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowableMovement(Dynamic<CGFloat>)
		case buttonMask(Dynamic<Int>)
		case minimumPressDuration(Dynamic<TimeInterval>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension PressGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = PressGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = NSPressGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension PressGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowableMovement(let x): return x.apply(instance) { i, v in i.allowableMovement = v }
		case .buttonMask(let x): return x.apply(instance) { i, v in i.buttonMask = v }
		case .minimumPressDuration(let x): return x.apply(instance) { i, v in i.minimumPressDuration = v }
			
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension PressGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: PressGestureRecognizerBinding {
	public typealias PressGestureRecognizerName<V> = BindingName<V, PressGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> PressGestureRecognizer.Binding) -> PressGestureRecognizerName<V> {
		return PressGestureRecognizerName<V>(source: source, downcast: Binding.pressGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: PressGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: PressGestureRecognizerName<$2> { return .name(PressGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowableMovement: PressGestureRecognizerName<Dynamic<CGFloat>> { return .name(PressGestureRecognizer.Binding.allowableMovement) }
	static var buttonMask: PressGestureRecognizerName<Dynamic<Int>> { return .name(PressGestureRecognizer.Binding.buttonMask) }
	static var minimumPressDuration: PressGestureRecognizerName<Dynamic<TimeInterval>> { return .name(PressGestureRecognizer.Binding.minimumPressDuration) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol PressGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsPressGestureRecognizer() -> PressGestureRecognizer.Instance
}
extension PressGestureRecognizerConvertible {
	public func nsGestureRecognizer() -> GestureRecognizer.Instance { return nsPressGestureRecognizer() }
}
extension NSPressGestureRecognizer: PressGestureRecognizerConvertible {
	public func nsPressGestureRecognizer() -> PressGestureRecognizer.Instance { return self }
}
public extension PressGestureRecognizer {
	func nsPressGestureRecognizer() -> PressGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol PressGestureRecognizerBinding: GestureRecognizerBinding {
	static func pressGestureRecognizerBinding(_ binding: PressGestureRecognizer.Binding) -> Self
	func asPressGestureRecognizerBinding() -> PressGestureRecognizer.Binding?
}
public extension PressGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return pressGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension PressGestureRecognizerBinding where Preparer.Inherited.Binding: PressGestureRecognizerBinding {
	func asPressGestureRecognizerBinding() -> PressGestureRecognizer.Binding? {
		return asInheritedBinding()?.asPressGestureRecognizerBinding()
	}
}
public extension PressGestureRecognizer.Binding {
	typealias Preparer = PressGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asPressGestureRecognizerBinding() -> PressGestureRecognizer.Binding? { return self }
	static func pressGestureRecognizerBinding(_ binding: PressGestureRecognizer.Binding) -> PressGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class RotationGestureRecognizer: Binder, RotationGestureRecognizerConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension RotationGestureRecognizer {
	enum Binding: RotationGestureRecognizerBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rotationInRadians(Dynamic<CGFloat>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension RotationGestureRecognizer {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = RotationGestureRecognizer.Binding
		public typealias Inherited = GestureRecognizer.Preparer
		public typealias Instance = NSRotationGestureRecognizer
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension RotationGestureRecognizer.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .rotationInRadians(let x): return x.apply(instance) { i, v in i.rotation = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension RotationGestureRecognizer.Preparer {
	public typealias Storage = GestureRecognizer.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: RotationGestureRecognizerBinding {
	public typealias RotationGestureRecognizerName<V> = BindingName<V, RotationGestureRecognizer.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> RotationGestureRecognizer.Binding) -> RotationGestureRecognizerName<V> {
		return RotationGestureRecognizerName<V>(source: source, downcast: Binding.rotationGestureRecognizerBinding)
	}
}
public extension BindingName where Binding: RotationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: RotationGestureRecognizerName<$2> { return .name(RotationGestureRecognizer.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var rotationInRadians: RotationGestureRecognizerName<Dynamic<CGFloat>> { return .name(RotationGestureRecognizer.Binding.rotationInRadians) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol RotationGestureRecognizerConvertible: GestureRecognizerConvertible {
	func nsRotationGestureRecognizer() -> RotationGestureRecognizer.Instance
}
extension RotationGestureRecognizerConvertible {
	public func nsGestureRecognizer() -> GestureRecognizer.Instance { return nsRotationGestureRecognizer() }
}
extension NSRotationGestureRecognizer: RotationGestureRecognizerConvertible {
	public func nsRotationGestureRecognizer() -> RotationGestureRecognizer.Instance { return self }
}
public extension RotationGestureRecognizer {
	func nsRotationGestureRecognizer() -> RotationGestureRecognizer.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol RotationGestureRecognizerBinding: GestureRecognizerBinding {
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -> Self
	func asRotationGestureRecognizerBinding() -> RotationGestureRecognizer.Binding?
}
public extension RotationGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return rotationGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
public extension RotationGestureRecognizerBinding where Preparer.Inherited.Binding: RotationGestureRecognizerBinding {
	func asRotationGestureRecognizerBinding() -> RotationGestureRecognizer.Binding? {
		return asInheritedBinding()?.asRotationGestureRecognizerBinding()
	}
}
public extension RotationGestureRecognizer.Binding {
	typealias Preparer = RotationGestureRecognizer.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asRotationGestureRecognizerBinding() -> RotationGestureRecognizer.Binding? { return self }
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -> RotationGestureRecognizer.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class ScrollView: Binder, ScrollViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ScrollView {
	enum Binding: ScrollViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsMagnification(Dynamic<Bool>)
		case autohidesScrollers(Dynamic<Bool>)
		case automaticallyAdjustsContentInsets(Dynamic<Bool>)
		case backgroundColor(Dynamic<NSColor>)
		case borderType(Dynamic<NSBorderType>)
		case contentInsets(Dynamic<NSEdgeInsets>)
		case contentView(Dynamic<ClipViewConvertible>)
		case documentCursor(Dynamic<NSCursor?>)
		case drawsBackground(Dynamic<Bool>)
		case findBarPosition(Dynamic<NSScrollView.FindBarPosition>)
		case floatingSubviews(Dynamic<[(view: ViewConvertible, axis: NSEvent.GestureAxis)]>)
		case hasHorizontalRuler(Dynamic<Bool>)
		case hasHorizontalScroller(Dynamic<Bool>)
		case hasVerticalRuler(Dynamic<Bool>)
		case hasVerticalScroller(Dynamic<Bool>)
		case horizontalLineScroll(Dynamic<CGFloat>)
		case horizontalPageScroll(Dynamic<CGFloat>)
		case horizontalScrollElasticity(Dynamic<NSScrollView.Elasticity>)
		case magnification(Dynamic<CGFloat>)
		case maxMagnification(Dynamic<CGFloat>)
		case minMagnification(Dynamic<CGFloat>)
		case rulersVisible(Dynamic<Bool>)
		case scrollerInsets(Dynamic<NSEdgeInsets>)
		case scrollerKnobStyle(Dynamic<NSScroller.KnobStyle>)
		case scrollerStyle(Dynamic<NSScroller.Style>)
		case scrollsDynamically(Dynamic<Bool>)
		case usesPredominantAxisScrolling(Dynamic<Bool>)
		case verticalLineScroll(Dynamic<CGFloat>)
		case verticalPageScroll(Dynamic<CGFloat>)
		case verticalScrollElasticity(Dynamic<NSScrollView.Elasticity>)

		// 2. Signal bindings are performed on the object after construction.
		case flashScrollers(Signal<Bool>)
		case magnificationCenteredAtPoint(Signal<(CGFloat, NSPoint)>)
		case magnifyToFitRect(Signal<CGRect>)
		case scrollWheel(Signal<NSEvent>)

		// 3. Action bindings are triggered by the object after construction.
		case didEndLiveMagnify(SignalInput<Void>)
		case didEndLiveScroll(SignalInput<Void>)
		case didLiveScroll(SignalInput<Void>)
		case willStartLiveMagnify(SignalInput<Void>)
		case willStartLiveScroll(SignalInput<Void>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension ScrollView {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = ScrollView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSScrollView
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ScrollView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsMagnification(let x): return x.apply(instance) { i, v in i.allowsMagnification = v }
		case .autohidesScrollers(let x): return x.apply(instance) { i, v in i.autohidesScrollers = v }
		case .automaticallyAdjustsContentInsets(let x): return x.apply(instance) { i, v in i.automaticallyAdjustsContentInsets = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .borderType(let x): return x.apply(instance) { i, v in i.borderType = v }
		case .contentInsets(let x): return x.apply(instance) { i, v in i.contentInsets = v }
		case .contentView(let x): return x.apply(instance) { i, v in i.contentView = v.nsClipView() }
		case .documentCursor(let x): return x.apply(instance) { i, v in i.documentCursor = v }
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .findBarPosition(let x): return x.apply(instance) { i, v in i.findBarPosition = v }
		case .floatingSubviews(let x):
			return x.apply(instance, storage) { i, s, v in
				s.floatingSubviews.forEach { $0.removeFromSuperview() }
				s.floatingSubviews = v.map {
					let sub = $0.view.nsView()
					i.addFloatingSubview(sub, for: $0.axis)
					return sub
				}
			}
		case .hasHorizontalRuler(let x): return x.apply(instance) { i, v in i.hasHorizontalRuler = v }
		case .hasHorizontalScroller(let x): return x.apply(instance) { i, v in i.hasHorizontalScroller = v }
		case .hasVerticalRuler(let x): return x.apply(instance) { i, v in i.hasVerticalRuler = v }
		case .hasVerticalScroller(let x): return x.apply(instance) { i, v in i.hasVerticalScroller = v }
		case .horizontalLineScroll(let x): return x.apply(instance) { i, v in i.horizontalLineScroll = v }
		case .horizontalPageScroll(let x): return x.apply(instance) { i, v in i.horizontalPageScroll = v }
		case .horizontalScrollElasticity(let x): return x.apply(instance) { i, v in i.horizontalScrollElasticity = v }
		case .magnification(let x): return x.apply(instance) { i, v in i.magnification = v }
		case .maxMagnification(let x): return x.apply(instance) { i, v in i.maxMagnification = v }
		case .minMagnification(let x): return x.apply(instance) { i, v in i.minMagnification = v }
		case .rulersVisible(let x): return x.apply(instance) { i, v in i.rulersVisible = v }
		case .scrollerInsets(let x): return x.apply(instance) { i, v in i.scrollerInsets = v }
		case .scrollerKnobStyle(let x): return x.apply(instance) { i, v in i.scrollerKnobStyle = v }
		case .scrollerStyle(let x): return x.apply(instance) { i, v in i.scrollerStyle = v }
		case .scrollsDynamically(let x): return x.apply(instance) { i, v in i.scrollsDynamically = v }
		case .usesPredominantAxisScrolling(let x): return x.apply(instance) { i, v in i.usesPredominantAxisScrolling = v }
		case .verticalLineScroll(let x): return x.apply(instance) { i, v in i.verticalLineScroll = v }
		case .verticalPageScroll(let x): return x.apply(instance) { i, v in i.verticalPageScroll = v }
		case .verticalScrollElasticity(let x): return x.apply(instance) { i, v in i.verticalScrollElasticity = v }

		// 2. Signal bindings are performed on the object after construction.
		case .flashScrollers(let x): return x.apply(instance) { i, v in i.flashScrollers() }
		case .magnificationCenteredAtPoint(let x): return x.apply(instance) { i, v in i.setMagnification(v.0, centeredAt: v.1) }
		case .magnifyToFitRect(let x): return x.apply(instance) { i, v in i.magnify(toFit: v) }
		case .scrollWheel(let x): return x.apply(instance) { i, v in i.scrollWheel(with: v) }

		// 3. Action bindings are triggered by the object after construction.
		case .didEndLiveMagnify(let x): return Signal.notifications(name: NSScrollView.didEndLiveMagnifyNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEndLiveScroll(let x): return Signal.notifications(name: NSScrollView.didEndLiveScrollNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didLiveScroll(let x): return Signal.notifications(name: NSScrollView.didLiveScrollNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willStartLiveMagnify(let x): return Signal.notifications(name: NSScrollView.willStartLiveMagnifyNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willStartLiveScroll(let x): return Signal.notifications(name: NSScrollView.willStartLiveScrollNotification, object: instance).map { n in () }.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ScrollView.Preparer {
	open class Storage: View.Preparer.Storage {
		open override var isInUse: Bool {
			return super.isInUse || !floatingSubviews.isEmpty
		}
		
		open var floatingSubviews: [NSView] = []
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ScrollViewBinding {
	public typealias ScrollViewName<V> = BindingName<V, ScrollView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ScrollView.Binding) -> ScrollViewName<V> {
		return ScrollViewName<V>(source: source, downcast: Binding.scrollViewBinding)
	}
}
public extension BindingName where Binding: ScrollViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ScrollViewName<$2> { return .name(ScrollView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMagnification: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.allowsMagnification) }
	static var autohidesScrollers: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.autohidesScrollers) }
	static var automaticallyAdjustsContentInsets: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.automaticallyAdjustsContentInsets) }
	static var backgroundColor: ScrollViewName<Dynamic<NSColor>> { return .name(ScrollView.Binding.backgroundColor) }
	static var borderType: ScrollViewName<Dynamic<NSBorderType>> { return .name(ScrollView.Binding.borderType) }
	static var contentInsets: ScrollViewName<Dynamic<NSEdgeInsets>> { return .name(ScrollView.Binding.contentInsets) }
	static var contentView: ScrollViewName<Dynamic<ClipViewConvertible>> { return .name(ScrollView.Binding.contentView) }
	static var documentCursor: ScrollViewName<Dynamic<NSCursor?>> { return .name(ScrollView.Binding.documentCursor) }
	static var drawsBackground: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.drawsBackground) }
	static var findBarPosition: ScrollViewName<Dynamic<NSScrollView.FindBarPosition>> { return .name(ScrollView.Binding.findBarPosition) }
	static var floatingSubviews: ScrollViewName<Dynamic<[(view: ViewConvertible, axis: NSEvent.GestureAxis)]>> { return .name(ScrollView.Binding.floatingSubviews) }
	static var hasHorizontalRuler: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.hasHorizontalRuler) }
	static var hasHorizontalScroller: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.hasHorizontalScroller) }
	static var hasVerticalRuler: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.hasVerticalRuler) }
	static var hasVerticalScroller: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.hasVerticalScroller) }
	static var horizontalLineScroll: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.horizontalLineScroll) }
	static var horizontalPageScroll: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.horizontalPageScroll) }
	static var horizontalScrollElasticity: ScrollViewName<Dynamic<NSScrollView.Elasticity>> { return .name(ScrollView.Binding.horizontalScrollElasticity) }
	static var magnification: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.magnification) }
	static var maxMagnification: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.maxMagnification) }
	static var minMagnification: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.minMagnification) }
	static var rulersVisible: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.rulersVisible) }
	static var scrollerInsets: ScrollViewName<Dynamic<NSEdgeInsets>> { return .name(ScrollView.Binding.scrollerInsets) }
	static var scrollerKnobStyle: ScrollViewName<Dynamic<NSScroller.KnobStyle>> { return .name(ScrollView.Binding.scrollerKnobStyle) }
	static var scrollerStyle: ScrollViewName<Dynamic<NSScroller.Style>> { return .name(ScrollView.Binding.scrollerStyle) }
	static var scrollsDynamically: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.scrollsDynamically) }
	static var usesPredominantAxisScrolling: ScrollViewName<Dynamic<Bool>> { return .name(ScrollView.Binding.usesPredominantAxisScrolling) }
	static var verticalLineScroll: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.verticalLineScroll) }
	static var verticalPageScroll: ScrollViewName<Dynamic<CGFloat>> { return .name(ScrollView.Binding.verticalPageScroll) }
	static var verticalScrollElasticity: ScrollViewName<Dynamic<NSScrollView.Elasticity>> { return .name(ScrollView.Binding.verticalScrollElasticity) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var flashScrollers: ScrollViewName<Signal<Bool>> { return .name(ScrollView.Binding.flashScrollers) }
	static var magnificationCenteredAtPoint: ScrollViewName<Signal<(CGFloat, NSPoint)>> { return .name(ScrollView.Binding.magnificationCenteredAtPoint) }
	static var magnifyToFitRect: ScrollViewName<Signal<CGRect>> { return .name(ScrollView.Binding.magnifyToFitRect) }
	static var scrollWheel: ScrollViewName<Signal<NSEvent>> { return .name(ScrollView.Binding.scrollWheel) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didEndLiveMagnify: ScrollViewName<SignalInput<Void>> { return .name(ScrollView.Binding.didEndLiveMagnify) }
	static var didEndLiveScroll: ScrollViewName<SignalInput<Void>> { return .name(ScrollView.Binding.didEndLiveScroll) }
	static var didLiveScroll: ScrollViewName<SignalInput<Void>> { return .name(ScrollView.Binding.didLiveScroll) }
	static var willStartLiveMagnify: ScrollViewName<SignalInput<Void>> { return .name(ScrollView.Binding.willStartLiveMagnify) }
	static var willStartLiveScroll: ScrollViewName<SignalInput<Void>> { return .name(ScrollView.Binding.willStartLiveScroll) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ScrollViewConvertible: ViewConvertible {
	func nsScrollView() -> ScrollView.Instance
}
extension ScrollViewConvertible {
	public func nsView() -> View.Instance { return nsScrollView() }
}
extension NSScrollView: ScrollViewConvertible {
	public func nsScrollView() -> ScrollView.Instance { return self }
}
public extension ScrollView {
	func nsScrollView() -> ScrollView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ScrollViewBinding: ViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self
	func asScrollViewBinding() -> ScrollView.Binding?
}
public extension ScrollViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}
public extension ScrollViewBinding where Preparer.Inherited.Binding: ScrollViewBinding {
	func asScrollViewBinding() -> ScrollView.Binding? {
		return asInheritedBinding()?.asScrollViewBinding()
	}
}
public extension ScrollView.Binding {
	typealias Preparer = ScrollView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asScrollViewBinding() -> ScrollView.Binding? { return self }
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> ScrollView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class SegmentedControl: Binder, SegmentedControlConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension SegmentedControl {
	enum Binding: SegmentedControlBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case isSpringLoaded(Dynamic<Bool>)
		case distribution(Dynamic<NSSegmentedControl.Distribution>)
		case segments(Dynamic<[SegmentDescription]>)
		case segmentStyle(Dynamic<NSSegmentedControl.Style>)
		case selectedSegment(Dynamic<Int>)
		case trackingMode(Dynamic<NSSegmentedControl.SwitchTracking>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension SegmentedControl {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = SegmentedControl.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = NSSegmentedControl
		
		public var inherited = Inherited()
		public init() {}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension SegmentedControl.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .isSpringLoaded(let x): return x.apply(instance) { i, v in i.isSpringLoaded = v }
		case .distribution(let x): return x.apply(instance) { i, v in i.segmentDistribution = v }
		case .segments(let x):
			return x.apply(instance) { i, v in
				i.segmentCount = v.count
				for (index, segment) in v.enumerated() {
					i.setAlignment(segment.alignment, forSegment: index)
					i.setImage(segment.image, forSegment: index)
					i.setImageScaling(segment.imageScaling, forSegment: index)
					i.setEnabled(segment.isEnabled, forSegment: index)
					i.setLabel(segment.label, forSegment: index)
					i.setMenu(segment.menu?.nsMenu(), forSegment: index)
					i.setShowsMenuIndicator(segment.showsMenuIndicator, forSegment: index)
					i.setTag(segment.tag, forSegment: index)
					i.setToolTip(segment.toolTip, forSegment: index)
					i.setWidth(segment.width, forSegment: index)
				}
			}
		case .selectedSegment(let x): return x.apply(instance) { i, v in i.selectedSegment = v }
		case .segmentStyle(let x): return x.apply(instance) { i, v in i.segmentStyle = v }
		case .trackingMode(let x): return x.apply(instance) { i, v in i.trackingMode = v }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SegmentedControl.Preparer {
	public typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SegmentedControlBinding {
	public typealias SegmentedControlName<V> = BindingName<V, SegmentedControl.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> SegmentedControl.Binding) -> SegmentedControlName<V> {
		return SegmentedControlName<V>(source: source, downcast: Binding.segmentedControlBinding)
	}
}
public extension BindingName where Binding: SegmentedControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SegmentedControlName<$2> { return .name(SegmentedControl.Binding.$1) }

	static var isSpringLoaded: SegmentedControlName<Dynamic<Bool>> { return .name(SegmentedControl.Binding.isSpringLoaded) }
	static var distribution: SegmentedControlName<Dynamic<NSSegmentedControl.Distribution>> { return .name(SegmentedControl.Binding.distribution) }
	static var segments: SegmentedControlName<Dynamic<[SegmentDescription]>> { return .name(SegmentedControl.Binding.segments) }
	static var segmentStyle: SegmentedControlName<Dynamic<NSSegmentedControl.Style>> { return .name(SegmentedControl.Binding.segmentStyle) }
	static var selectedSegment: SegmentedControlName<Dynamic<Int>> { return .name(SegmentedControl.Binding.selectedSegment) }
	static var trackingMode: SegmentedControlName<Dynamic<NSSegmentedControl.SwitchTracking>> { return .name(SegmentedControl.Binding.trackingMode) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol SegmentedControlConvertible: ControlConvertible {
	func nsSegmentedControl() -> SegmentedControl.Instance
}
extension SegmentedControlConvertible {
	public func nsControl() -> Control.Instance { return nsSegmentedControl() }
}
extension NSSegmentedControl: SegmentedControlConvertible /* , HasDelegate // if Preparer is BinderDelegateEmbedderConstructor */ {
	public func nsSegmentedControl() -> SegmentedControl.Instance { return self }
}
public extension SegmentedControl {
	func nsSegmentedControl() -> SegmentedControl.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol SegmentedControlBinding: ControlBinding {
	static func segmentedControlBinding(_ binding: SegmentedControl.Binding) -> Self
	func asSegmentedControlBinding() -> SegmentedControl.Binding?
}
public extension SegmentedControlBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return segmentedControlBinding(.inheritedBinding(binding))
	}
}
public extension SegmentedControlBinding where Preparer.Inherited.Binding: SegmentedControlBinding {
	func asSegmentedControlBinding() -> SegmentedControl.Binding? {
		return asInheritedBinding()?.asSegmentedControlBinding()
	}
}
public extension SegmentedControl.Binding {
	typealias Preparer = SegmentedControl.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSegmentedControlBinding() -> SegmentedControl.Binding? { return self }
	static func segmentedControlBinding(_ binding: SegmentedControl.Binding) -> SegmentedControl.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public struct SegmentDescription {
	public let alignment: NSTextAlignment
	public let image: NSImage?
	public let imageScaling: NSImageScaling
	public let isEnabled: Bool
	public let isSelected: Bool
	public let label: String
	public let menu: MenuConvertible?
	public let showsMenuIndicator: Bool
	public let tag: Int
	public let toolTip: String?
	public let width: CGFloat
	
	public init(label: String, alignment: NSTextAlignment = .center, image: NSImage? = nil, imageScaling: NSImageScaling = .scaleProportionallyDown, isEnabled: Bool = true, isSelected: Bool = false, menu: NSMenu? = nil, showsMenuIndicator: Bool = false, tag: Int = 0, toolTip: String? = nil, width: CGFloat = 0) {
		self.alignment = alignment
		self.image = image
		self.imageScaling = imageScaling
		self.isEnabled = isEnabled
		self.isSelected = isSelected
		self.label = label
		self.menu = menu
		self.showsMenuIndicator = showsMenuIndicator
		self.tag = tag
		self.toolTip = toolTip
		self.width = width
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class Slider: Binder, SliderConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Slider {
	enum Binding: SliderBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsTickMarkValuesOnly(Dynamic<Bool>)
		case altIncrementValue(Dynamic<Double>)
		case isVertical(Dynamic<Bool>)
		case maxValue(Dynamic<Double>)
		case minValue(Dynamic<Double>)
		case numberOfTickMarks(Dynamic<Int>)
		case sliderType(Dynamic<NSSlider.SliderType>)
		case tickMarkPosition(Dynamic<NSSlider.TickMarkPosition>)
		case trackFillColor(Dynamic<NSColor?>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension Slider {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = Slider.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = NSSlider
		
		public var inherited = Inherited()
		public init() {}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Slider.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .allowsTickMarkValuesOnly(let x): return x.apply(instance) { i, v in i.allowsTickMarkValuesOnly = v }
		case .altIncrementValue(let x): return x.apply(instance) { i, v in i.altIncrementValue = v }
		case .isVertical(let x): return x.apply(instance) { i, v in i.isVertical = v }
		case .maxValue(let x): return x.apply(instance) { i, v in i.maxValue = v }
		case .minValue(let x): return x.apply(instance) { i, v in i.minValue = v }
		case .numberOfTickMarks(let x): return x.apply(instance) { i, v in i.numberOfTickMarks = v }
		case .sliderType(let x): return x.apply(instance) { i, v in i.sliderType = v }
		case .tickMarkPosition(let x): return x.apply(instance) { i, v in i.tickMarkPosition = v }
		case .trackFillColor(let x): return x.apply(instance) { i, v in i.trackFillColor = v }
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Slider.Preparer {
	public typealias Storage = Control.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SliderBinding {
	public typealias SliderName<V> = BindingName<V, Slider.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Slider.Binding) -> SliderName<V> {
		return SliderName<V>(source: source, downcast: Binding.sliderBinding)
	}
}
public extension BindingName where Binding: SliderBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SliderName<$2> { return .name(Slider.Binding.$1) }

	static var allowsTickMarkValuesOnly: SliderName<Dynamic<Bool>> { return .name(Slider.Binding.allowsTickMarkValuesOnly) }
	static var altIncrementValue: SliderName<Dynamic<Double>> { return .name(Slider.Binding.altIncrementValue) }
	static var isVertical: SliderName<Dynamic<Bool>> { return .name(Slider.Binding.isVertical) }
	static var maxValue: SliderName<Dynamic<Double>> { return .name(Slider.Binding.maxValue) }
	static var minValue: SliderName<Dynamic<Double>> { return .name(Slider.Binding.minValue) }
	static var numberOfTickMarks: SliderName<Dynamic<Int>> { return .name(Slider.Binding.numberOfTickMarks) }
	static var sliderType: SliderName<Dynamic<NSSlider.SliderType>> { return .name(Slider.Binding.sliderType) }
	static var tickMarkPosition: SliderName<Dynamic<NSSlider.TickMarkPosition>> { return .name(Slider.Binding.tickMarkPosition) }
	static var trackFillColor: SliderName<Dynamic<NSColor?>> { return .name(Slider.Binding.trackFillColor) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol SliderConvertible: ControlConvertible {
	func nsSlider() -> Slider.Instance
}
extension SliderConvertible {
	public func nsControl() -> Control.Instance { return nsSlider() }
}
extension NSSlider: SliderConvertible /* , HasDelegate // if Preparer is BinderDelegateEmbedderConstructor */ {
	public func nsSlider() -> Slider.Instance { return self }
}
public extension Slider {
	func nsSlider() -> Slider.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol SliderBinding: ControlBinding {
	static func sliderBinding(_ binding: Slider.Binding) -> Self
	func asSliderBinding() -> Slider.Binding?
}
public extension SliderBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return sliderBinding(.inheritedBinding(binding))
	}
}
public extension SliderBinding where Preparer.Inherited.Binding: SliderBinding {
	func asSliderBinding() -> Slider.Binding? {
		return asInheritedBinding()?.asSliderBinding()
	}
}
public extension Slider.Binding {
	typealias Preparer = Slider.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSliderBinding() -> Slider.Binding? { return self }
	static func sliderBinding(_ binding: Slider.Binding) -> Slider.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class SplitView: Binder, SplitViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	public static var verticalThinBindings: [Binding] {
		return [
			.isVertical -- true,
			.dividerStyle -- .thin
		]
	}
	
	public static func verticalThin(type: Instance.Type = Instance.self, _ bindings: Binding...) -> SplitView {
		return SplitView(type: type, parameters: (), bindings: SplitView.verticalThinBindings + bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension SplitView {
	enum Binding: SplitViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case arrangedSubviews(Dynamic<ArrayMutation<SplitSubview>>)
		case autosaveName(Dynamic<NSSplitView.AutosaveName?>)
		case dividerStyle(Dynamic<NSSplitView.DividerStyle>)
		case isVertical(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.
		case setDividerPosition(Signal<(position: CGFloat, dividerIndex: Int)>)

		// 3. Action bindings are triggered by the object after construction.
		case didResizeSubviews(SignalInput<Int?>)
		case willResizeSubviews(SignalInput<Int?>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case additionalEffectiveRect((_ splitView: NSSplitView, _ dividerAt: Int) -> NSRect)
		case canCollapseSubview((_ splitView: NSSplitView, _ subview: NSView) -> Bool)
		case constrainMaxCoordinate((_ splitView: NSSplitView, _ proposedMaximumPosition: CGFloat, _ dividerIndex: Int) -> CGFloat)
		case constrainMinCoordinate((_ splitView: NSSplitView, _ proposedMinimumPosition: CGFloat, _ dividerIndex: Int) -> CGFloat)
		case constrainSplitPosition((_ splitView: NSSplitView, _ proposedPosition: CGFloat, _ dividerIndex: Int) -> CGFloat)
		case effectiveRectForDrawnRect((_ splitView: NSSplitView, _ proposedEffectiveRect: NSRect, _ drawnRect: NSRect, _ dividerIndex: Int) -> NSRect)
		case resizeSubviews((NSSplitView, NSSize) -> Void)
		case shouldAdjustSizeOfSubview((_ splitView: NSSplitView, _ subview: NSView) -> Bool)
		case shouldCollapseSubview((_ splitView: NSSplitView, _ subview: NSView, _ dividerIndex: Int) -> Bool)
		case shouldHideDivider((_ splitView: NSSplitView, _ dividerIndex: Int) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
public extension SplitView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = SplitView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSSplitView
		public typealias Parameters = () /* change if non-default construction required */
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var autosaveName: Dynamic<NSSplitView.AutosaveName?>? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension SplitView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)

		case .additionalEffectiveRect(let x): delegate().addSingleHandler2(x, #selector(NSSplitViewDelegate.splitView(_:additionalEffectiveRectOfDividerAt:)))
		case .autosaveName(let x): autosaveName = x
		case .canCollapseSubview(let x): delegate().addSingleHandler2(x, #selector(NSSplitViewDelegate.splitView(_:canCollapseSubview:)))
		case .constrainMaxCoordinate(let x): delegate().addSingleHandler3(x, #selector(NSSplitViewDelegate.splitView(_:constrainMaxCoordinate:ofSubviewAt:)))
		case .constrainMinCoordinate(let x): delegate().addSingleHandler3(x, #selector(NSSplitViewDelegate.splitView(_:constrainMinCoordinate:ofSubviewAt:)))
		case .constrainSplitPosition(let x): delegate().addSingleHandler3(x, #selector(NSSplitViewDelegate.splitView(_:constrainSplitPosition:ofSubviewAt:)))
		case .effectiveRectForDrawnRect(let x): delegate().addSingleHandler4(x, #selector(NSSplitViewDelegate.splitView(_:effectiveRect:forDrawnRect:ofDividerAt:)))
		case .resizeSubviews(let x): delegate().addMultiHandler2(x, #selector(NSSplitViewDelegate.splitView(_:resizeSubviewsWithOldSize:)))
		case .shouldAdjustSizeOfSubview(let x): delegate().addSingleHandler2(x, #selector(NSSplitViewDelegate.splitView(_:shouldAdjustSizeOfSubview:)))
		case .shouldCollapseSubview(let x): delegate().addSingleHandler3(x, #selector(NSSplitViewDelegate.splitView(_:shouldCollapseSubview:forDoubleClickOnDividerAt:)))
		case .shouldHideDivider(let x): delegate().addSingleHandler2(x, #selector(NSSplitViewDelegate.splitView(_:shouldHideDividerAt:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .arrangedSubviews(let x): return x.apply(instance) { i, v in
			v.insertionsAndRemovals(length: i.arrangedSubviews.count, insert: { index, component in
				let view = component.view.nsView()
				view.removeFromSuperview()
				instance.insertArrangedSubview(view, at: index)
				instance.setHoldingPriority(component.holdingPriority, forSubviewAt: index)
				
				let viewAnchor = instance.isVertical ? view.widthAnchor : view.heightAnchor
				let instanceAnchor = instance.isVertical ? i.widthAnchor : i.heightAnchor
				
				NSLayoutConstraint.activate(
					component.constraints.map { $0.scaledConstraintBetween(first: viewAnchor, second: instanceAnchor) }
				)
			}, remove: { index in
				instance.removeArrangedSubview(instance.arrangedSubviews[index])
			})
		}
		case .autosaveName: return nil
		case .dividerStyle(let x): return x.apply(instance) { i, v in i.dividerStyle = v }
		case .isVertical(let x): return x.apply(instance) { i, v in i.isVertical = v }

		// 2. Signal bindings are performed on the object after construction.
		case .setDividerPosition(let x): return x.apply(instance) { i, v in i.setPosition(v.position, ofDividerAt: v.dividerIndex) }

		// 3. Action bindings are triggered by the object after construction.
		case .didResizeSubviews(let x): return Signal.notifications(name: NSSplitView.didResizeSubviewsNotification, object: instance).map { n in return n.userInfo?["NSSplitViewDividerIndex"] as? Int }.cancellableBind(to: x)
		case .willResizeSubviews(let x):return Signal.notifications(name: NSSplitView.willResizeSubviewsNotification, object: instance).map { n in return n.userInfo?["NSSplitViewDividerIndex"] as? Int }.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .additionalEffectiveRect: return nil
		case .canCollapseSubview: return nil
		case .constrainMaxCoordinate: return nil
		case .constrainMinCoordinate: return nil
		case .constrainSplitPosition: return nil
		case .effectiveRectForDrawnRect: return nil
		case .resizeSubviews: return nil
		case .shouldAdjustSizeOfSubview: return nil
		case .shouldCollapseSubview: return nil
		case .shouldHideDivider: return nil
		}
	}

	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		var lifetimes = [Lifetime]()
		lifetimes += autosaveName?.apply(instance) { i, v in
			i.autosaveName = v
		}

		lifetimes += inheritedFinalizedInstance(instance, storage: storage)
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension SplitView.Preparer {
	open class Storage: View.Preparer.Storage, NSSplitViewDelegate {
		var constraints: [(Layout.Dimension, NSLayoutConstraint)] = []
	}
	
	open class Delegate: DynamicDelegate, NSSplitViewDelegate {
		public func splitView(_ splitView: NSSplitView, additionalEffectiveRectOfDividerAt dividerIndex: Int) -> NSRect {
			return singleHandler(splitView, dividerIndex)
		}
		
		public func splitView(_ splitView: NSSplitView, canCollapseSubview subview: NSView) -> Bool {
			return singleHandler(splitView, subview)
		}
		
		public func splitView(_ splitView: NSSplitView, constrainMaxCoordinate proposedMaximumPosition: CGFloat, ofSubviewAt dividerIndex: Int) -> CGFloat {
			return singleHandler(splitView, proposedMaximumPosition, dividerIndex)
		}
		
		public func splitView(_ splitView: NSSplitView, constrainMinCoordinate proposedMinimumPosition: CGFloat, ofSubviewAt dividerIndex: Int) -> CGFloat {
			return singleHandler(splitView, proposedMinimumPosition, dividerIndex)
		}
		
		public func splitView(_ splitView: NSSplitView, constrainSplitPosition proposedPosition: CGFloat, ofSubviewAt dividerIndex: Int) -> CGFloat {
			return singleHandler(splitView, proposedPosition, dividerIndex)
		}
		
		public func splitView(_ splitView: NSSplitView, effectiveRect proposedEffectiveRect: NSRect, forDrawnRect drawnRect: NSRect, ofDividerAt dividerIndex: Int) -> NSRect {
			return singleHandler(splitView, proposedEffectiveRect, drawnRect, dividerIndex)
		}
		
		public func splitView(_ splitView: NSSplitView, resizeSubviewsWithOldSize oldSize: NSSize) {
			multiHandler(splitView, oldSize)
		}
		
		public func splitView(_ splitView: NSSplitView, shouldAdjustSizeOfSubview view: NSView) -> Bool {
			return singleHandler(splitView, view)
		}
		
		public func splitView(_ splitView: NSSplitView, shouldCollapseSubview subview: NSView, forDoubleClickOnDividerAt dividerIndex: Int) -> Bool {
			return singleHandler(splitView, subview, dividerIndex)
		}
		
		public func splitView(_ splitView: NSSplitView, shouldHideDividerAt dividerIndex: Int) -> Bool {
			return singleHandler(splitView, dividerIndex)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: SplitViewBinding {
	public typealias SplitViewName<V> = BindingName<V, SplitView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> SplitView.Binding) -> SplitViewName<V> {
		return SplitViewName<V>(source: source, downcast: Binding.splitViewBinding)
	}
}
public extension BindingName where Binding: SplitViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: SplitViewName<$2> { return .name(SplitView.Binding.$1) }

	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var arrangedSubviews: SplitViewName<Dynamic<ArrayMutation<SplitSubview>>> { return .name(SplitView.Binding.arrangedSubviews) }
	static var autosaveName: SplitViewName<Dynamic<NSSplitView.AutosaveName?>> { return .name(SplitView.Binding.autosaveName) }
	static var dividerStyle: SplitViewName<Dynamic<NSSplitView.DividerStyle>> { return .name(SplitView.Binding.dividerStyle) }
	static var isVertical: SplitViewName<Dynamic<Bool>> { return .name(SplitView.Binding.isVertical) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var setDividerPosition: SplitViewName<Signal<(position: CGFloat, dividerIndex: Int)>> { return .name(SplitView.Binding.setDividerPosition) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didResizeSubviews: SplitViewName<SignalInput<Int?>> { return .name(SplitView.Binding.didResizeSubviews) }
	static var willResizeSubviews: SplitViewName<SignalInput<Int?>> { return .name(SplitView.Binding.willResizeSubviews) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var additionalEffectiveRect: SplitViewName<(_ splitView: NSSplitView, _ dividerAt: Int) -> NSRect> { return .name(SplitView.Binding.additionalEffectiveRect) }
	static var canCollapseSubview: SplitViewName<(_ splitView: NSSplitView, _ subview: NSView) -> Bool> { return .name(SplitView.Binding.canCollapseSubview) }
	static var constrainMaxCoordinate: SplitViewName<(_ splitView: NSSplitView, _ proposedMaximumPosition: CGFloat, _ dividerIndex: Int) -> CGFloat> { return .name(SplitView.Binding.constrainMaxCoordinate) }
	static var constrainMinCoordinate: SplitViewName<(_ splitView: NSSplitView, _ proposedMinimumPosition: CGFloat, _ dividerIndex: Int) -> CGFloat> { return .name(SplitView.Binding.constrainMinCoordinate) }
	static var constrainSplitPosition: SplitViewName<(_ splitView: NSSplitView, _ proposedPosition: CGFloat, _ dividerIndex: Int) -> CGFloat> { return .name(SplitView.Binding.constrainSplitPosition) }
	static var effectiveRectForDrawnRect: SplitViewName<(_ splitView: NSSplitView, _ proposedEffectiveRect: NSRect, _ drawnRect: NSRect, _ dividerIndex: Int) -> NSRect> { return .name(SplitView.Binding.effectiveRectForDrawnRect) }
	static var resizeSubviews: SplitViewName<(NSSplitView, NSSize) -> Void> { return .name(SplitView.Binding.resizeSubviews) }
	static var shouldAdjustSizeOfSubview: SplitViewName<(_ splitView: NSSplitView, _ subview: NSView) -> Bool> { return .name(SplitView.Binding.shouldAdjustSizeOfSubview) }
	static var shouldCollapseSubview: SplitViewName<(_ splitView: NSSplitView, _ subview: NSView, _ dividerIndex: Int) -> Bool> { return .name(SplitView.Binding.shouldCollapseSubview) }
	static var shouldHideDivider: SplitViewName<(_ splitView: NSSplitView, _ dividerIndex: Int) -> Bool> { return .name(SplitView.Binding.shouldHideDivider) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol SplitViewConvertible: ViewConvertible {
	func nsSplitView() -> SplitView.Instance
}
extension SplitViewConvertible {
	public func nsView() -> View.Instance { return nsSplitView() }
}
extension NSSplitView: SplitViewConvertible, HasDelegate {
	public func nsSplitView() -> SplitView.Instance { return self }
}
public extension SplitView {
	func nsSplitView() -> SplitView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol SplitViewBinding: ViewBinding {
	static func splitViewBinding(_ binding: SplitView.Binding) -> Self
	func asSplitViewBinding() -> SplitView.Binding?
}
public extension SplitViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return splitViewBinding(.inheritedBinding(binding))
	}
}
public extension SplitViewBinding where Preparer.Inherited.Binding: SplitViewBinding {
	func asSplitViewBinding() -> SplitView.Binding? {
		return asInheritedBinding()?.asSplitViewBinding()
	}
}
public extension SplitView.Binding {
	typealias Preparer = SplitView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asSplitViewBinding() -> SplitView.Binding? { return self }
	static func splitViewBinding(_ binding: SplitView.Binding) -> SplitView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public struct SplitSubview {
	let view: ViewConvertible
	let holdingPriority: NSLayoutConstraint.Priority
	let constraints: [Layout.Dimension]
	
	public init(view: ViewConvertible, holdingPriority: NSLayoutConstraint.Priority, constraints: [Layout.Dimension]) {
		self.view = view
		self.holdingPriority = holdingPriority
		self.constraints = constraints
	}
	
	public static func subview(_ viewConvertible: ViewConvertible, holdingPriority: NSLayoutConstraint.Priority = .defaultLow, constraints: Layout.Dimension...) -> SplitSubview {
		return SplitSubview(view: viewConvertible, holdingPriority: holdingPriority, constraints: constraints)
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class TabViewItem: Binder, TabViewItemConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TabViewItem {
	enum Binding: TabViewItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case color(Dynamic<NSColor>)
		case image(Dynamic<NSImage?>)
		case initialFirstResponderTag(Dynamic<Int>)
		case label(Dynamic<String>)
		case toolTip(Dynamic<String>)
		case view(Dynamic<ViewConvertible>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension TabViewItem {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = TabViewItem.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = NSTabViewItem
		
		public var inherited = Inherited()
		public init() {}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var initialFirstResponderTag: Dynamic<Int>? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TabViewItem.Preparer {
	func constructInstance(type: Instance.Type, parameters: Void) -> Instance {
		return type.init(identifier: nil)
	}
	
	mutating func prepareBinding(_ binding: TabViewItem.Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .initialFirstResponderTag(let x): initialFirstResponderTag = x
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		case .color(let x): return x.apply(instance) { i, v in i.color = v }
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .initialFirstResponderTag: return nil
		case .label(let x): return x.apply(instance) { i, v in i.label = v }
		case .toolTip(let x): return x.apply(instance) { i, v in i.toolTip = v }
		case .view(let x): return x.apply(instance) { i, v in i.view = v.nsView() }
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		var lifetimes = [Lifetime]()
		lifetimes += initialFirstResponderTag?.apply(instance) { i, v in
			let view = i.view?.viewWithTag(v)
			i.initialFirstResponder = view
		}
		lifetimes += inheritedFinalizedInstance(instance, storage: storage)
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabViewItem.Preparer {
	public typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabViewItemBinding {
	public typealias TabViewItemName<V> = BindingName<V, TabViewItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TabViewItem.Binding) -> TabViewItemName<V> {
		return TabViewItemName<V>(source: source, downcast: Binding.tabViewItemBinding)
	}
}
public extension BindingName where Binding: TabViewItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabViewItemName<$2> { return .name(TabViewItem.Binding.$1) }
	static var color: TabViewItemName<Dynamic<NSColor>> { return .name(TabViewItem.Binding.color) }
	static var image: TabViewItemName<Dynamic<NSImage?>> { return .name(TabViewItem.Binding.image) }
	static var initialFirstResponderTag: TabViewItemName<Dynamic<Int>> { return .name(TabViewItem.Binding.initialFirstResponderTag) }
	static var label: TabViewItemName<Dynamic<String>> { return .name(TabViewItem.Binding.label) }
	static var toolTip: TabViewItemName<Dynamic<String>> { return .name(TabViewItem.Binding.toolTip) }
	static var view: TabViewItemName<Dynamic<ViewConvertible>> { return .name(TabViewItem.Binding.view) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TabViewItemConvertible {
	func nsTabViewItem() -> TabViewItem.Instance
}
extension TabViewItemConvertible {
	public func nsBinderBase() -> BinderBase.Instance { return nsTabViewItem() }
}
extension NSTabViewItem: TabViewItemConvertible /* , HasDelegate // if Preparer is BinderDelegateEmbedderConstructor */ {
	public func nsTabViewItem() -> TabViewItem.Instance { return self }
}
public extension TabViewItem {
	func nsTabViewItem() -> TabViewItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TabViewItemBinding: BinderBaseBinding {
	static func tabViewItemBinding(_ binding: TabViewItem.Binding) -> Self
	func asTabViewItemBinding() -> TabViewItem.Binding?
}
public extension TabViewItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return tabViewItemBinding(.inheritedBinding(binding))
	}
}
public extension TabViewItemBinding where Preparer.Inherited.Binding: TabViewItemBinding {
	func asTabViewItemBinding() -> TabViewItem.Binding? {
		return asInheritedBinding()?.asTabViewItemBinding()
	}
}
public extension TabViewItem.Binding {
	typealias Preparer = TabViewItem.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTabViewItemBinding() -> TabViewItem.Binding? { return self }
	static func tabViewItemBinding(_ binding: TabViewItem.Binding) -> TabViewItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class TabView<Identifier: Equatable>: Binder, TabViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TabView {
	enum Binding: TabViewBinding {
		public typealias IdentifierType = Identifier
		
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsTruncatedLabels(Dynamic<Bool>)
		case borderType(Dynamic<NSTabView.TabViewBorderType>)
		case controlSize(Dynamic<NSControl.ControlSize>)
		case drawsBackground(Dynamic<Bool>)
		case font(Dynamic<NSFont>)
		case position(Dynamic<NSTabView.TabPosition>)
		case tabs(Dynamic<ArrayMutation<Identifier>>)
		case type(Dynamic<NSTabView.TabType>)

		// 2. Signal bindings are performed on the object after construction.
		case selectedItem(Dynamic<Identifier>)
		case selectFirstItem(Signal<Void>)
		case selectLastItem(Signal<Void>)
		case selectNextItem(Signal<Void>)
		case selectPreviousItem(Signal<Void>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didChangeNumberOfItems((NSTabView) -> Void)
		case didSelect((NSTabView, NSTabViewItem?, Identifier?) -> Void)
		case shouldSelect((NSTabView, NSTabViewItem?, Identifier?) -> Bool)
		case tabConstructor((Identifier) -> TabViewItemConvertible)
		case willSelect((NSTabView, NSTabViewItem?, Identifier?) -> Void)
	}
}

// MARK: - Binder Part 3: Preparer
public extension TabView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = TabView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSTabView
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var tabConstructor: ((Identifier) -> TabViewItemConvertible)? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TabView.Preparer {
	func constructStorage(instance: Instance) -> Storage {
		return Storage(tabConstructor: tabConstructor)
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .didChangeNumberOfItems(let x): delegate().addMultiHandler1(x, #selector(NSTabViewDelegate.tabViewDidChangeNumberOfTabViewItems(_:)))
		case .didSelect(let x): delegate().addMultiHandler3(x, #selector(NSTabViewDelegate.tabView(_:didSelect:)))
		case .shouldSelect(let x): delegate().addSingleHandler3(x, #selector(NSTabViewDelegate.tabView(_:shouldSelect:)))
		case .tabConstructor(let x): tabConstructor = x
		case .willSelect(let x): delegate().addMultiHandler3(x, #selector(NSTabViewDelegate.tabView(_:willSelect:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		// 0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsTruncatedLabels(let x): return x.apply(instance) { i, v in i.allowsTruncatedLabels = v }
		case .borderType(let x): return x.apply(instance) { i, v in i.tabViewBorderType = v }
		case .controlSize(let x): return x.apply(instance) { i, v in i.controlSize = v }
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .position(let x): return x.apply(instance) { i, v in i.tabPosition = v }
		case .selectedItem(let x):
			return x.apply(instance) { i, v in
				for tabItem in i.tabViewItems {
					if let identifier = tabItem.identifier as? Identifier, identifier == v {
						i.selectTabViewItem(tabItem)
						if let window = i.window, let responder = tabItem.initialFirstResponder {
							window.makeFirstResponder(responder)
						}
						break
					}
				}
			}
		case .tabs(let x):
			return x.apply(instance, storage) { i, s, v in
				let constructor = s.tabConstructor ?? { _ in NSTabViewItem(identifier: nil) }
				v.insertionsAndRemovals(
					length: i.numberOfTabViewItems,
					insert: { index, identifier in
						let item = constructor(identifier).nsTabViewItem()
						item.identifier = identifier
						i.insertTabViewItem(item, at: index)
					},
					remove: { index in i.removeTabViewItem(i.tabViewItem(at: index)) }
				)
			}
		case .type(let x): return x.apply(instance) { i, v in i.tabViewType = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .selectFirstItem(let x): return x.apply(instance) { i, v in i.selectFirstTabViewItem(nil) }
		case .selectLastItem(let x): return x.apply(instance) { i, v in i.selectLastTabViewItem(nil) }
		case .selectNextItem(let x): return x.apply(instance) { i, v in i.selectNextTabViewItem(nil) }
		case .selectPreviousItem(let x): return x.apply(instance) { i, v in i.selectPreviousTabViewItem(nil) }
			
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .didChangeNumberOfItems: return nil
		case .didSelect: return nil
		case .shouldSelect: return nil
		case .tabConstructor: return nil
		case .willSelect: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TabView.Preparer {
	open class Storage: View.Preparer.Storage, NSTabViewDelegate {
		open var tabConstructor: ((Identifier) -> TabViewItemConvertible)?
		public init(tabConstructor: ((Identifier) -> TabViewItemConvertible)?) {
			self.tabConstructor = tabConstructor
		}
	}

	open class Delegate: DynamicDelegate, NSTabViewDelegate {
		open func tabViewDidChangeNumberOfTabViewItems(_ tabView: NSTabView) {
			multiHandler(tabView)
		}
		
		open func tabView(_ tabView: NSTabView, didSelect tabViewItem: NSTabViewItem?) {
			multiHandler(tabView, tabViewItem, tabViewItem?.identifier as? Identifier)
		}
		
		open func tabView(_ tabView: NSTabView, shouldSelect tabViewItem: NSTabViewItem?) -> Bool {
			return singleHandler(tabView, tabViewItem, tabViewItem?.identifier as? Identifier)
		}
		
		open func tabView(_ tabView: NSTabView, willSelect tabViewItem: NSTabViewItem?) {
			multiHandler(tabView, tabViewItem, tabViewItem?.identifier as? Identifier)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TabViewBinding {
	public typealias TabViewName<V> = BindingName<V, TabView<Binding.IdentifierType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TabView<Binding.IdentifierType>.Binding) -> TabViewName<V> {
		return TabViewName<V>(source: source, downcast: Binding.tabViewBinding)
	}
}
public extension BindingName where Binding: TabViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TabViewName<$2> { return .name(TabView.Binding.$1) }
	
	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsTruncatedLabels: TabViewName<Dynamic<Bool>> { return .name(TabView.Binding.allowsTruncatedLabels) }
	static var borderType: TabViewName<Dynamic<NSTabView.TabViewBorderType>> { return .name(TabView.Binding.borderType) }
	static var controlSize: TabViewName<Dynamic<NSControl.ControlSize>> { return .name(TabView.Binding.controlSize) }
	static var drawsBackground: TabViewName<Dynamic<Bool>> { return .name(TabView.Binding.drawsBackground) }
	static var font: TabViewName<Dynamic<NSFont>> { return .name(TabView.Binding.font) }
	static var position: TabViewName<Dynamic<NSTabView.TabPosition>> { return .name(TabView.Binding.position) }
	static var tabs: TabViewName<Dynamic<ArrayMutation<Binding.IdentifierType>>> { return .name(TabView.Binding.tabs) }
	static var type: TabViewName<Dynamic<NSTabView.TabType>> { return .name(TabView.Binding.type) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectedItem: TabViewName<Dynamic<Binding.IdentifierType>> { return .name(TabView.Binding.selectedItem) }
	static var selectFirstItem: TabViewName<Signal<Void>> { return .name(TabView.Binding.selectFirstItem) }
	static var selectLastItem: TabViewName<Signal<Void>> { return .name(TabView.Binding.selectLastItem) }
	static var selectNextItem: TabViewName<Signal<Void>> { return .name(TabView.Binding.selectNextItem) }
	static var selectPreviousItem: TabViewName<Signal<Void>> { return .name(TabView.Binding.selectPreviousItem) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didChangeNumberOfItems: TabViewName<(NSTabView) -> Void> { return .name(TabView.Binding.didChangeNumberOfItems) }
	static var didSelect: TabViewName<(NSTabView, NSTabViewItem?, Binding.IdentifierType?) -> Void> { return .name(TabView.Binding.didSelect) }
	static var shouldSelect: TabViewName<(NSTabView, NSTabViewItem?, Binding.IdentifierType?) -> Bool> { return .name(TabView.Binding.shouldSelect) }
	static var tabConstructor: TabViewName<(Binding.IdentifierType) -> TabViewItemConvertible> { return .name(TabView.Binding.tabConstructor) }
	static var willSelect: TabViewName<(NSTabView, NSTabViewItem?, Binding.IdentifierType?) -> Void> { return .name(TabView.Binding.willSelect) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TabViewConvertible: ViewConvertible {
	func nsTabView() -> NSTabView
}
extension TabViewConvertible {
	public func nsView() -> View.Instance { return nsTabView() }
}
extension NSTabView: TabViewConvertible, HasDelegate {
	public func nsTabView() -> NSTabView { return self }
}
public extension TabView {
	func nsTabView() -> TabView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TabViewBinding: ViewBinding {
	associatedtype IdentifierType: Equatable
	static func tabViewBinding(_ binding: TabView<IdentifierType>.Binding) -> Self
	func asTabViewBinding() -> TabView<IdentifierType>.Binding?
}
public extension TabViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tabViewBinding(.inheritedBinding(binding))
	}
}
public extension TabViewBinding where Preparer.Inherited.Binding: TabViewBinding, Preparer.Inherited.Binding.IdentifierType == IdentifierType {
	func asTabViewBinding() -> TabView<IdentifierType>.Binding? {
		return asInheritedBinding()?.asTabViewBinding()
	}
}
public extension TabView.Binding {
	typealias Preparer = TabView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTabViewBinding() -> TabView.Binding? { return self }
	static func tabViewBinding(_ binding: TabView<IdentifierType>.Binding) -> TabView<IdentifierType>.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class TableCellView: Binder, TableCellViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TableCellView {
	enum Binding: TableCellViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundStyle(Dynamic<NSView.BackgroundStyle>)
		case rowSizeStyle(Dynamic<NSTableView.RowSizeStyle>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension TableCellView {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = TableCellView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSTableCellView
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TableCellView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundStyle(let x): return x.apply(instance) { i, v in i.backgroundStyle = v }
		case .rowSizeStyle(let x): return x.apply(instance) { i, v in i.rowSizeStyle = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableCellView.Preparer {
	public typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableCellViewBinding {
	public typealias TableCellViewName<V> = BindingName<V, TableCellView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TableCellView.Binding) -> TableCellViewName<V> {
		return TableCellViewName<V>(source: source, downcast: Binding.tableCellViewBinding)
	}
}
public extension BindingName where Binding: TableCellViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableCellViewName<$2> { return .name(TableCellView.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundStyle: TableCellViewName<Dynamic<NSView.BackgroundStyle>> { return .name(TableCellView.Binding.backgroundStyle) }
	static var rowSizeStyle: TableCellViewName<Dynamic<NSTableView.RowSizeStyle>> { return .name(TableCellView.Binding.rowSizeStyle) }

	// 2. Signal bindings are performed on the object after construction.

	// 3. Action bindings are triggered by the object after construction.

	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TableCellViewConvertible: ViewConvertible {
	func nsTableCellView() -> TableCellView.Instance
}
extension TableCellViewConvertible {
	public func nsView() -> View.Instance { return nsTableCellView() }
}
extension NSTableCellView: TableCellViewConvertible {
	public func nsTableCellView() -> TableCellView.Instance { return self }
}
public extension TableCellView {
	func nsTableCellView() -> TableCellView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TableCellViewBinding: ViewBinding {
	static func tableCellViewBinding(_ binding: TableCellView.Binding) -> Self
	func asTableCellViewBinding() -> TableCellView.Binding?
}
public extension TableCellViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tableCellViewBinding(.inheritedBinding(binding))
	}
}
public extension TableCellViewBinding where Preparer.Inherited.Binding: TableCellViewBinding {
	func asTableCellViewBinding() -> TableCellView.Binding? {
		return asInheritedBinding()?.asTableCellViewBinding()
	}
}
public extension TableCellView.Binding {
	typealias Preparer = TableCellView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableCellViewBinding() -> TableCellView.Binding? { return self }
	static func tableCellViewBinding(_ binding: TableCellView.Binding) -> TableCellView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
private var associatedInputKey = NSObject()
public extension NSTableCellView {
	func associatedRowInput<B>(valueType: B.Type) -> 
		SignalInput<B>? {
			return objc_getAssociatedObject(self, &associatedInputKey) as? SignalInput<B>
	}
	
	func setAssociatedRowInput<B>(to input: SignalInput<B>) {
		objc_setAssociatedObject(self, &associatedInputKey, input, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN)
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class TableColumn<RowData>: Binder {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TableColumn {
	enum Binding: TableColumnBinding {
		public typealias RowDataType = RowData
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case identifier(Constant<NSUserInterfaceItemIdentifier>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case headerCell(Dynamic<NSTableHeaderCell>)
		case headerToolTip(Dynamic<String?>)
		case isEditable(Dynamic<Bool>)
		case isHidden(Dynamic<Bool>)
		case maxWidth(Dynamic<CGFloat>)
		case minWidth(Dynamic<CGFloat>)
		case resizingMask(Dynamic<NSTableColumn.ResizingOptions>)
		case sortDescriptorPrototype(Dynamic<NSSortDescriptor?>)
		case sortFunction(Dynamic<(_ isRow: RowData, _ orderedBefore: RowData) -> Bool>)
		case title(Dynamic<String>)
		case width(Dynamic<CGFloat>)

		// 2. Signal bindings are performed on the object after construction.
		case sizeToFit(Signal<Void>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case cellConstructor((_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti<RowData>) -> TableCellViewConvertible)
		case cellIdentifierForRow((RowData?) -> NSUserInterfaceItemIdentifier)
		case dataMissingCell(() -> TableCellViewConvertible?)
	}
}

// MARK: - Binder Part 3: Preparer
public extension TableColumn {
	struct Preparer: BinderConstructor {
		public typealias Binding = TableColumn.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = NSTableColumn
		public typealias Output = Storage
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage(tableColumn: instance, cellConstructor: cellConstructor, cellIdentifier: cellIdentifier, dataMissingCell: dataMissingCell) }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var columnIdentifier: NSUserInterfaceItemIdentifier?
		var cellConstructor: ((_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti<RowData>) -> TableCellViewConvertible)?
		var cellIdentifier: ((RowData?) -> NSUserInterfaceItemIdentifier)?
		var dataMissingCell: (() -> TableCellViewConvertible?)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TableColumn.Preparer {
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		return type.init(identifier: columnIdentifier ?? NSUserInterfaceItemIdentifier(UUID().uuidString))
	}
	
	func combine(lifetimes: [Lifetime], instance: Instance, storage: Storage) -> Storage {
		return storage
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		
		case .identifier(let x): columnIdentifier = x.value
		case .cellConstructor(let x): cellConstructor = x
		case .cellIdentifierForRow(let x): cellIdentifier = x
		case .dataMissingCell(let x): dataMissingCell = x
		default: break
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .identifier: return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .headerCell(let x): return x.apply(instance) { i, v in i.headerCell = v }
		case .headerToolTip(let x): return x.apply(instance) { i, v in i.headerToolTip = v }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .maxWidth(let x): return x.apply(instance) { i, v in i.maxWidth = v }
		case .minWidth(let x): return x.apply(instance) { i, v in i.minWidth = v }
		case .resizingMask(let x): return x.apply(instance) { i, v in i.resizingMask = v }
		case .sortDescriptorPrototype(let x): return x.apply(instance) { i, v in i.sortDescriptorPrototype = v }
		case .sortFunction(let x): return x.apply(instance, storage) { i, s, v in s.sortFunction = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .width(let x): return x.apply(instance) { i, v in i.width = v }

		// 2. Signal bindings are performed on the object after construction.
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }

		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .cellConstructor: return nil
		case .cellIdentifierForRow: return nil
		case .dataMissingCell: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableColumn.Preparer {
	open class Storage: AssociatedBinderStorage {
		public let tableColumn: NSTableColumn
		public let cellConstructor: ((_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti<RowData>) -> TableCellViewConvertible)?
		public let cellIdentifier: ((RowData?) -> NSUserInterfaceItemIdentifier)?
		public let dataMissingCell: (() -> TableCellViewConvertible?)?

		open var sortFunction: ((_ isRow: RowData, _ orderedBefore: RowData) -> Bool)?

		public init(tableColumn: NSTableColumn, cellConstructor: ((_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti<RowData>) -> TableCellViewConvertible)?, cellIdentifier: ((RowData?) -> NSUserInterfaceItemIdentifier)?, dataMissingCell: (() -> TableCellViewConvertible?)?) {
			self.tableColumn = tableColumn
			self.cellConstructor = cellConstructor
			self.cellIdentifier = cellIdentifier
			self.dataMissingCell = dataMissingCell
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableColumnBinding {
	public typealias TableColumnName<V> = BindingName<V, TableColumn<Binding.RowDataType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TableColumn<Binding.RowDataType>.Binding) -> TableColumnName<V> {
		return TableColumnName<V>(source: source, downcast: Binding.tableColumnBinding)
	}
}
public extension BindingName where Binding: TableColumnBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableColumnName<$2> { return .name(TableColumn.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var identifier: TableColumnName<Constant<NSUserInterfaceItemIdentifier>> { return .name(TableColumn.Binding.identifier) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var headerCell: TableColumnName<Dynamic<NSTableHeaderCell>> { return .name(TableColumn.Binding.headerCell) }
	static var headerToolTip: TableColumnName<Dynamic<String?>> { return .name(TableColumn.Binding.headerToolTip) }
	static var isEditable: TableColumnName<Dynamic<Bool>> { return .name(TableColumn.Binding.isEditable) }
	static var isHidden: TableColumnName<Dynamic<Bool>> { return .name(TableColumn.Binding.isHidden) }
	static var maxWidth: TableColumnName<Dynamic<CGFloat>> { return .name(TableColumn.Binding.maxWidth) }
	static var minWidth: TableColumnName<Dynamic<CGFloat>> { return .name(TableColumn.Binding.minWidth) }
	static var resizingMask: TableColumnName<Dynamic<NSTableColumn.ResizingOptions>> { return .name(TableColumn.Binding.resizingMask) }
	static var sortDescriptorPrototype: TableColumnName<Dynamic<NSSortDescriptor?>> { return .name(TableColumn.Binding.sortDescriptorPrototype) }
	static var sortFunction: TableColumnName<Dynamic<(_ isRow: Binding.RowDataType, _ orderedBefore: Binding.RowDataType) -> Bool>> { return .name(TableColumn.Binding.sortFunction) }
	static var title: TableColumnName<Dynamic<String>> { return .name(TableColumn.Binding.title) }
	static var width: TableColumnName<Dynamic<CGFloat>> { return .name(TableColumn.Binding.width) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var sizeToFit: TableColumnName<Signal<Void>> { return .name(TableColumn.Binding.sizeToFit) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var cellConstructor: TableColumnName<(_ identifier: NSUserInterfaceItemIdentifier, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableCellViewConvertible> { return .name(TableColumn.Binding.cellConstructor) }
	static var cellIdentifierForRow: TableColumnName<(Binding.RowDataType?) -> NSUserInterfaceItemIdentifier> { return .name(TableColumn.Binding.cellIdentifierForRow) }
	static var dataMissingCell: TableColumnName<() -> TableCellViewConvertible?> { return .name(TableColumn.Binding.dataMissingCell) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)

// MARK: - Binder Part 8: Downcast protocols
public protocol TableColumnBinding: BinderBaseBinding {
	associatedtype RowDataType
	static func tableColumnBinding(_ binding: TableColumn<RowDataType>.Binding) -> Self
	func asTableColumnBinding() -> TableColumn<RowDataType>.Binding?
}
public extension TableColumnBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return tableColumnBinding(.inheritedBinding(binding))
	}
}
public extension TableColumnBinding where Preparer.Inherited.Binding: TableColumnBinding, Preparer.Inherited.Binding.RowDataType == RowDataType {
	func asTableColumnBinding() -> TableColumn<RowDataType>.Binding? {
		return asInheritedBinding()?.asTableColumnBinding()
	}
}
public extension TableColumn.Binding {
	typealias Preparer = TableColumn.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableColumnBinding() -> TableColumn.Binding? { return self }
	static func tableColumnBinding(_ binding: TableColumn.Binding) -> TableColumn.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class TableHeaderView: Binder, TableHeaderViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TableHeaderView {
	enum Binding: TableHeaderViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension TableHeaderView {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = TableHeaderView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSTableHeaderView
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TableHeaderView {
}


// MARK: - Binder Part 5: Storage and Delegate
extension TableHeaderView.Preparer {
	public typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableHeaderViewBinding {
	public typealias TableHeaderViewName<V> = BindingName<V, TableHeaderView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TableHeaderView.Binding) -> TableHeaderViewName<V> {
		return TableHeaderViewName<V>(source: source, downcast: Binding.tableHeaderViewBinding)
	}
}
public extension BindingName where Binding: TableHeaderViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableHeaderViewName<$2> { return .name(TableHeaderView.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TableHeaderViewConvertible: ViewConvertible {
	func nsTableHeaderView() -> TableHeaderView.Instance
}
extension TableHeaderViewConvertible {
	public func nsView() -> View.Instance { return nsTableHeaderView() }
}
extension NSTableHeaderView: TableHeaderViewConvertible {
	public func nsTableHeaderView() -> TableHeaderView.Instance { return self }
}
public extension TableHeaderView {
	func nsTableHeaderView() -> TableHeaderView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TableHeaderViewBinding: ViewBinding {
	static func tableHeaderViewBinding(_ binding: TableHeaderView.Binding) -> Self
	func asTableHeaderViewBinding() -> TableHeaderView.Binding?
}
public extension TableHeaderViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tableHeaderViewBinding(.inheritedBinding(binding))
	}
}
public extension TableHeaderViewBinding where Preparer.Inherited.Binding: TableHeaderViewBinding {
	func asTableHeaderViewBinding() -> TableHeaderView.Binding? {
		return asInheritedBinding()?.asTableHeaderViewBinding()
	}
}
public extension TableHeaderView.Binding {
	typealias Preparer = TableHeaderView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableHeaderViewBinding() -> TableHeaderView.Binding? { return self }
	static func tableHeaderViewBinding(_ binding: TableHeaderView.Binding) -> TableHeaderView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class TableRowView: Binder, TableRowViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TableRowView {
	enum Binding: TableRowViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case backgroundColor(Dynamic<NSColor>)
		case draggingDestinationFeedbackStyle(Dynamic<NSTableView.DraggingDestinationFeedbackStyle>)
		case indentationForDropOperation(Dynamic<CGFloat>)
		case isEmphasized(Dynamic<Bool>)
		case isFloating(Dynamic<Bool>)
		case isGroupRowStyle(Dynamic<Bool>)
		case isSelected(Dynamic<Bool>)
		case isTargetForDropOperation(Dynamic<Bool>)
		case selectionHighlightStyle(Dynamic<NSTableView.SelectionHighlightStyle>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension TableRowView {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = TableRowView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSTableRowView
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TableRowView.Preparer {
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .draggingDestinationFeedbackStyle(let x): return x.apply(instance) { i, v in i.draggingDestinationFeedbackStyle = v }
		case .indentationForDropOperation(let x): return x.apply(instance) { i, v in i.indentationForDropOperation = v }
		case .isEmphasized(let x): return x.apply(instance) { i, v in i.isEmphasized = v }
		case .isFloating(let x): return x.apply(instance) { i, v in i.isFloating = v }
		case .isGroupRowStyle(let x): return x.apply(instance) { i, v in i.isGroupRowStyle = v }
		case .isSelected(let x): return x.apply(instance) { i, v in i.isSelected = v }
		case .isTargetForDropOperation(let x): return x.apply(instance) { i, v in i.isTargetForDropOperation = v }
		case .selectionHighlightStyle(let x): return x.apply(instance) { i, v in i.selectionHighlightStyle = v }

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableRowView.Preparer {
	public typealias Storage = View.Preparer.Storage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableRowViewBinding {
	public typealias TableRowViewName<V> = BindingName<V, TableRowView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TableRowView.Binding) -> TableRowViewName<V> {
		return TableRowViewName<V>(source: source, downcast: Binding.tableRowViewBinding)
	}
}
public extension BindingName where Binding: TableRowViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableRowViewName<$2> { return .name(TableRowView.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundColor: TableRowViewName<Dynamic<NSColor>> { return .name(TableRowView.Binding.backgroundColor) }
	static var draggingDestinationFeedbackStyle: TableRowViewName<Dynamic<NSTableView.DraggingDestinationFeedbackStyle>> { return .name(TableRowView.Binding.draggingDestinationFeedbackStyle) }
	static var indentationForDropOperation: TableRowViewName<Dynamic<CGFloat>> { return .name(TableRowView.Binding.indentationForDropOperation) }
	static var isEmphasized: TableRowViewName<Dynamic<Bool>> { return .name(TableRowView.Binding.isEmphasized) }
	static var isFloating: TableRowViewName<Dynamic<Bool>> { return .name(TableRowView.Binding.isFloating) }
	static var isGroupRowStyle: TableRowViewName<Dynamic<Bool>> { return .name(TableRowView.Binding.isGroupRowStyle) }
	static var isSelected: TableRowViewName<Dynamic<Bool>> { return .name(TableRowView.Binding.isSelected) }
	static var isTargetForDropOperation: TableRowViewName<Dynamic<Bool>> { return .name(TableRowView.Binding.isTargetForDropOperation) }
	static var selectionHighlightStyle: TableRowViewName<Dynamic<NSTableView.SelectionHighlightStyle>> { return .name(TableRowView.Binding.selectionHighlightStyle) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TableRowViewConvertible: ViewConvertible {
	func nsTableRowView() -> TableRowView.Instance
}
extension TableRowViewConvertible {
	public func nsView() -> View.Instance { return nsTableRowView() }
}
extension NSTableRowView: TableRowViewConvertible {
	public func nsTableRowView() -> TableRowView.Instance { return self }
}
extension TableRowView {
	public func nsTableRowView() -> TableRowView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TableRowViewBinding: ViewBinding {
	static func tableRowViewBinding(_ binding: TableRowView.Binding) -> Self
	func asTableRowViewBinding() -> TableRowView.Binding?
}
public extension TableRowViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return tableRowViewBinding(.inheritedBinding(binding))
	}
}
public extension TableRowViewBinding where Preparer.Inherited.Binding: TableRowViewBinding {
	func asTableRowViewBinding() -> TableRowView.Binding? {
		return asInheritedBinding()?.asTableRowViewBinding()
	}
}
public extension TableRowView.Binding {
	typealias Preparer = TableRowView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableRowViewBinding() -> TableRowView.Binding? { return self }
	static func tableRowViewBinding(_ binding: TableRowView.Binding) -> TableRowView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class TableView<RowData>: Binder, TableViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	public static func scrollEmbedded(type: NSTableView.Type = NSTableView.self, _ bindings: Binding...) -> ScrollView {
		return ScrollView(
			.borderType -- .noBorder,
			.hasVerticalScroller -- true,
			.hasHorizontalScroller -- true,
			.autohidesScrollers -- true,
			.contentView -- ClipView(
				.documentView -- TableView<RowData>(type: type, bindings: bindings)
			)
		)
	}
}

// MARK: - Binder Part 2: Binding
public extension TableView {
	enum Binding: TableViewBinding {
		public typealias RowDataType = RowData
		
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsColumnReordering(Dynamic<Bool>)
		case allowsColumnResizing(Dynamic<Bool>)
		case allowsColumnSelection(Dynamic<Bool>)
		case allowsEmptySelection(Dynamic<Bool>)
		case allowsMultipleSelection(Dynamic<Bool>)
		case allowsTypeSelect(Dynamic<Bool>)
		case autosaveName(Dynamic<NSTableView.AutosaveName?>)
		case autosaveTableColumns(Dynamic<Bool>)
		case backgroundColor(Dynamic<NSColor>)
		case columnAutoresizingStyle(Dynamic<NSTableView.ColumnAutoresizingStyle>)
		case columns(Dynamic<[TableColumn<RowData>]>)
		case cornerView(Dynamic<ViewConvertible?>)
		case draggingDestinationFeedbackStyle(Dynamic<NSTableView.DraggingDestinationFeedbackStyle>)
		case floatsGroupRows(Dynamic<Bool>)
		case gridColor(Dynamic<NSColor>)
		case gridStyleMask(Dynamic<NSTableView.GridLineStyle>)
		case headerView(Dynamic<TableHeaderViewConvertible?>)
		case intercellSpacing(Dynamic<NSSize>)
		case rowHeight(Dynamic<CGFloat>)
		case rows(Dynamic<TableRowAnimatable<RowData>>)
		case rowSizeStyle(Dynamic<NSTableView.RowSizeStyle>)
		case selectionHighlightStyle(Dynamic<NSTableView.SelectionHighlightStyle>)
		case userInterfaceLayoutDirection(Dynamic<NSUserInterfaceLayoutDirection>)
		case usesAlternatingRowBackgroundColors(Dynamic<Bool>)
		case usesAutomaticRowHeights(Dynamic<Bool>)
		case verticalMotionCanBeginDrag(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.
		case deselectAll(Signal<Void>)
		case deselectColumn(Signal<NSUserInterfaceItemIdentifier>)
		case deselectRow(Signal<Int>)
		case hideRowActions(Signal<Void>)
		case hideRows(Signal<(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)>)
		case highlightColumn(Signal<NSUserInterfaceItemIdentifier?>)
		case moveColumn(Signal<(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)>)
		case scrollColumnToVisible(Signal<NSUserInterfaceItemIdentifier>)
		case scrollRowToVisible(Signal<Int>)
		case selectAll(Signal<Void>)
		case selectColumns(Signal<(identifiers: Set<NSUserInterfaceItemIdentifier>, byExtendingSelection: Bool)>)
		case selectRows(Signal<(indexes: IndexSet, byExtendingSelection: Bool)>)
		case sizeLastColumnToFit(Signal<Void>)
		case sizeToFit(Signal<Void>)
		case unhideRows(Signal<(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)>)

		// 3. Action bindings are triggered by the object after construction.
		case columnMoved(SignalInput<(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)>)
		case columnResized(SignalInput<(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)>)
		case doubleAction(TargetAction)
		case visibleRowsChanged(SignalInput<CountableRange<Int>>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case acceptDrop((_ tableView: NSTableView, _ row: Int, _ data: RowData?) -> Bool)
		case didClickTableColumn((NSTableView, NSTableColumn) -> Void)
		case didDragTableColumn((NSTableView, NSTableColumn) -> Void)
		case draggingSessionEnded((_ tableView: NSTableView, _ session: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -> Void)
		case draggingSessionWillBegin((_ tableView: NSTableView, _ session: NSDraggingSession, _ willBeginAt: NSPoint, _ forRowIndexes: IndexSet) -> Void)
		case groupRowCellConstructor((Int) -> TableCellViewConvertible)
		case heightOfRow((_ tableView: NSTableView, _ row: Int, _ rowData: RowData?) -> CGFloat)
		case isGroupRow((_ tableView: NSTableView, _ row: Int, _ rowData: RowData?) -> Bool)
		case mouseDownInHeaderOfTableColumn((NSTableView, NSTableColumn) -> Void)
		case nextTypeSelectMatch((_ tableView: NSTableView, _ startRow: Int, _ endRow: Int, _ searchString: String) -> Int)
		case pasteboardWriter((_ tableView: NSTableView, _ row: Int, _ data: RowData?) -> NSPasteboardWriting)
		case rowActionsForRow((_ tableView: NSTableView, _ row: Int, _ data: RowData?, _ edge: NSTableView.RowActionEdge) -> [NSTableViewRowAction])
		case rowView((_ tableView: NSTableView, _ row: Int, _ rowData: RowData?) -> TableRowViewConvertible?)
		case selectionDidChange((Notification) -> Void)
		case selectionIndexesForProposedSelection((_ tableView: NSTableView, IndexSet) -> IndexSet)
		case selectionShouldChange((_ tableView: NSTableView) -> Bool)
		case shouldReorderColumn((_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier, _ newIndex: Int) -> Bool)
		case shouldSelectRow((_ tableView: NSTableView, _ row: Int, _ rowData: RowData?) -> Bool)
		case shouldSelectTableColumn((_ tableView: NSTableView, _ column: NSTableColumn?) -> Bool)
		case shouldTypeSelectForEvent((_ tableView: NSTableView, _ event: NSEvent, _ searchString: String?) -> Bool)
		case sizeToFitWidthOfColumn((_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier) -> CGFloat)
		case sortDescriptorsDidChange((NSTableView, [NSSortDescriptor]) -> Void)
		case typeSelectString((_ tableView: NSTableView, _ cell: TableCell<RowData>) -> String?)
		case updateDraggingItems((_ tableView: NSTableView, _ forDrag: NSDraggingInfo) -> Void)
		case validateDrop((_ tableView: NSTableView, _ info: NSDraggingInfo, _ proposedRow: Int, _ proposedDropOperation: NSTableView.DropOperation) -> NSDragOperation)
	}
}

// MARK: - Binder Part 3: Preparer
public extension TableView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = TableView.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = NSTableView
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage(visibleRowsChanged: visibleRowsChanged) }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var singleAction: TargetAction?
		var doubleAction: TargetAction?
		var visibleRowsChanged: MultiOutput<CountableRange<Int>>?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TableView.Preparer {
	var delegateIsRequired: Bool { return true }
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(.action(let x)): singleAction = x
		case .inheritedBinding(let x): inherited.prepareBinding(x)
			
		case .acceptDrop(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDataSource.tableView(_:acceptDrop:row:dropOperation:)))
		case .didDragTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDelegate.tableView(_:didDrag:)))
		case .didClickTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDelegate.tableView(_:didClick:)))
		case .doubleAction(let x): doubleAction = x
		case .draggingSessionEnded(let x): delegate().addMultiHandler4(x, #selector(NSTableViewDataSource.tableView(_:draggingSession:endedAt:operation:)))
		case .draggingSessionWillBegin(let x): delegate().addMultiHandler4(x, #selector(NSTableViewDataSource.tableView(_:draggingSession:willBeginAt:forRowIndexes:)))
		case .heightOfRow(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:heightOfRow:)))
		case .isGroupRow(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:isGroupRow:)))
		case .mouseDownInHeaderOfTableColumn(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDelegate.tableView(_:mouseDownInHeaderOf:)))
		case .nextTypeSelectMatch(let x): delegate().addSingleHandler4(x, #selector(NSTableViewDelegate.tableView(_:nextTypeSelectMatchFromRow:toRow:for:)))
		case .pasteboardWriter(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDataSource.tableView(_:pasteboardWriterForRow:)))
		case .rowActionsForRow(let x): delegate().addSingleHandler4(x, #selector(NSTableViewDelegate.tableView(_:rowActionsForRow:edge:)))
		case .rowView(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:rowViewForRow:)))
		case .selectionDidChange(let x): delegate().addMultiHandler1(x, #selector(NSTableViewDelegate.tableViewSelectionDidChange(_:)))
		case .selectionIndexesForProposedSelection(let x): delegate().addSingleHandler2(x, #selector(NSTableViewDelegate.tableView(_:selectionIndexesForProposedSelection:)))
		case .selectionShouldChange(let x): delegate().addSingleHandler1(x, #selector(NSTableViewDelegate.selectionShouldChange(in:)))
		case .shouldReorderColumn(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:shouldReorderColumn:toColumn:)))
		case .shouldSelectRow(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:shouldSelectRow:)))
		case .shouldSelectTableColumn(let x): delegate().addSingleHandler2(x, #selector(NSTableViewDelegate.tableView(_:shouldSelect:)))
		case .shouldTypeSelectForEvent(let x): delegate().addSingleHandler3(x, #selector(NSTableViewDelegate.tableView(_:shouldTypeSelectFor:withCurrentSearch:)))
		case .sizeToFitWidthOfColumn(let x): delegate().addSingleHandler2(x, #selector(NSTableViewDelegate.tableView(_:sizeToFitWidthOfColumn:)))
		case .sortDescriptorsDidChange(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDataSource.tableView(_:sortDescriptorsDidChange:)))
		case .typeSelectString(let x): delegate().addSingleHandler2(x, #selector(NSTableViewDelegate.tableView(_:typeSelectStringFor:row:)))
		case .updateDraggingItems(let x): delegate().addMultiHandler2(x, #selector(NSTableViewDataSource.tableView(_:updateDraggingItemsForDrag:)))
		case .validateDrop(let x): delegate().addSingleHandler4(x, #selector(NSTableViewDataSource.tableView(_:validateDrop:proposedRow:proposedDropOperation:)))
		case .visibleRowsChanged(let x):
			visibleRowsChanged = visibleRowsChanged ?? Input().multicast()
			visibleRowsChanged?.signal.bind(to: x)
		default: break
		}
	}

	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		instance.dataSource = storage
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(.action): return nil
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .allowsColumnReordering(let x): return x.apply(instance) { i, v in i.allowsColumnReordering = v }
		case .allowsColumnResizing(let x): return x.apply(instance) { i, v in i.allowsColumnResizing = v }
		case .allowsColumnSelection(let x): return x.apply(instance) { i, v in i.allowsColumnSelection = v }
		case .allowsEmptySelection(let x): return x.apply(instance) { i, v in i.allowsEmptySelection = v }
		case .allowsMultipleSelection(let x): return x.apply(instance) { i, v in i.allowsMultipleSelection = v }
		case .allowsTypeSelect(let x): return x.apply(instance) { i, v in i.allowsTypeSelect = v }
		case .autosaveName(let x): return x.apply(instance) { i, v in i.autosaveName = v }
		case .autosaveTableColumns(let x): return x.apply(instance) { i, v in i.autosaveTableColumns = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .columnAutoresizingStyle(let x): return x.apply(instance) { i, v in i.columnAutoresizingStyle = v }
		case .columns(let x): return x.apply(instance, storage) { i, s, v in s.updateColumns(v.map { $0.construct() }, in: i) }
		case .cornerView(let x): return x.apply(instance) { i, v in i.cornerView = v?.nsView() }
		case .draggingDestinationFeedbackStyle(let x): return x.apply(instance) { i, v in i.draggingDestinationFeedbackStyle = v }
		case .floatsGroupRows(let x): return x.apply(instance) { i, v in i.floatsGroupRows = v }
		case .gridColor(let x): return x.apply(instance) { i, v in i.gridColor = v }
		case .gridStyleMask(let x): return x.apply(instance) { i, v in i.gridStyleMask = v }
		case .intercellSpacing(let x): return x.apply(instance) { i, v in i.intercellSpacing = v }
		case .rowHeight(let x): return x.apply(instance) { i, v in i.rowHeight = v }
		case .rowSizeStyle(let x): return x.apply(instance) { i, v in i.rowSizeStyle = v }
		case .selectionHighlightStyle(let x): return x.apply(instance) { i, v in i.selectionHighlightStyle = v }
		case .userInterfaceLayoutDirection(let x): return x.apply(instance) { i, v in i.userInterfaceLayoutDirection = v }
		case .usesAlternatingRowBackgroundColors(let x): return x.apply(instance) { i, v in i.usesAlternatingRowBackgroundColors = v }
		case .usesAutomaticRowHeights(let x): return x.apply(instance) { i, v in i.usesAutomaticRowHeights = v }
		case .verticalMotionCanBeginDrag(let x): return x.apply(instance) { i, v in i.verticalMotionCanBeginDrag = v }

		// 2. Signal bindings are performed on the object after construction.
		case .deselectAll(let x): return x.apply(instance) { i, v in i.deselectAll(nil) }
		case .deselectColumn(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v })?.offset {
					i.deselectColumn(index)
				}
			}
		case .deselectRow(let x): return x.apply(instance) { i, v in i.deselectRow(v) }
		case .hideRowActions(let x): return x.apply(instance) { i, v in i.rowActionsVisible = false }
		case .hideRows(let x): return x.apply(instance) { i, v in i.hideRows(at: v.indexes, withAnimation: v.withAnimation) }
		case .highlightColumn(let x):
			return x.apply(instance) { i, v in
				i.highlightedTableColumn = v.flatMap { (identifier: NSUserInterfaceItemIdentifier) -> NSTableColumn? in
					return i.tableColumns.first(where: { $0.identifier == identifier })
				}
			}
		case .moveColumn(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v.identifier })?.offset {
					i.moveColumn(index, toColumn: v.toIndex)
				}
			}
		case .scrollRowToVisible(let x): return x.apply(instance) { i, v in i.scrollRowToVisible(v) }
		case .scrollColumnToVisible(let x):
			return x.apply(instance) { i, v in
				if let index = i.tableColumns.enumerated().first(where: { $0.element.identifier == v })?.offset {
					i.scrollColumnToVisible(index)
				}
			}
		case .selectAll(let x): return x.apply(instance) { i, v in i.selectAll(nil) }
		case .selectColumns(let x):
			return x.apply(instance) { i, v in
				let indexes = v.identifiers.compactMap { identifier in i.tableColumns.enumerated().first(where: { $0.element.identifier == identifier })?.offset }
				let indexSet = IndexSet(indexes)
				i.selectColumnIndexes(indexSet, byExtendingSelection: v.byExtendingSelection)
			}
		case .selectRows(let x): return x.apply(instance) { i, v in i.selectRowIndexes(v.indexes, byExtendingSelection: v.byExtendingSelection) }
		case .sizeLastColumnToFit(let x): return x.apply(instance) { i, v in i.sizeLastColumnToFit() }
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }
		case .unhideRows(let x): return x.apply(instance) { i, v in i.unhideRows(at: v.indexes, withAnimation: v.withAnimation) }

		// 3. Action bindings are triggered by the object after construction.
		case .columnMoved(let x):
			return Signal.notifications(name: NSTableView.columnDidMoveNotification, object: instance).compactMap { [weak instance] notification -> (column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)? in
				guard let index = (notification.userInfo?["NSNewColumn"] as? NSNumber)?.intValue, let column = instance?.tableColumns.at(index) else {
					return nil
				}
				guard let oldIndex = (notification.userInfo?["NSNewColumn"] as? NSNumber)?.intValue else {
					return nil
				}
				return (column: column.identifier, oldIndex: oldIndex, newIndex: index)
			}.cancellableBind(to: x)
		case .columnResized(let x):
			return Signal.notifications(name: NSTableView.columnDidResizeNotification, object: instance).compactMap { notification -> (column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)? in
				guard let column = (notification.userInfo?["NSTableColumn"] as? NSTableColumn) else {
					return nil
				}
				guard let oldWidth = (notification.userInfo?["NSOldWidth"] as? NSNumber)?.doubleValue else {
					return nil
				}
				return (column: column.identifier, oldWidth: CGFloat(oldWidth), newWidth: column.width)
			}.cancellableBind(to: x)
		case .doubleAction: return nil
		case .visibleRowsChanged: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .acceptDrop: return nil
		case .didClickTableColumn: return nil
		case .didDragTableColumn: return nil
		case .draggingSessionEnded: return nil
		case .draggingSessionWillBegin: return nil
		case .groupRowCellConstructor(let x):
			storage.groupRowCellConstructor = x
			return nil
		case .headerView(let x): return x.apply(instance) { i, v in i.headerView = v?.nsTableHeaderView() }
		case .heightOfRow: return nil
		case .isGroupRow: return nil
		case .mouseDownInHeaderOfTableColumn: return nil
		case .nextTypeSelectMatch: return nil
		case .pasteboardWriter: return nil
		case .rowActionsForRow: return nil
		case .rows(let x): return x.apply(instance, storage) { i, s, v in s.applyRowAnimation(v, in: i) }
		case .rowView: return nil
		case .selectionDidChange: return nil
		case .selectionIndexesForProposedSelection: return nil
		case .selectionShouldChange: return nil
		case .shouldReorderColumn: return nil
		case .shouldSelectRow: return nil
		case .shouldSelectTableColumn: return nil
		case .shouldTypeSelectForEvent: return nil
		case .sizeToFitWidthOfColumn: return nil
		case .sortDescriptorsDidChange: return nil
		case .typeSelectString: return nil
		case .updateDraggingItems: return nil
		case .validateDrop: return nil
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		var lifetimes = [Lifetime]()
		
		switch (singleAction, doubleAction) {
		case (nil, nil): break
		case (.firstResponder(let sa)?, .firstResponder(let da)?):
			instance.action = sa
			instance.doubleAction = da
			instance.target = nil
		case (.singleTarget(let st)?, .singleTarget(let dt)?):
			let target = SignalDoubleActionTarget()
			instance.target = target 
			lifetimes += target.signal.cancellableBind(to: st)
			lifetimes += target.signal.cancellableBind(to: dt)
			instance.action = SignalDoubleActionTarget.selector
			instance.doubleAction = SignalDoubleActionTarget.secondSelector
		case (let s?, nil):
			lifetimes += s.apply(to: instance, constructTarget: SignalActionTarget.init)
		case (nil, let d?):
			lifetimes += d.apply(to: instance, constructTarget: SignalActionTarget.init)
			instance.doubleAction = instance.action
			instance.action = nil
		case (.some, .some): fatalError("Action and double action may not use mix of single target and first responder")
		}
		
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TableView.Preparer {
	open class Storage: View.Preparer.Storage, NSTableViewDelegate, NSTableViewDataSource {
		public let visibleRowsChanged: MultiOutput<CountableRange<Int>>?

		open var actionTarget: SignalDoubleActionTarget? = nil
		open var rowState: TableRowState<RowData> = TableRowState<RowData>()
		open var visibleRows: IndexSet = []
		open var groupRowCellConstructor: ((Int) -> TableCellViewConvertible)?
		open var columns: [TableColumn<RowData>.Preparer.Storage] = []
		
		public init(visibleRowsChanged: MultiOutput<CountableRange<Int>>?) {
			self.visibleRowsChanged = visibleRowsChanged
		}
		
		open override var isInUse: Bool { return true }
		
		fileprivate func rowData(at row: Int) -> RowData? {
			return rowState.values?.at(row)
		}
		
		open func columnForIdentifier(_ identifier: NSUserInterfaceItemIdentifier) -> (offset: Int, element: TableColumn<RowData>.Preparer.Storage)? {
			return columns.enumerated().first { (tuple: (offset: Int, element: TableColumn<RowData>.Preparer.Storage)) -> Bool in
				tuple.element.tableColumn.identifier == identifier
			}
		}
		
		open func numberOfRows(in tableView: NSTableView) -> Int {
			return rowState.globalCount
		}

		open func tableView(_ tableView: NSTableView, didAdd: NSTableRowView, forRow: Int) {
			DispatchQueue.main.async {
				if let vrsi = self.visibleRowsChanged?.input {
					let previousMin = self.visibleRows.min() ?? 0
					let previousMax = self.visibleRows.max() ?? previousMin
					self.visibleRows.insert(forRow)
					let newMin = self.visibleRows.min() ?? 0
					let newMax = self.visibleRows.max() ?? newMin
					if previousMin != newMin || previousMax != newMax {
						vrsi.send(value: newMin..<newMax)
					}
				}
			}
		}
		
		open func tableView(_ tableView: NSTableView, didRemove: NSTableRowView, forRow: Int) {
			DispatchQueue.main.async {
				if let vrsi = self.visibleRowsChanged?.input {
					let previousMin = self.visibleRows.min() ?? 0
					let previousMax = self.visibleRows.max() ?? previousMin
					self.visibleRows.remove(forRow)
					let newMin = self.visibleRows.min() ?? 0
					let newMax = self.visibleRows.max() ?? newMin
					if previousMin != newMin || previousMax != newMax {
						vrsi.send(value: newMin..<newMax)
					}
				}
			}
		}

		open func tableView(_ tableView: NSTableView, objectValueFor tableColumn: NSTableColumn?, row: Int) -> Any? {
			return nil
		}
		
		open func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -> NSView? {
			if let tc = tableColumn {
				if let col = columnForIdentifier(tc.identifier) {
					let data = rowState.values?.at(row - rowState.localOffset)
					let identifier = col.element.cellIdentifier?(data) ?? tc.identifier

					let cellView: NSTableCellView
					let cellInput: SignalInput<RowData>?
					if let reusedView = tableView.makeView(withIdentifier: identifier, owner: tableView), let downcast = reusedView as? NSTableCellView {
						cellView = downcast
						cellInput = cellView.associatedRowInput(valueType: RowData.self)
					} else if let cc = col.element.cellConstructor {
						let dataTuple = Signal<RowData>.create()
						let constructed = cc(identifier, dataTuple.signal.multicast()).nsTableCellView()
						if constructed.identifier == nil {
							constructed.identifier = identifier
						}
						cellView = constructed
						cellInput = dataTuple.input
						cellView.setAssociatedRowInput(to: dataTuple.input)
					} else {
						return col.element.dataMissingCell?()?.nsTableCellView()
					}
					
					if let d = data {
						_ = cellInput?.send(value: d)
					}
					return cellView
				}
			} else {
				return groupRowCellConstructor?(row).nsTableCellView()
			}
			return nil
		}

		open func updateColumns(_ v: [TableColumn<RowData>.Preparer.Storage], in tableView: NSTableView) {
			columns = v
			let columnsArray = v.map { $0.tableColumn }
			let newColumnSet = Set(columnsArray)
			let oldColumnSet = Set(tableView.tableColumns)
			
			for c in columnsArray {
				if !oldColumnSet.contains(c) {
					tableView.addTableColumn(c)
				}
				if !newColumnSet.contains(c) {
					tableView.removeTableColumn(c)
				}
			}
		}

		open func applyRowAnimation(_ rowAnimation: TableRowAnimatable<RowData>, in tableView: NSTableView) {
			rowAnimation.value.apply(toSubrange: &rowState)
			rowAnimation.value.updateMetadata(&rowState)
			
			let animation = rowAnimation.animation ?? []
			let indices = rowAnimation.value.indexSet.offset(by: rowState.localOffset)

			switch rowAnimation.value.kind {
			case .delete:
				tableView.removeRows(at: indices, withAnimation: animation)
			case .move(let destination):
				tableView.beginUpdates()
				for (count, index) in indices.enumerated() {
					tableView.moveRow(at: index, to: destination + count)
				}
				tableView.endUpdates()
			case .insert:
				tableView.insertRows(at: indices, withAnimation: animation)
			case .scroll:
				tableView.reloadData(forRowIndexes: indices, columnIndexes: IndexSet(integersIn: 0..<tableView.tableColumns.count))
			case .update:
				tableView.beginUpdates()
				for rowIndex in indices {
					for columnIndex in 0..<tableView.numberOfColumns {
						guard let cell = tableView.view(atColumn: columnIndex, row: rowIndex, makeIfNecessary: false) as? NSTableCellView, let value = rowState.values?.at(rowIndex - rowState.localOffset) else { continue }
						cell.associatedRowInput(valueType: RowData.self)?.send(value: value)
					}
				}
				tableView.endUpdates()
			case .reload:
				tableView.reloadData()
			}
		}
	}

	open class Delegate: DynamicDelegate, NSTableViewDelegate, NSTableViewDataSource {
		private func storage(for tableView: NSTableView) -> Storage? {
			return tableView.delegate as? Storage
		}
		
		open func tableView(_ tableView: NSTableView, didDrag tableColumn: NSTableColumn) {
			multiHandler(tableView, tableColumn)
		}

		open func tableView(_ tableView: NSTableView, didClick tableColumn: NSTableColumn) {
			multiHandler(tableView, tableColumn)
		}

		open func tableView(_ tableView: NSTableView, mouseDownInHeaderOf tableColumn: NSTableColumn) {
			multiHandler(tableView, tableColumn)
		}

		open func tableView(_ tableView: NSTableView, rowViewForRow rowIndex: Int) -> NSTableRowView? {
			return (singleHandler(rowIndex, storage(for: tableView)?.rowData(at: rowIndex)) as TableRowViewConvertible?)?.nsTableRowView()
		}

		open func tableView(_ tableView: NSTableView, shouldReorderColumn columnIndex: Int, toColumn newColumnIndex: Int) -> Bool {
			if let column = tableView.tableColumns.at(columnIndex) {
				return singleHandler(tableView, column.identifier, newColumnIndex)
			}
			return false
		}

		open func tableView(_ tableView: NSTableView, sizeToFitWidthOfColumn column: Int) -> CGFloat {
			if let column = tableView.tableColumns.at(column) {
				return singleHandler(tableView, column.identifier)
			}
			return 0
		}

		open func tableView(_ tableView: NSTableView, shouldTypeSelectFor event: NSEvent, withCurrentSearch searchString: String?) -> Bool {
			return singleHandler(tableView, event, searchString)
		}

		open func tableView(_ tableView: NSTableView, typeSelectStringFor tableColumn: NSTableColumn?, row: Int) -> String? {
			guard let tc = tableColumn, row >= 0 else { return nil }
			return singleHandler(TableCell<RowData>(row: row, column: tc, tableView: tableView))
		}

		open func tableView(_ tableView: NSTableView, nextTypeSelectMatchFromRow startRow: Int, toRow endRow: Int, for searchString: String) -> Int {
			return singleHandler(tableView, startRow, endRow, searchString)
		}

		open func tableView(_ tableView: NSTableView, heightOfRow rowIndex: Int) -> CGFloat {
			return singleHandler(rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}

		open func tableView(_ tableView: NSTableView, shouldSelect tableColumn: NSTableColumn?) -> Bool {
			return singleHandler(tableView, tableColumn)
		}

		open func tableView(_ tableView: NSTableView, selectionIndexesForProposedSelection proposedSelectionIndexes: IndexSet) -> IndexSet {
			return singleHandler(tableView, proposedSelectionIndexes)
		}

		open func tableView(_ tableView: NSTableView, shouldSelectRow rowIndex: Int) -> Bool {
			return singleHandler(rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}

		open func selectionShouldChange(in tableView: NSTableView) -> Bool {
			return singleHandler(tableView)
		}

		open func tableView(_ tableView: NSTableView, isGroupRow rowIndex: Int) -> Bool {
			return singleHandler(rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}

		open func tableView(_ tableView: NSTableView, sortDescriptorsDidChange oldDescriptors: [NSSortDescriptor]) {
			multiHandler(tableView, oldDescriptors)
		}

		open func tableView(_ tableView: NSTableView, pasteboardWriterForRow rowIndex: Int) -> NSPasteboardWriting? {
			return singleHandler(tableView, rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}
		
		open func tableViewSelectionDidChange(_ notification: Notification) {
			multiHandler(notification)
		}
		
		open func tableView(_ tableView: NSTableView, acceptDrop info: NSDraggingInfo, row rowIndex: Int, dropOperation: NSTableView.DropOperation) -> Bool {
			return singleHandler(tableView, rowIndex, storage(for: tableView)?.rowData(at: rowIndex))
		}

		open func tableView(_ tableView: NSTableView, validateDrop info: NSDraggingInfo, proposedRow row: Int, proposedDropOperation dropOperation: NSTableView.DropOperation) -> NSDragOperation {
			return singleHandler(tableView, info, row, dropOperation)
		}

		open func tableView(_ tableView: NSTableView, draggingSession session: NSDraggingSession, willBeginAt screenPoint: NSPoint, forRowIndexes rowIndexes: IndexSet) {
			return singleHandler(tableView, session, screenPoint, rowIndexes)
		}

		open func tableView(_ tableView: NSTableView, updateDraggingItemsForDrag draggingInfo: NSDraggingInfo) {
			return singleHandler(tableView, draggingInfo)
		}

		open func tableView(_ tableView: NSTableView, draggingSession session: NSDraggingSession, endedAt screenPoint: NSPoint, operation: NSDragOperation) {
			return singleHandler(tableView, session, screenPoint, operation)
		}

		open func tableView(_ tableView: NSTableView, rowActionsForRow row: Int, edge: NSTableView.RowActionEdge) -> [NSTableViewRowAction] {
			return singleHandler(tableView, row, edge)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TableViewBinding {
	public typealias TableViewName<V> = BindingName<V, TableView<Binding.RowDataType>.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TableView<Binding.RowDataType>.Binding) -> TableViewName<V> {
		return TableViewName<V>(source: source, downcast: Binding.tableViewBinding)
	}
}
public extension BindingName where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TableViewName<$2> { return .name(TableView.Binding.$1) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsColumnReordering: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsColumnReordering) }
	static var allowsColumnResizing: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsColumnResizing) }
	static var allowsColumnSelection: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsColumnSelection) }
	static var allowsEmptySelection: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsEmptySelection) }
	static var allowsMultipleSelection: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsMultipleSelection) }
	static var allowsTypeSelect: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.allowsTypeSelect) }
	static var autosaveName: TableViewName<Dynamic<NSTableView.AutosaveName?>> { return .name(TableView.Binding.autosaveName) }
	static var autosaveTableColumns: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.autosaveTableColumns) }
	static var backgroundColor: TableViewName<Dynamic<NSColor>> { return .name(TableView.Binding.backgroundColor) }
	static var columnAutoresizingStyle: TableViewName<Dynamic<NSTableView.ColumnAutoresizingStyle>> { return .name(TableView.Binding.columnAutoresizingStyle) }
	static var columns: TableViewName<Dynamic<[TableColumn<Binding.RowDataType>]>> { return .name(TableView.Binding.columns) }
	static var cornerView: TableViewName<Dynamic<ViewConvertible?>> { return .name(TableView.Binding.cornerView) }
	static var draggingDestinationFeedbackStyle: TableViewName<Dynamic<NSTableView.DraggingDestinationFeedbackStyle>> { return .name(TableView.Binding.draggingDestinationFeedbackStyle) }
	static var floatsGroupRows: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.floatsGroupRows) }
	static var gridColor: TableViewName<Dynamic<NSColor>> { return .name(TableView.Binding.gridColor) }
	static var gridStyleMask: TableViewName<Dynamic<NSTableView.GridLineStyle>> { return .name(TableView.Binding.gridStyleMask) }
	static var headerView: TableViewName<Dynamic<TableHeaderViewConvertible?>> { return .name(TableView.Binding.headerView) }
	static var intercellSpacing: TableViewName<Dynamic<NSSize>> { return .name(TableView.Binding.intercellSpacing) }
	static var rowHeight: TableViewName<Dynamic<CGFloat>> { return .name(TableView.Binding.rowHeight) }
	static var rows: TableViewName<Dynamic<TableRowAnimatable<Binding.RowDataType>>> { return .name(TableView.Binding.rows) }
	static var rowSizeStyle: TableViewName<Dynamic<NSTableView.RowSizeStyle>> { return .name(TableView.Binding.rowSizeStyle) }
	static var selectionHighlightStyle: TableViewName<Dynamic<NSTableView.SelectionHighlightStyle>> { return .name(TableView.Binding.selectionHighlightStyle) }
	static var userInterfaceLayoutDirection: TableViewName<Dynamic<NSUserInterfaceLayoutDirection>> { return .name(TableView.Binding.userInterfaceLayoutDirection) }
	static var usesAlternatingRowBackgroundColors: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.usesAlternatingRowBackgroundColors) }
	static var usesAutomaticRowHeights: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.usesAutomaticRowHeights) }
	static var verticalMotionCanBeginDrag: TableViewName<Dynamic<Bool>> { return .name(TableView.Binding.verticalMotionCanBeginDrag) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var deselectAll: TableViewName<Signal<Void>> { return .name(TableView.Binding.deselectAll) }
	static var deselectColumn: TableViewName<Signal<NSUserInterfaceItemIdentifier>> { return .name(TableView.Binding.deselectColumn) }
	static var deselectRow: TableViewName<Signal<Int>> { return .name(TableView.Binding.deselectRow) }
	static var hideRowActions: TableViewName<Signal<Void>> { return .name(TableView.Binding.hideRowActions) }
	static var hideRows: TableViewName<Signal<(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)>> { return .name(TableView.Binding.hideRows) }
	static var highlightColumn: TableViewName<Signal<NSUserInterfaceItemIdentifier?>> { return .name(TableView.Binding.highlightColumn) }
	static var moveColumn: TableViewName<Signal<(identifier: NSUserInterfaceItemIdentifier, toIndex: Int)>> { return .name(TableView.Binding.moveColumn) }
	static var scrollColumnToVisible: TableViewName<Signal<NSUserInterfaceItemIdentifier>> { return .name(TableView.Binding.scrollColumnToVisible) }
	static var scrollRowToVisible: TableViewName<Signal<Int>> { return .name(TableView.Binding.scrollRowToVisible) }
	static var selectAll: TableViewName<Signal<Void>> { return .name(TableView.Binding.selectAll) }
	static var selectColumns: TableViewName<Signal<(identifiers: Set<NSUserInterfaceItemIdentifier>, byExtendingSelection: Bool)>> { return .name(TableView.Binding.selectColumns) }
	static var selectRows: TableViewName<Signal<(indexes: IndexSet, byExtendingSelection: Bool)>> { return .name(TableView.Binding.selectRows) }
	static var sizeLastColumnToFit: TableViewName<Signal<Void>> { return .name(TableView.Binding.sizeLastColumnToFit) }
	static var sizeToFit: TableViewName<Signal<Void>> { return .name(TableView.Binding.sizeToFit) }
	static var unhideRows: TableViewName<Signal<(indexes: IndexSet, withAnimation: NSTableView.AnimationOptions)>> { return .name(TableView.Binding.unhideRows) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var columnMoved: TableViewName<SignalInput<(column: NSUserInterfaceItemIdentifier, oldIndex: Int, newIndex: Int)>> { return .name(TableView.Binding.columnMoved) }
	static var columnResized: TableViewName<SignalInput<(column: NSUserInterfaceItemIdentifier, oldWidth: CGFloat, newWidth: CGFloat)>> { return .name(TableView.Binding.columnResized) }
	static var doubleAction: TableViewName<TargetAction> { return .name(TableView.Binding.doubleAction) }
	static var visibleRowsChanged: TableViewName<SignalInput<CountableRange<Int>>> { return .name(TableView.Binding.visibleRowsChanged) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var acceptDrop: TableViewName<(_ tableView: NSTableView, _ row: Int, _ data: Binding.RowDataType?) -> Bool> { return .name(TableView.Binding.acceptDrop) }
	static var didClickTableColumn: TableViewName<(NSTableView, NSTableColumn) -> Void> { return .name(TableView.Binding.didClickTableColumn) }
	static var didDragTableColumn: TableViewName<(NSTableView, NSTableColumn) -> Void> { return .name(TableView.Binding.didDragTableColumn) }
	static var draggingSessionEnded: TableViewName<(_ tableView: NSTableView, _ session: NSDraggingSession, _ endedAt: NSPoint, _ operation: NSDragOperation) -> Void> { return .name(TableView.Binding.draggingSessionEnded) }
	static var draggingSessionWillBegin: TableViewName<(_ tableView: NSTableView, _ session: NSDraggingSession, _ willBeginAt: NSPoint, _ forRowIndexes: IndexSet) -> Void> { return .name(TableView.Binding.draggingSessionWillBegin) }
	static var groupRowCellConstructor: TableViewName<(Int) -> TableCellViewConvertible> { return .name(TableView.Binding.groupRowCellConstructor) }
	static var heightOfRow: TableViewName<(_ tableView: NSTableView, _ row: Int, _ rowData: Binding.RowDataType?) -> CGFloat> { return .name(TableView.Binding.heightOfRow) }
	static var isGroupRow: TableViewName<(_ tableView: NSTableView, _ row: Int, _ rowData: Binding.RowDataType?) -> Bool> { return .name(TableView.Binding.isGroupRow) }
	static var mouseDownInHeaderOfTableColumn: TableViewName<(NSTableView, NSTableColumn) -> Void> { return .name(TableView.Binding.mouseDownInHeaderOfTableColumn) }
	static var nextTypeSelectMatch: TableViewName<(_ tableView: NSTableView, _ startRow: Int, _ endRow: Int, _ searchString: String) -> Int> { return .name(TableView.Binding.nextTypeSelectMatch) }
	static var pasteboardWriter: TableViewName<(_ tableView: NSTableView, _ row: Int, _ data: Binding.RowDataType?) -> NSPasteboardWriting> { return .name(TableView.Binding.pasteboardWriter) }
	static var rowActionsForRow: TableViewName<(_ tableView: NSTableView, _ row: Int, _ data: Binding.RowDataType?, _ edge: NSTableView.RowActionEdge) -> [NSTableViewRowAction]> { return .name(TableView.Binding.rowActionsForRow) }
	static var rowView: TableViewName<(_ tableView: NSTableView, _ row: Int, _ rowData: Binding.RowDataType?) -> TableRowViewConvertible?> { return .name(TableView.Binding.rowView) }
	static var selectionDidChange: TableViewName<(Notification) -> Void> { return .name(TableView.Binding.selectionDidChange) }
	static var selectionIndexesForProposedSelection: TableViewName<(_ tableView: NSTableView, IndexSet) -> IndexSet> { return .name(TableView.Binding.selectionIndexesForProposedSelection) }
	static var selectionShouldChange: TableViewName<(_ tableView: NSTableView) -> Bool> { return .name(TableView.Binding.selectionShouldChange) }
	static var shouldReorderColumn: TableViewName<(_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier, _ newIndex: Int) -> Bool> { return .name(TableView.Binding.shouldReorderColumn) }
	static var shouldSelectRow: TableViewName<(_ tableView: NSTableView, _ row: Int, _ rowData: Binding.RowDataType?) -> Bool> { return .name(TableView.Binding.shouldSelectRow) }
	static var shouldSelectTableColumn: TableViewName<(_ tableView: NSTableView, _ column: NSTableColumn?) -> Bool> { return .name(TableView.Binding.shouldSelectTableColumn) }
	static var shouldTypeSelectForEvent: TableViewName<(_ tableView: NSTableView, _ event: NSEvent, _ searchString: String?) -> Bool> { return .name(TableView.Binding.shouldTypeSelectForEvent) }
	static var sizeToFitWidthOfColumn: TableViewName<(_ tableView: NSTableView, _ column: NSUserInterfaceItemIdentifier) -> CGFloat> { return .name(TableView.Binding.sizeToFitWidthOfColumn) }
	static var sortDescriptorsDidChange: TableViewName<(NSTableView, [NSSortDescriptor]) -> Void> { return .name(TableView.Binding.sortDescriptorsDidChange) }
	static var typeSelectString: TableViewName<(_ tableView: NSTableView, _ cell: TableCell<Binding.RowDataType>) -> String?> { return .name(TableView.Binding.typeSelectString) }
	static var updateDraggingItems: TableViewName<(_ tableView: NSTableView, _ forDrag: NSDraggingInfo) -> Void> { return .name(TableView.Binding.updateDraggingItems) }
	static var validateDrop: TableViewName<(_ tableView: NSTableView, _ info: NSDraggingInfo, _ proposedRow: Int, _ proposedDropOperation: NSTableView.DropOperation) -> NSDragOperation> { return .name(TableView.Binding.validateDrop) }

	// Composite binding names
	static func doubleAction<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> TableViewName<SignalInput<Value>> {
		return Binding.keyPathActionName(keyPath, TableView.Binding.doubleAction, Binding.tableViewBinding)
	}
	static func cellSelected<Value>(_ keyPath: KeyPath<TableCell<Binding.RowDataType>, Value>) -> TableViewName<SignalInput<Value?>> {
		return Binding.compositeName(
			value: { (input: SignalInput<Value?>) in
				{ (notification: Notification) -> Void in
					guard let view = (notification.object as? NSTableView) else { return }
					let cell = TableCell<Binding.RowDataType>(row: view.selectedRow, column: view.selectedColumn, tableView: view)
					let value = cell?[keyPath: keyPath]
					_ = input.send(value: value)
				}
			},
			binding: TableView.Binding.selectionDidChange,
			downcast: Binding.tableViewBinding
		)
	}
	static func cellSelected(_ void: Void = ()) -> TableViewName<SignalInput<TableCell<Binding.RowDataType>?>> {
		return Binding.compositeName(
			value: { (input: SignalInput<TableCell<Binding.RowDataType>?>) in
				{ (notification: Notification) -> Void in
					guard let view = (notification.object as? NSTableView) else { return }
					let cell = TableCell<Binding.RowDataType>(row: view.selectedRow, column: view.selectedColumn, tableView: view)
					_ = input.send(value: cell)
				}
			},
			binding: TableView.Binding.selectionDidChange,
			downcast: Binding.tableViewBinding
		)
	}
	static func selectRow(_ void: Void = ()) -> TableViewName<Signal<Int?>> {
		return Binding.compositeName(
			value:
				{ (input: Signal<Int?>) in
					return input.map {
						$0.map { (indexes: IndexSet(integer: $0), byExtendingSelection: false) } ?? (indexes: IndexSet(), byExtendingSelection: false)
					}
				},
			binding: TableView.Binding.selectRows,
			downcast: Binding.tableViewBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TableViewConvertible: ControlConvertible {
	func nsTableView() -> NSTableView
}
extension NSTableView: TableViewConvertible, HasDelegate {
	public func nsTableView() -> NSTableView { return self }
}
public extension TableViewConvertible {
	func nsControl() -> Control.Instance { return nsTableView() }
}
public extension TableView {
	func nsTableView() -> NSTableView { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TableViewBinding: ControlBinding {
	associatedtype RowDataType
	static func tableViewBinding(_ binding: TableView<RowDataType>.Binding) -> Self
	func asTableViewBinding() -> TableView<RowDataType>.Binding?
}
public extension TableViewBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return tableViewBinding(.inheritedBinding(binding))
	}
}
public extension TableViewBinding where Preparer.Inherited.Binding: TableViewBinding, Preparer.Inherited.Binding.RowDataType == RowDataType {
	func asTableViewBinding() -> TableView<RowDataType>.Binding? {
		return asInheritedBinding()?.asTableViewBinding()
	}
}
public extension TableView.Binding {
	typealias Preparer = TableView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTableViewBinding() -> TableView.Binding? { return self }
	static func tableViewBinding(_ binding: TableView<RowDataType>.Binding) -> TableView<RowDataType>.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public typealias TableRowMutation<Element> = SubrangeMutation<Element, ()>
public typealias TableRowAnimatable<Element> = Animatable<TableRowMutation<Element>, NSTableView.AnimationOptions>

public typealias TableRowState<Element> = SubrangeState<Element, ()>

public struct TableCell<RowData> {
	public let row: Int?
	public let column: Int?
	public let columnIdentifier: NSUserInterfaceItemIdentifier?
	public let data: RowData?
	
	public init?(row: Int, column: Int, tableView: NSTableView) {
		guard row >= 0 || column >= 0 else {
			return nil
		}
		self.row = row > 0 ? row : nil
		self.column = column > 0 ? column : nil
		self.columnIdentifier = tableView.tableColumns.at(column)?.identifier
		self.data = (tableView.delegate as? TableView<RowData>.Preparer.Storage)?.rowData(at: row)
	}
	
	public init?(row: Int, column: NSTableColumn, tableView: NSTableView) {
		self.init(row: row, column: tableView.column(withIdentifier: column.identifier), tableView: tableView)
	}
}

public extension Sequence {
	func tableData() -> TableRowAnimatable<Element> {
		return .set(.reload(Array(self)))
	}
}

public extension Signal {
	func tableData<RowData>(_ choice: AnimationChoice = .subsequent) -> Signal<TableRowAnimatable<RowData>> where IndexedMutation<RowData, ()> == OutputValue {
		return map(initialState: false) { (alreadyReceived: inout Bool, rowMutation: OutputValue) -> TableRowAnimatable<RowData> in
			if alreadyReceived || choice == .always {
				return .animate(TableRowMutation(kind: rowMutation.kind, metadata: nil, indexSet: rowMutation.indexSet, values: rowMutation.values), animation: .effectFade)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(TableRowMutation(kind: rowMutation.kind, metadata: nil, indexSet: rowMutation.indexSet, values: rowMutation.values))
			}
		}
	}

	func tableData<RowData>(_ choice: AnimationChoice = .subsequent) -> Signal<TableRowAnimatable<RowData>> where TableRowMutation<RowData> == OutputValue {
		return map(initialState: false) { (alreadyReceived: inout Bool, rowMutation: OutputValue) -> TableRowAnimatable<RowData> in
			if alreadyReceived || choice == .always {
				return .animate(rowMutation, animation: .effectFade)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(rowMutation)
			}
		}
	}
}

public extension Adapter where State == VarState<Int?> {
	func updateFirstRow() -> SignalInput<CountableRange<Int>> {
		return Input().map { $0.first }.bind(to: update())
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class TextField: Binder, TextFieldConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	public static var labelBindings: [Binding] {
		return [
			.isEditable -- false,
			.isSelectable -- true,
			.isBordered -- false,
			.drawsBackground -- false
		]
	}
	
	public static var wrappingLabelBindings: [Binding] {
		return [
			.isEditable -- false,
			.isSelectable -- true,
			.isBordered -- false,
			.drawsBackground -- false,
			.lineBreakMode -- .byWordWrapping,
			.horizontalContentCompressionResistancePriority -- .defaultLow
		]
	}
	
	public static func label(type: Instance.Type = Instance.self, _ bindings: Binding...) -> TextField {
		return TextField(type: type, parameters: (), bindings: TextField.labelBindings + bindings)
	}
	
	public static func wrappingLabel(type: Instance.Type = Instance.self, _ bindings: Binding...) -> TextField {
		return TextField(type: type, parameters: (), bindings: TextField.wrappingLabelBindings + bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension TextField {
	enum Binding: TextFieldBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsCharacterPickerTouchBarItem(Dynamic<Bool>)
		case allowsDefaultTighteningForTruncation(Dynamic<Bool>)
		case allowsEditingTextAttributes(Dynamic<Bool>)
		case allowsUndo(Dynamic<Bool>)
		case backgroundColor(Dynamic<NSColor?>)
		case bezelStyle(Dynamic<NSTextField.BezelStyle>)
		case drawsBackground(Dynamic<Bool>)
		case importsGraphics(Dynamic<Bool>)
		case isAutomaticTextCompletionEnabled(Dynamic<Bool>)
		case isBezeled(Dynamic<Bool>)
		case isBordered(Dynamic<Bool>)
		case isEditable(Dynamic<Bool>)
		case isSelectable(Dynamic<Bool>)
		case maximumNumberOfLines(Dynamic<Int>)
		case placeholderAttributedString(Dynamic<NSAttributedString?>)
		case placeholderString(Dynamic<String?>)
		case preferredMaxLayoutWidth(Dynamic<CGFloat>)
		case sendsActionOnEndEditing(Dynamic<Bool>)
		case textColor(Dynamic<NSColor?>)
		case usesSingleLineMode(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.
		case selectText(Signal<Void>)

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case completions((_ control: NSTextField, _ textView: NSTextView, _ completions: [String], _ partialWordRange: NSRange, _ indexOfSelectedItem: UnsafeMutablePointer<Int>) -> [String])
		case didFailToFormatString((_ control: NSTextField, _ string: String, _ errorDescription: String?) -> Bool)
		case didFailToValidatePartialString((_ control: NSTextField, _ partialString: String, _ errorDescription: String?) -> Void)
		case doCommand((_ control: NSTextField, _ textView: NSText, _ doCommandBySelector: Selector) -> Bool)
		case isValidObject((_ control: NSTextField, _ object: AnyObject) -> Bool)
		case shouldBeginEditing((_ control: NSTextField, _ text: NSText) -> Bool)
		case shouldEndEditing((_ control: NSTextField, _ text: NSText) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
public extension TextField {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = TextField.Binding
		public typealias Inherited = Control.Preparer
		public typealias Instance = NSTextField
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TextField.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .completions(let x): delegate().addSingleHandler5(x, #selector(NSTextFieldDelegate.control(_:textView:completions:forPartialWordRange:indexOfSelectedItem:)))
		case .didFailToFormatString(let x): delegate().addSingleHandler3(x, #selector(NSTextFieldDelegate.control(_:didFailToFormatString:errorDescription:)))
		case .didFailToValidatePartialString(let x): delegate().addMultiHandler3(x, #selector(NSTextFieldDelegate.control(_:didFailToValidatePartialString:errorDescription:)))
		case .doCommand(let x): delegate().addSingleHandler3(x, #selector(NSTextFieldDelegate.control(_:textView:doCommandBy:)))
		case .isValidObject(let x): delegate().addSingleHandler2(x, #selector(NSTextFieldDelegate.control(_:isValidObject:)))
		case .shouldBeginEditing(let x): delegate().addSingleHandler2(x, #selector(NSTextFieldDelegate.control(_:textShouldBeginEditing:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler2(x, #selector(NSTextFieldDelegate.control(_:textShouldEndEditing:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case .allowsCharacterPickerTouchBarItem(let x): return x.apply(instance) { i, v in i.allowsCharacterPickerTouchBarItem = v }
		case .allowsDefaultTighteningForTruncation(let x): return x.apply(instance) { i, v in i.allowsDefaultTighteningForTruncation = v }
		case .allowsEditingTextAttributes(let x): return x.apply(instance) { i, v in i.allowsEditingTextAttributes = v }
		case .allowsUndo(let x): return x.apply(instance) { i, v in i.cell?.allowsUndo = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .isBezeled(let x): return x.apply(instance) { i, v in i.isBezeled = v }
		case .bezelStyle(let x): return x.apply(instance) { i, v in i.bezelStyle = v }
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .importsGraphics(let x): return x.apply(instance) { i, v in i.importsGraphics = v }
		case .isAutomaticTextCompletionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticTextCompletionEnabled = v }
		case .isBordered(let x): return x.apply(instance) { i, v in i.isBordered = v }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .isSelectable(let x): return x.apply(instance) { i, v in i.isSelectable = v }
		case .maximumNumberOfLines(let x): return x.apply(instance) { i, v in i.maximumNumberOfLines = v }
		case .placeholderAttributedString(let x): return x.apply(instance) { i, v in i.placeholderAttributedString = v }
		case .placeholderString(let x): return x.apply(instance) { i, v in i.placeholderString = v }
		case .preferredMaxLayoutWidth(let x): return x.apply(instance) { i, v in i.preferredMaxLayoutWidth = v }
		case .sendsActionOnEndEditing(let x): return x.apply(instance) { i, v in i.cell?.sendsActionOnEndEditing = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		case .usesSingleLineMode(let x): return x.apply(instance) { i, v in i.usesSingleLineMode = v }

		// 2. Signal bindings are performed on the object after construction.
		case .selectText(let x): return x.apply(instance) { i, v in i.selectText(nil) }

		// 3. Action bindings are triggered by the object after construction.
		case .didFailToValidatePartialString: return nil

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .completions: return nil
		case .didFailToFormatString: return nil
		case .doCommand: return nil
		case .isValidObject: return nil
		case .shouldBeginEditing: return nil
		case .shouldEndEditing: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TextField.Preparer {
	open class Storage: Control.Preparer.Storage, NSTextFieldDelegate {}

	open class Delegate: DynamicDelegate, NSTextFieldDelegate {
		open func control(_ control: NSControl, isValidObject obj: Any?) -> Bool {
			return singleHandler(control as! NSTextField, obj as AnyObject)
		}
		
		open func control(_ control: NSControl, didFailToValidatePartialString string: String, errorDescription error: String?) {
			multiHandler(control, string, error)
		}
		
		open func control(_ control: NSControl, didFailToFormatString string: String, errorDescription error: String?) -> Bool {
			return singleHandler(control as! NSTextField, string, error)
		}
		
		open func control(_ control: NSControl, textShouldBeginEditing fieldEditor: NSText) -> Bool {
			return singleHandler(control as! NSTextField, fieldEditor)
		}
		
		open func control(_ control: NSControl, textShouldEndEditing fieldEditor: NSText) -> Bool {
			return singleHandler(control as! NSTextField, fieldEditor)
		}
		
		open func control(_ control: NSControl, textView: NSTextView, completions words: [String], forPartialWordRange charRange: NSRange, indexOfSelectedItem index: UnsafeMutablePointer<Int>) -> [String] {
			return singleHandler(control as! NSTextField, textView, words, charRange, index)
		}
		
		open func control(_ control: NSControl, textView: NSTextView, doCommandBy doCommandBySelector: Selector) -> Bool {
			return singleHandler(control as! NSTextField, textView, doCommandBySelector)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TextFieldBinding {
	public typealias TextFieldName<V> = BindingName<V, TextField.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TextField.Binding) -> TextFieldName<V> {
		return TextFieldName<V>(source: source, downcast: Binding.textFieldBinding)
	}
}
public extension BindingName where Binding: TextFieldBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TextFieldName<$2> { return .name(TextField.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsCharacterPickerTouchBarItem: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.allowsCharacterPickerTouchBarItem) }
	static var allowsDefaultTighteningForTruncation: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.allowsDefaultTighteningForTruncation) }
	static var allowsEditingTextAttributes: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.allowsEditingTextAttributes) }
	static var allowsUndo: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.allowsUndo) }
	static var backgroundColor: TextFieldName<Dynamic<NSColor?>> { return .name(TextField.Binding.backgroundColor) }
	static var isBezeled: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.isBezeled) }
	static var bezelStyle: TextFieldName<Dynamic<NSTextField.BezelStyle>> { return .name(TextField.Binding.bezelStyle) }
	static var drawsBackground: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.drawsBackground) }
	static var importsGraphics: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.importsGraphics) }
	static var isAutomaticTextCompletionEnabled: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.isAutomaticTextCompletionEnabled) }
	static var isBordered: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.isBordered) }
	static var isEditable: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.isEditable) }
	static var isSelectable: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.isSelectable) }
	static var maximumNumberOfLines: TextFieldName<Dynamic<Int>> { return .name(TextField.Binding.maximumNumberOfLines) }
	static var placeholderAttributedString: TextFieldName<Dynamic<NSAttributedString?>> { return .name(TextField.Binding.placeholderAttributedString) }
	static var placeholderString: TextFieldName<Dynamic<String?>> { return .name(TextField.Binding.placeholderString) }
	static var preferredMaxLayoutWidth: TextFieldName<Dynamic<CGFloat>> { return .name(TextField.Binding.preferredMaxLayoutWidth) }
	static var sendsActionOnEndEditing: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.sendsActionOnEndEditing) }
	static var textColor: TextFieldName<Dynamic<NSColor?>> { return .name(TextField.Binding.textColor) }
	static var usesSingleLineMode: TextFieldName<Dynamic<Bool>> { return .name(TextField.Binding.usesSingleLineMode) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectText: TextFieldName<Signal<Void>> { return .name(TextField.Binding.selectText) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var completions: TextFieldName<(_ control: NSTextField, _ textView: NSTextView, _ completions: [String], _ partialWordRange: NSRange, _ indexOfSelectedItem: UnsafeMutablePointer<Int>) -> [String]> { return .name(TextField.Binding.completions) }
	static var didFailToFormatString: TextFieldName<(_ control: NSTextField, _ string: String, _ errorDescription: String?) -> Bool> { return .name(TextField.Binding.didFailToFormatString) }
	static var didFailToValidatePartialString: TextFieldName<(_ control: NSTextField, _ partialString: String, _ errorDescription: String?) -> Void> { return .name(TextField.Binding.didFailToValidatePartialString) }
	static var doCommand: TextFieldName<(_ control: NSTextField, _ textView: NSText, _ doCommandBySelector: Selector) -> Bool> { return .name(TextField.Binding.doCommand) }
	static var isValidObject: TextFieldName<(_ control: NSTextField, _ object: AnyObject) -> Bool> { return .name(TextField.Binding.isValidObject) }
	static var shouldBeginEditing: TextFieldName<(_ control: NSTextField, _ text: NSText) -> Bool> { return .name(TextField.Binding.shouldBeginEditing) }
	static var shouldEndEditing: TextFieldName<(_ control: NSTextField, _ text: NSText) -> Bool> { return .name(TextField.Binding.shouldEndEditing) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TextFieldConvertible: ControlConvertible {
	func nsTextField() -> TextField.Instance
}
extension TextFieldConvertible {
	public func nsControl() -> Control.Instance { return nsTextField() }
}
extension NSTextField: TextFieldConvertible, HasDelegate {
	public func nsTextField() -> TextField.Instance { return self }
}
public extension TextField {
	func nsTextField() -> TextField.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TextFieldBinding: ControlBinding {
	static func textFieldBinding(_ binding: TextField.Binding) -> Self
	func asTextFieldBinding() -> TextField.Binding?
}
public extension TextFieldBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return textFieldBinding(.inheritedBinding(binding))
	}
}
public extension TextFieldBinding where Preparer.Inherited.Binding: TextFieldBinding {
	func asTextFieldBinding() -> TextField.Binding? {
		return asInheritedBinding()?.asTextFieldBinding()
	}
}
public extension TextField.Binding {
	typealias Preparer = TextField.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTextFieldBinding() -> TextField.Binding? { return self }
	static func textFieldBinding(_ binding: TextField.Binding) -> TextField.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class TextView: Binder, TextViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	public static func scrollEmbedded(type: NSTextView.Type = NSTextView.self, _ bindings: Binding...) -> ScrollView {
		return ScrollView(
			.borderType -- .noBorder,
			.hasVerticalScroller -- true,
			.hasHorizontalScroller -- true,
			.autohidesScrollers -- true,
			.contentView -- ClipView(
				.documentView -- TextView(type: type, bindings: bindings)
			)
		)
	}
}

// MARK: - Binder Part 2: Binding
public extension TextView {
	enum Binding: TextViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case string(Dynamic<String>)
		case backgroundColor(Dynamic<NSColor>)
		case drawsBackground(Dynamic<Bool>)
		case isEditable(Dynamic<Bool>)
		case isSelectable(Dynamic<Bool>)
		case isFieldEditor(Dynamic<Bool>)
		case isRichText(Dynamic<Bool>)
		case importsGraphics(Dynamic<Bool>)
		case usesFontPanel(Dynamic<Bool>)
		case font(Dynamic<NSFont>)
		case alignment(Dynamic<NSTextAlignment>)
		case textColor(Dynamic<NSColor>)
		case baseWritingDirection(Dynamic<NSWritingDirection>)
		case maxSize(Dynamic<NSSize>)
		case minSize(Dynamic<NSSize>)
		case isVerticallyResizable(Dynamic<Bool>)
		case isHorizontallyResizable(Dynamic<Bool>)
		
		case textContainerInset(Dynamic<NSSize>)
		case allowsDocumentBackgroundColorChange(Dynamic<Bool>)
		case allowsUndo(Dynamic<Bool>)
		case defaultParagraphStyle(Dynamic<NSParagraphStyle>)
		case allowsImageEditing(Dynamic<Bool>)
		case isAutomaticQuoteSubstitutionEnabled(Dynamic<Bool>)
		case isAutomaticLinkDetectionEnabled(Dynamic<Bool>)
		case displaysLinkToolTips(Dynamic<Bool>)
		case usesRuler(Dynamic<Bool>)
		case usesInspectorBar(Dynamic<Bool>)
		case selectionGranularity(Dynamic<NSSelectionGranularity>)
		case insertionPointColor(Dynamic<NSColor>)
		case selectedTextAttributes(Dynamic<[NSAttributedString.Key : Any]>)
		case markedTextAttributes(Dynamic<[NSAttributedString.Key : Any]>)
		case linkTextAttributes(Dynamic<[NSAttributedString.Key : Any]>)
		case typingAttributes(Dynamic<[NSAttributedString.Key : Any]>)
		case isContinuousSpellCheckingEnabled(Dynamic<Bool>)
		case isGrammarCheckingEnabled(Dynamic<Bool>)
		case usesFindPanel(Dynamic<Bool>)
		case enabledTextCheckingTypes(Dynamic<NSTextCheckingTypes>)
		case isAutomaticDashSubstitutionEnabled(Dynamic<Bool>)
		case isAutomaticDataDetectionEnabled(Dynamic<Bool>)
		case isAutomaticSpellingCorrectionEnabled(Dynamic<Bool>)
		case isAutomaticTextReplacementEnabled(Dynamic<Bool>)
		case layoutOrientation(Dynamic<NSLayoutManager.TextLayoutOrientation>)
		case usesFindBar(Dynamic<Bool>)
		case isIncrementalSearchingEnabled(Dynamic<Bool>)
		case allowsCharacterPickerTouchBarItem(Dynamic<Bool>)
		case isAutomaticTextCompletionEnabled(Dynamic<Bool>)
		case usesRolloverButtonForSelection(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.
		case selectRange(Signal<NSRange>)
		case selectAll(Signal<Void>)
		case copy(Signal<Void>)
		case cut(Signal<Void>)
		case paste(Signal<Void>)
		case copyFont(Signal<Void>)
		case pasteFont(Signal<Void>)
		case copyRuler(Signal<Void>)
		case pasteRuler(Signal<Void>)
		case delete(Signal<Void>)
		case changeFont(Signal<Void>)
		case alignCenter(Signal<Void>)
		case alignLeft(Signal<Void>)
		case alignRight(Signal<Void>)
		case superscript(Signal<Void>)
		case `subscript`(Signal<Void>)
		case unscript(Signal<Void>)
		case underline(Signal<Void>)
		case checkSpelling(Signal<Void>)
		case showGuessPanel(Signal<Void>)
		case sizeToFit(Signal<Void>)
		case scrollRangeToVisible(Signal<NSRange>)

		case showFindIndicator(Signal<NSRange>)
		case changeDocumentBackgroundColor(Signal<Void>)
		case outline(Signal<Void>)
		case alignJustified(Signal<Void>)
		case changeAttributes(Signal<Void>)
		case useStandardKerning(Signal<Void>)
		case lowerBaseline(Signal<Void>)
		case raiseBaseline(Signal<Void>)
		case turnOffKerning(Signal<Void>)
		case loosenKerning(Signal<Void>)
		case tightenKerning(Signal<Void>)
		case useStandardLigatures(Signal<Void>)
		case turnOffLigatures(Signal<Void>)
		case useAllLigatures(Signal<Void>)
		case clicked(Signal<(Any, Int)>)
		case pasteAsPlainText(Signal<Void>)
		case pasteAsRichText(Signal<Void>)
		case breakUndoCoalescing(Signal<Void>)
		case setSpellingState(Signal<(NSAttributedString.SpellingState, NSRange)>)
		case orderFrontSharingServicePicker(Signal<Void>)
		case startSpeaking(Signal<Void>)
		case stopSpeaking(Signal<Void>)
		case performFindPanelAction(Signal<Void>)
		case orderFrontLinkPanel(Signal<Void>)
		case orderFrontListPanel(Signal<Void>)
		case orderFrontSpacingPanel(Signal<Void>)
		case orderFrontTablePanel(Signal<Void>)
		case orderFrontSubstitutionsPanel(Signal<Void>)
		case complete(Signal<Void>)
		case checkTextInDocument(Signal<Void>)
		case checkTextInSelection(Signal<Void>)
		case checkText(Signal<(NSRange, NSTextCheckingTypes, [NSSpellChecker.OptionKey: Any])>)
		case updateQuickLookPreviewPanel(Signal<Void>)
		case toggleQuickLookPreviewPanel(Signal<Void>)
		case updateCandidates(Signal<Void>)
		case updateTextTouchBarItems(Signal<Void>)
		case updateTouchBarItemIdentifiers(Signal<Void>)

		// 3. Action bindings are triggered by the object after construction.
		case didBeginEditing(SignalInput<NSTextView>)
		case didChange(SignalInput<NSTextView>)
		case didEndEditing(SignalInput<(NSTextView, NSTextMovement?)>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBeginEditing((NSTextView) -> Bool)
		case shouldEndEditing((NSTextView) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
public extension TextView {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = TextView.Binding
		public typealias Inherited = View.Preparer
		public typealias Instance = NSTextView
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension TextView.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let x): inherited.prepareBinding(x)
		case .shouldBeginEditing(let x): delegate().addSingleHandler1(x, #selector(NSTextViewDelegate.textShouldBeginEditing(_:)))
		case .shouldEndEditing(let x): delegate().addSingleHandler1(x, #selector(NSTextViewDelegate.textShouldEndEditing(_:)))
		default: break
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)

		// 0. Static bindings are applied at construction and are subsequently immutable.
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .string(let x): return x.apply(instance) { i, v in i.string = v }
		case .backgroundColor(let x): return x.apply(instance) { i, v in i.backgroundColor = v }
		case .drawsBackground(let x): return x.apply(instance) { i, v in i.drawsBackground = v }
		case .isEditable(let x): return x.apply(instance) { i, v in i.isEditable = v }
		case .isSelectable(let x): return x.apply(instance) { i, v in i.isSelectable = v }
		case .isFieldEditor(let x): return x.apply(instance) { i, v in i.isFieldEditor = v }
		case .isRichText(let x): return x.apply(instance) { i, v in i.isRichText = v }
		case .importsGraphics(let x): return x.apply(instance) { i, v in i.importsGraphics = v }
		case .usesFontPanel(let x): return x.apply(instance) { i, v in i.usesFontPanel = v }
		case .font(let x): return x.apply(instance) { i, v in i.font = v }
		case .alignment(let x): return x.apply(instance) { i, v in i.alignment = v }
		case .textColor(let x): return x.apply(instance) { i, v in i.textColor = v }
		case .baseWritingDirection(let x): return x.apply(instance) { i, v in i.baseWritingDirection = v }
		case .maxSize(let x): return x.apply(instance) { i, v in i.maxSize = v }
		case .minSize(let x): return x.apply(instance) { i, v in i.minSize = v }
		case .isVerticallyResizable(let x): return x.apply(instance) { i, v in i.isVerticallyResizable = v }
		case .isHorizontallyResizable(let x): return x.apply(instance) { i, v in i.isHorizontallyResizable = v }

		case .textContainerInset(let x): return x.apply(instance) { i, v in i.textContainerInset = v }
		case .allowsDocumentBackgroundColorChange(let x): return x.apply(instance) { i, v in i.allowsDocumentBackgroundColorChange = v }
		case .allowsUndo(let x): return x.apply(instance) { i, v in i.allowsUndo = v }
		case .defaultParagraphStyle(let x): return x.apply(instance) { i, v in i.defaultParagraphStyle = v }
		case .allowsImageEditing(let x): return x.apply(instance) { i, v in i.allowsImageEditing = v }
		case .isAutomaticQuoteSubstitutionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticQuoteSubstitutionEnabled = v }
		case .isAutomaticLinkDetectionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticLinkDetectionEnabled = v }
		case .displaysLinkToolTips(let x): return x.apply(instance) { i, v in i.displaysLinkToolTips = v }
		case .usesRuler(let x): return x.apply(instance) { i, v in i.usesRuler = v }
		case .usesInspectorBar(let x): return x.apply(instance) { i, v in i.usesInspectorBar = v }
		case .selectionGranularity(let x): return x.apply(instance) { i, v in i.selectionGranularity = v }
		case .insertionPointColor(let x): return x.apply(instance) { i, v in i.insertionPointColor = v }
		case .selectedTextAttributes(let x): return x.apply(instance) { i, v in i.selectedTextAttributes = v }
		case .markedTextAttributes(let x): return x.apply(instance) { i, v in i.markedTextAttributes = v }
		case .linkTextAttributes(let x): return x.apply(instance) { i, v in i.linkTextAttributes = v }
		case .typingAttributes(let x): return x.apply(instance) { i, v in i.typingAttributes = v }
		case .isContinuousSpellCheckingEnabled(let x): return x.apply(instance) { i, v in i.isContinuousSpellCheckingEnabled = v }
		case .isGrammarCheckingEnabled(let x): return x.apply(instance) { i, v in i.isGrammarCheckingEnabled = v }
		case .usesFindPanel(let x): return x.apply(instance) { i, v in i.usesFindPanel = v }
		case .enabledTextCheckingTypes(let x): return x.apply(instance) { i, v in i.enabledTextCheckingTypes = v }
		case .isAutomaticDashSubstitutionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticDashSubstitutionEnabled = v }
		case .isAutomaticDataDetectionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticDataDetectionEnabled = v }
		case .isAutomaticSpellingCorrectionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticSpellingCorrectionEnabled = v }
		case .isAutomaticTextReplacementEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticTextReplacementEnabled = v }
		case .layoutOrientation(let x): return x.apply(instance) { i, v in i.setLayoutOrientation(v) }
		case .usesFindBar(let x): return x.apply(instance) { i, v in i.usesFindBar = v }
		case .isIncrementalSearchingEnabled(let x): return x.apply(instance) { i, v in i.isIncrementalSearchingEnabled = v }
		case .allowsCharacterPickerTouchBarItem(let x): return x.apply(instance) { i, v in i.allowsCharacterPickerTouchBarItem = v }
		case .isAutomaticTextCompletionEnabled(let x): return x.apply(instance) { i, v in i.isAutomaticTextCompletionEnabled = v }
		case .usesRolloverButtonForSelection(let x): return x.apply(instance) { i, v in i.usesRolloverButtonForSelection = v }
			
		// 2. Signal bindings are performed on the object after construction.
		case .selectRange(let x): return x.apply(instance) { i, v in i.selectedRange = v }
		case .selectAll(let x): return x.apply(instance) { i, v in i.selectAll(nil) }
		case .copy(let x): return x.apply(instance) { i, v in i.copy(nil) }
		case .cut(let x): return x.apply(instance) { i, v in i.cut(nil) }
		case .paste(let x): return x.apply(instance) { i, v in i.paste(nil) }
		case .copyFont(let x): return x.apply(instance) { i, v in i.copyFont(nil) }
		case .pasteFont(let x): return x.apply(instance) { i, v in i.pasteFont(nil) }
		case .copyRuler(let x): return x.apply(instance) { i, v in i.copyRuler(nil) }
		case .pasteRuler(let x): return x.apply(instance) { i, v in i.pasteRuler(nil) }
		case .delete(let x): return x.apply(instance) { i, v in i.delete(nil) }
		case .changeFont(let x): return x.apply(instance) { i, v in i.changeFont(nil) }
		case .alignCenter(let x): return x.apply(instance) { i, v in i.alignCenter(nil) }
		case .alignLeft(let x): return x.apply(instance) { i, v in i.alignLeft(nil) }
		case .alignRight(let x): return x.apply(instance) { i, v in i.alignRight(nil) }
		case .superscript(let x): return x.apply(instance) { i, v in i.superscript(nil) }
		case .subscript(let x): return x.apply(instance) { i, v in i.superscript(nil) }
		case .unscript(let x): return x.apply(instance) { i, v in i.unscript(nil) }
		case .underline(let x): return x.apply(instance) { i, v in i.underline(nil) }
		case .checkSpelling(let x): return x.apply(instance) { i, v in i.checkSpelling(nil) }
		case .showGuessPanel(let x): return x.apply(instance) { i, v in i.showGuessPanel(nil) }
		case .sizeToFit(let x): return x.apply(instance) { i, v in i.sizeToFit() }
		case .scrollRangeToVisible(let x): return x.apply(instance) { i, v in i.scrollRangeToVisible(v) }

		case .showFindIndicator(let x): return x.apply(instance) { i, v in i.showFindIndicator(for: v) }
		case .changeDocumentBackgroundColor(let x): return x.apply(instance) { i, v in i.changeDocumentBackgroundColor(nil) }
		case .outline(let x): return x.apply(instance) { i, v in i.outline(nil) }
		case .alignJustified(let x): return x.apply(instance) { i, v in i.alignJustified(nil) }
		case .changeAttributes(let x): return x.apply(instance) { i, v in i.changeAttributes(nil) }
		case .useStandardKerning(let x): return x.apply(instance) { i, v in i.useStandardKerning(nil) }
		case .lowerBaseline(let x): return x.apply(instance) { i, v in i.lowerBaseline(nil) }
		case .raiseBaseline(let x): return x.apply(instance) { i, v in i.raiseBaseline(nil) }
		case .turnOffKerning(let x): return x.apply(instance) { i, v in i.turnOffKerning(nil) }
		case .loosenKerning(let x): return x.apply(instance) { i, v in i.loosenKerning(nil) }
		case .tightenKerning(let x): return x.apply(instance) { i, v in i.tightenKerning(nil) }
		case .useStandardLigatures(let x): return x.apply(instance) { i, v in i.useStandardLigatures(nil) }
		case .turnOffLigatures(let x): return x.apply(instance) { i, v in i.turnOffLigatures(nil) }
		case .useAllLigatures(let x): return x.apply(instance) { i, v in i.useAllLigatures(nil) }
		case .clicked(let x): return x.apply(instance) { i, v in i.clicked(onLink: v.0, at: v.1) }
		case .pasteAsPlainText(let x): return x.apply(instance) { i, v in i.pasteAsPlainText(nil) }
		case .pasteAsRichText(let x): return x.apply(instance) { i, v in i.pasteAsRichText(nil) }
		case .breakUndoCoalescing(let x): return x.apply(instance) { i, v in i.breakUndoCoalescing() }
		case .setSpellingState(let x): return x.apply(instance) { i, v in i.setSpellingState(v.0.rawValue, range: v.1) }
		case .orderFrontSharingServicePicker(let x): return x.apply(instance) { i, v in i.orderFrontSharingServicePicker(nil) }
		case .startSpeaking(let x): return x.apply(instance) { i, v in i.startSpeaking(nil) }
		case .stopSpeaking(let x): return x.apply(instance) { i, v in i.stopSpeaking(nil) }
		case .performFindPanelAction(let x): return x.apply(instance) { i, v in i.performFindPanelAction(nil) }
		case .orderFrontLinkPanel(let x): return x.apply(instance) { i, v in i.orderFrontLinkPanel(nil) }
		case .orderFrontListPanel(let x): return x.apply(instance) { i, v in i.orderFrontListPanel(nil) }
		case .orderFrontSpacingPanel(let x): return x.apply(instance) { i, v in i.orderFrontSpacingPanel(nil) }
		case .orderFrontTablePanel(let x): return x.apply(instance) { i, v in i.orderFrontTablePanel(nil) }
		case .orderFrontSubstitutionsPanel(let x): return x.apply(instance) { i, v in i.orderFrontSubstitutionsPanel(nil) }
		case .complete(let x): return x.apply(instance) { i, v in i.complete(nil) }
		case .checkTextInDocument(let x): return x.apply(instance) { i, v in i.checkTextInDocument(nil) }
		case .checkTextInSelection(let x): return x.apply(instance) { i, v in i.checkTextInSelection(nil) }
		case .checkText(let x): return x.apply(instance) { i, v in i.checkText(in: v.0, types: v.1, options: v.2) }
		case .updateQuickLookPreviewPanel(let x): return x.apply(instance) { i, v in i.updateQuickLookPreviewPanel() }
		case .toggleQuickLookPreviewPanel(let x): return x.apply(instance) { i, v in i.toggleQuickLookPreviewPanel(nil) }
		case .updateCandidates(let x): return x.apply(instance) { i, v in i.updateCandidates() }
		case .updateTextTouchBarItems(let x): return x.apply(instance) { i, v in i.updateTextTouchBarItems() }
		case .updateTouchBarItemIdentifiers(let x): return x.apply(instance) { i, v in i.updateTouchBarItemIdentifiers() }
			
		// 3. Action bindings are triggered by the object after construction.
		case .didBeginEditing(let x): return Signal.notifications(name: NSTextView.didBeginEditingNotification, object: instance).compactMap { notification -> NSTextView? in notification.object as? NSTextView }.cancellableBind(to: x)
		case .didChange(let x): return Signal.notifications(name: NSTextView.didChangeSelectionNotification, object: instance).compactMap { notification -> NSTextView? in notification.object as? NSTextView }.cancellableBind(to: x)
		case .didEndEditing(let x): return Signal.notifications(name: NSTextView.didEndEditingNotification, object: instance).compactMap { notification -> (NSTextView, NSTextMovement?)? in (notification.object as? NSTextView).map { ($0, notification.userInfo?[NSText.movementUserInfoKey] as? NSTextMovement) } }.cancellableBind(to: x)
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldBeginEditing: return nil
		case .shouldEndEditing: return nil
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension TextView.Preparer {
	open class Storage: View.Preparer.Storage, NSTextViewDelegate {}
	
	open class Delegate: DynamicDelegate, NSTextViewDelegate {
		open func textShouldBeginEditing(_ textObject: NSText) -> Bool {
			return singleHandler(textObject)
		}
		open func textShouldEndEditing(_ textObject: NSText) -> Bool {
			return singleHandler(textObject)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: TextViewBinding {
	public typealias TextViewName<V> = BindingName<V, TextView.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> TextView.Binding) -> TextViewName<V> {
		return TextViewName<V>(source: source, downcast: Binding.textViewBinding)
	}
}
public extension BindingName where Binding: TextViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: TextViewName<$2> { return .name(TextView.Binding.$1) }

	// 0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var string: TextViewName<Dynamic<String>> { return .name(TextView.Binding.string) }
	static var backgroundColor: TextViewName<Dynamic<NSColor>> { return .name(TextView.Binding.backgroundColor) }
	static var drawsBackground: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.drawsBackground) }
	static var isEditable: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isEditable) }
	static var isSelectable: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isSelectable) }
	static var isFieldEditor: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isFieldEditor) }
	static var isRichText: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isRichText) }
	static var importsGraphics: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.importsGraphics) }
	static var usesFontPanel: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.usesFontPanel) }
	static var font: TextViewName<Dynamic<NSFont>> { return .name(TextView.Binding.font) }
	static var alignment: TextViewName<Dynamic<NSTextAlignment>> { return .name(TextView.Binding.alignment) }
	static var textColor: TextViewName<Dynamic<NSColor>> { return .name(TextView.Binding.textColor) }
	static var baseWritingDirection: TextViewName<Dynamic<NSWritingDirection>> { return .name(TextView.Binding.baseWritingDirection) }
	static var maxSize: TextViewName<Dynamic<NSSize>> { return .name(TextView.Binding.maxSize) }
	static var minSize: TextViewName<Dynamic<NSSize>> { return .name(TextView.Binding.minSize) }
	static var isVerticallyResizable: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isVerticallyResizable) }
	static var isHorizontallyResizable: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isHorizontallyResizable) }

	static var textContainerInset: TextViewName<Dynamic<NSSize>> { return .name(TextView.Binding.textContainerInset) }
	static var allowsDocumentBackgroundColorChange: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.allowsDocumentBackgroundColorChange) }
	static var allowsUndo: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.allowsUndo) }
	static var defaultParagraphStyle: TextViewName<Dynamic<NSParagraphStyle>> { return .name(TextView.Binding.defaultParagraphStyle) }
	static var allowsImageEditing: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.allowsImageEditing) }
	static var isAutomaticQuoteSubstitutionEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isAutomaticQuoteSubstitutionEnabled) }
	static var isAutomaticLinkDetectionEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isAutomaticLinkDetectionEnabled) }
	static var displaysLinkToolTips: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.displaysLinkToolTips) }
	static var usesRuler: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.usesRuler) }
	static var usesInspectorBar: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.usesInspectorBar) }
	static var selectionGranularity: TextViewName<Dynamic<NSSelectionGranularity>> { return .name(TextView.Binding.selectionGranularity) }
	static var insertionPointColor: TextViewName<Dynamic<NSColor>> { return .name(TextView.Binding.insertionPointColor) }
	static var selectedTextAttributes: TextViewName<Dynamic<[NSAttributedString.Key : Any]>> { return .name(TextView.Binding.selectedTextAttributes) }
	static var markedTextAttributes: TextViewName<Dynamic<[NSAttributedString.Key : Any]>> { return .name(TextView.Binding.markedTextAttributes) }
	static var linkTextAttributes: TextViewName<Dynamic<[NSAttributedString.Key : Any]>> { return .name(TextView.Binding.linkTextAttributes) }
	static var typingAttributes: TextViewName<Dynamic<[NSAttributedString.Key : Any]>> { return .name(TextView.Binding.typingAttributes) }
	static var isContinuousSpellCheckingEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isContinuousSpellCheckingEnabled) }
	static var isGrammarCheckingEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isGrammarCheckingEnabled) }
	static var usesFindPanel: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.usesFindPanel) }
	static var enabledTextCheckingTypes: TextViewName<Dynamic<NSTextCheckingTypes>> { return .name(TextView.Binding.enabledTextCheckingTypes) }
	static var isAutomaticDashSubstitutionEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isAutomaticDashSubstitutionEnabled) }
	static var isAutomaticDataDetectionEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isAutomaticDataDetectionEnabled) }
	static var isAutomaticSpellingCorrectionEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isAutomaticSpellingCorrectionEnabled) }
	static var isAutomaticTextReplacementEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isAutomaticTextReplacementEnabled) }
	static var layoutOrientation: TextViewName<Dynamic<NSLayoutManager.TextLayoutOrientation>> { return .name(TextView.Binding.layoutOrientation) }
	static var usesFindBar: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.usesFindBar) }
	static var isIncrementalSearchingEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isIncrementalSearchingEnabled) }
	static var allowsCharacterPickerTouchBarItem: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.allowsCharacterPickerTouchBarItem) }
	static var isAutomaticTextCompletionEnabled: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.isAutomaticTextCompletionEnabled) }
	static var usesRolloverButtonForSelection: TextViewName<Dynamic<Bool>> { return .name(TextView.Binding.usesRolloverButtonForSelection) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var selectRange: TextViewName<Signal<NSRange>> { return .name(TextView.Binding.selectRange) }
	static var selectAll: TextViewName<Signal<Void>> { return .name(TextView.Binding.selectAll) }
	static var copy: TextViewName<Signal<Void>> { return .name(TextView.Binding.copy) }
	static var cut: TextViewName<Signal<Void>> { return .name(TextView.Binding.cut) }
	static var paste: TextViewName<Signal<Void>> { return .name(TextView.Binding.paste) }
	static var copyFont: TextViewName<Signal<Void>> { return .name(TextView.Binding.copyFont) }
	static var pasteFont: TextViewName<Signal<Void>> { return .name(TextView.Binding.pasteFont) }
	static var copyRuler: TextViewName<Signal<Void>> { return .name(TextView.Binding.copyRuler) }
	static var pasteRuler: TextViewName<Signal<Void>> { return .name(TextView.Binding.pasteRuler) }
	static var delete: TextViewName<Signal<Void>> { return .name(TextView.Binding.delete) }
	static var changeFont: TextViewName<Signal<Void>> { return .name(TextView.Binding.changeFont) }
	static var alignCenter: TextViewName<Signal<Void>> { return .name(TextView.Binding.alignCenter) }
	static var alignLeft: TextViewName<Signal<Void>> { return .name(TextView.Binding.alignLeft) }
	static var alignRight: TextViewName<Signal<Void>> { return .name(TextView.Binding.alignRight) }
	static var superscript: TextViewName<Signal<Void>> { return .name(TextView.Binding.superscript) }
	static var `subscript`: TextViewName<Signal<Void>> { return .name(TextView.Binding.`subscript`) }
	static var unscript: TextViewName<Signal<Void>> { return .name(TextView.Binding.unscript) }
	static var underline: TextViewName<Signal<Void>> { return .name(TextView.Binding.underline) }
	static var checkSpelling: TextViewName<Signal<Void>> { return .name(TextView.Binding.checkSpelling) }
	static var showGuessPanel: TextViewName<Signal<Void>> { return .name(TextView.Binding.showGuessPanel) }
	static var sizeToFit: TextViewName<Signal<Void>> { return .name(TextView.Binding.sizeToFit) }
	static var scrollRangeToVisible: TextViewName<Signal<NSRange>> { return .name(TextView.Binding.scrollRangeToVisible) }

	static var showFindIndicator: TextViewName<Signal<NSRange>> { return .name(TextView.Binding.showFindIndicator) }
	static var changeDocumentBackgroundColor: TextViewName<Signal<Void>> { return .name(TextView.Binding.changeDocumentBackgroundColor) }
	static var outline: TextViewName<Signal<Void>> { return .name(TextView.Binding.outline) }
	static var alignJustified: TextViewName<Signal<Void>> { return .name(TextView.Binding.alignJustified) }
	static var changeAttributes: TextViewName<Signal<Void>> { return .name(TextView.Binding.changeAttributes) }
	static var useStandardKerning: TextViewName<Signal<Void>> { return .name(TextView.Binding.useStandardKerning) }
	static var lowerBaseline: TextViewName<Signal<Void>> { return .name(TextView.Binding.lowerBaseline) }
	static var raiseBaseline: TextViewName<Signal<Void>> { return .name(TextView.Binding.raiseBaseline) }
	static var turnOffKerning: TextViewName<Signal<Void>> { return .name(TextView.Binding.turnOffKerning) }
	static var loosenKerning: TextViewName<Signal<Void>> { return .name(TextView.Binding.loosenKerning) }
	static var tightenKerning: TextViewName<Signal<Void>> { return .name(TextView.Binding.tightenKerning) }
	static var useStandardLigatures: TextViewName<Signal<Void>> { return .name(TextView.Binding.useStandardLigatures) }
	static var turnOffLigatures: TextViewName<Signal<Void>> { return .name(TextView.Binding.turnOffLigatures) }
	static var useAllLigatures: TextViewName<Signal<Void>> { return .name(TextView.Binding.useAllLigatures) }
	static var clicked: TextViewName<Signal<(Any, Int)>> { return .name(TextView.Binding.clicked) }
	static var pasteAsPlainText: TextViewName<Signal<Void>> { return .name(TextView.Binding.pasteAsPlainText) }
	static var pasteAsRichText: TextViewName<Signal<Void>> { return .name(TextView.Binding.pasteAsRichText) }
	static var breakUndoCoalescing: TextViewName<Signal<Void>> { return .name(TextView.Binding.breakUndoCoalescing) }
	static var setSpellingState: TextViewName<Signal<(NSAttributedString.SpellingState, NSRange)>> { return .name(TextView.Binding.setSpellingState) }
	static var orderFrontSharingServicePicker: TextViewName<Signal<Void>> { return .name(TextView.Binding.orderFrontSharingServicePicker) }
	static var startSpeaking: TextViewName<Signal<Void>> { return .name(TextView.Binding.startSpeaking) }
	static var stopSpeaking: TextViewName<Signal<Void>> { return .name(TextView.Binding.stopSpeaking) }
	static var performFindPanelAction: TextViewName<Signal<Void>> { return .name(TextView.Binding.performFindPanelAction) }
	static var orderFrontLinkPanel: TextViewName<Signal<Void>> { return .name(TextView.Binding.orderFrontLinkPanel) }
	static var orderFrontListPanel: TextViewName<Signal<Void>> { return .name(TextView.Binding.orderFrontListPanel) }
	static var orderFrontSpacingPanel: TextViewName<Signal<Void>> { return .name(TextView.Binding.orderFrontSpacingPanel) }
	static var orderFrontTablePanel: TextViewName<Signal<Void>> { return .name(TextView.Binding.orderFrontTablePanel) }
	static var orderFrontSubstitutionsPanel: TextViewName<Signal<Void>> { return .name(TextView.Binding.orderFrontSubstitutionsPanel) }
	static var complete: TextViewName<Signal<Void>> { return .name(TextView.Binding.complete) }
	static var checkTextInDocument: TextViewName<Signal<Void>> { return .name(TextView.Binding.checkTextInDocument) }
	static var checkTextInSelection: TextViewName<Signal<Void>> { return .name(TextView.Binding.checkTextInSelection) }
	static var checkText: TextViewName<Signal<(NSRange, NSTextCheckingTypes, [NSSpellChecker.OptionKey: Any])>> { return .name(TextView.Binding.checkText) }
	static var updateQuickLookPreviewPanel: TextViewName<Signal<Void>> { return .name(TextView.Binding.updateQuickLookPreviewPanel) }
	static var toggleQuickLookPreviewPanel: TextViewName<Signal<Void>> { return .name(TextView.Binding.toggleQuickLookPreviewPanel) }
	static var updateCandidates: TextViewName<Signal<Void>> { return .name(TextView.Binding.updateCandidates) }
	static var updateTextTouchBarItems: TextViewName<Signal<Void>> { return .name(TextView.Binding.updateTextTouchBarItems) }
	static var updateTouchBarItemIdentifiers: TextViewName<Signal<Void>> { return .name(TextView.Binding.updateTouchBarItemIdentifiers) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var didBeginEditing: TextViewName<SignalInput<NSTextView>> { return .name(TextView.Binding.didBeginEditing) }
	static var didChange: TextViewName<SignalInput<NSTextView>> { return .name(TextView.Binding.didChange) }
	static var didEndEditing: TextViewName<SignalInput<(NSTextView, NSTextMovement?)>> { return .name(TextView.Binding.didEndEditing) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldBeginEditing: TextViewName<(NSTextView) -> Bool> { return .name(TextView.Binding.shouldBeginEditing) }
	static var shouldEndEditing: TextViewName<(NSTextView) -> Bool> { return .name(TextView.Binding.shouldEndEditing) }
	
	// Composite binding names
	static func font(_ void: Void = ()) -> BindingName<Dynamic<NSFont>, BinderBase.Binding, Binding> {
		return Binding.compositeName(
			value: { (x: Dynamic<NSFont>) -> (Any) -> Lifetime? in
				{ (instance: Any) -> Lifetime? in
					return x.apply(instance as! NSTextView) { (i: NSTextView, v: NSFont) -> Void in
						if (i.textStorage?.length ?? 0) == 0 {
							var attributes = i.typingAttributes
							attributes[NSAttributedString.Key.font] = v
							i.typingAttributes = attributes
						} else {
							i.textStorage?.addAttribute(NSAttributedString.Key.font, value: v, range: NSRange(location: 0, length: i.textStorage?.length ?? 0))
						}
					}
				}
			},
			binding: BinderBase.Binding.adHocFinalize,
			downcast: Binding.binderBaseBinding
		)
	}
	
	static func stringChanged(_ void: Void = ()) -> TextViewName<SignalInput<String>> {
		return Binding.compositeName(
			value: { (input: SignalInput<String>) in Input<NSTextView>().compactMap { $0.string }.bind(to: input) },
			binding: TextView.Binding.didChange,
			downcast: Binding.textViewBinding
		)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol TextViewConvertible: ViewConvertible {
	func nsTextView() -> TextView.Instance
}
extension TextViewConvertible {
	public func nsView() -> View.Instance { return nsTextView() }
}
extension NSTextView: TextViewConvertible, HasDelegate {
	public func nsTextView() -> TextView.Instance { return self }
}
public extension TextView {
	func nsTextView() -> TextView.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol TextViewBinding: ViewBinding {
	static func textViewBinding(_ binding: TextView.Binding) -> Self
	func asTextViewBinding() -> TextView.Binding?
}
public extension TextViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return textViewBinding(.inheritedBinding(binding))
	}
}
public extension TextViewBinding where Preparer.Inherited.Binding: TextViewBinding {
	func asTextViewBinding() -> TextView.Binding? {
		return asInheritedBinding()?.asTextViewBinding()
	}
}
public extension TextView.Binding {
	typealias Preparer = TextView.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asTextViewBinding() -> TextView.Binding? { return self }
	static func textViewBinding(_ binding: TextView.Binding) -> TextView.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class ToolbarItem: Binder, ToolbarItemConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	public convenience init(type: Instance.Type = Instance.self, itemIdentifier: NSToolbarItem.Identifier, _ bindings: Binding...) {
		self.init(type: type, parameters: itemIdentifier, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension ToolbarItem {
	enum Binding: ToolbarItemBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case image(Dynamic<NSImage?>)
		case isEnabled(Dynamic<Bool>)
		case label(Dynamic<String>)
		case maxSize(Dynamic<NSSize>)
		case menuFormRepresentation(Dynamic<MenuItemConvertible>)
		case minSize(Dynamic<NSSize>)
		case paletteLabel(Dynamic<String>)
		case tag(Dynamic<Int>)
		case toolTip(Dynamic<String?>)
		case view(Dynamic<ViewConvertible?>)
		case visibilityPriority(Dynamic<NSToolbarItem.VisibilityPriority>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case action(TargetAction)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case validate((NSToolbarItem) -> Bool)
	}
}

// MARK: - Binder Part 3: Preparer
public extension ToolbarItem {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = ToolbarItem.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = NSToolbarItem
		public typealias Parameters = NSToolbarItem.Identifier
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var validator: ((NSToolbarItem) -> Bool)?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension ToolbarItem.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .validate(let x): validator = x
		default: break
		}
	}

	func constructInstance(type: Instance.Type, parameters: NSToolbarItem.Identifier) -> NSToolbarItem {
		return type.init(itemIdentifier: parameters)
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static styles are applied at construction and are subsequently immutable.
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .image(let x): return x.apply(instance) { i, v in i.image = v }
		case .isEnabled(let x): return x.apply(instance) { i, v in i.isEnabled = v }
		case .label(let x): return x.apply(instance) { i, v in i.label = v }
		case .maxSize(let x): return x.apply(instance) { i, v in i.maxSize = v }
		case .menuFormRepresentation(let x): return x.apply(instance) { i, v in i.menuFormRepresentation = v.nsMenuItem() }
		case .minSize(let x): return x.apply(instance) { i, v in i.minSize = v }
		case .paletteLabel(let x): return x.apply(instance) { i, v in i.paletteLabel = v }
		case .tag(let x): return x.apply(instance) { i, v in i.tag = v }
		case .toolTip(let x): return x.apply(instance) { i, v in i.toolTip = v }
		case .view(let x): return x.apply(instance) { i, v in i.view = v?.nsView() }
		case .visibilityPriority(let x): return x.apply(instance) { i, v in i.visibilityPriority = v }
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case .action(let x): return x.apply(to: instance, constructTarget: ToolbarItemTarget.init)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .validate: return nil
		}
	}
	
	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		// Need to apply the validator *after* the action exists
		if let v = validator, let target = instance.target as? ToolbarItemTarget {
			target.validator = v
		}
		
		return inheritedFinalizedInstance(instance, storage: storage)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension ToolbarItem.Preparer {
	public typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ToolbarItemBinding {
	public typealias ToolbarItemName<V> = BindingName<V, ToolbarItem.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> ToolbarItem.Binding) -> ToolbarItemName<V> {
		return ToolbarItemName<V>(source: source, downcast: Binding.toolbarItemBinding)
	}
}
public extension BindingName where Binding: ToolbarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ToolbarItemName<$2> { return .name(ToolbarItem.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var image: ToolbarItemName<Dynamic<NSImage?>> { return .name(ToolbarItem.Binding.image) }
	static var isEnabled: ToolbarItemName<Dynamic<Bool>> { return .name(ToolbarItem.Binding.isEnabled) }
	static var label: ToolbarItemName<Dynamic<String>> { return .name(ToolbarItem.Binding.label) }
	static var maxSize: ToolbarItemName<Dynamic<NSSize>> { return .name(ToolbarItem.Binding.maxSize) }
	static var menuFormRepresentation: ToolbarItemName<Dynamic<MenuItemConvertible>> { return .name(ToolbarItem.Binding.menuFormRepresentation) }
	static var minSize: ToolbarItemName<Dynamic<NSSize>> { return .name(ToolbarItem.Binding.minSize) }
	static var paletteLabel: ToolbarItemName<Dynamic<String>> { return .name(ToolbarItem.Binding.paletteLabel) }
	static var tag: ToolbarItemName<Dynamic<Int>> { return .name(ToolbarItem.Binding.tag) }
	static var toolTip: ToolbarItemName<Dynamic<String?>> { return .name(ToolbarItem.Binding.toolTip) }
	static var view: ToolbarItemName<Dynamic<ViewConvertible?>> { return .name(ToolbarItem.Binding.view) }
	static var visibilityPriority: ToolbarItemName<Dynamic<NSToolbarItem.VisibilityPriority>> { return .name(ToolbarItem.Binding.visibilityPriority) }
	
	// 2. Signal bindings are performed on the object after construction.
	
	// 3. Action bindings are triggered by the object after construction.
	static var action: ToolbarItemName<TargetAction> { return .name(ToolbarItem.Binding.action) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var validate: ToolbarItemName<(NSToolbarItem) -> Bool> { return .name(ToolbarItem.Binding.validate) }

	// Composite binding names
	static func action<Value>(_ keyPath: KeyPath<Binding.Preparer.Instance, Value>) -> ToolbarItemName<SignalInput<Value>> {
		return Binding.keyPathActionName(keyPath, ToolbarItem.Binding.action, Binding.toolbarItemBinding)
	}
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ToolbarItemConvertible {
	func nsToolbarItem() -> ToolbarItem.Instance
}
extension NSToolbarItem: ToolbarItemConvertible, TargetActionSender {
	public func nsToolbarItem() -> ToolbarItem.Instance { return self }
}
public extension ToolbarItem {
	func nsToolbarItem() -> ToolbarItem.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ToolbarItemBinding: BinderBaseBinding {
	static func toolbarItemBinding(_ binding: ToolbarItem.Binding) -> Self
	func asToolbarItemBinding() -> ToolbarItem.Binding?
}
public extension ToolbarItemBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return toolbarItemBinding(.inheritedBinding(binding))
	}
}
public extension ToolbarItemBinding where Preparer.Inherited.Binding: ToolbarItemBinding {
	func asToolbarItemBinding() -> ToolbarItem.Binding? {
		return asInheritedBinding()?.asToolbarItemBinding()
	}
}
public extension ToolbarItem.Binding {
	typealias Preparer = ToolbarItem.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asToolbarItemBinding() -> ToolbarItem.Binding? { return self }
	static func toolbarItemBinding(_ binding: ToolbarItem.Binding) -> ToolbarItem.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
open class ToolbarItemTarget: SignalActionTarget {
	open var validator: ((NSToolbarItem) -> Bool)?
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class Toolbar: Binder, ToolbarConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}

	public convenience init(type: Instance.Type = Instance.self, identifier: NSToolbar.Identifier, _ bindings: Binding...) {
		self.init(type: type, parameters: identifier, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Toolbar {
	enum Binding: ToolbarBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static styles are applied at construction and are subsequently immutable.
		case itemDescriptions(Constant<[ToolbarItemDescription]>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case allowsExtensionItems(Dynamic<Bool>)
		case allowsUserCustomization(Dynamic<Bool>)
		case autosavesConfiguration(Dynamic<Bool>)
		case displayMode(Dynamic<NSToolbar.DisplayMode>)
		case isVisible(Dynamic<Bool>)
		case selectedItemIdentifier(Dynamic<NSToolbarItem.Identifier>)
		case showsBaselineSeparator(Dynamic<Bool>)
		case sizeMode(Dynamic<NSToolbar.SizeMode>)

		// 2. Signal bindings are performed on the object after construction.
		case runCustomizationPalette(Signal<Void>)

		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case didRemoveItem(SignalInput<Void>)
		case willAddItem(SignalInput<Void>)
	}
}

// MARK: - Binder Part 3: Preparer
public extension Toolbar {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = Toolbar.Binding
		public typealias Delegate = DynamicDelegate
		public typealias Inherited = BinderBase
		public typealias Instance = NSToolbar
		public typealias Parameters = NSToolbar.Identifier
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var itemDescriptions: [ToolbarItemDescription]?
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Toolbar.Preparer {
	var delegateIsRequired: Bool { return true }
	
	func constructInstance(type: Instance.Type, parameters: Parameters) -> Instance {
		return type.init(identifier: parameters)
	}
	
	mutating func prepareBinding(_ binding: Toolbar.Binding) {
		switch binding {
		case .inheritedBinding(let s): inherited.prepareBinding(s)
		
		case .itemDescriptions(let x): itemDescriptions = x.value
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		prepareDelegate(instance: instance, storage: storage)
		if let id = itemDescriptions {
			storage.itemDescriptions = id
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .itemDescriptions:return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .displayMode(let x): return x.apply(instance) { i, v in i.displayMode = v }
		case .showsBaselineSeparator(let x): return x.apply(instance) { i, v in i.showsBaselineSeparator = v }
		case .allowsUserCustomization(let x): return x.apply(instance) { i, v in i.allowsUserCustomization = v }
		case .allowsExtensionItems(let x): return x.apply(instance) { i, v in i.allowsExtensionItems = v }
		case .sizeMode(let x): return x.apply(instance) { i, v in i.sizeMode = v }
		case .selectedItemIdentifier(let x): return x.apply(instance) { i, v in i.selectedItemIdentifier = v }
		case .isVisible(let x): return x.apply(instance) { i, v in i.isVisible = v }
		case .autosavesConfiguration(let x): return x.apply(instance) { i, v in i.autosavesConfiguration = v }
		
		// 2. Signal bindings are performed on the object after construction.
		case .runCustomizationPalette(let x): return x.apply(instance) { i, v in i.runCustomizationPalette(nil) }
		
		// 3. Action bindings are triggered by the object after construction.
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .didRemoveItem(let x): return Signal.notifications(name: NSToolbar.didRemoveItemNotification, object: instance).map { _ in () }.cancellableBind(to: x)
		case .willAddItem(let x): return Signal.notifications(name: NSToolbar.willAddItemNotification, object: instance).map { _ in () }.cancellableBind(to: x)
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Toolbar.Preparer {
	open class Storage: AssociatedBinderStorage, NSToolbarDelegate {
		open override var isInUse: Bool { return true }
		
		open var itemDescriptions: [ToolbarItemDescription] = []
		open func toolbar(_ toolbar: NSToolbar, itemForItemIdentifier itemIdentifier: NSToolbarItem.Identifier, willBeInsertedIntoToolbar flag: Bool) -> NSToolbarItem? {
			return itemDescriptions.first { $0.identifier == itemIdentifier }?.constructor(itemIdentifier, flag)?.nsToolbarItem()
		}
		
		open var allowedItemIdentifiers: [NSToolbarItem.Identifier] = []
		open func toolbarAllowedItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {
			return itemDescriptions.filter { $0.isAllowed }.map { $0.identifier }
		}
		
		open var defaultItemIdentifiers: [NSToolbarItem.Identifier] = []
		open func toolbarDefaultItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {
			return itemDescriptions.filter { $0.isDefault }.map { $0.identifier }
		}
		
		open var selectableItemIdentifiers: [NSToolbarItem.Identifier] = []
		open func toolbarSelectableItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {
			return itemDescriptions.filter { $0.isSelectable }.map { $0.identifier }
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ToolbarBinding {
	public typealias ToolbarName<V> = BindingName<V, Toolbar.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Toolbar.Binding) -> ToolbarName<V> {
		return ToolbarName<V>(source: source, downcast: Binding.toolbarBinding)
	}
}
public extension BindingName where Binding: ToolbarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ToolbarName<$2> { return .name(Toolbar.Binding.$1) }

	//	0. Static styles are applied at construction and are subsequently immutable.
	static var itemDescriptions: ToolbarName<Constant<[ToolbarItemDescription]>> { return .name(Toolbar.Binding.itemDescriptions) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var allowsExtensionItems: ToolbarName<Dynamic<Bool>> { return .name(Toolbar.Binding.allowsExtensionItems) }
	static var allowsUserCustomization: ToolbarName<Dynamic<Bool>> { return .name(Toolbar.Binding.allowsUserCustomization) }
	static var autosavesConfiguration: ToolbarName<Dynamic<Bool>> { return .name(Toolbar.Binding.autosavesConfiguration) }
	static var displayMode: ToolbarName<Dynamic<NSToolbar.DisplayMode>> { return .name(Toolbar.Binding.displayMode) }
	static var isVisible: ToolbarName<Dynamic<Bool>> { return .name(Toolbar.Binding.isVisible) }
	static var selectedItemIdentifier: ToolbarName<Dynamic<NSToolbarItem.Identifier>> { return .name(Toolbar.Binding.selectedItemIdentifier) }
	static var showsBaselineSeparator: ToolbarName<Dynamic<Bool>> { return .name(Toolbar.Binding.showsBaselineSeparator) }
	static var sizeMode: ToolbarName<Dynamic<NSToolbar.SizeMode>> { return .name(Toolbar.Binding.sizeMode) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var runCustomizationPalette: ToolbarName<Signal<Void>> { return .name(Toolbar.Binding.runCustomizationPalette) }
	
	// 3. Action bindings are triggered by the object after construction.
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var didRemoveItem: ToolbarName<SignalInput<Void>> { return .name(Toolbar.Binding.didRemoveItem) }
	static var willAddItem: ToolbarName<SignalInput<Void>> { return .name(Toolbar.Binding.willAddItem) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol ToolbarConvertible {
	func nsToolbar() -> Toolbar.Instance
}
extension NSToolbar: ToolbarConvertible, DefaultConstructable, HasDelegate {
	public func nsToolbar() -> Toolbar.Instance { return self }
}
public extension Toolbar {
	func nsToolbar() -> Toolbar.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ToolbarBinding: BinderBaseBinding {
	static func toolbarBinding(_ binding: Toolbar.Binding) -> Self
	func asToolbarBinding() -> Toolbar.Binding?
}
extension ToolbarBinding {
	public static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return toolbarBinding(.inheritedBinding(binding))
	}
}
public extension ToolbarBinding where Preparer.Inherited.Binding: ToolbarBinding {
	func asToolbarBinding() -> Toolbar.Binding? {
		return asInheritedBinding()?.asToolbarBinding()
	}
}
public extension Toolbar.Binding {
	typealias Preparer = Toolbar.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asToolbarBinding() -> Toolbar.Binding? { return self }
	static func toolbarBinding(_ binding: Toolbar.Binding) -> Toolbar.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public struct ToolbarItemDescription {
	public let identifier: NSToolbarItem.Identifier
	public let isDefault: Bool
	public let isAllowed: Bool
	public let isSelectable: Bool
	public let constructor: (_ itemIdentifier: NSToolbarItem.Identifier, _ willBeInserted: Bool) -> ToolbarItemConvertible?
	
	public init(identifier: NSToolbarItem.Identifier, isDefault: Bool = true, isAllowed: Bool = true, isSelectable: Bool = false, constructor: @escaping (_ itemIdentifier: NSToolbarItem.Identifier, _ willBeInserted: Bool) -> ToolbarItemConvertible?) {
		self.identifier = identifier
		self.isDefault = isDefault
		self.isAllowed = isAllowed
		self.isSelectable = isSelectable
		self.constructor = constructor
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class View: Binder, ViewConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension View {
	enum Binding: ViewBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static styles are applied at construction and are subsequently immutable.
		case layer(Constant<Layer>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case appearance(Dynamic<NSAppearance?>)
		case canDrawSubviewsIntoLayer(Dynamic<Bool>)
		case focusRingType(Dynamic<NSFocusRingType>)
		case frameRotation(Dynamic<CGFloat>)
		case gestureRecognizers(Dynamic<[GestureRecognizerConvertible]>)
		case horizontalContentCompressionResistancePriority(Dynamic<NSLayoutConstraint.Priority>)
		case horizontalContentHuggingPriority(Dynamic<NSLayoutConstraint.Priority>)
		case identifier(Dynamic<NSUserInterfaceItemIdentifier?>)
		case isHidden(Dynamic<Bool>)
		case layerContentsRedrawPolicy(Dynamic<NSView.LayerContentsRedrawPolicy>)
		case layout(Dynamic<Layout>)
		case pressureConfiguration(Dynamic<NSPressureConfiguration>)
		case registeredDragTypes(Dynamic<[NSPasteboard.PasteboardType]>)
		case tooltip(Dynamic<String>)
		case verticalContentCompressionResistancePriority(Dynamic<NSLayoutConstraint.Priority>)
		case verticalContentHuggingPriority(Dynamic<NSLayoutConstraint.Priority>)
		
		// 2. Signal bindings are performed on the object after construction.
		case becomeFirstResponder(Signal<Void>)
		case needsDisplay(Signal<Bool>)
		case printView(Signal<Void>)
		case scrollRectToVisible(Signal<NSRect>)
		case setNeedsDisplayInRect(Signal<NSRect>)
		
		// 3. Action bindings are triggered by the object after construction.
		case boundsDidChange(SignalInput<NSRect>)
		case frameDidChange(SignalInput<NSRect>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
}

// MARK: - Binder Part 3: Preparer
public extension View {
	struct Preparer: BinderEmbedderConstructor {
		public typealias Binding = View.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = NSView
		
		public var inherited = Inherited()
		public init() {}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}
		
		var backingLayer: Layer? = nil
		var postsFrameChangedNotifications: Bool = false
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension View.Preparer {
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .layer(let x): backingLayer = x.value
		case .boundsDidChange: postsFrameChangedNotifications = true 
		case .frameDidChange: postsFrameChangedNotifications = true
		default: break
		}
	}
	
	func prepareInstance(_ instance: Instance, storage: Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		if let layer = backingLayer {
			instance.wantsLayer = true
			layer.apply(to: instance.layer!)
		}
		if postsFrameChangedNotifications {
			instance.postsFrameChangedNotifications = true
		}
	}
	
	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let x): return inherited.applyBinding(x, instance: instance, storage: storage)
			
		//	0. Static styles are applied at construction and are subsequently immutable.
		case .layer: return nil
			
		// 1. Value bindings may be applied at construction and may subsequently change.
		case .appearance(let x): return x.apply(instance) { i, v in i.appearance = v }
		case .canDrawSubviewsIntoLayer(let x): return x.apply(instance) { i, v in i.canDrawSubviewsIntoLayer = v }
		case .focusRingType(let x): return x.apply(instance) { i, v in i.focusRingType = v }
		case .frameRotation(let x): return x.apply(instance) { i, v in i.frameRotation = v }
		case .gestureRecognizers(let x): return x.apply(instance) { i, v in i.gestureRecognizers = v.map { $0.nsGestureRecognizer() } }
		case .horizontalContentCompressionResistancePriority(let x): return x.apply(instance) { i, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Orientation.horizontal) }
		case .horizontalContentHuggingPriority(let x): return x.apply(instance) { i, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Orientation.horizontal) }
		case .identifier(let x): return x.apply(instance) { i, v in i.identifier = v }
		case .isHidden(let x): return x.apply(instance) { i, v in i.isHidden = v }
		case .layerContentsRedrawPolicy(let x): return x.apply(instance) { i, v in i.layerContentsRedrawPolicy = v }
		case .layout(let x): return x.apply(instance) { i, v in i.applyLayout(v) }
		case .pressureConfiguration(let x): return x.apply(instance) { i, v in i.pressureConfiguration = v }
		case .registeredDragTypes(let x):
			return x.apply(instance) { i, v in
				if v.isEmpty {
					i.unregisterDraggedTypes()
				} else {
					i.registerForDraggedTypes(v)
				}
			}
		case .tooltip(let x): return x.apply(instance) { i, v in i.toolTip = v }
		case .verticalContentCompressionResistancePriority(let x): return x.apply(instance) { i, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Orientation.vertical) }
		case .verticalContentHuggingPriority(let x): return x.apply(instance) { i, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Orientation.vertical) }
			
		// 2. Signal bindings are performed on the object after construction.
		case .becomeFirstResponder(let x): return x.apply(instance) { i, _ in i.window?.makeFirstResponder(i) }
		case .needsDisplay(let x): return x.apply(instance) { i, v in i.needsDisplay = v }
		case .printView(let x): return x.apply(instance) { i, v in i.printView(nil) }
		case .setNeedsDisplayInRect(let x): return x.apply(instance) { i, v in i.setNeedsDisplay(v) }
		case .scrollRectToVisible(let x): return x.apply(instance) { i, v in i.scrollToVisible(v) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .frameDidChange(let x):
			instance.postsFrameChangedNotifications = true
			return Signal.notifications(name: NSView.frameDidChangeNotification, object: instance).compactMap { notification -> NSRect? in (notification.object as? NSView)?.frame }.cancellableBind(to: x)
		case .boundsDidChange(let x):
			instance.postsBoundsChangedNotifications = true
			return Signal.notifications(name: NSView.boundsDidChangeNotification, object: instance).compactMap { notification -> NSRect? in (notification.object as? NSView)?.bounds }.cancellableBind(to: x)
			
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		}
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension View.Preparer {
	public typealias Storage = AssociatedBinderStorage
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: ViewBinding {
	public typealias ViewName<V> = BindingName<V, View.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> View.Binding) -> ViewName<V> {
		return ViewName<V>(source: source, downcast: Binding.viewBinding)
	}
}
public extension BindingName where Binding: ViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: ViewName<$2> { return .name(View.Binding.$1) }
	
	//	0. Static styles are applied at construction and are subsequently immutable.
	static var layer: ViewName<Constant<Layer>> { return .name(View.Binding.layer) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var appearance: ViewName<Dynamic<NSAppearance?>> { return .name(View.Binding.appearance) }
	static var canDrawSubviewsIntoLayer: ViewName<Dynamic<Bool>> { return .name(View.Binding.canDrawSubviewsIntoLayer) }
	static var focusRingType: ViewName<Dynamic<NSFocusRingType>> { return .name(View.Binding.focusRingType) }
	static var frameRotation: ViewName<Dynamic<CGFloat>> { return .name(View.Binding.frameRotation) }
	static var gestureRecognizers: ViewName<Dynamic<[GestureRecognizerConvertible]>> { return .name(View.Binding.gestureRecognizers) }
	static var horizontalContentCompressionResistancePriority: ViewName<Dynamic<NSLayoutConstraint.Priority>> { return .name(View.Binding.horizontalContentCompressionResistancePriority) }
	static var horizontalContentHuggingPriority: ViewName<Dynamic<NSLayoutConstraint.Priority>> { return .name(View.Binding.horizontalContentHuggingPriority) }
	static var identifier: ViewName<Dynamic<NSUserInterfaceItemIdentifier?>> { return .name(View.Binding.identifier) }
	static var isHidden: ViewName<Dynamic<Bool>> { return .name(View.Binding.isHidden) }
	static var layerContentsRedrawPolicy: ViewName<Dynamic<NSView.LayerContentsRedrawPolicy>> { return .name(View.Binding.layerContentsRedrawPolicy) }
	static var layout: ViewName<Dynamic<Layout>> { return .name(View.Binding.layout) }
	static var pressureConfiguration: ViewName<Dynamic<NSPressureConfiguration>> { return .name(View.Binding.pressureConfiguration) }
	static var registeredDragTypes: ViewName<Dynamic<[NSPasteboard.PasteboardType]>> { return .name(View.Binding.registeredDragTypes) }
	static var tooltip: ViewName<Dynamic<String>> { return .name(View.Binding.tooltip) }
	static var verticalContentCompressionResistancePriority: ViewName<Dynamic<NSLayoutConstraint.Priority>> { return .name(View.Binding.verticalContentCompressionResistancePriority) }
	static var verticalContentHuggingPriority: ViewName<Dynamic<NSLayoutConstraint.Priority>> { return .name(View.Binding.verticalContentHuggingPriority) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var becomeFirstResponder: ViewName<Signal<Void>> { return .name(View.Binding.becomeFirstResponder) }
	static var needsDisplay: ViewName<Signal<Bool>> { return .name(View.Binding.needsDisplay) }
	static var printView: ViewName<Signal<Void>> { return .name(View.Binding.printView) }
	static var scrollRectToVisible: ViewName<Signal<NSRect>> { return .name(View.Binding.scrollRectToVisible) }
	static var setNeedsDisplayInRect: ViewName<Signal<NSRect>> { return .name(View.Binding.setNeedsDisplayInRect) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var boundsDidChange: ViewName<SignalInput<NSRect>> { return .name(View.Binding.boundsDidChange) }
	static var frameDidChange: ViewName<SignalInput<NSRect>> { return .name(View.Binding.frameDidChange) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
extension NSView: DefaultConstructable {}
public extension View {
	func nsView() -> Layout.View { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol ViewBinding: BinderBaseBinding {
	static func viewBinding(_ binding: View.Binding) -> Self
	func asViewBinding() -> View.Binding?
}
public extension ViewBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return viewBinding(.inheritedBinding(binding))
	}
}
public extension ViewBinding where Preparer.Inherited.Binding: ViewBinding {
	func asViewBinding() -> View.Binding? {
		return asInheritedBinding()?.asViewBinding()
	}
}
public extension View.Binding {
	typealias Preparer = View.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asViewBinding() -> View.Binding? { return self }
	static func viewBinding(_ binding: View.Binding) -> View.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public extension ViewConvertible {
	func nsView(frame: NSRect) -> Layout.View {
		let v = nsView()
		v.frame = frame
		return v
	}
	func nsView(width: CGFloat, height: CGFloat) -> Layout.View {
		return nsView(frame: NSRect(x: 0, y: 0, width: width, height: height))
	}
}

#endif

#if os(macOS)

// MARK: - Binder Part 1: Binder
public class Window: Binder, WindowConvertible {
	public var state: BinderState<Preparer>
	public required init(type: Preparer.Instance.Type, parameters: Preparer.Parameters, bindings: [Preparer.Binding]) {
		state = .pending(type: type, parameters: parameters, bindings: bindings)
	}
}

// MARK: - Binder Part 2: Binding
public extension Window {
	enum Binding: WindowBinding {
		case inheritedBinding(Preparer.Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case deferCreation(Constant<Bool>)
		case initialFirstResponderTag(Constant<Int>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case acceptsMouseMovedEvents(Dynamic<Bool>)
		case allowsConcurrentViewDrawing(Dynamic<Bool>)
		case allowsToolTipsWhenApplicationIsInactive(Dynamic<Bool>)
		case alphaValue(Dynamic<CGFloat>)
		case animationBehavior(Dynamic<NSWindow.AnimationBehavior>)
		case appearance(Dynamic<NSAppearance?>)
		case autorecalculatesKeyViewLoop(Dynamic<Bool>)
		case backingType(Dynamic<NSWindow.BackingStoreType>)
		case canBecomeVisibleWithoutLogin(Dynamic<Bool>)
		case canHide(Dynamic<Bool>)
		case collectionBehavior(Dynamic<NSWindow.CollectionBehavior>)
		case colorSpace(Dynamic<NSColorSpace>)
		case contentAspectRatio(Dynamic<NSSize>)
		case contentHeight(Dynamic<WindowDimension>)
		case contentMaxSize(Dynamic<NSSize>)
		case contentMinSize(Dynamic<NSSize>)
		case contentResizeIncrements(Dynamic<NSSize>)
		case contentRelativity(Dynamic<WindowDimension.Relativity>)
		case contentView(Dynamic<ViewConvertible>)
		case contentWidth(Dynamic<WindowDimension>)
		case depthLimit(Dynamic<NSWindow.Depth?>)
		case displaysWhenScreenProfileChanges(Dynamic<Bool>)
		case frameAutosaveName(Dynamic<NSWindow.FrameAutosaveName>)
		case frameHorizontal(Dynamic<WindowDimension>)
		case frameVertical(Dynamic<WindowDimension>)
		case hasShadow(Dynamic<Bool>)
		case hidesOnDeactivate(Dynamic<Bool>)
		case ignoresMouseEvents(Dynamic<Bool>)
		case isDocumentEdited(Dynamic<Bool>)
		case isExcludedFromWindowsMenu(Dynamic<Bool>)
		case isMovable(Dynamic<Bool>)
		case isMovableByWindowBackground(Dynamic<Bool>)
		case isOpaque(Dynamic<Bool>)
		case isRestorable(Dynamic<Bool>)
		case key(Dynamic<Bool>)
		case level(Dynamic<NSWindow.Level>)
		case main(Dynamic<Bool>)
		case maxFullScreenContentSize(Dynamic<NSSize>)
		case minFullScreenContentSize(Dynamic<NSSize>)
		case miniwindowImage(Dynamic<NSImage?>)
		case miniwindowTitle(Dynamic<String>)
		case order(Dynamic<WindowOrder>)
		case preservesContentDuringLiveResize(Dynamic<Bool>)
		case preventsApplicationTerminationWhenModal(Dynamic<Bool>)
		case representedURL(Dynamic<URL?>)
		case resizeStyle(Dynamic<WindowResizeStyle>)
		case restorationClass(Dynamic<NSWindowRestoration.Type>)
		case screen(Dynamic<NSScreen?>)
		case sharingType(Dynamic<NSWindow.SharingType>)
		case styleMask(Dynamic<NSWindow.StyleMask>)
		case title(Dynamic<String>)
		case titlebarAppearsTransparent(Dynamic<Bool>)
		case titleVisibility(Dynamic<NSWindow.TitleVisibility>)
		case toolbar(Dynamic<ToolbarConvertible>)

		// 2. Signal bindings are performed on the object after construction.
		case close(Signal<WindowCloseBehavior>)
		case criticalSheet(Signal<Callback<NSWindow, NSApplication.ModalResponse>>)
		case deminiaturize(Signal<Void>)
		case display(Signal<Bool>)
		case invalidateShadow(Signal<Void>)
		case miniaturize(Signal<Bool>)
		case presentError(Signal<Callback<Error, Bool>>)
		case printWindow(Signal<Void>)
		case recalculateKeyViewLoop(Signal<Void>)
		case runToolbarCustomizationPalette(Signal<Void>)
		case selectNextKeyView(Signal<Void>)
		case selectPreviousKeyView(Signal<Void>)
		case sheet(Signal<Callback<NSWindow, NSApplication.ModalResponse>>)
		case toggleFullScreen(Signal<Void>)
		case toggleToolbarShown(Signal<Void>)
		case zoom(Signal<Bool>)
		
		// 3. Action bindings are triggered by the object after construction.
		case effectiveAppearanceName(SignalInput<NSAppearance.Name>)
		case didBecomeKey(SignalInput<Void>)
		case didBecomeMain(SignalInput<Void>)
		case didChangeBackingProperties(SignalInput<(oldColorSpace: NSColorSpace?, oldScaleFactor: CGFloat?)>)
		case didChangeOcclusionState(SignalInput<Void>)
		case didChangeScreen(SignalInput<Void>)
		case didChangeScreenProfile(SignalInput<Void>)
		case didDeminiaturize(SignalInput<Void>)
		case didEndLiveResize(SignalInput<Void>)
		case didEndSheet(SignalInput<Void>)
		case didEnterFullScreen(SignalInput<Void>)
		case didEnterVersionBrowser(SignalInput<Void>)
		case didExitFullScreen(SignalInput<Void>)
		case didExitVersionBrowser(SignalInput<Void>)
		case didExpose(SignalInput<NSRect>)
		case didMiniaturize(SignalInput<Void>)
		case didMove(SignalInput<Void>)
		case didResignKey(SignalInput<Void>)
		case didResignMain(SignalInput<Void>)
		case didResize(SignalInput<Void>)
		case didUpdate(SignalInput<Void>)
		case willBeginSheet(SignalInput<Void>)
		case willClose(SignalInput<Void>)
		case willEnterFullScreen(SignalInput<Void>)
		case willEnterVersionBrowser(SignalInput<Void>)
		case willExitFullScreen(SignalInput<Void>)
		case willExitVersionBrowser(SignalInput<Void>)
		case willMiniaturize(SignalInput<Void>)
		case willMove(SignalInput<Void>)
		case willStartLiveResize(SignalInput<Void>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldClose((NSWindow) -> Bool)
		case shouldPopUpDocumentPathMenu((NSWindow, NSMenu) -> Bool)
		case shouldZoom((NSWindow, NSRect) -> Bool)
		case willResize((NSWindow, NSSize) -> NSSize)
		case willResizeForVersionBrowser((_ window: NSWindow, _ maxPreferredSize: NSSize, _ maxAllowedSize: NSSize) -> NSSize)
		case willUseFullScreenContentSize((NSWindow, NSSize) -> NSSize)
		case willUseFullScreenPresentationOptions((NSWindow, NSApplication.PresentationOptions) -> NSApplication.PresentationOptions)
		case willUseStandardFrame((NSWindow, NSRect) -> NSRect)
	}
}

// MARK: - Binder Part 3: Preparer
public extension Window {
	struct Preparer: BinderDelegateEmbedderConstructor {
		public typealias Binding = Window.Binding
		public typealias Inherited = BinderBase
		public typealias Instance = NSWindow
		
		public var inherited = Inherited()
		public var dynamicDelegate: Delegate? = nil
		public let delegateClass: Delegate.Type
		public init(delegateClass: Delegate.Type) {
			self.delegateClass = delegateClass
		}
		public func constructStorage(instance: Instance) -> Storage { return Storage() }
		public func inheritedBinding(from: Binding) -> Inherited.Binding? {
			if case .inheritedBinding(let b) = from { return b } else { return nil }
		}

		var deferCreation: Bool? = nil
		var initialFirstResponder: Int? = nil
		
		var contentWidth = InitialSubsequent<WindowDimension>()
		var contentHeight = InitialSubsequent<WindowDimension>()
		var windowSizeRelativity = InitialSubsequent<WindowDimension.Relativity>()
		var screen = InitialSubsequent<NSScreen?>()
		var styleMask = InitialSubsequent<NSWindow.StyleMask>()
		var backingType = InitialSubsequent<NSWindow.BackingStoreType>()
		
		var contentView: Dynamic<ViewConvertible>? = nil
		var frameAutosaveName: Dynamic<String>? = nil
		var frameHorizontal: Dynamic<WindowDimension>? = nil
		var frameVertical: Dynamic<WindowDimension>? = nil
		var key: Dynamic<Bool>? = nil
		var main: Dynamic<Bool>? = nil
		var order: Dynamic<WindowOrder>? = nil
	}
}

// MARK: - Binder Part 4: Preparer overrides
public extension Window.Preparer {
	func constructInstance(type: NSWindow.Type, parameters: Void) -> NSWindow {
		let width = contentWidth.initial ?? WindowDimension(constant: WindowDimension.fallbackWindowSize)
		let height = contentHeight.initial ?? WindowDimension(constant: WindowDimension.fallbackWindowSize)
		let relativity = windowSizeRelativity.initial ?? .independent
		let screen = self.screen.initial ?? NSScreen.screens.first
		let styleMask = self.styleMask.initial ?? [.titled, .resizable, .closable, .miniaturizable]
		let backingType = self.backingType.initial ?? .buffered
		
		// Apply the ContentSize binding
		let contentSize = WindowDimension.contentSize(width: width, height: height, relativity: relativity, onScreen: screen, windowClass: type, styleMask: styleMask)
		
		var frameRect = type.frameRect(forContentRect: NSRect(x: 0, y: 0, width: contentSize.width, height: contentSize.height), styleMask: styleMask)
		frameRect.origin.y = screen.map { $0.visibleFrame.origin.y + $0.visibleFrame.size.height - frameRect.size.height } ?? 0
		
		let cr = type.contentRect(forFrameRect: frameRect, styleMask: styleMask)
		
		// Create the window
		let w = type.init(contentRect: cr, styleMask: styleMask, backing: backingType, defer: deferCreation ?? true, screen: screen)
		w.isReleasedWhenClosed = false
		
		// To be consistent with setting ".Screen", constrain the window to the screen.
		if let scr = screen {
			let r = w.constrainFrameRect(w.frame, to:scr)
			w.setFrameOrigin(r.origin)
		}
		return w
	}
	
	mutating func prepareBinding(_ binding: Binding) {
		switch binding {
		case .inheritedBinding(let preceeding): inherited.prepareBinding(preceeding)
		
		case .backingType(let x): backingType = x.initialSubsequent()
		case .contentHeight(let x): contentHeight = x.initialSubsequent()
		case .contentWidth(let x): contentWidth = x.initialSubsequent()
		case .contentView(let x): contentView = x
		case .deferCreation(let x): deferCreation = x.value
		case .frameAutosaveName(let x): frameAutosaveName = x
		case .frameHorizontal(let x): frameHorizontal = x
		case .frameVertical(let x): frameVertical = x
		case .key(let x): key = x
		case .initialFirstResponderTag(let x): initialFirstResponder = x.value
		case .main(let x): main = x
		case .order(let x): order = x
		case .screen(let x): screen = x.initialSubsequent()
		case .shouldClose(let x): delegate().addSingleHandler1(x, #selector(NSWindowDelegate.windowShouldClose(_:)))
		case .shouldPopUpDocumentPathMenu(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.window(_:shouldPopUpDocumentPathMenu:)))
		case .shouldZoom(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.windowShouldZoom(_:toFrame:)))
		case .styleMask(let x): styleMask = x.initialSubsequent()
		case .willResize(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.windowWillResize(_:to:)))
		case .willResizeForVersionBrowser(let x): delegate().addSingleHandler3(x, #selector(NSWindowDelegate.window(_:willResizeForVersionBrowserWithMaxPreferredSize:maxAllowedSize:)))
		case .willUseFullScreenContentSize(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.window(_:willUseFullScreenContentSize:)))
		case .willUseFullScreenPresentationOptions(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.window(_:willUseFullScreenPresentationOptions:)))
		case .willUseStandardFrame(let x): delegate().addSingleHandler2(x, #selector(NSWindowDelegate.windowWillUseStandardFrame(_:defaultFrame:)))
		default: break
		}
	}
	
	func prepareInstance(_ instance: NSWindow, storage: Window.Preparer.Storage) {
		inheritedPrepareInstance(instance, storage: storage)
		
		if let relativity = windowSizeRelativity.initial {
			storage.windowSizeRelativity = relativity
		}
	}

	func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
		switch binding {
		case .inheritedBinding(let s): return inherited.applyBinding(s, instance: instance, storage: storage)
			
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case .deferCreation: return nil

		// 1. Value bindings may be applied at construction and may subsequently change.
		case .acceptsMouseMovedEvents(let x): return x.apply(instance) { i, v in i.acceptsMouseMovedEvents = v }
		case .allowsConcurrentViewDrawing(let x): return x.apply(instance) { i, v in i.allowsConcurrentViewDrawing = v }
		case .allowsToolTipsWhenApplicationIsInactive(let x): return x.apply(instance) { i, v in i.allowsToolTipsWhenApplicationIsInactive = v }
		case .alphaValue(let x): return x.apply(instance) { i, v in i.alphaValue = v }
		case .animationBehavior(let x): return x.apply(instance) { i, v in i.animationBehavior = v }
		case .appearance(let x): return x.apply(instance) { i, v in i.appearance = v }
		case .autorecalculatesKeyViewLoop(let x): return x.apply(instance) { i, v in i.autorecalculatesKeyViewLoop = v }
		case .backingType: return backingType.resume()?.apply(instance) { i, v in i.backingType = v }
		case .canBecomeVisibleWithoutLogin(let x): return x.apply(instance) { i, v in i.canBecomeVisibleWithoutLogin = v }
		case .canHide(let x): return x.apply(instance) { i, v in i.canHide = v }
		case .collectionBehavior(let x): return x.apply(instance) { i, v in i.collectionBehavior = v }
		case .colorSpace(let x): return x.apply(instance) { i, v in i.colorSpace = v }
		case .contentAspectRatio(let x): return x.apply(instance) { i, v in i.contentAspectRatio = v }
		case .contentHeight: return contentHeight.resume()?.apply(instance, storage) { i, s, v in
			let widthSize = WindowDimension(ratio: 0, constant: i.contentView!.frame.size.width)
			i.setContentSize(WindowDimension.contentSize(width: widthSize, height: v, relativity: s.windowSizeRelativity, onScreen: i.screen, windowClass: type(of: i), styleMask: i.styleMask))
		}
		case .contentMaxSize(let x): return x.apply(instance) { i, v in i.contentMaxSize = v }
		case .contentMinSize(let x): return x.apply(instance) { i, v in i.contentMinSize = v }
		case .contentRelativity(let x): return x.apply(instance, storage) { i, s, v in
			let widthSize = WindowDimension(ratio: 0, constant: i.contentView!.frame.size.width)
			let heightSize = WindowDimension(ratio: 0, constant: i.contentView!.frame.size.height)
			s.windowSizeRelativity = v
			i.setContentSize(WindowDimension.contentSize(width: widthSize, height: heightSize, relativity: s.windowSizeRelativity, onScreen: i.screen, windowClass: type(of: i), styleMask: i.styleMask))
		}
		case .contentResizeIncrements(let x): return x.apply(instance) { i, v in i.contentResizeIncrements = v }
		case .contentView: return nil
		case .contentWidth: return contentWidth.resume()?.apply(instance, storage) { i, s, v in
			let heightSize = WindowDimension(ratio: 0, constant: i.contentView!.frame.size.height)
			i.setContentSize(WindowDimension.contentSize(width: v, height: heightSize, relativity: s.windowSizeRelativity, onScreen: i.screen, windowClass: type(of: i), styleMask: i.styleMask))
		}
		case .depthLimit(let x): return x.apply(instance) { i, v in v.map { i.depthLimit = $0 } ?? i.setDynamicDepthLimit(true) }
		case .displaysWhenScreenProfileChanges(let x): return x.apply(instance) { i, v in i.displaysWhenScreenProfileChanges = v }
		case .frameAutosaveName: return nil
		case .frameHorizontal: return nil
		case .frameVertical: return nil
		case .hasShadow(let x): return x.apply(instance) { i, v in i.hasShadow = v }
		case .hidesOnDeactivate(let x): return x.apply(instance) { i, v in i.hidesOnDeactivate = v }
		case .ignoresMouseEvents(let x): return x.apply(instance) { i, v in i.ignoresMouseEvents = v }
		case .isDocumentEdited(let x): return x.apply(instance) { i, v in i.isDocumentEdited = v }
		case .isExcludedFromWindowsMenu(let x): return x.apply(instance) { i, v in i.isExcludedFromWindowsMenu = v }
		case .isMovable(let x): return x.apply(instance) { i, v in i.isMovable = v }
		case .isMovableByWindowBackground(let x): return x.apply(instance) { i, v in i.isMovableByWindowBackground = v }
		case .isOpaque(let x): return x.apply(instance) { i, v in i.isOpaque = v }
		case .isRestorable(let x): return x.apply(instance) { i, v in i.isRestorable = v }
		case .initialFirstResponderTag: return nil
		case .key: return nil
		case .level(let x): return x.apply(instance) { i, v in i.level = v }
		case .main: return nil
		case .minFullScreenContentSize(let x): return x.apply(instance) { i, v in i.minFullScreenContentSize = v }
		case .miniwindowImage(let x): return x.apply(instance) { i, v in i.miniwindowImage = v }
		case .miniwindowTitle(let x): return x.apply(instance) { i, v in i.miniwindowTitle = v }
		case .maxFullScreenContentSize(let x): return x.apply(instance) { i, v in i.maxFullScreenContentSize = v }
		case .order: return nil
		case .preservesContentDuringLiveResize(let x): return x.apply(instance) { i, v in i.preservesContentDuringLiveResize = v }
		case .preventsApplicationTerminationWhenModal(let x): return x.apply(instance) { i, v in i.preventsApplicationTerminationWhenModal = v }
		case .representedURL(let x): return x.apply(instance) { i, v in i.representedURL = v }
		case .resizeStyle(let x):
			return x.apply(instance) { i, v in
				switch v {
				case .increment(let s):
					i.resizeIncrements = s
				case .contentAspect(let s):
					i.contentAspectRatio = s
				}
			}
		case .restorationClass(let x): return x.apply(instance) { i, v in i.restorationClass = v }
		case .screen:
			return screen.apply(instance) { i, v in
				let r = i.constrainFrameRect(i.frame, to:v)
				i.setFrameOrigin(r.origin)
			}
		case .sharingType(let x): return x.apply(instance) { i, v in i.sharingType = v }
		case .styleMask: return styleMask.apply(instance) { i, v in i.styleMask = v }
		case .title(let x): return x.apply(instance) { i, v in i.title = v }
		case .titlebarAppearsTransparent(let x): return x.apply(instance) { i, v in i.titlebarAppearsTransparent = v }
		case .titleVisibility(let x): return x.apply(instance) { i, v in i.titleVisibility = v }
		case .toolbar(let x): return x.apply(instance) { i, v in i.toolbar = v.nsToolbar() }
		
		// 2. Signal bindings are performed on the object after construction.
		case .close(let x):
			return x.apply(instance) { i, v in
				switch v {
				case .stopModal(let c):
					if i.isSheet {
						i.sheetParent?.endSheet(i, returnCode: c)
					} else if NSApplication.shared.modalWindow == i {
						NSApplication.shared.stopModal(withCode: c)
					} else {
						i.close()
					}
				case _ where i.isSheet: i.sheetParent?.endSheet(i)
				case _ where NSApplication.shared.modalWindow == i: NSApplication.shared.stopModal()
				case .perform: i.performClose(nil)
				case .dismiss: i.close()
				}
			}
		case .criticalSheet(let x): return x.apply(instance) { i, v in i.beginCriticalSheet(v.value) { r in _ = v.callback.send(value: r) } }
		case .deminiaturize(let x): return x.apply(instance) { i, v in i.deminiaturize(nil) }
		case .display(let x): return x.apply(instance) { i, v in v ? i.displayIfNeeded() : i.display() }
		case .invalidateShadow(let x): return x.apply(instance) { i, v in i.invalidateShadow() }
		case .miniaturize(let x): return x.apply(instance) { i, v in v ? i.performMiniaturize(nil) : i.miniaturize(nil) }
		case .presentError(let x):
			return x.apply(instance, storage) { i, s, v in
				let ptr = Unmanaged.passRetained(v.callback).toOpaque()
				let sel = #selector(Window.Preparer.Storage.didPresentError(recovered:contextInfo:))
				i.presentError(v.value, modalFor: i, delegate: s, didPresent: sel, contextInfo: ptr)
			}
		case .printWindow(let x): return x.apply(instance) { i, v in i.printWindow(nil) }
		case .recalculateKeyViewLoop(let x): return x.apply(instance) { i, v in i.recalculateKeyViewLoop() }
		case .runToolbarCustomizationPalette(let x): return x.apply(instance) { i, v in i.runToolbarCustomizationPalette(nil) }
		case .selectNextKeyView(let x): return x.apply(instance) { i, v in i.selectNextKeyView(nil) }
		case .selectPreviousKeyView(let x): return x.apply(instance) { i, v in i.selectPreviousKeyView(nil) }
		case .sheet(let x): return x.apply(instance) { i, v in i.beginSheet(v.value) { r in _ = v.callback.send(value: r) } }
		case .toggleFullScreen(let x): return x.apply(instance) { i, v in i.toggleFullScreen(nil) }
		case .toggleToolbarShown(let x): return x.apply(instance) { i, v in i.toggleToolbarShown(nil) }
		case .zoom(let x): return x.apply(instance) { i, v in v ? i.performZoom(nil) : i.zoom(nil) }
			
		// 3. Action bindings are triggered by the object after construction.
		case .effectiveAppearanceName(let x):
			return instance.observe(\.effectiveAppearance, options: [.initial, .new]) { instance, change in
				if let value = change.newValue {
					x.send(value: value.name)
				}
			}
		case .didBecomeKey(let x): return Signal.notifications(name: NSWindow.didBecomeKeyNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didBecomeMain(let x): return Signal.notifications(name: NSWindow.didBecomeMainNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeBackingProperties(let x):
			return Signal.notifications(name: NSWindow.didChangeBackingPropertiesNotification, object: instance).map { n in
				let cs = n.userInfo.flatMap { $0[NSWindow.oldColorSpaceUserInfoKey] as? NSColorSpace }
				let sf = n.userInfo.flatMap { ($0[NSWindow.oldScaleFactorUserInfoKey] as? NSNumber).map { CGFloat($0.doubleValue) } }
				return (oldColorSpace: cs, oldScaleFactor: sf )
			}.cancellableBind(to: x)
		case .didChangeOcclusionState(let x): return Signal.notifications(name: NSWindow.didChangeOcclusionStateNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeScreen(let x): return Signal.notifications(name: NSWindow.didChangeScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didChangeScreenProfile(let x): return Signal.notifications(name: NSWindow.didChangeScreenProfileNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didDeminiaturize(let x): return Signal.notifications(name: NSWindow.didDeminiaturizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEndLiveResize(let x): return Signal.notifications(name: NSWindow.didEndLiveResizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEndSheet(let x): return Signal.notifications(name: NSWindow.didEndSheetNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEnterFullScreen(let x): return Signal.notifications(name: NSWindow.didEnterFullScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didEnterVersionBrowser(let x): return Signal.notifications(name: NSWindow.didEnterVersionBrowserNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didExitFullScreen(let x): return Signal.notifications(name: NSWindow.didExitFullScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didExitVersionBrowser(let x): return Signal.notifications(name: NSWindow.didExitVersionBrowserNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didExpose(let x): return Signal.notifications(name: NSWindow.didExposeNotification, object: instance).compactMap { (n: Notification) -> NSRect? in return (n.userInfo?["NSExposedRect"] as? NSValue)?.rectValue ?? nil }.cancellableBind(to: x)
		case .didMiniaturize(let x): return Signal.notifications(name: NSWindow.didMiniaturizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didMove(let x): return Signal.notifications(name: NSWindow.didMoveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didResignKey(let x): return Signal.notifications(name: NSWindow.didResignKeyNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didResignMain(let x): return Signal.notifications(name: NSWindow.didResignMainNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didResize(let x): return Signal.notifications(name: NSWindow.didResizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .didUpdate(let x): return Signal.notifications(name: NSWindow.didUpdateNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willBeginSheet(let x): return Signal.notifications(name: NSWindow.willBeginSheetNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willClose(let x): return Signal.notifications(name: NSWindow.willCloseNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willEnterFullScreen(let x): return Signal.notifications(name: NSWindow.willEnterFullScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willEnterVersionBrowser(let x): return Signal.notifications(name: NSWindow.willEnterVersionBrowserNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willExitFullScreen(let x): return Signal.notifications(name: NSWindow.willExitFullScreenNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willExitVersionBrowser(let x): return Signal.notifications(name: NSWindow.willExitVersionBrowserNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willMiniaturize(let x): return Signal.notifications(name: NSWindow.willMiniaturizeNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willMove(let x): return Signal.notifications(name: NSWindow.willMoveNotification, object: instance).map { n in () }.cancellableBind(to: x)
		case .willStartLiveResize(let x): return Signal.notifications(name: NSWindow.willStartLiveResizeNotification, object: instance).map { n in () }.cancellableBind(to: x)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case .shouldClose: return nil
		case .shouldPopUpDocumentPathMenu: return nil
		case .shouldZoom: return nil
		case .willResize: return nil
		case .willResizeForVersionBrowser: return nil
		case .willUseFullScreenContentSize: return nil
		case .willUseFullScreenPresentationOptions: return nil
		case .willUseStandardFrame: return nil
		}
	}

	func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
		var lifetimes = [Lifetime]()
		
		// Apply the autosave size
		let originalFrame = instance.frame
		lifetimes += frameAutosaveName?.apply(instance) { i, v in
			i.setFrameAutosaveName(v)
		}
		
		// The window's content size is now correct, so we can add and layout content.
		// NOTE: this must be done *after* the content size is established, otherwise some container-dependent layout will be done incorrectly.
		lifetimes += contentView?.apply(instance) { i, v in
			i.contentView = v.nsView()
		}
		instance.layoutIfNeeded()
		if let initialFirstResponder = initialFirstResponder {
			instance.initialFirstResponder = instance.contentView?.viewWithTag(initialFirstResponder)
		}
		
		// With content laid out, we can place the frame. NOTE: if autolayout has already placed the frame, respect that placement.
		var skipInitialPlacementIfAutosavePlacementOccurred = instance.frame != originalFrame
		lifetimes += frameHorizontal?.apply(instance) { i, v in
			if !skipInitialPlacementIfAutosavePlacementOccurred {
				i.setFrameOrigin(v.applyFrameHorizontal(i.screen, frameRect: i.frame))
			}
		}
		lifetimes += frameVertical?.apply(instance) { i, v in
			if !skipInitialPlacementIfAutosavePlacementOccurred {
				i.setFrameOrigin(v.applyFrameVertical(i.screen, frameRect: i.frame))
			}
		}
		skipInitialPlacementIfAutosavePlacementOccurred = false
		
		// Set intial order, key and main after everything else
		let captureOrder = order?.initialSubsequent()
		let captureKey = key?.initialSubsequent()
		let captureMain = main?.initialSubsequent()
		switch (captureOrder?.initial ?? .front) {
		case .front where captureKey?.initial == true: instance.makeKeyAndOrderFront(nil)
		case .front: fallthrough
		case .back: WindowOrder.back.applyToWindow(instance)
		case .out: break
		}
		if (captureMain?.initial ?? true) == true {
			instance.makeMain()
		}
		
		// Resume order, key and main
		lifetimes += captureOrder?.resume()?.apply(instance) { i, v in v.applyToWindow(i) }
		lifetimes += captureKey?.resume()?.apply(instance) { i, v in v ? i.makeKey() : i.resignKey() }
		lifetimes += captureMain?.resume()?.apply(instance) { i, v in v ? i.makeMain() : i.resignMain() }
		
		lifetimes += inheritedFinalizedInstance(instance, storage: storage)
		
		return lifetimes.isEmpty ? nil : AggregateLifetime(lifetimes: lifetimes)
	}
}

// MARK: - Binder Part 5: Storage and Delegate
extension Window.Preparer {
	open class Storage: View.Preparer.Storage, NSWindowDelegate {
		var windowSizeRelativity: WindowDimension.Relativity = .independent
		@objc func didPresentError(recovered: Bool, contextInfo: UnsafeMutableRawPointer?) {
			if let ptr = contextInfo {
				Unmanaged<SignalInput<Bool>>.fromOpaque(ptr).takeRetainedValue().send(value: recovered)
			}
		}
	}

	open class Delegate: DynamicDelegate, NSWindowDelegate {
		open func windowWillResize(_ window: NSWindow, to toSize: NSSize) -> NSSize {
			return singleHandler(window, toSize)
		}
		
		open func windowWillUseStandardFrame(_ window: NSWindow, defaultFrame: NSRect) -> NSRect {
			return singleHandler(window, defaultFrame)
		}
		
		open func windowShouldZoom(_ window: NSWindow, toFrame: NSRect) -> Bool {
			return singleHandler(window, toFrame)
		}
		
		open func window(_ window: NSWindow, willUseFullScreenContentSize param: NSSize) -> NSSize {
			return singleHandler(window, param)
		}
		
		open func window(_ window: NSWindow, willUseFullScreenPresentationOptions param: NSApplication.PresentationOptions) -> NSApplication.PresentationOptions {
			return singleHandler(window, param)
		}
		
		open func windowShouldClose(_ window: NSWindow) -> Bool {
			return singleHandler(window)
		}
		
		open func window(_ window: NSWindow, shouldPopUpDocumentPathMenu param: NSMenu) -> Bool {
			return singleHandler(window, param)
		}
		
		open func window(_ window: NSWindow, willResizeForVersionBrowserWithMaxPreferredSize: NSSize, maxAllowedSize: NSSize) -> NSSize {
			return singleHandler(window, willResizeForVersionBrowserWithMaxPreferredSize, maxAllowedSize)
		}
	}
}

// MARK: - Binder Part 6: BindingNames
extension BindingName where Binding: WindowBinding {
	public typealias WindowName<V> = BindingName<V, Window.Binding, Binding>
	private static func name<V>(_ source: @escaping (V) -> Window.Binding) -> WindowName<V> {
		return WindowName<V>(source: source, downcast: Binding.windowBinding)
	}
}
public extension BindingName where Binding: WindowBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: WindowName<$2> { return .name(Window.Binding.$1) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	
	//	1. Static styles are applied at construction and are subsequently immutable.
	static var deferCreation: WindowName<Constant<Bool>> { return .name(Window.Binding.deferCreation) }
	
	// 1. Value bindings may be applied at construction and may subsequently change.
	static var acceptsMouseMovedEvents: WindowName<Dynamic<Bool>> { return .name(Window.Binding.acceptsMouseMovedEvents) }
	static var allowsConcurrentViewDrawing: WindowName<Dynamic<Bool>> { return .name(Window.Binding.allowsConcurrentViewDrawing) }
	static var allowsToolTipsWhenApplicationIsInactive: WindowName<Dynamic<Bool>> { return .name(Window.Binding.allowsToolTipsWhenApplicationIsInactive) }
	static var alphaValue: WindowName<Dynamic<CGFloat>> { return .name(Window.Binding.alphaValue) }
	static var animationBehavior: WindowName<Dynamic<NSWindow.AnimationBehavior>> { return .name(Window.Binding.animationBehavior) }
	static var appearance: WindowName<Dynamic<NSAppearance?>> { return .name(Window.Binding.appearance) }
	static var autorecalculatesKeyViewLoop: WindowName<Dynamic<Bool>> { return .name(Window.Binding.autorecalculatesKeyViewLoop) }
	static var backingType: WindowName<Dynamic<NSWindow.BackingStoreType>> { return .name(Window.Binding.backingType) }
	static var canBecomeVisibleWithoutLogin: WindowName<Dynamic<Bool>> { return .name(Window.Binding.canBecomeVisibleWithoutLogin) }
	static var canHide: WindowName<Dynamic<Bool>> { return .name(Window.Binding.canHide) }
	static var collectionBehavior: WindowName<Dynamic<NSWindow.CollectionBehavior>> { return .name(Window.Binding.collectionBehavior) }
	static var colorSpace: WindowName<Dynamic<NSColorSpace>> { return .name(Window.Binding.colorSpace) }
	static var contentAspectRatio: WindowName<Dynamic<NSSize>> { return .name(Window.Binding.contentAspectRatio) }
	static var contentHeight: WindowName<Dynamic<WindowDimension>> { return .name(Window.Binding.contentHeight) }
	static var contentMaxSize: WindowName<Dynamic<NSSize>> { return .name(Window.Binding.contentMaxSize) }
	static var contentMinSize: WindowName<Dynamic<NSSize>> { return .name(Window.Binding.contentMinSize) }
	static var contentResizeIncrements: WindowName<Dynamic<NSSize>> { return .name(Window.Binding.contentResizeIncrements) }
	static var contentRelativity: WindowName<Dynamic<WindowDimension.Relativity>> { return .name(Window.Binding.contentRelativity) }
	static var contentView: WindowName<Dynamic<ViewConvertible>> { return .name(Window.Binding.contentView) }
	static var contentWidth: WindowName<Dynamic<WindowDimension>> { return .name(Window.Binding.contentWidth) }
	static var depthLimit: WindowName<Dynamic<NSWindow.Depth?>> { return .name(Window.Binding.depthLimit) }
	static var displaysWhenScreenProfileChanges: WindowName<Dynamic<Bool>> { return .name(Window.Binding.displaysWhenScreenProfileChanges) }
	static var frameAutosaveName: WindowName<Dynamic<NSWindow.FrameAutosaveName>> { return .name(Window.Binding.frameAutosaveName) }
	static var frameHorizontal: WindowName<Dynamic<WindowDimension>> { return .name(Window.Binding.frameHorizontal) }
	static var frameVertical: WindowName<Dynamic<WindowDimension>> { return .name(Window.Binding.frameVertical) }
	static var hasShadow: WindowName<Dynamic<Bool>> { return .name(Window.Binding.hasShadow) }
	static var hidesOnDeactivate: WindowName<Dynamic<Bool>> { return .name(Window.Binding.hidesOnDeactivate) }
	static var ignoresMouseEvents: WindowName<Dynamic<Bool>> { return .name(Window.Binding.ignoresMouseEvents) }
	static var isDocumentEdited: WindowName<Dynamic<Bool>> { return .name(Window.Binding.isDocumentEdited) }
	static var isExcludedFromWindowsMenu: WindowName<Dynamic<Bool>> { return .name(Window.Binding.isExcludedFromWindowsMenu) }
	static var isMovable: WindowName<Dynamic<Bool>> { return .name(Window.Binding.isMovable) }
	static var isMovableByWindowBackground: WindowName<Dynamic<Bool>> { return .name(Window.Binding.isMovableByWindowBackground) }
	static var isOpaque: WindowName<Dynamic<Bool>> { return .name(Window.Binding.isOpaque) }
	static var isRestorable: WindowName<Dynamic<Bool>> { return .name(Window.Binding.isRestorable) }
	static var key: WindowName<Dynamic<Bool>> { return .name(Window.Binding.key) }
	static var level: WindowName<Dynamic<NSWindow.Level>> { return .name(Window.Binding.level) }
	static var main: WindowName<Dynamic<Bool>> { return .name(Window.Binding.main) }
	static var maxFullScreenContentSize: WindowName<Dynamic<NSSize>> { return .name(Window.Binding.maxFullScreenContentSize) }
	static var minFullScreenContentSize: WindowName<Dynamic<NSSize>> { return .name(Window.Binding.minFullScreenContentSize) }
	static var miniwindowImage: WindowName<Dynamic<NSImage?>> { return .name(Window.Binding.miniwindowImage) }
	static var miniwindowTitle: WindowName<Dynamic<String>> { return .name(Window.Binding.miniwindowTitle) }
	static var order: WindowName<Dynamic<WindowOrder>> { return .name(Window.Binding.order) }
	static var preservesContentDuringLiveResize: WindowName<Dynamic<Bool>> { return .name(Window.Binding.preservesContentDuringLiveResize) }
	static var preventsApplicationTerminationWhenModal: WindowName<Dynamic<Bool>> { return .name(Window.Binding.preventsApplicationTerminationWhenModal) }
	static var representedURL: WindowName<Dynamic<URL?>> { return .name(Window.Binding.representedURL) }
	static var resizeStyle: WindowName<Dynamic<WindowResizeStyle>> { return .name(Window.Binding.resizeStyle) }
	static var restorationClass: WindowName<Dynamic<NSWindowRestoration.Type>> { return .name(Window.Binding.restorationClass) }
	static var screen: WindowName<Dynamic<NSScreen?>> { return .name(Window.Binding.screen) }
	static var sharingType: WindowName<Dynamic<NSWindow.SharingType>> { return .name(Window.Binding.sharingType) }
	static var styleMask: WindowName<Dynamic<NSWindow.StyleMask>> { return .name(Window.Binding.styleMask) }
	static var title: WindowName<Dynamic<String>> { return .name(Window.Binding.title) }
	static var titlebarAppearsTransparent: WindowName<Dynamic<Bool>> { return .name(Window.Binding.titlebarAppearsTransparent) }
	static var titleVisibility: WindowName<Dynamic<NSWindow.TitleVisibility>> { return .name(Window.Binding.titleVisibility) }
	static var toolbar: WindowName<Dynamic<ToolbarConvertible>> { return .name(Window.Binding.toolbar) }
	
	// 2. Signal bindings are performed on the object after construction.
	static var close: WindowName<Signal<WindowCloseBehavior>> { return .name(Window.Binding.close) }
	static var criticalSheet: WindowName<Signal<Callback<NSWindow, NSApplication.ModalResponse>>> { return .name(Window.Binding.criticalSheet) }
	static var deminiaturize: WindowName<Signal<Void>> { return .name(Window.Binding.deminiaturize) }
	static var display: WindowName<Signal<Bool>> { return .name(Window.Binding.display) }
	static var invalidateShadow: WindowName<Signal<Void>> { return .name(Window.Binding.invalidateShadow) }
	static var miniaturize: WindowName<Signal<Bool>> { return .name(Window.Binding.miniaturize) }
	static var presentError: WindowName<Signal<Callback<Error, Bool>>> { return .name(Window.Binding.presentError) }
	static var printWindow: WindowName<Signal<Void>> { return .name(Window.Binding.printWindow) }
	static var recalculateKeyViewLoop: WindowName<Signal<Void>> { return .name(Window.Binding.recalculateKeyViewLoop) }
	static var runToolbarCustomizationPalette: WindowName<Signal<Void>> { return .name(Window.Binding.runToolbarCustomizationPalette) }
	static var selectNextKeyView: WindowName<Signal<Void>> { return .name(Window.Binding.selectNextKeyView) }
	static var selectPreviousKeyView: WindowName<Signal<Void>> { return .name(Window.Binding.selectPreviousKeyView) }
	static var sheet: WindowName<Signal<Callback<NSWindow, NSApplication.ModalResponse>>> { return .name(Window.Binding.sheet) }
	static var toggleFullScreen: WindowName<Signal<Void>> { return .name(Window.Binding.toggleFullScreen) }
	static var toggleToolbarShown: WindowName<Signal<Void>> { return .name(Window.Binding.toggleToolbarShown) }
	static var zoom: WindowName<Signal<Bool>> { return .name(Window.Binding.zoom) }
	
	// 3. Action bindings are triggered by the object after construction.
	static var effectiveAppearanceName: WindowName<SignalInput<NSAppearance.Name>> { return .name(Window.Binding.effectiveAppearanceName) }
	static var didBecomeKey: WindowName<SignalInput<Void>> { return .name(Window.Binding.didBecomeKey) }
	static var didBecomeMain: WindowName<SignalInput<Void>> { return .name(Window.Binding.didBecomeMain) }
	static var didChangeBackingProperties: WindowName<SignalInput<(oldColorSpace: NSColorSpace?, oldScaleFactor: CGFloat?)>> { return .name(Window.Binding.didChangeBackingProperties) }
	static var didChangeOcclusionState: WindowName<SignalInput<Void>> { return .name(Window.Binding.didChangeOcclusionState) }
	static var didChangeScreen: WindowName<SignalInput<Void>> { return .name(Window.Binding.didChangeScreen) }
	static var didChangeScreenProfile: WindowName<SignalInput<Void>> { return .name(Window.Binding.didChangeScreenProfile) }
	static var didDeminiaturize: WindowName<SignalInput<Void>> { return .name(Window.Binding.didDeminiaturize) }
	static var didEndLiveResize: WindowName<SignalInput<Void>> { return .name(Window.Binding.didEndLiveResize) }
	static var didEndSheet: WindowName<SignalInput<Void>> { return .name(Window.Binding.didEndSheet) }
	static var didEnterFullScreen: WindowName<SignalInput<Void>> { return .name(Window.Binding.didEnterFullScreen) }
	static var didEnterVersionBrowser: WindowName<SignalInput<Void>> { return .name(Window.Binding.didEnterVersionBrowser) }
	static var didExitFullScreen: WindowName<SignalInput<Void>> { return .name(Window.Binding.didExitFullScreen) }
	static var didExitVersionBrowser: WindowName<SignalInput<Void>> { return .name(Window.Binding.didExitVersionBrowser) }
	static var didExpose: WindowName<SignalInput<NSRect>> { return .name(Window.Binding.didExpose) }
	static var didMiniaturize: WindowName<SignalInput<Void>> { return .name(Window.Binding.didMiniaturize) }
	static var didMove: WindowName<SignalInput<Void>> { return .name(Window.Binding.didMove) }
	static var didResignKey: WindowName<SignalInput<Void>> { return .name(Window.Binding.didResignKey) }
	static var didResignMain: WindowName<SignalInput<Void>> { return .name(Window.Binding.didResignMain) }
	static var didResize: WindowName<SignalInput<Void>> { return .name(Window.Binding.didResize) }
	static var didUpdate: WindowName<SignalInput<Void>> { return .name(Window.Binding.didUpdate) }
	static var willBeginSheet: WindowName<SignalInput<Void>> { return .name(Window.Binding.willBeginSheet) }
	static var willClose: WindowName<SignalInput<Void>> { return .name(Window.Binding.willClose) }
	static var willEnterFullScreen: WindowName<SignalInput<Void>> { return .name(Window.Binding.willEnterFullScreen) }
	static var willEnterVersionBrowser: WindowName<SignalInput<Void>> { return .name(Window.Binding.willEnterVersionBrowser) }
	static var willExitFullScreen: WindowName<SignalInput<Void>> { return .name(Window.Binding.willExitFullScreen) }
	static var willExitVersionBrowser: WindowName<SignalInput<Void>> { return .name(Window.Binding.willExitVersionBrowser) }
	static var willMiniaturize: WindowName<SignalInput<Void>> { return .name(Window.Binding.willMiniaturize) }
	static var willMove: WindowName<SignalInput<Void>> { return .name(Window.Binding.willMove) }
	static var willStartLiveResize: WindowName<SignalInput<Void>> { return .name(Window.Binding.willStartLiveResize) }
	
	// 4. Delegate bindings require synchronous evaluation within the object's context.
	static var shouldClose: WindowName<(NSWindow) -> Bool> { return .name(Window.Binding.shouldClose) }
	static var shouldPopUpDocumentPathMenu: WindowName<(NSWindow, NSMenu) -> Bool> { return .name(Window.Binding.shouldPopUpDocumentPathMenu) }
	static var shouldZoom: WindowName<(NSWindow, NSRect) -> Bool> { return .name(Window.Binding.shouldZoom) }
	static var willResize: WindowName<(NSWindow, NSSize) -> NSSize> { return .name(Window.Binding.willResize) }
	static var willResizeForVersionBrowser: WindowName<(_ window: NSWindow, _ maxPreferredSize: NSSize, _ maxAllowedSize: NSSize) -> NSSize> { return .name(Window.Binding.willResizeForVersionBrowser) }
	static var willUseFullScreenContentSize: WindowName<(NSWindow, NSSize) -> NSSize> { return .name(Window.Binding.willUseFullScreenContentSize) }
	static var willUseFullScreenPresentationOptions: WindowName<(NSWindow, NSApplication.PresentationOptions) -> NSApplication.PresentationOptions> { return .name(Window.Binding.willUseFullScreenPresentationOptions) }
	static var willUseStandardFrame: WindowName<(NSWindow, NSRect) -> NSRect> { return .name(Window.Binding.willUseStandardFrame) }
}

// MARK: - Binder Part 7: Convertible protocols (if constructible)
public protocol WindowConvertible {
	func nsWindow() -> Window.Instance
}
extension NSWindow: WindowConvertible, DefaultConstructable, HasDelegate {
	public func nsWindow() -> Window.Instance { return self }
}
public extension Window {
	func nsWindow() -> Window.Instance { return instance() }
}

// MARK: - Binder Part 8: Downcast protocols
public protocol WindowBinding: BinderBaseBinding {
	static func windowBinding(_ binding: Window.Binding) -> Self
	func asWindowBinding() -> Window.Binding?
}
public extension WindowBinding {
	static func binderBaseBinding(_ binding: BinderBase.Binding) -> Self {
		return windowBinding(.inheritedBinding(binding))
	}
}
public extension WindowBinding where Preparer.Inherited.Binding: WindowBinding {
	func asWindowBinding() -> Window.Binding? {
		return asInheritedBinding()?.asWindowBinding()
	}
}
public extension Window.Binding {
	typealias Preparer = Window.Preparer
	func asInheritedBinding() -> Preparer.Inherited.Binding? { if case .inheritedBinding(let b) = self { return b } else { return nil } }
	func asWindowBinding() -> Window.Binding? { return self }
	static func windowBinding(_ binding: Window.Binding) -> Window.Binding {
		return binding
	}
}

// MARK: - Binder Part 9: Other supporting types
public enum WindowCloseBehavior {
	case dismiss
	case perform
	case stopModal(NSApplication.ModalResponse)
}

public enum WindowOrder {
	case front
	case back
	case out
	
	public func applyToWindow(_ window: NSWindow) {
		switch self {
		case .front: window.orderFront(nil)
		case .back: window.orderBack(nil)
		case .out: window.orderOut(nil)
		}
	}
}

public enum WindowResizeStyle {
	case increment(NSSize)
	case contentAspect(NSSize)
	
	public static func normal() -> WindowResizeStyle {
		return .increment(NSSize(width: 1.0, height: 1.0))
	}
}

public struct WindowDimension: ExpressibleByIntegerLiteral, ExpressibleByFloatLiteral {
	public typealias FloatLiteralType = Double
	public typealias IntegerLiteralType = Int

	public enum Relativity {
		case independent
		case widthRelativeToHeight
		case heightRelativeToWidth
	}
	
	public let ratio: CGFloat
	public let constant: CGFloat
	
	public init(integerLiteral value: Int) {
		self.init(constant: CGFloat(value))
	}

	public init(floatLiteral value: Double) {
		self.ratio = 0
		self.constant = CGFloat(value)
	}
	
	public init(ratio: CGFloat = 0, constant: CGFloat = 0) {
		self.ratio = ratio
		self.constant = constant
	}
	
	public static func ratio(_ ratio: CGFloat = 0, constant: CGFloat = 0) -> WindowDimension {
		return WindowDimension(ratio: ratio, constant: constant)
	}
	
	public static let fallbackWindowSize: CGFloat = 400
	
	public static func contentSize<W: NSWindow>(width widthSize: WindowDimension, height heightSize: WindowDimension, relativity: Relativity, onScreen: NSScreen?, windowClass: W.Type, styleMask: NSWindow.StyleMask) -> NSSize {
		let width: CGFloat
		let height: CGFloat
		switch relativity {
		case .widthRelativeToHeight:
			if heightSize.ratio != 0, let s = onScreen {
				let screenFrame = windowClass.contentRect(forFrameRect: s.visibleFrame, styleMask: styleMask)
				height = heightSize.ratio * screenFrame.height + heightSize.constant
			} else {
				height = heightSize.constant
			}
			width = widthSize.ratio * height + widthSize.constant
		case .heightRelativeToWidth:
			if widthSize.ratio != 0, let s = onScreen {
				let screenFrame = windowClass.contentRect(forFrameRect: s.visibleFrame, styleMask: styleMask)
				width = widthSize.ratio * screenFrame.height + widthSize.constant
			} else {
				width = widthSize.constant
			}
			height = heightSize.ratio * width + heightSize.constant
		case .independent:
			if (widthSize.ratio != 0 || heightSize.ratio != 0), let s = onScreen {
				let screenFrame = windowClass.contentRect(forFrameRect: s.visibleFrame, styleMask: styleMask)
				width = widthSize.ratio * screenFrame.height + widthSize.constant
				height = heightSize.ratio * screenFrame.height + heightSize.constant
			} else {
				width = widthSize.constant
				height = heightSize.constant
			}
		}
		return NSSize(width: width, height: height)
	}

	fileprivate func applyFrameValue(frameLength: CGFloat, screenAvailable: CGFloat) -> CGFloat {
		let space = screenAvailable - frameLength
		if space > 0 {
			return space * ratio + constant
		} else {
			return 0
		}
	}
	
	public func applyFrameVertical(_ screen: NSScreen?, frameRect: NSRect) -> NSPoint {
		guard let visible = screen?.visibleFrame else {
			return frameRect.origin
		}
		
		let offset = applyFrameValue(frameLength: frameRect.size.height, screenAvailable: visible.size.height)
		let y = visible.origin.y + visible.size.height - frameRect.size.height - offset
		return NSPoint(x: frameRect.origin.x, y: y)
	}
	
	public func applyFrameHorizontal(_ screen: NSScreen?, frameRect: NSRect) -> NSPoint {
		guard let visible = screen?.visibleFrame else {
			return frameRect.origin
		}
		
		let offset = applyFrameValue(frameLength: frameRect.size.width, screenAvailable: visible.size.width)
		let x = visible.origin.x + offset
		return NSPoint(x: x, y: frameRect.origin.y)
	}
}

extension NSWindow: Lifetime {
	public static var titleBarHeight: CGFloat {
		return NSWindow.frameRect(forContentRect: .zero, styleMask: [.titled]).height
	}
	
	public static var integratedToolbarHeight: CGFloat {
		return 24 + 8 + 8 // is there a smarter way to calculate this?
	}
	
	public func cancel() {
		return nsWindow().close()
	}
}

#endif
